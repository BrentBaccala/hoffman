#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# Print the MD5 digest of the data portion of a Hoffman tablebase

use strict;

use IO::Zlib;
use XML::LibXML;
use Digest::MD5;

use English;
$LIST_SEPARATOR = undef;

#open(VERBOSE,">&STDOUT");
#open(DEBUG,">&STDOUT");
#open(DEBUG2,">&STDOUT");

# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package XML_prefix_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;
	return 0 if (defined $self->{'truncate'});

	my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	if ($search_result != -1) {
	    substr($$bufref, $search_result - length($self->{'trailing data'}) + length("</tablebase>")) = "";
	    $result = length($$bufref);
	    $self->{'truncate'} = 1;
	} else {
	    $self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	}
	return $result;
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

my $XMLparser = XML::LibXML->new();

# If we don't have an Internet connection, the program will die when it tries to validate against
# the DTD, unless loading external DTDs are turned off.

$XMLparser->load_ext_dtd(0);
$XMLparser->validation(0);

for my $filename (@ARGV) {

    tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open tablebase $filename\n";
    tie *FILE, 'XML_prefix_only', *ZFILE;

    my $xml = $XMLparser->parse_fh(*FILE)->getDocumentElement() or die "$filename doesn't appear to be a Hoffman tablebase\n";
    my $offset = hex $xml->findvalue('@offset') or die "$filename doesn't appear to be a Hoffman tablebase\n";

    close(FILE);

    tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open tablebase $filename\n";

    # seek(*ZFILE, $offset, 0) isn't support by IO::Zlib, so...

    my $buf;
    $offset -= read(*ZFILE, $buf, $offset, undef) while ($offset > 0);

    my $ctx = Digest::MD5->new;

    # $ctx->addfile(*ZFILE) doesn't appear to work either

    while (read(*ZFILE, $buf, 256, undef)) {
	$ctx->add($buf);
    }

    close(*ZFILE);

    print $ctx->hexdigest, "        $filename\n";
}
