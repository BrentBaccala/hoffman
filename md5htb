#! /usr/bin/perl
# -*- fill-column: 100; -*-

use strict;

use IO::Zlib;
use XML::LibXML;
use Digest::MD5 qw(md5 md5_hex md5_base64);

use English;
$LIST_SEPARATOR = undef;

#open(VERBOSE,">&STDOUT");
#open(DEBUG,">&STDOUT");
#open(DEBUG2,">&STDOUT");

# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package XML_prefix_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;
	return 0 if (defined $self->{'truncate'});

	my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	if ($search_result != -1) {
	    substr($$bufref, $search_result - length($self->{'trailing data'}) + length("</tablebase>")) = "";
	    $result = length($$bufref);
	    $self->{'truncate'} = 1;
	} else {
	    $self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	}
	return $result;
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package trailing_data_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;

	if (defined $self->{'truncate'}) {
	    return read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	}

	while (1) {
	    my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	    my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	    if ($search_result != -1) {
		substr($$bufref, 0, $search_result - length($self->{'trailing data'}) + length("</tablebase>") + 1) = "";
		$result = length($$bufref);
		$self->{'truncate'} = 1;
		return $result;
	    } else {
		$self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	    }
	}
    }

    sub READLINE {
	my ($self) = @_;
	my $buf;
	if ($self->READ($buf, 80, undef) > 0) {
	    return $buf;
	} else {
	    return undef;
	}
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

my $filename = $ARGV[0];

tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open tablebase $filename\n";

#print while (<ZFILE>);
#exit;

tie *FILE, 'trailing_data_only', *ZFILE;

print while (<FILE>);
exit;

my $ctx = Digest::MD5->new;
$ctx->addfile(*FILE);

close(FILE);

print $ctx->hexdigest, "\n";
