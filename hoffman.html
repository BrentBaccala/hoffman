<HTML>
<HEAD><TITLE>Hoffman</TITLE></HEAD>
<BODY>
<CENTER><H3>Hoffman</H3></CENTER>

<center>26 May 2008 - <tt>freesoft.org</tt> is pleased to announce the 1.0 release of
Hoffman, an open-source tablebase generator for chess endgames.</center>

<p>
Hoffman calculates chess tablebases, which are large files containing all possible
configurations of chess pieces in an endgame and the best play to either win or draw.  Unlike a
conventional chess engine, which uses a heuristic evaluation function, a retrograde engine is
almost completely non-heuristic.  When it labels a position as a win, it is because it has
considered all possibles lines, be they 10, 20, or 100 moves long, and determined that the win is
forced, even with best play by the opposing side.  Some chess-like games, such as the Japanese
game Shogi, are not suitable for retrograde analysis because pieces never leave the game
(captured pieces in Shogi can be put back into play by the capturing player).  Yet for chess, the
frequent reduction of games to positions where only a handful of pieces remain has created an
entire subfield of endgame analysis.

<p>
Systematic analysis of chess endgames dates at least to the ninth century.  Pioneering work in
computer retrograde analysis was done in the 1980s by Ken Thompson, of UNIX fame, and
S.J. Edwards, but the most popular tablebases today are those generated by a program written by
E.V. Nalimov.  Suffice it to say that while Nalimov's program has completely solved all chess
endgames with six or fewer pieces remaining, and while Nalimov tablebases are widely available on
the Internet, the Nalimov approach of solving an endgame completely results in very slow run
times and exceptionally large tablebases.  The K+P+P vs K+P endgame, for example, due to the
possibility of all pawns queening, requires the K+Q+Q vs K+Q endgame to be solved before it can
be calculated.  The Nalimov kppkp tablebase occupies 64MB; Hoffman's current, less efficient
storage scheme requires 225MB for the same tablebase.

<p>
Hoffman takes a somewhat different approach, one pioneered by Eiko Bleicher's <a href="http://www.freezerchess.com">Freezer</A>, now a
commercial program. When faced with something like K+P+P vs K+P, rather than calculate all
possible resulting positions, it may ignore the possibility of more than two pawns queening at
the same time, thus computing nothing more complex than K+Q+P vs K+Q.  While incomplete, such a
tablebase is nevertheless useful.  For the player with two pawns, if the tablebase finds a
winning line subject to the queening restrictions, then that line is still playable for a win,
even though a faster winning line may exist.  From the opposing point of view, if the tablebase
treats any position where the third pawn queens as a loss, then the player can be confident that
any drawing line can not be improved upon by the superior side.  From a computational
perspective, we have reduced the complexity requirements to a point where the calculation can be
performed in a reasonable amount of time.  While still too slow for over-the-board use, we now
have a useful tool for the analysis of more complex endgames, useful for either static analysis,
or for the slow time controls of correspondence games.

<p>
Hoffman improves upon Freezer with a more sophisticated method of chaining one endgame analysis
into another, allowing more realistic modeling of queening combinations and exchanges.  For
example, in a bishop vs knight endgame (with pawns), we can (if we wish) analyze first the king
and pawn endgame resulting after a trade of the minors, then use this information to analyze a
similar set of king vs knight and king vs bishop endgames, and finally combine all this
information together to analyze the original endgame.  While the current version of Freezer can
only regard the capture of the knight or bishop as a forced win for one side or the other,
Hoffman can look through the exchange to determine the result more accurately.

<p>
Hoffman thus attempts to combine the best of Nalimov and Freezer.  Unlike Freezer, the program is
powerful enough to solve any endgame completely (given enough computing resources), reproducing
any Nalimov tablebase.  Unlike Nalimov, the program is capable of pruning pawn moves, queening
combinations, movement options and exchanges, giving it Freezer's ability to solve complex
endgames in a reasonable amount of time.  The exact tradeoff between the two extremes is made
using a XML-based configuration that can seem daunting at first, but ultimately offers the user
the ability to extensively tailor the program's operation.  Combined with a human being's common
sense and chess judgement, it is my hope that this flexibility with ultimately make the program
more useful for endgame retrograde analysis than either Nalimov or Freezer.

<p>
For those not up on Americana, the program is named after Trevor Hoffman, an All Star baseball
pitcher who specializes in "closing" games.  It was written specifically for The World vs. Arno
Nickel game (ultimately won by the World team with no help needed from Hoffman).


<CENTER><H3>Hoffman 1.0 - Memorial Day Release</H3></CENTER>

<TT><A HREF="26May2008/hoffman-1.0.tgz">hoffman-1.0.tgz</A></TT> (source)
<BR>
<TT><A HREF="26May2008/hoffman-1.0.exe">hoffman-1.0.exe</A></TT> (installer for Windows executable)
<P>
<A HREF="26May2008/tutorial.pdf">The Hoffman Tutorial</A>
<BR>
<A HREF="26May2008/reference.pdf">The Hoffman Reference Guide</A>

<CENTER><H3>Older releases from 2006</H3></CENTER>

December 25 version:
<TT>
<A HREF="Dec25/setup.exe">setup.exe</A> (Windows)
</TT>

August 27 version:
<TT>
<A HREF="Aug27/hoffman.c">hoffman.c</A>
<A HREF="Aug27/hoffman.xml">hoffman.xml</A>
</TT>

<P>
September 3 version:
<TT>
<A HREF="Sep3/hoffman.c">hoffman.c</A>
<A HREF="Sep3/hoffman.xml">hoffman.xml</A>
</TT>

<P>
September 7 version:
<TT>
<A HREF="Sep7/hoffman.c">hoffman.c</A>
</TT>

<P>
September 10 version:
<TT>
<A HREF="Sep10/hoffman.c">hoffman.c</A>
</TT>

<P>
September 21 version:
<TT>
<A HREF="Sep21/hoffman.c">hoffman.c</A>
<A HREF="Sep21/kk.xml">kk.xml</A>
<A HREF="Sep21/kqk.xml">kqk.xml</A>
<A HREF="Sep21/krk.xml">krk.xml</A>
<A HREF="Sep21/knk.xml">knk.xml</A>
<A HREF="Sep21/kpk.xml">kpk.xml</A>
</TT>

<P>
September 22 version:
<TT>
<A HREF="Sep22/hoffman.txt">hoffman.txt</A>
<A HREF="Sep22/hoffman.c">hoffman.c</A>
<A HREF="Sep22/kqkq.xml">kqkq.xml</A>
<A HREF="Sep22/kqkr.xml">kqkr.xml</A>
<A HREF="Sep22/kqkn.xml">kqkn.xml</A>
<A HREF="Sep22/kpkq.xml">kpkq.xml</A>
</TT>

<P>
September 23 version:
<TT>
<A HREF="Sep23/hoffman.txt">hoffman.txt</A>
<A HREF="Sep23/Makefile">Makefile</A>
<A HREF="Sep23/hoffman.c">hoffman.c</A>
<A HREF="Sep23/tablebase.dtd">tablebase.dtd</A>
</TT>

<P>
September 27 version:
<TT>
<A HREF="Sep27/Makefile">Makefile</A>
<A HREF="Sep27/hoffman.c">hoffman.c</A>
<A HREF="Sep27/tablebase.dtd">tablebase.dtd</A>
</TT>

<P>
October 3 version:
<TT>
<A HREF="Oct3/Makefile">Makefile</A>
<A HREF="Oct3/hoffman.c">hoffman.c</A>
<A HREF="Oct3/tablebase.dtd">tablebase.dtd</A>
</TT>

<P>
October 8 version:
<TT>
<A HREF="Oct8/Makefile">Makefile</A>
<A HREF="Oct8/hoffman.c">hoffman.c</A>
<A HREF="Oct8/tablebase.dtd">tablebase.dtd</A>
</TT>

I've stopped releasing versions of the XML control files along with
the program.
<P>
All Oct 8 XML control files can be downloaded from <A HREF="Oct8/xml">this directory</A>.

</BODY>
</HTML>
