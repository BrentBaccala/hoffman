#
# Testing framework for Hoffman
#
# HOFFMAN is how we call the program
#
# NALIMOV is an optional directory containing Nalimov tablebases.  If
# they exist, they are used to verify any corresponding Hoffman
# tablebases after they are built.
#
# PROBES-FAST and PROBES-SLOW are files containing a list of Hoffman
# queries against various tablebases, along with the MD5 hashes of the
# expected output.  The tablebases listed are built as needed, along
# with any dependencies.  Thus, the presence of a query against
# kpkp.htb triggers building all 2-vs-2 tablebases.  Tablebases must
# either have control files in the xml/ subdirectory or follow the
# naming convention recognized by genctlfile.pl.
#
# GNU Make is required to process this makefile, along with xmllint
# (part of libxml2) to extract dependencies from the control files.

HOFFMAN ?= ../hoffman

NALIMOV ?= ~/Nalimov

PROBES-FAST = ../PROBES-FAST
PROBES-SLOW = ../PROBES-SLOW

check-fast: $(PROBES-FAST)
	@cat $(PROBES-FAST) | while read md5expected input files; do					\
		if [ "$$md5expected" != "" -a "$$md5expected" != "#" ]; then				\
			if [ "$$files" != "" -a "$$files" != "doesNotExist.htb" ]; then			\
				make $$files;								\
			fi;										\
			echo $$input									\
				| $(HOFFMAN) -p $$files 2>&1 | tee /dev/stderr				\
				| tail -n +2								\
				| md5sum | ( read md5actual junk;					\
					if [ "$$md5expected" != "$$md5actual" ]; then			\
						echo $$md5expected != $$md5actual; exit 1;		\
					fi								\
				) || exit 1;								\
		fi;											\
	done
	@echo
	@echo All tests completed successfully

check-slow: $(PROBES-SLOW)
	@cat $(PROBES-SLOW) | while read md5expected input files; do					\
		if [ "$$md5expected" != "" -a "$$md5expected" != "#" ]; then				\
			if [ "$$files" != "" -a "$$files" != "doesNotExist.htb" ]; then			\
				make $$files;								\
			fi;										\
			echo $$input									\
				| $(HOFFMAN) -p $$files 2>&1 | tee /dev/stderr				\
				| tail -n +2								\
				| md5sum | ( read md5actual junk;					\
					if [ "$$md5expected" != "$$md5actual" ]; then			\
						echo $$md5expected != $$md5actual; exit 1;		\
					fi								\
				) || exit 1;								\
		fi;											\
	done
	@echo
	@echo All tests completed successfully

# Generate XML files by either copying them from the xml directory or
# using a Perl script.  XML files generated by this rule are
# intermediate targets and would be removed except for .SECONDARY:

%.xml:
	@if [ -r ../xml/$@ ]; then echo ln -s ../xml/$@ .; else echo ../genctlfile.pl $@; fi
	@if [ -r ../xml/$@ ]; then ln -s ../xml/$@ .; else ../genctlfile.pl $@; fi

.SECONDARY:

# $(call futurebases, XMLFILE)
#    returns a list of futurebases that this XMLFILE depends on
#
# Example: $(call futurebases, kpkp.xml) might return
#    "kk.htb kqk.htb krk.htb kbk.htb knk.htb"
#
# This next version doesn't work because XPath 'string' only uses the
# first item in the node set and xmllint doesn't support XPath 2.0's
# 'string-join'
#
# define futurebases
#    $(shell xmllint --xpath "string(//futurebase/@filename)" $(1))
# endef
#
# If you don't have xmllint you can use this version:
#
# define futurebases
#    $(shell grep futurebase $(1) | cut -d \" -f 2)
# endef

define futurebases
   $(shell xmllint --xpath "//futurebase/@filename" $(1) | sed -e 's/[^"]*"//' -e ':a' -e 's/"[^"]*"/ /' -e 'ta' -e 's/".*/\n/')
endef

# We may need to build other tablebases that the target depends
# on. This next idea doesn't work because make won't use implicit
# rules multiple times in a chain.  So we recursively call make
# instead.
#
# .SECONDEXPANSION:
#
# %.htb: %.xml $$(call futurebases, %.xml)
# 	$(HOFFMAN) -g $<

%.htb: %.xml
	@echo Making $@
	@$(if $(strip $(call futurebases, $<)), $(MAKE) $(call futurebases, $<))
	$(HOFFMAN) -g -v $<
	$(if $(wildcard $(NALIMOV)/$*.nbb.emd), $(HOFFMAN) -v -n $(NALIMOV) $@)

clean:
	-rm $(wildcard *.xml) $(wildcard *.htb)
