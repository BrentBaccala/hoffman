#
# Testing framework for Hoffman
#
# HOFFMAN is how we call the program
#
# NALIMOV is an optional directory containing Nalimov tablebases.  If
# they exist, they are used to verify any corresponding Hoffman
# tablebases after they are built.
#
# REQUIRED_HTBs are the tablebases that must be built for a 'make
# check'.  They include kpkp (the simplest tablebase which checks
# en-passant handling), a few bitbases and suicide analyses, and
# almost all of the xml files starting with an r, which are test cases
# to check bugs fixed in various numbered RCS revisions, i.e, r796.xml
# tests a bug in the initialization routine fixed in revision 1.796.
#
# FAILING_TESTS are a list of xml tests which are expected to fail to
# build.  They test bugs which produced segfaults or corrupt
# tablebases, and are excluded from REQUIRED_HTBs.
#
# PROBES is a file containing a list of Hoffman queries against the
# tablebases listed as REQUIRED_HTBs, along with the MD5 hashes of the
# expected output
#
# GNU Make is required to process this makefile, along with xmllint
# (part of libxml2) to extract dependencies from the control files.

HOFFMAN ?= ../hoffman

NALIMOV ?= ~/Nalimov

FAILING_TESTS = r810.xml r814.xml

TESTING_XMLs = $(filter-out $(FAILING_TESTS), $(notdir $(wildcard ../xml/r*.xml)))

REQUIRED_HTBs = kpkp.htb kqk-basic.htb kqk-whitewins.htb krvq.htb \
	fortress.htb lasker1901.htb kqpk.htb $(TESTING_XMLs)

PROBES = ../PROBES

check: $(REQUIRED_HTBs) $(PROBES)
	@cat $(PROBES) | while read md5expected input files; do						\
		if [ "$$md5expected" != "" -a "$$md5expected" != "#" ]; then				\
			echo $$input									\
				| $(HOFFMAN) -p $$files 2>&1 | tee /dev/stderr				\
				| tail -n +2								\
				| md5sum | ( read md5actual junk;					\
					if [ "$$md5expected" != "$$md5actual" ]; then			\
						echo $$md5expected != $$md5actual; exit 1;		\
					fi								\
				) || exit 1;								\
		fi;											\
	done
	@echo
	@echo All tests completed successfully


# Generate XML files by either copying them from the xml directory or
# using a Perl script XML files generated by this rule are
# intermediate targets and would be removed except for .SECONDARY:

%.xml:
	@if [ -r ../xml/$@ ]; then echo ln -s ../xml/$@ .; else echo ../genctlfile.pl $@; fi
	@if [ -r ../xml/$@ ]; then ln -s ../xml/$@ .; else ../genctlfile.pl $@; fi

.SECONDARY:

# $(call futurebases, XMLFILE)
#    returns a list of futurebases that this XMLFILE depends on
#
# Example: $(call futurebases, kpkp.xml) might return
#    "kk.htb kqk.htb krk.htb kbk.htb knk.htb"
#
# This next version doesn't work because XPath 'string' only uses the
# first item in the node set and xmllint doesn't support XPath 2.0's
# 'string-join'
#
# define futurebases
#    $(shell xmllint --xpath "string(//futurebase/@filename)" $(1))
# endef
#
# If you don't have xmllint you can use this version:
#
# define futurebases
#    $(shell grep futurebase $(1) | cut -d \" -f 2)
# endef

define futurebases
   $(shell xmllint --xpath "//futurebase/@filename" $(1) | sed -e 's/[^"]*"//' -e ':a' -e 's/"[^"]*"/ /' -e 'ta' -e 's/".*/\n/')
endef

# We may need to build other tablebases that the target depends
# on. This next idea doesn't work because make won't use implicit
# rules multiple times in a chain.  So we recursively call make
# instead.
#
# .SECONDEXPANSION:
#
# %.htb: %.xml $$(call futurebases, %.xml)
# 	$(HOFFMAN) -g $<

%.htb: %.xml
	@echo Making $@
	@$(if $(strip $(call futurebases, $<)), $(MAKE) $(call futurebases, $<))
	$(HOFFMAN) -g -v $<
	$(if $(wildcard $(NALIMOV)/$*.nbb.emd), $(HOFFMAN) -v -n $(NALIMOV) $@)

clean:
	-rm $(wildcard *.xml) $(wildcard *.htb)
