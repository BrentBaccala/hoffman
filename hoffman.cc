/* -*- mode: C; fill-column: 100; eval: (c-set-style "stroustrup"); -*-
 *
 * HOFFMAN - a chess endgame tablebase builder
 *
 * by Brent Baccala
 *
 * August, 2006
 *
 * no rights reserved; you may freely copy, modify, or distribute HOFFMAN
 *
 * written in C for speed
 *
 * This program is formated for a (minimum) 100 character wide display.
 *
 * INTRODUCTION
 *
 * This program calculates chess tablebases, which are large files containing all possible
 * configurations of chess pieces in an endgame and the best play to either win or draw.  Unlike a
 * conventional chess engine, which uses a heuristic evaluation function, a retrograde engine is
 * almost completely non-heuristic.  When it labels a position as a win, it is because it has
 * considered all possibles lines, be they 10, 20, or 100 moves long, and determined that the win is
 * forced, even with best play by the opposing side.  Some chess-like games, such as the Japanese
 * game Shogi, are not suitable for retrograde analysis because pieces never leave the game
 * (captured pieces in Shogi can be put back into play by the capturing player).  Yet for chess, the
 * frequent reduction of games to positions where only a handful of pieces remain has created an
 * entire subfield of endgame analysis.
 *
 * Systematic analysis of chess endgames dates at least to the ninth century.  Pioneering work in
 * computer retrograde analysis was done in the 1980s by Ken Thompson, the same of UNIX fame, and
 * S.J. Edwards, but the most popular tablebases today are those generated by a program written by
 * E.V. Nalimov.  Suffice it to say that while Nalimov's program has completely solved all chess
 * endgames with six or fewer pieces remaining, and while Nalimov tablebases are widely available on
 * the Internet, the Nalimov approach of solving an endgame completely results in very slow run
 * times and exceptionally large tablebases.  The K+P+P vs K+P endgame, for example, due to the
 * possibility of all pawns queening, requires the K+Q+Q vs K+Q endgame to be solved before it can
 * be calculated.
 *
 * Hoffman takes a somewhat different approach, one pioneered by the Eiko Bleicher's Freezer, now a
 * commercial program. When faced with something like K+P+P vs K+P, rather than calculate all
 * possible resulting positions, it may ignore the possibility of more than two pawns queening at
 * the same time, thus computing nothing more complex than K+Q+P vs K+Q.  While incomplete, such a
 * tablebase is nevertheless useful.  For the player with two pawns, if the tablebase finds a
 * winning line subject to the queening restrictions, then that line is still playable for a win,
 * even though a faster winning line may exist.  From the opposing point of view, if the tablebase
 * treats any position where the third pawn queens as a forced win, then the player can be confident
 * that any drawing line can not be improved upon by the superior side.  From a computational
 * perspective, we have reduced the complexity requirements to a point where the calculation can be
 * performed in a reasonable amount of time.  While still too slow for over-the-board use, we now
 * have a useful tool for the analysis of more complex endgames, useful for either static analysis,
 * or for the slow time controls of correspondence games.
 *
 * Hoffman improves upon Freezer with a more sophisticated method of chaining one endgame analysis
 * into another, allowing more realistic modeling of queening combinations and exchanges.  For
 * example, in a bishop vs knight endgame (with pawns), if we can (if we wish) analyze first the
 * king and pawn endgame resulting after a trade of the minors, then use this information to analyze
 * a similar set of king vs knight and king vs bishop endgames, and finally combine all this
 * information together to analyze the bishop vs knight endgame.  While the current version of
 * Freezer can only regard the capture of the knight or bishop as a forced win for one side or the
 * other, Hoffman can look through the exchange to determine the result more accurately.
 *
 * Hoffman thus attempts to combine the best of Nalimov and Freezer.  Unlike Freezer, the program is
 * powerful enough to solve any endgame completely (given enough computing resources), exactly
 * reproducing any Nalimov tablebase.  Unlike Nalimov, the program is capable of pruning pawn moves,
 * queening combinations, movement options and exchanges, giving it Freezer's ability to solve
 * complex endgames in a reasonable amount of time.  The exact tradeoff between the two extremes is
 * made using a XML-based configuration that can seem daunting at first, but ultimately offers the
 * user the ability to extensively tailor the program's operation.  Combined with a human being's
 * common sense and chess judgement, it is my hope that this flexibility with ultimately make the
 * program more useful for endgame retrograde analysis than either Nalimov or Freezer.
 *
 * For those not up on Americana, the program is named after Trevor Hoffman, an All Star baseball
 * pitcher who specializes in "closing" games.  It was written specifically for The World vs. Arno
 * Nickel game.
 *
 *
 * Usage: hoffman -g -o <output-tablebase> <xml-control-file>     (generate mode)
 *        hoffman -v <tablebase> ...                              (verification mode)
 *        hoffman -p <tablebase> ...                              (probe mode)
 */

#define _LARGEFILE64_SOURCE	/* because some of our files will require 64-bit offsets */

#define _XOPEN_SOURCE 600	/* for posix_memalign() and posix_fadvise() */

#define _GNU_SOURCE		/* to get O_DIRECT */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>	/* for write(), lseek(), gethostname() */
#include <time.h>	/* for putting timestamps on the output tablebases */
#include <fcntl.h>	/* for O_RDONLY */
#include <netdb.h>	/* for gethostbyname() */

#include <sys/time.h>     /* for reporting resource utilization */
#include <sys/resource.h>

#include <sys/mman.h>	/* for mmap() */

#include <errno.h>	/* for EINPROGRESS */

/* The program uses POSIX asynchronous I/O extensively.  Right now (November 2006), there are
 * basically two different Linux implementations available for this.  The native interface in the
 * 2.6 kernel series looks great on paper, but still seems to block at critical places.  GLIBC does
 * asynchronous I/O using threads, which works better right now but incurs the overhead of context
 * switches between the threads.  I've got both versions installed on my system and pick which one I
 * want to use by selecting the appropriate header file here and the appropriate library
 * (-lposix-aio for the native interface; -lrt for the GLIBC threads version) in the Makefile.  The
 * two selections have to match up; if they don't things will compile without warnings but fail with
 * various mysterious errors at runtime.
 */

#include </usr/local/include/aio.h>
/* #include </usr/include/aio.h> */

/* The GNU readline library, used for prompting the user during the probe code.  By defining
 * READLINE_LIBRARY, the library is set up to read include files from a directory specified on the
 * compiler's command line, rather than a system-wide /usr/include/readline.  I use it this way
 * simply because I don't have the readline include files installed system-wide on my machine.
 */

#define READLINE_LIBRARY
#include "readline.h"
#include "history.h"

/* The GNOME XML library.  To use it, I need "-I /usr/include/libxml2" (compiler) and "-lxml2"
 * (linker).
 */

#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xmlsave.h>

/* The ZLIB compression library */

#include <zlib.h>

/* According the GCC documentation, "long long" ints are supported by the C99 standard as well as
 * the GCC compiler.  In any event, since chess boards have 64 squares, being able to use 64 bit
 * integers makes a bunch of stuff a lot easier.  Might have to be careful with this if porting.
 */

typedef unsigned long long int int64;
typedef unsigned int int32;
typedef short boolean;

typedef int32 index_t;


#define ROW(square) ((square) / 8)
#define COL(square) ((square) % 8)

inline int square(int row, int col)
{
    return (col + row*8);
}

/***** GLOBAL CONSTANTS *****/

/* Maximum number of pieces; used to simplify various arrays
 *
 * "8" may seem absurd, but it's probably about right.  "4" is easily doable in memory.  "5"
 * requires sweeping passes across a file on disk.  "6" and "7" are worse than "5", but doable with
 * severe restrictions on the movements of the pieces.  So "8" is enough.
 */

#define MAX_PIECES 16

/* Why 100?  Well, I just think it's less likely to introduce bugs into this code if I count
 * half-moves instead of moves.  So it takes 100 half-moves to stalemate.
 */

#define STALEMATE_COUNT 100

/* Number of possibilities for pawn promotions.  "2" means queen and knight, but that can cause some
 * problems, as I've learned the hard (and embarrassing) way.
 */

#define PROMOTION_POSSIBILITIES 4

/* seven possible pieces: KQRBNP; 64 possible squares, up to 8 directions per piece, up to 7
 * movements in one direction
 */

#define NUM_PIECES 6
#define NUM_SQUARES 64
#define NUM_DIR 8
#define NUM_MOVEMENTS 7

/* Variables for gathering statistics */

int64 backproped_moves = 0;

int64 total_legal_positions = 0;
int64 total_PNTM_mated_positions = 0;
int64 total_stalemate_positions = 0;
int64 total_moves = 0;
int64 total_futuremoves = 0;
int64 total_backproped_moves = 0;
int64 total_passes = 0;

struct timeval program_start_time;
struct timeval pass_start_time;

int entries_write_stalls = 0;
int entries_read_stalls = 0;
int proptable_read_stalls = 0;
int proptable_writes = 0;

struct timeval entries_write_stall_time = {0, 0};
struct timeval entries_read_stall_time = {0, 0};
struct timeval proptable_read_stall_time = {0, 0};
struct timeval proptable_write_time = {0, 0};
struct timeval proptable_preload_time = {0, 0};


/***** DATA STRUCTURES *****/

/* 'futurevectors' are bit vector used to track which futuremoves have been handled in a particular
 * position.  They are of type futurevector_t, and the primary operations used to construct them are
 * FUTUREVECTOR(move) to get a futurevector with a bit set in move's position, and
 * FUTUREVECTORS(move,n) to get a futurevector with n bits set starting with move.
 */

typedef int64 futurevector_t;
#define FUTUREVECTOR(move) (1ULL << (move))
#define FUTUREVECTORS(move, n) (((1ULL << (n)) - 1) << (move))

/* These arrays hold the bit locations in the futurevector of various futuremoves. */

int num_futuremoves = 0;
int futurecaptures[MAX_PIECES][MAX_PIECES];
int promotions[MAX_PIECES];
int futuremoves[MAX_PIECES][64];

/* XXX hardwired 100 futuremove max here */
char movestr[100][16];

futurevector_t pruned_futuremoves = 0;
futurevector_t conceded_futuremoves = 0;
futurevector_t discarded_futuremoves = 0;

/* position - the data structures that represents a board position
 *
 * There are two kinds of positions: local and global.  Locals are faster but are tied to a specific
 * tablebase.  Globals are more general and are used for probing.
 *
 * Both types use a 64-bit board_vector with one bit for each board position, in addition to a flag
 * to indicate which side is to move and the en passant capture square (or -1 if no en passant
 * capture is possible).  We use board_vector to easily check if possible moves are legal by looking
 * for pieces that block our moving piece.  This is done during futurebase propagation, during
 * intratable propagation, and during initialization.  It could be used to check if en passant
 * positions are legal (are the two squares behind the pawn blocked or not), but that is problematic
 * now because the board_vector isn't correct at the point where we need to make that check.
 *
 * Local positions use numbers (0-63) indicating the positions of the pieces, and also have a quick
 * way to check captures using a PTM_vector (pieces of the Player to Move).  You have to look into
 * the tablebase structure to figure out what piece corresponds to each number.  PTM_vector is only
 * used during tablebase initialization and in the probe code.
 *
 * It makes sense to include these vectors in the position structures because it's easiest to
 * compute them in the routines that convert indices to positions, but if you alter the position,
 * then they get out of sync, and its tempting to just leave them that way because you rarely need
 * them to be right at that point.  This really came back to haunt me when implementing en passant.
 *
 * Global positions contain an 8x8 unsigned char array with ASCII characters representing each
 * piece.
 *
 * Sometimes I allow the board and PTM vectors to get out of sync with the position (for speed).
 * This can be a problem, so it has to be done really carefully.
 *
 * We don't worry about moving a piece that's pinned on our king, for example.  The resulting
 * position will already have been flagged illegal in the table.
 *
 */

/* Where are the kings located in the piece list? */

#define WHITE_KING 0
#define BLACK_KING 1

typedef struct {
    struct tablebase *tb;
    int64 board_vector;
    int64 PTM_vector;
    short side_to_move;
    short en_passant_square;
    short piece_position[MAX_PIECES];
} local_position_t;

/* This is a global position, that doesn't depend on a particular tablebase.  It's slower to
 * manipulate, but is suitable for probing tablebases.  Each char in the array is either 0 for an
 * empty square, and one of the FEN characters for a chess piece.
 */

typedef struct {
    unsigned char board[64];
    short side_to_move;
    short en_passant_square;
} global_position_t;


/* bitvector gets initialized in init_movements() */

int64 bitvector[64];
int64 allones_bitvector = 0xffffffffffffffffLL;

/* pawn can't be on the first or last eight squares of the board */
#define LEGAL_PAWN_BITVECTOR 0x00ffffffffffff00LL

/* I'm not sure which one of these will be faster... */

/* #define BITVECTOR(square) bitvector[square] */
#define BITVECTOR(square) (1ULL << (square))

/* tablebase - the data structure used to hold tablebases
 *
 * WHITE and BLACK are also used for the side_to_move variable in the position type above
 */

#define KING 0
#define QUEEN 1
#define ROOK 2
#define BISHOP 3
#define KNIGHT 4
#define PAWN 5

char * piece_name[NUM_PIECES+1] = {"KING", "QUEEN", "ROOK", "BISHOP", "KNIGHT", "PAWN", NULL};
char piece_char[NUM_PIECES+1] = {'K', 'Q', 'R', 'B', 'N', 'P', 0};

char * colors[3] = {"WHITE", "BLACK", NULL};

/* We make a tacit assumption later (during promotion back propagation, when we compute the
 * futuremove number) that these numbers (QUEEN to KNIGHT) range from 1 to 4, and that they appear
 * in this array in numerical order.
 */

int promoted_pieces[] = {QUEEN, ROOK, BISHOP, KNIGHT, 0};

unsigned char global_pieces[2][NUM_PIECES] = {{'K', 'Q', 'R', 'B', 'N', 'P'},
					      {'k', 'q', 'r', 'b', 'n', 'p'}};

#define WHITE 0
#define BLACK 1


/* tablebase_t
 *
 * The 'xml' in the tablebase is authoritative; much of the other info is extracted from it
 * for efficiency.
 *
 * To make this work for either white or black positions, let's adopt the notation PTM (Player to
 * move) and PNTM (Player not to move)
 *
 * 'movecnt' is is the number of moves FORWARD from this position that haven't been analyzed yet,
 * with the high bit (128) set if PTM is in check.
 *
 * 'dtm' (Distance to Mate) is the number of moves required to force a mate.  It is positive
 * for a PTM mate and negative for a PNTM mate.
 *
 * Now PTM can mate with even a single move out of a position, so a postive dtm means PTM mates.
 * PNTM can only mate if PTM has no possible move that leads to mate, so a negative dtm coupled with
 * a 0 or 128 movecnt means PNTM mates.
 *
 * So, if we backtrace from a single PTM WINS, then this position becomes PTM WINS.  If we backtrace
 * from PNTM WINS, we decrement movecnt and adjust dtm to the lowest value (the slowest mate).  If
 * movecnt reaches 0 or 128, then the position becomes PNTM WINS.  When we're all done backtracing
 * possible wins, anything left with a non-zero movecnt, or a zero dtm, is a DRAW.
 *
 * We also need a mate-in count and a stalemate (conversion) count.
 *
 */

struct fourbyte_entry {
    unsigned char movecnt;
    char dtm;
    unsigned char dtc;
    unsigned char resv;
};

#define RESTRICTION_NONE 0
#define RESTRICTION_DISCARD 1
#define RESTRICTION_CONCEDE 2

char * restriction_types[4] = {"NONE", "DISCARD", "CONCEDE", NULL};

#define FORMAT_FOURBYTE 0
#define FORMAT_ONE_BYTE_DTM 1

char * formats[] = {"fourbyte", "one-byte-dtm", NULL};

typedef struct tablebase {
    index_t max_index;
    index_t modulus;
    enum {NAIVE_INDEX=1, SIMPLE_INDEX, XOR_INDEX} index_type;
    int total_legal_piece_positions[MAX_PIECES];
    int simple_piece_positions[MAX_PIECES][64];
    int simple_piece_indices[MAX_PIECES][64];
    int last_identical_piece[MAX_PIECES];
    int next_identical_piece[MAX_PIECES];

    /* for futurebases only */
    gzFile file;
    long offset;
    int invert_colors;
    int extra_piece;
    int missing_pawn;
    int missing_non_pawn;

    xmlDocPtr xml;
    xmlNodePtr per_pass_stats;
    xmlNodePtr current_pass_stats;

    int num_pieces;
    int move_restrictions[2];		/* one for each color */
    short piece_type[MAX_PIECES];
    short piece_color[MAX_PIECES];
    int64 piece_legal_squares[MAX_PIECES];

    int format;

    int entries_fd;
    struct fourbyte_entry *entries;
    futurevector_t *futurevectors;
} tablebase_t;

/* Propagation table
 *
 * This is used to optimize back propagation for large tablebases where the entire entries array
 * can't fit in memory.  Back propagation is done by first building proptable entries and sorting
 * them into a proptable.  The sorted proptable is then merged into the entries array.
 *
 * Currently, proptable entries are 16 bytes (128 bits) - a 32 bit index, 32 more bits of
 * housekeeping, and a 64 bit futurevector.  This is significant because many Pentium architectures
 * use 64 byte cache lines.
 */

typedef struct {
    index_t index;
    short dtm;
    unsigned char dtc;
    unsigned char movecnt;
    futurevector_t futurevector;
} proptable_entry_t;

proptable_entry_t *proptable = NULL;

tablebase_t *proptable_tb = NULL;

/* 0 indicates that we're not use proptables */
int num_propentries = 0;

/* PROPTABLE_BITS for 16 byte entries:
 *
 * 8 = 256 entries = 4KB (testing)
 * 16 = 64K entries (what I've been using)
 * 20 = 1M entries = 16MB
 * 24 = 16M entries = 256MB
 */

#define MAX_ZEROOFFSET 25

#define SEPERATE_PROPTABLE_FILES 0

#define FINITE_FIELD_INVERSION 1


/***** UTILITY FUNCTIONS *****/

/* Matches a string against a NULL-terminated array of strings using case insensitive match.
 * Returns index in array of matching string, or -1 if there was no match.
 */

int find_name_in_array(char * name, char * array[])
{
    int i=0;

    while (*array != NULL) {
	if (!strcasecmp(name, *array)) return i;
	array ++;
	i ++;
    }

    return -1;
}


/***** INDICES *****/

/* Basically there are two functions here - one converts an index to a local position, the other
 * converts a local position to an index - but they exist in several different versions, depending
 * on the type of index we're using for a particular tablebase.  These functions are used
 * extensively during all types of back propagation.
 *
 * local_position_to_index() also updates the position's board_vector (which doesn't have to be
 * valid going in), but not the PTM_vector.  It does this to check for illegal en passant positions.
 * It returns either an index into the table, or -1 if the position is illegal.
 *
 * Actually, it doesn't update the board vector anymore because we work on a copy of the position.
 *
 * index_to_local_position(), given an index, fill in a board position.  Obviously has to correspond
 * to local_position_to_index() and it's a big bug if it doesn't.  The boolean that gets returned is
 * TRUE if the operation succeeded and FALSE if the index was illegal.
 *
 * Several issues crop up for all index types.
 *
 * What exactly is an illegal position?  Well, for starters, one that index_to_local_position()
 * reports as illegal, because that's the function that initialize_tablebase() uses to figure which
 * positions are flagged illegal, as well as which positions to consider during back prop, and the
 * program screams if you try to back prop into an illegal position.  So the two functions have to
 * agree on illegality.  But there's also a subtle interaction between the legality tests here and
 * the move counting code in initialize_tablebase().  If we count a move, and it's not considered a
 * futuremove, then it'd better lead to a legal position, because we'll never backprop from an
 * illegal one, and that would imbalance the forward and reverse move counting.  For speed purposes,
 * the move counting code currently does not actually check positions to see if they are illegal.
 * So we can't, for example, flag positions with adjacent kings as illegal without updating that
 * code.
 *
 * En passant.  This is another case where subtle concepts of "legality" show up.  When we back
 * propagate a local position from either a futurebase or intratable, we generate en passant
 * positions simply by running through the pawns on the fourth and fifth ranks.  We look then to see
 * if there was a piece behind the "en passant" pawn (that would have prevented it from moving), but
 * (unlike Nalimov) we don't check if there is an enemy pawn that actually could have captured.
 * Again, the code has to match up between the two places, or we would try to back propagate to a
 * position that had been labeled illegal during initialization by index_to_local_position().
 *
 * Identical pieces.  Identical positions need to generate identical indices.  If we have two
 * identical pieces, then transposing them in a position can't affect the outcome of
 * local_position_to_index().  Right now, I deal with this by making a copy of the local position
 * and sorting identical pieces into ascending position numbers.
 *
 * So how about a static 64-bit vector with bits set for pieces frozen on a single square?
 * Everytime we call index_to_local_position, copy from the static vector into the position
 * structure.  Then we compute the positions of the mobile pieces and plug their bits into the
 * structure's vector at the right places.  Might implement this some day.
 */

unsigned char byte_transform[256];

unsigned char multiply_in_GF2_8(unsigned char a, unsigned char b)
{
    unsigned char result = 0;

    while (a != 0) {
	if ((a&1) == 1) result ^= b;
	a >>= 1;
	if ((b&0x80) == 0x80) {
	    b ^= 0x80;
	    b <<= 1;
	    b ^= 0x1b;
	} else {
	    b <<= 1;
	}
    }
    return result;
}

unsigned char byte_transform_64[64];
unsigned char byte_transform_64b[64];
unsigned char byte_transform_64c[64];

unsigned char multiply_in_GF2_6(unsigned char a, unsigned char b, unsigned char irreducible_polynomial)
{
    unsigned char result = 0;

    while (a != 0) {
	if ((a&1) == 1) result ^= b;
	a >>= 1;
	b <<= 1;
	if ((b&0x40) == 0x40) {
	    b ^= irreducible_polynomial;
	}
    }
    return result;
}

void initialize_byte_transform(void)
{
    unsigned char a;
    unsigned char b;

    byte_transform[0] = 0;

    for (a=1; a!=0; a++) {
	for (b=1; b!=0; b++) {
	    if (multiply_in_GF2_8(a,b) == 1) {
		byte_transform[a] = b;
		break;
	    }
	}
	if (b == 0) {
	    fprintf(stderr, "Couldn't invert in initialize_byte_transform\n");
	}
	/* fprintf(stderr, "0x%02x -> 0x%02x\n", a, b); */
    }

    byte_transform_64[0] = 0;
    byte_transform_64b[0] = 0;
    byte_transform_64c[0] = 0;

    /* use first three irreducible polynomials from Marsh's table for GF(2^6) */

    for (a=1; a<=63; a++) {
	for (b=1; b<=63; b++) {
	    if (multiply_in_GF2_6(a,b, 0103) == 1) {
		byte_transform_64[a] = b;
	    }
	    if (multiply_in_GF2_6(a,b, 0111) == 1) {
		byte_transform_64b[a] = b;
	    }
	    if (multiply_in_GF2_6(a,b, 0127) == 1) {
		byte_transform_64c[a] = b;
	    }
	}
    }
}

#define encode_index(INDEX)                                                                     \
   asm("                                                                                        \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                          " : "+a" (INDEX) : "b" (byte_transform) : "cx", "cc")

#define decode_index(INDEX)                                                                     \
   asm("                                                                                        \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                          " : "+a" (INDEX) : "b" (byte_transform) : "cx", "cc")

/* Later in the program, I'll use these indices as the keys in an address calculation insertion
 * sort.  This kind of sort performs well if the keys are evenly distributed, and performs horribly
 * if the keys are clumped together.  Since checkmates occur in groups of similar positions,
 * something has to be done.  "Something" is inversion of the indices in a finite field,
 * specifically a modulo ring with a prime modulus.  The modulus is specified in the XML
 * configuration, and I don't check to make sure it's prime - there are other programs available
 * that do that.
 *
 * Originally, I used the HalfExtendedEuclidian algorithm from Manuel Bronstein's book "Symbolic
 * Integration I":
 *
 * Given a Euclidean domain D and a,b in D, return s,g in D such that g = gcd(a,b) and sa=g (mod b)
 *
 * But I had so much trouble implementing it that I wrote out the following explanation and then
 * coded it myself.
 *
 * Consider an array of number x[n].  To compute gcd(a,b), we set up x[0]=a and x[1]=b, then
 * repeatedly compute x[n+1] = x[n-1] % x[n].  So
 *
 *      x[n-1] = q[n] * x[n] + x[n+1],
 *
 * because x[n+1] is the remainder, and q[n] is the quotient of the n'th division.
 *
 *      x[n+1] = x[n-1] - q[n] * x[n],
 *
 * so all common factors of x[n] and x[n-1] are preserved in x[n+1] (if it is non-zero).
 * Eventually, x[n+1] will be zero, and x[n] will then be gcd(a,b).
 *
 * Now, each x[n] can be written in terms of a and b: x[n] = a[n] * a + b[n] * b.  Since
 *
 *      x[n+1]                  = x[n-1]                    - q[n] * x[n]
 *
 *      a[n+1] * a + b[n+1] * b = (a[n-1] * a + b[n-1] * b) - q[n] * (a[n] * a + b[n] * b)
 *
 *                              = (a[n-1] * a + b[n-1] * b) - q[n] * a[n] * a - q[n] * b[n] * b
 *
 *                              = (a[n-1] - q[n] * a[n]) * a + (b[n-1] - q[n] * b[n]) * b
 *
 *      a[n+1] = a[n-1] - q[n] * a[n]      and      b[n+1] = b[n-1] - q[n] * b[n]
 *
 * We started with x[0]=a and x[1]=b, so a[0]=1, b[0]=0, a[1]=0, and b[1]=1
 *
 * When we finally compute x[n] = gcd(a,b), we can decompose this into a[n] * a + b[n] * b,
 * and if a was the prime modulus of our finite field, then x[n] = gcd(a,b) = 1, so:
 *
 *        1 = a[n] * a + b[n] * b
 *
 *        1 = b[n] * b  (mod a)
 *
 * i.e, b[n] is the multiplicative inverse of b (mod a).
 *
 * Even a hand-coded assembly version of this algorithm was too slow, so on the advice of
 * Prof. Christof Paar I switched to using a binary extended GCD algorithm.  This is based on
 * computing a GCD by repeatedly subtracting the smaller number from the larger one.  A
 * consideration of the equation c = a - b shows that a common multiple of any two of the numbers
 * must be a common multiple of the third.  Therefore, subtracting preserves common multiples in the
 * result and does not introduce any new common multiples.  Because we are working with a binary
 * architecture, detecting multiples of two is easy, so we can eliminate them by right shifting.
 * Since subtracting two odd numbers gives an even number, we can right shift by at least one bit
 * per iteration.  Combining the two operations of subtraction and right shifting, we get a GCD
 * algorithm (14.61 in Menezes' Handbook of Applied Cryptography) that requires more iterations, but
 * still completes in a reasonable time and avoids the expensive multiplications and divisions.
 *
 * As above, we need to track the b[n] part of x[n] = a[n] * a + b[n] * b until we reach a GCD of 1.
 * Subtracting (x[n+1] = x[n] - x[n-1]) is easy:
 *
 *                a[n+1] = a[n] - a[n-1]    and    b[n+1] = b[n] - b[n-1]
 *
 * Right shifting (division by 2) is only a little more difficult.  Let's first note that if x[n] is
 * even (the only case in which we'd be right shifting) and a is odd (it's a prime modulus, after
 * all), then either a[n] is even or a[n] and b[n] must both be odd.  So if b[n] is even, then a[n]
 * is also even and we can right shift everything: x[n]/2 = a[n]/2 * a + b[n]/2 * b, while if
 * b[n] is odd, we can add and subtract a * b to obtain:
 *
 *             x[n] = (a[n] + b) * a + (b[n] - a) * b
 *
 *             x[n]/2 = (a[n] + b)/2 * a + (b[n] - a)/2 * b
 *
 * Remember that a[n] gets discarded; b[n] is all we care about computing.
 *
 * So our operations are:
 *
 *    subtract (x > y)    x = x - y             b[x] = (b[x] - b[y]) mod m
 *
 *    subtract (y > x)    y = y - x             b[y] = (b[y] - b[x]) mod m
 *
 *    right shift x (b[x] even)     x = x / 2                  b[x] = b[x] / 2
 *
 *    right shift x (b[x] odd)      x = x / 2                  b[x] = ((b[x] - m) / 2) mod m
 *
 *                                                         or  b[x] = ((b[x] + m) / 2) mod m
 *
 * m    -> EAX
 * x    -> EBX
 * y    -> ECX
 * (m+1)/2 -> EDX
 * b[x] -> ESI
 * b[y] -> EDI
 *
 * This is a GNU compiler, so we use AT&T assembler syntax - the destination comes second.
 */

#define ASM_invert_in_finite_field(INDEX, MODULUS)						\
   asm("                                                                                        \
                /* Input                                                                    */  \
                /*                                                                          */  \
                /* EAX - modulus                                                            */  \
                /* ECX - index                                                              */  \
                                                                                                \
                mov %%eax, %%ebx;                                                               \
                mov $0, %%esi;                                                                  \
                mov $1, %%edi;                                                                  \
                                                                                                \
                mov %%eax, %%edx;                                                               \
                add $1, %%edx;                                                                  \
                shr %%edx;                                                                      \
                                                                                                \
                /* while ((y&1) == 0)                                                       */  \
                                                                                                \
           1:   test $1, %%ecx;                                                                 \
                jne 2f;                                                                         \
                                                                                                \
                /*     y >>= 1;                                                             */  \
                shr %%ecx;                                                                      \
                                                                                                \
                /*     if ((by&1) == 0) {                                                   */  \
                /*        by >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        by = ((by + m)/2) mod m;                                          */  \
                /*        by = (((by-1 + m+1)/2) mod m;                                     */  \
                /*        by = ((by-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%edi;                                                                      \
                jnc 1b;                                                                         \
                add %%edx, %%edi;                                                               \
                cmp %%eax, %%edi;                                                               \
                jc  1b;                                                                         \
                sub %%eax, %%edi;                                                               \
                jmp 1b;                                                                         \
                                                                                                \
           2:   /* Is x = y ?  Is x > y ?                                                   */  \
                cmp %%ecx, %%ebx;                                                               \
                jz  6f;                                                                         \
                jc  4f;                                                                         \
                                                                                                \
                /* Yes, x > y                                                               */  \
                /* Set x = x - y                                                            */  \
                sub %%ecx, %%ebx;                                                               \
                                                                                                \
                /* Set b[x] = (b[x] - b[y]) mod m                                           */  \
                sub %%edi, %%esi;                                                               \
                jnc 3f;                                                                         \
                add %%eax, %%esi;                                                               \
                                                                                                \
                /* while ((x&1) == 0)                                                       */  \
                                                                                                \
           3:   test $1, %%ebx;                                                                 \
                jne 2b;                                                                         \
                                                                                                \
                /*     x >>= 1;                                                             */  \
                shr %%ebx;                                                                      \
                                                                                                \
                /*     if ((bx&1) == 0) {                                                   */  \
                /*        bx >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        bx = ((bx + m)/2) mod m;                                          */  \
                /*        bx = (((bx-1 + m+1)/2) mod m;                                     */  \
                /*        bx = ((bx-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%esi;                                                                      \
                jnc 3b;                                                                         \
                add %%edx, %%esi;                                                               \
                cmp %%eax, %%esi;                                                               \
                jc  3b;                                                                         \
                sub %%eax, %%esi;                                                               \
                jmp 3b;                                                                         \
                                                                                                \
                /* y > x                                                                    */  \
                /* Set y = y - x                                                            */  \
           4:   sub %%ebx, %%ecx;                                                               \
                                                                                                \
                /* Set b[y] = (b[y] - b[x]) mod m                                           */  \
                sub %%esi, %%edi;                                                               \
                jnc 1b;                                                                         \
                add %%eax, %%edi;                                                               \
                                                                                                \
                jmp 1b;                                                                         \
                                                                                                \
           6:   mov %%edi, %%ecx;                                                               \
                                                                                                \
                          " : "+c" (INDEX) : "a" (MODULUS) : "bx", "dx", "di", "si", "cc")

int32 invert_in_finite_field(int32 b, int32 m)
{
#if 0
    int32 x = m;
    int32 y = b;
    int32 bx = 0;
    int32 by = 1;

    int test = b;
    ASM_invert_in_finite_field(test, m);

    while ((y&1) == 0) {
	y >>= 1;
	if ((by&1) == 0) {
	    by >>= 1;
	} else {
	    by = ((by + m)/2)%m;
	}
    }

    while (x != y) {
	if (x > y) {
	    x = x - y;

	    if (bx > by) bx = (bx - by)%m;
	    else bx = (m + bx - by)%m;

	    while ((x&1) == 0) {
		x >>= 1;
		if ((bx&1) == 0) {
		    bx >>= 1;
		} else {
		    bx = ((bx + m)/2)%m;
		}
	    }
	} else {
	    y = y - x;

	    if (by > bx) by = (by - bx)%m;
	    else by = (m + by - bx)%m;

	    while ((y&1) == 0) {
		y >>= 1;
		if ((by&1) == 0) {
		    by >>= 1;
		} else {
		    by = ((by + m)/2)%m;
		}
	    }
	}
    }
    if (x != 1) fprintf(stderr, "x != 1 in invert_finite_field v2\n");

    if (by != test) {
	fprintf(stderr, "%d: assembly inversion (%d) didn't match C code (%d)\n", b, test, by);
    }

    return by;
#else
    ASM_invert_in_finite_field(b, m);
    return b;
#endif
}

#if 0
int invert_in_finite_field(int b, int modulus)
{
#if 1
    /* We start with n=1 */

    int xn_1 = modulus;  /* x_n-1 = x[0] = a */
    int xn = b;          /* x_n = x[1] = b */
    int bn_1 = 0;        /* b_n-1 = b[0] = 0 */
    int bn = 1;          /* b_n = b[1] = 1 */
    int bnn;

#if 0
    int test = b;
    ASM_invert_in_finite_field(test, modulus);
#else
    int test = invert_in_finite_field_v2(b, modulus);
#endif

    while (xn != 0) {

	int q = xn_1/xn;
	int r = xn_1%xn;

	bnn=bn_1-q*bn;   /* b[n+1] = b[n-1] - q_n * b[n] */

	bn_1=bn;         /* b[n-1] = b[n] */
	bn=bnn;          /* b[n] = b[n+1] */

	xn_1=xn;         /* x[n-1] = x[n] */
	xn=r;            /* x[n] = x[n+1] */
    }

    /* Since xn = x[n] is zero, that means x[n-1] is the gcd (1), and b[n-1] is our inverse.
     *
     * We may, however, have to adjust it to be within the range of our modulo field
     */

    bn_1 = bn_1 % modulus;
    if (bn_1 < 0) bn_1 += modulus;

    if (bn_1 != test) {
	fprintf(stderr, "%d: assembly inversion (%d) didn't match C code (%d)\n", b, test, bn_1);
    }

    if (xn_1 != 1) {
	fprintf(stderr, "GCD not 1 in invert_in_finite_field; was modulus prime?!\n");
    }
    if (bn_1 == 0) {
	fprintf(stderr, "inverse 0 in invert_in_finite_field; was modulus prime?!\n");
    }
    return bn_1;
#else
    ASM_invert_in_finite_field(b, modulus);
    return b;
#endif
}
#endif

/* "Naive" index.  Just assigns a number from 0 to 63 to each square on the board and
 * multiplies them together for the various pieces.  Simple and fast.
 */

index_t local_position_to_naive_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;

    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->piece_legal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");  /* BREAKPOINT */
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index |= COL(pos->en_passant_square) << shift_count;
	} else {
	    index |= pos->piece_position[piece] << shift_count;
	}
	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);

	shift_count += 6;  /* because 2^6=64 */
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean naive_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square = index & 63;

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which positions are legal and which are
	 * not.
	 */

	if (!(tb->piece_legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
	index >>= 6;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "XOR" index.  Assigns a number from 0 to 63 to each square on the board and xor's them together
 * for the various pieces.  Ensures that moving a single piece will result in large strides in the
 * index.
 */

index_t local_position_to_xor_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;
    int val = 0;
    int val1 = 0;
    int val2 = 0;
    int val3 = 0;

    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
    /* for (piece = tb->num_pieces - 1; piece >= 0; piece--) { */

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->piece_legal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");  /* BREAKPOINT */
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    val = COL(pos->en_passant_square);
	} else {
	    val = pos->piece_position[piece];
	}
	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);

#if 0
	index |= (val^val1^val2) << shift_count;
	val2 = val1;
	val1 = byte_transform_64[val];
#else
#if 1
	if (piece == tb->num_pieces - 1) {
	    index |= (val^val3) << shift_count;
	} else if (piece == tb->num_pieces - 2) {
	    index |= (val^val2) << shift_count;
	} else if (piece == tb->num_pieces - 3) {
	    index |= (val^val1) << shift_count;
	} else {
	    index |= val << shift_count;
	}
#else
	if (piece == 0) {
	    index |= (val^val3) << shift_count;
	} else if (piece == 1) {
	    index |= (val^val2) << shift_count;
	} else if (piece == 2) {
	    index |= (val^val1) << shift_count;
	} else {
	    index |= val << shift_count;
	}
#endif
	val1 ^= byte_transform_64[val];
	val2 ^= byte_transform_64b[val];
	val3 ^= byte_transform_64c[val];
#endif

	shift_count += 6;  /* because 2^6=64 */
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean xor_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    int val1 = 0;
    int val2 = 0;
    int val3 = 0;
    int square;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {
    /* for (piece = tb->num_pieces - 1; piece >= 0; piece--) { */

#if 0
	square = (index & 63) ^ val1 ^ val2;
	val2 = val1;
	val1 = byte_transform_64[square];
#else
#if 1
	if (piece == tb->num_pieces - 1) {
	    square = (index & 63) ^ val3;
	} else if (piece == tb->num_pieces - 2) {
	    square = (index & 63) ^ val2;
	} else if (piece == tb->num_pieces - 3) {
	    square = (index & 63) ^ val1;
	} else {
	    square = (index & 63);
	}
#else
	if (piece == 0) {
	    square = (index & 63) ^ val3;
	} else if (piece == 1) {
	    square = (index & 63) ^ val2;
	} else if (piece == 2) {
	    square = (index & 63) ^ val1;
	} else {
	    square = (index & 63);
	}
#endif
	val1 ^= byte_transform_64[square];
	val2 ^= byte_transform_64b[square];
	val3 ^= byte_transform_64c[square];
#endif

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which positions are legal and which are
	 * not.
	 */

	if (!(tb->piece_legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
	index >>= 6;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Simple" index.  Like naive, but only assigns numbers to squares that are legal for a particular
 * piece.  Slower to compute than naive, but more compact for tablebases with lots of movement
 * restrictions on the pieces.
 */

index_t local_position_to_simple_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;

    index = 0;
    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	index *= tb->total_legal_piece_positions[piece];

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->piece_legal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");  /* BREAKPOINT */
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index += tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    index += tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}

	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

    /* We've still got code that assumes flipping the index's LSB flip side-to-move */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean simple_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = tb->simple_piece_positions[piece][index % tb->total_legal_piece_positions[piece]];
	index /= tb->total_legal_piece_positions[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* This should never happen. */

	if (!(tb->piece_legal_squares[piece] & BITVECTOR(square))) {
	    fprintf(stderr, "Illegal piece position in simple_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }

    if (index != 0) {
	fprintf (stderr, "index != 0 at end of simple_index_to_local_position!\n");  /* BREAKPOINT */
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

index_t local_position_to_index(tablebase_t *tb, local_position_t *pos)
{
    int piece;
    int piece2;
    index_t index;

    /* Sort any identical pieces so that the lowest square number always comes first.  We don't want
     * to change around the original position, so we use a copy of it.
     */

    local_position_t copy = *pos;
    pos = &copy;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (pos->piece_position[piece2] < pos->piece_position[tb->last_identical_piece[piece2]])) {
	    int square = pos->piece_position[piece2];
	    pos->piece_position[piece2] = pos->piece_position[tb->last_identical_piece[piece2]];
	    pos->piece_position[tb->last_identical_piece[piece2]] = square;
	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    switch (tb->index_type) {
    case NAIVE_INDEX:
	index = local_position_to_naive_index(tb, pos);
	break;
    case XOR_INDEX:
	index = local_position_to_xor_index(tb, pos);
	break;
    case SIMPLE_INDEX:
	index = local_position_to_simple_index(tb, pos);
	break;
    default:
	fprintf(stderr, "Unknown index type in local_position_to_index()\n");  /* BREAKPOINT */
	return -1;
    }

    if ((index != -1) && (index != 0) && (tb->modulus != 0)) {
#if FINITE_FIELD_INVERSION
	index = invert_in_finite_field(index, tb->modulus);
#else
	encode_index(index);
#endif
    }

    return index;
}

boolean index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    if ((index != 0) && (tb->modulus != 0)) {
#if FINITE_FIELD_INVERSION
	index = invert_in_finite_field(index, tb->modulus);
#else
	decode_index(index);
#endif
    }

    switch (tb->index_type) {
    case NAIVE_INDEX:
	return naive_index_to_local_position(tb, index, p);
    case XOR_INDEX:
	return xor_index_to_local_position(tb, index, p);
    case SIMPLE_INDEX:
	return simple_index_to_local_position(tb, index, p);
    default:
	fprintf(stderr, "Unknown index type in index_to_local_position()\n");  /* BREAKPOINT */
	return 0;
    }
}

/* check_1000_positions(); check_1000_indices() - used just to double check the code above.
 *
 * I don't use check_1000_positions() anymore because it barks if there are identical pieces in a
 * position that come back sorted after being run through a position->index->position conversion.
 */

void check_1000_positions(tablebase_t *tb)
{
    local_position_t position1;
    local_position_t position2;
    index_t index;
    int positions;
    int piece;

    for (positions=0; positions < 1000; positions ++) {

	memset(&position1, 0, sizeof(position1));

	position1.side_to_move = rand() % 2;
	position1.en_passant_square = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    do {
		position1.piece_position[piece] = rand() % 64;
	    } while (! (BITVECTOR(position1.piece_position[piece]) & tb->piece_legal_squares[piece]));
	}

	index = local_position_to_index(tb, &position1);

	if (index != -1) {

	    /* PTM_vector wasn't set in position1, so don't check them now */

	    if (!index_to_local_position(tb, index, &position2)
		|| (position2.PTM_vector = 0,
		    memcmp(&position1, &position2, sizeof(position1)))) {
		fprintf(stderr, "Mismatch in check_1000_positions()\n");  /* BREAKPOINT */
	    }
	}
    }
}

void check_1000_indices(tablebase_t *tb)
{
    local_position_t position;
    index_t index;
    index_t index2;
    int positions;

    for (positions=0; positions < 1000; positions ++) {

	index = rand() % (tb->max_index + 1);

	if (index_to_local_position(tb, index, &position)) {
	    index2 = local_position_to_index(tb, &position);
	    if (index != index2) {
		fprintf(stderr, "Mismatch in check_1000_indices()\n");  /* BREAKPOINT */
	    }
	}
    }
}

/***** XML TABLEBASE INTERACTION *****/

/* Parses XML, creates a tablebase structure corresponding to it, and returns it.
 *
 * I use a DTD and validate the XML input, so there's very little error checking here.  The idea is
 * that the validation provides most of the error checks.
 */

tablebase_t * parse_XML_into_tablebase(xmlDocPtr doc)
{
    tablebase_t *tb;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    xmlNodePtr tablebase;
    xmlChar * format;
    xmlChar * index;
    xmlChar * modulus;

    tb = malloc(sizeof(tablebase_t));
    if (tb == NULL) {
	fprintf(stderr, "Can't malloc tablebase\n");
	return NULL;
    }
    memset(tb, 0, sizeof(tablebase_t));

    tb->xml = doc;

    /* Fetch tablebase from XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression((const xmlChar *) "//tablebase", context);
    tablebase = result->nodesetval->nodeTab[0];
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Fetch the pieces from the XML */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression((const xmlChar *) "//piece", context);
    if (xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fprintf(stderr, "No pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr < 2) {
	fprintf(stderr, "Too few pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr > MAX_PIECES) {
	fprintf(stderr, "Too many pieces!\n");
	return NULL;
    } else {
	int piece;
	int piece2;

	tb->num_pieces = result->nodesetval->nodeNr;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    xmlChar * color;
	    xmlChar * type;
	    xmlChar * location;
	    color = xmlGetProp(result->nodesetval->nodeTab[piece], (const xmlChar *) "color");
	    type = xmlGetProp(result->nodesetval->nodeTab[piece], (const xmlChar *) "type");
	    location = xmlGetProp(result->nodesetval->nodeTab[piece], (const xmlChar *) "location");
	    tb->piece_color[piece] = find_name_in_array((char *) color, colors);
	    tb->piece_type[piece] = find_name_in_array((char *) type, piece_name);

	    if (location == NULL) {
		if (tb->piece_type[piece] == PAWN) {
		    tb->piece_legal_squares[piece] = LEGAL_PAWN_BITVECTOR;
		} else {
		    tb->piece_legal_squares[piece] = allones_bitvector;
		}
	    } else {
		int j = 0;
		tb->piece_legal_squares[piece] = 0;
		while ((location[j] >= 'a') && (location[j] <= 'h')
		       && (location[j+1] >= '1') && (location[j+1] <= '8')) {
		    tb->piece_legal_squares[piece]
			|= BITVECTOR(square(location[j+1] - '1', location[j] - 'a'));
		    j += 2;
		    while (location[j] == ' ') j ++;
		}
		if (location[j] != '\0') {
		    fprintf(stderr, "Illegal piece location (%s)\n", location);
		    return NULL;
		}
	    }

	    if ((tb->piece_color[piece] == -1) || (tb->piece_type[piece] == -1)) {
		fprintf(stderr, "Illegal piece color (%s) or type (%s)\n", color, type);
		return NULL;
	    }

	    /* Now we need to figure out if there are any other pieces identical to this one,
	     * because if so, exchanging the two pieces would not change the position, and that has
	     * to be taken into account in the index code.  Move restrictions on the pieces
	     * complicate this, unless they are either identical or completely non-overlapping.
	     */

	    tb->last_identical_piece[piece] = -1;
	    tb->next_identical_piece[piece] = -1;

	    for (piece2 = piece - 1; piece2 >= 0; piece2 --) {
		if ((tb->piece_color[piece2] == tb->piece_color[piece])
		    && (tb->piece_type[piece2] == tb->piece_type[piece])) {
		    if (tb->piece_legal_squares[piece2] == tb->piece_legal_squares[piece]) {
			tb->last_identical_piece[piece] = piece2;
			tb->next_identical_piece[piece2] = piece;
			break;
		    } else if (tb->piece_legal_squares[piece2] & tb->piece_legal_squares[piece]) {
			fprintf(stderr, "Identical pieces with overlapping non-identical move restrictions not allowed\n");
			return NULL;
		    }
		}
	    }

	    if (color != NULL) xmlFree(color);
	    if (type != NULL) xmlFree(type);
	    if (location != NULL) xmlFree(location);
	}
    }

    if ((tb->piece_color[WHITE_KING] != WHITE) || (tb->piece_type[WHITE_KING] != KING)
	|| (tb->piece_color[BLACK_KING] != BLACK) || (tb->piece_type[BLACK_KING] != KING)) {
	fprintf(stderr, "Kings aren't where they need to be in piece list!\n");
	return NULL;
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    format = xmlGetProp(tablebase, (const xmlChar *) "format");
    if (format == NULL) {
	tb->format = FORMAT_FOURBYTE;
	xmlNewProp(tablebase, (const xmlChar *) "format", (const xmlChar *) formats[tb->format]);
	fprintf(stderr, "Format not expressly specified; assuming FOURBYTE\n");
    } else {
	tb->format = find_name_in_array((char *) format, formats);
	if (tb->format == -1) {
	    fprintf(stderr, "Unknown tablebase format '%s'\n", format);
	    return NULL;
	}
    }

    /* Fetch the index type and compute tb->max_index (but see next section of code) */

    index = xmlGetProp(tablebase, (const xmlChar *) "index");
    if ((index == NULL) || !strcasecmp((char *) index, "naive")) {
	if (index == NULL) {
	    xmlNewProp(tablebase, (const xmlChar *) "index", (const xmlChar *) "naive");
	    fprintf(stderr, "Index type not expressly specified; assuming NAIVE\n");
	}
	tb->index_type = NAIVE_INDEX;
	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	tb->max_index = (2<<(6*tb->num_pieces)) - 1;
    } else if (!strcasecmp((char *) index, "xor")) {
	tb->index_type = XOR_INDEX;
	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	tb->max_index = (2<<(6*tb->num_pieces)) - 1;
    } else if (!strcasecmp((char *) index, "simple")) {
	int piece, square;

	/* The "2" is because side-to-play is part of the position */
	tb->index_type = SIMPLE_INDEX;
	tb->max_index = 2;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (square = 0; square < 64; square ++) {
		if (! (tb->piece_legal_squares[piece] & BITVECTOR(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->simple_piece_indices[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    tb->max_index *= tb->total_legal_piece_positions[piece];
	}

	tb->max_index --;

    } else {
	fprintf(stderr, "Unknown index type (%s) in XML\n", index);
	return NULL;
    }

    /* See if a modulus was specified for inversion in a finite field */

    modulus = xmlGetProp(tablebase, (const xmlChar *) "modulus");
    if (modulus != NULL) {
	tb->modulus = strtoll((const char *) modulus, NULL, 0);
	if (tb->modulus <= tb->max_index) {
	    fprintf(stderr, "modulus %d less than max_index %d\n", tb->modulus, tb->max_index);
	    return NULL;
	}
#if FINITE_FIELD_INVERSION
	/* XXX took this out for encode/decode index */
	tb->max_index = tb->modulus - 1;
#endif
    }

    /* Fetch the move restrictions */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression((const xmlChar *) "//move-restriction", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	int i;
	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * color_str;
	    xmlChar * type_str;
	    int color;
	    int type;

	    color_str = xmlGetProp(result->nodesetval->nodeTab[i], (const xmlChar *) "color");
	    type_str = xmlGetProp(result->nodesetval->nodeTab[i], (const xmlChar *) "type");

	    color = find_name_in_array((char *) color_str, colors);
	    type = find_name_in_array((char *) type_str, restriction_types);
	    if ((color == -1) || (type == -1)) {
		fprintf(stderr, "Illegal move restriction\n");
		return NULL;
	    } else {
		if ((tb->move_restrictions[color] > 0) && (tb->move_restrictions[color] != type)) {
		    fprintf(stderr, "Incompatible move restrictions\n");
		    return NULL;
		} else {
		    tb->move_restrictions[color] = type;
		}
	    }
	}
    }

    xmlXPathFreeContext(context);

    return tb;
}

/* Parses an XML control file.
 */

tablebase_t * parse_XML_control_file(char *filename)
{
    xmlParserCtxtPtr ctxt; /* the parser context */
    xmlDocPtr doc;
    tablebase_t *tb;

    /* create a parser context */
    ctxt = xmlNewParserCtxt();
    if (ctxt == NULL) {
        fprintf(stderr, "Failed to allocate parser context\n");
	return NULL;
    }
    /* parse the file, activating the DTD validation option */
    doc = xmlCtxtReadFile(ctxt, filename, NULL, XML_PARSE_DTDVALID);

    /* check if parsing suceeded */
    if (doc == NULL) {
	fprintf(stderr, "'%s' failed XML read\n", filename);
	return NULL;
    } else {
	/* check if validation suceeded */
        if (ctxt->valid == 0) {
	    fprintf(stderr, "WARNING: '%s' failed XML validatation\n", filename);
	}
    }
    /* free up the parser context */
    xmlFreeParserCtxt(ctxt);

#if 0
    doc = xmlReadFile(filename, NULL, 0);
    if (doc == NULL) {
	fprintf(stderr, "'%s' failed XML read\n", filename);
	return NULL;
    }
#endif

    tb = parse_XML_into_tablebase(doc);
    if (tb == NULL) return NULL;

    /* XXX We use fourbyte during calculation even if it's a one-byte-DTM tablebase */
    tb->format = FORMAT_FOURBYTE;

    /* We don't free the XML doc because the tablebase struct contains a pointer to it */

    return tb;
}

/* preload_futurebase_from_file() reads a tablebase's XML header and parses it, leaving the file
 * open and ready to begin reading the first entry with fetch_next_DTM_from_disk().
 */

tablebase_t * preload_futurebase_from_file(char *filename)
{
    gzFile file;
    int xml_size;
    char fileptr[16384];	/* XXX hardwired max size of XML */
    xmlDocPtr doc;
    tablebase_t *tb = NULL;
    xmlNodePtr tablebase;
    xmlChar * offsetstr;

    file = gzopen(filename, "r");

    if (file == NULL) {

	fprintf(stderr, "Can't gzopen file '%s'\n", filename);

    } else {

	for (xml_size = 0; (fileptr[xml_size] = gzgetc(file)) != '\0'; xml_size ++) ;

	doc = xmlReadMemory(fileptr, xml_size, NULL, NULL, 0);

	tb = parse_XML_into_tablebase(doc);

	tb->file = file;

	tablebase = xmlDocGetRootElement(doc);

	offsetstr = xmlGetProp(tablebase, (const xmlChar *) "offset");
	tb->offset = strtol((const char *) offsetstr, NULL, 0);

	gzseek(file, tb->offset, SEEK_SET);
    }

    return tb;
}

char fetch_next_DTM_from_disk(tablebase_t *tb)
{
    int retval;

    if (tb->file == NULL) {
	fprintf(stderr, "Attempt to fetch_next_DTM_from_disk() from a non-preloaded tablebase\n");
	return 0;
    } else if (tb->format != FORMAT_ONE_BYTE_DTM) {
	fprintf(stderr, "Can't fetch_next_DTM_from_disk() on anything but a one-byte-dtm (yet)\n");
	return 0;
    } else {
	retval = gzgetc(tb->file);
	if (retval == EOF) {
	    fprintf(stderr, "fetch_next_DTM_from_disk() hit EOF\n");
	    return 0;
	} else {
	    return (char) retval;
	}
    }
}

char fetch_DTM_from_disk(tablebase_t *tb, index_t index)
{
    int retval;

    if (tb->file == NULL) {
	fprintf(stderr, "Attempt to fetch_DTM_from_disk() from a non-preloaded tablebase\n");/* BREAKPOINT */
	return 0;
    } else if (tb->format != FORMAT_ONE_BYTE_DTM) {
	fprintf(stderr, "Can't fetch_DTM_from_disk() on anything but a one-byte-dtm\n");  /* BREAKPOINT */
	return 0;
    } else {
	gzseek(tb->file, tb->offset + index, SEEK_SET);
	retval = gzgetc(tb->file);
	if (retval == EOF) {
	    fprintf(stderr, "fetch_next_DTM_from_disk() hit EOF\n");
	    return 0;
	} else {
	    return (char) retval;
	}
    }
}

void unload_futurebase(tablebase_t *tb)
{
    if (tb->xml != NULL) xmlFreeDoc(tb->xml);
    tb->xml = NULL;
    if (tb->file != NULL) gzclose(tb->file);
    tb->file = NULL;
}

/* Given a tablebase, change its XML structure to reflect the fact that the tablebase has now
 * actually been built.  Adds a dummy "offset" property to the root element which will be adjusted
 * later to reflect the actual byte offset of the tablebase entries, and a "generated-by" block
 * indicating the program, time, and host that generated the data.
 */

void subtract_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec -= src->tv_sec;
    if (dest->tv_usec > src->tv_usec) {
	dest->tv_usec -= src->tv_usec;
    } else {
	dest->tv_usec = 1000000 + dest->tv_usec - src->tv_usec;
	dest->tv_sec --;
    }
}

void add_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec += src->tv_sec;
    dest->tv_usec += src->tv_usec;
    if (dest->tv_usec >= 1000000) {
	dest->tv_usec -= 1000000;
	dest->tv_sec ++;
    }
}

void sprint_timeval(char *strbuf, struct timeval *timevalp)
{
    if (timevalp->tv_sec < 60) {
	sprintf(strbuf, "%ld.%03lds", timevalp->tv_sec, timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 3600) {
	sprintf(strbuf, "%ldm%02ld.%03lds", timevalp->tv_sec/60, timevalp->tv_sec%60,
		timevalp->tv_usec/1000);
    } else {
	sprintf(strbuf, "%ldh%02ldm%02ld.%03lds", timevalp->tv_sec/3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    }
}

void fprint_system_time(void)
{
    struct rusage rusage;
    char strbuf[256];

    getrusage(RUSAGE_SELF, &rusage);
    sprint_timeval(strbuf, &rusage.ru_stime);
    fprintf(stderr, "System time: %s\n", strbuf);
}

xmlDocPtr finalize_XML_header(tablebase_t *tb, char *options)
{
    xmlNodePtr tablebase, node;
    time_t creation_time;
    char ctimestr[256];
    char hostname[256];
    struct hostent *he;
    struct rusage rusage;
    char utimestr[256];
    char stimestr[256];
    struct timeval program_end_time;
    char rtimestr[256];
    char minfltstr[256];
    char majfltstr[256];
    char strbuf[256];

    tablebase = xmlDocGetRootElement(tb->xml);

    xmlNewProp(tablebase, (const xmlChar *) "offset", (const xmlChar *) "0x1000");

    node = xmlNewChild(tablebase, NULL, (const xmlChar *) "tablebase-statistics", NULL);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%d", tb->max_index + 1);
    xmlNewChild(node, NULL, (const xmlChar *) "indices", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_legal_positions);
    xmlNewChild(node, NULL, (const xmlChar *) "legal-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_PNTM_mated_positions);
    xmlNewChild(node, NULL, (const xmlChar *) "PNTM-mated-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_stalemate_positions);
    xmlNewChild(node, NULL, (const xmlChar *) "stalemate-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_moves);
    xmlNewChild(node, NULL, (const xmlChar *) "forward-moves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_futuremoves);
    xmlNewChild(node, NULL, (const xmlChar *) "futuremoves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_backproped_moves);
    xmlNewChild(node, NULL, (const xmlChar *) "backproped-moves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    sprintf(strbuf, "%lld", total_passes);
    xmlNewChild(node, NULL, (const xmlChar *) "passes", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n");

    xmlNodeAddContent(tablebase, BAD_CAST "\n");

    node = xmlNewChild(tablebase, NULL, (const xmlChar *) "generation-statistics", NULL);

    time(&creation_time);
    strftime(ctimestr, sizeof(ctimestr), "%c %Z", localtime(&creation_time));

    gethostname(hostname, sizeof(hostname));
    he = gethostbyname(hostname);

    getrusage(RUSAGE_SELF, &rusage);
    sprint_timeval(utimestr, &rusage.ru_utime);
    sprint_timeval(stimestr, &rusage.ru_stime);

    gettimeofday(&program_end_time, NULL);
    subtract_timeval(&program_end_time, &program_start_time);
    sprint_timeval(rtimestr, &program_end_time);

    sprintf(minfltstr, "%ld", rusage.ru_minflt);
    sprintf(majfltstr, "%ld", rusage.ru_majflt);

    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "host", (const xmlChar *) he->h_name);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "program",
		(const xmlChar *) "Hoffman $Revision: 1.216 $ $Locker: baccala $");
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "args", (const xmlChar *) options);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "completion-time", (const xmlChar *) ctimestr);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "user-time", (const xmlChar *) utimestr);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "system-time", (const xmlChar *) stimestr);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "real-time", (const xmlChar *) rtimestr);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "page-faults", (const xmlChar *) majfltstr);
    xmlNodeAddContent(node, BAD_CAST "\n   ");
    xmlNewChild(node, NULL, (const xmlChar *) "page-reclaims", (const xmlChar *) minfltstr);

    if (num_propentries > 0) {
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprintf(strbuf, "%d", entries_write_stalls);
	xmlNewChild(node, NULL, (const xmlChar *) "entries-write-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprintf(strbuf, "%d", entries_read_stalls);
	xmlNewChild(node, NULL, (const xmlChar *) "entries-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprintf(strbuf, "%d", proptable_read_stalls);
	xmlNewChild(node, NULL, (const xmlChar *) "proptable-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprintf(strbuf, "%d", proptable_writes);
	xmlNewChild(node, NULL, (const xmlChar *) "proptable-writes", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprint_timeval(strbuf, &entries_write_stall_time);
	xmlNewChild(node, NULL, (const xmlChar *) "entries-write-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprint_timeval(strbuf, &entries_read_stall_time);
	xmlNewChild(node, NULL, (const xmlChar *) "entries-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprint_timeval(strbuf, &proptable_read_stall_time);
	xmlNewChild(node, NULL, (const xmlChar *) "proptable-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprint_timeval(strbuf, &proptable_write_time);
	xmlNewChild(node, NULL, (const xmlChar *) "proptable-write-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n   ");
	sprint_timeval(strbuf, &proptable_preload_time);
	xmlNewChild(node, NULL, (const xmlChar *) "proptable-preload-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n");
    }

    xmlNodeAddContent(tablebase, BAD_CAST "\n");

    xmlNodeAddContent(tb->per_pass_stats, BAD_CAST "\n");

    xmlAddNextSibling(node, tb->per_pass_stats);

    return tb->xml;
}

/* do_write() is like the system call write(), but keeps repeating until the write is complete */

int do_write(int fd, void *ptr, int length)
{
    while (length > 0) {
	int writ = write(fd, ptr, length);
	if (writ == -1) {
	    perror("do_write");
	    return -1;
	}
	ptr += writ;
	length -= writ;
    }
    return 0;
}

void write_tablebase_to_file(tablebase_t *tb, char *filename, char *options)
{
    xmlDocPtr doc;
    int fd;
    int index;
    FILE *file;
    xmlNodePtr tablebase;
    xmlChar *buf;
    xmlChar *format;
    int size;
    int padded_size;
    char str[16];

    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (fd == -1) {
	fprintf(stderr, "Can't open '%s' for writing tablebase\n", filename);
	return;
    }

    doc = finalize_XML_header(tb, options);

    /* We want at least one zero byte after the XML header, because that's how we figure out where
     * it ends when we read it back it, and I also want to align the tablebase on a four-byte
     * boundary for the hell of it.  (size+5)&(~3) achieves these goals.  I then modify the XML
     * header with the updated string that gives the offset to the tablebase, and make sure that its
     * size hasn't changed.
     */

    xmlDocDumpMemory(doc, &buf, &size);
    padded_size = (size+5)&(~3);

    sprintf(str, "0x%04x", padded_size);

    tablebase = xmlDocGetRootElement(doc);
    xmlSetProp(tablebase, (const xmlChar *) "offset", (const xmlChar *) str);

    xmlDocDumpMemory(doc, &buf, &size);

    if (padded_size != ((size+5)&(~3))) {
	fprintf(stderr, "sizes don't match in write_tablebase_to_file\n");
    }

    do_write(fd, buf, size);
    xmlFree(buf);

    /* We set the format to fourbyte during calcuation no matter what, so reset it here */
    format = xmlGetProp(tablebase, (const xmlChar *) "format");
    tb->format = find_name_in_array((char *) format, formats);

    if (tb->format == FORMAT_FOURBYTE) {
	if (lseek(fd, padded_size, SEEK_SET) != padded_size) {
	    fprintf(stderr, "seek failed\n");
	}
	do_write(fd, tb->entries, sizeof(struct fourbyte_entry) * (tb->max_index + 1));
	close(fd);
    } else if (tb->format == FORMAT_ONE_BYTE_DTM) {
	close(fd);
	file = fopen(filename, "a");
	if (file == NULL) {
	    fprintf(stderr, "Can't fopen output file\n");
	} else {
	    while (ftell(file) < padded_size) {
		fputc(0, file);
	    }
	    for (index = 0; index <= tb->max_index; index ++) {
		fputc(get_DTM(tb, index), file);
	    }
	}
	fclose(file);
    } else {
	fprintf(stderr, "Unknown format in write_tablebase_to_file()\n");
    }

}


/***** INDICES AND POSITIONS *****/

/* This function could be made a bit faster, but this simpler version is hopefully safer. */

int index_to_side_to_move(tablebase_t *tb, index_t index)
{
    local_position_t position;

    if (! index_to_local_position(tb, index, &position)) return -1;
    else return position.side_to_move;
}

inline void flip_side_to_move_local(local_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

inline void flip_side_to_move_global(global_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

/* invert_colors_of_global_position - just what its name implies
 *
 * We used to use this when propagating from a futurebase, but now it's only use is in the probe
 * code.  It translates a position for a tablebase built for the opposite colors, say a K+R vs K
 * endgame that we now want to probe where the rook is black, not white.  If there are pawns in the
 * game, this function has to reflect the board around a horizontal centerline.
 */

void invert_colors_of_global_position(global_position_t *global)
{
    int squareA;

    for (squareA=0; squareA < NUM_SQUARES/2; squareA++) {
	unsigned char pieceA;
	unsigned char pieceB;
	int squareB = square(7-ROW(squareA),COL(squareA));

	pieceA = global->board[squareA];
	pieceB = global->board[squareB];

	if ((pieceA >= 'A') && (pieceA <= 'Z')) {
	    pieceA += 'a' - 'A';
	} else if ((pieceA >= 'a') && (pieceA <= 'z')) {
	    pieceA += 'A' - 'a';
	}

	if ((pieceB >= 'A') && (pieceB <= 'Z')) {
	    pieceB += 'a' - 'A';
	} else if ((pieceB >= 'a') && (pieceB <= 'z')) {
	    pieceB += 'A' - 'a';
	}
	
	global->board[squareA] = pieceB;
	global->board[squareB] = pieceA;
    }

    if (global->side_to_move == WHITE) {
	global->side_to_move = BLACK;
	if (global->en_passant_square != -1) global->en_passant_square -= 3*8;
    } else {
	global->side_to_move = WHITE;
	if (global->en_passant_square != -1) global->en_passant_square += 3*8;
    }
}

/* translate_foreign_index_to_local_position() - one of our key, key functions, used extensively
 * during futurebase back propagation.  It takes an index into a foreign tablebase and converts it
 * to a position in the local tablebase (the tablebase we're processing).  Of course, the pieces
 * might not match up between the two tablebases, but there are only a finite number of possible
 * differences:
 *
 * 1. There can be an "extra" piece in the foreign tablebase that doesn't appear in the
 * local tablebase.
 *
 * 2. There can be up to two "missing" pieces in the local tablebase that don't appear in
 * the foreign tablebase.
 *
 * 3. There can be one piece (the "restricted" piece) that matches up, but is on a square flagged
 * illegal for it in the local tablebase.
 *
 * If there are additional differences not covered in this list (more than one extra piece, for
 * example), or if the index isn't legal in the foreign tablebase, the function returns -1.
 * Otherwise, the return value is a 32 bit integer split into four eight bit fields:
 *
 * bits 0-7:   local tb piece number of missing piece #1
 * bits 8-15:  local tb piece number of restricted piece
 * bits 16-23: foreign tb piece number of extra piece
 * bits 24-31: local tb piece number of missing piece #2
 *
 * If any of the fields are unused (because there is no corresponding piece), it's value is 0x80.
 * If there are two missing pieces and only one of them is a pawn, the pawn will always be returned
 * as missing piece #1.  If there are multiple identical missing pieces, the last one will always be
 * returned as the missing piece(s).
 *
 * The function does not depend on the indexing scheme used by the foreign tablebase.  Instead, it
 * uses index_to_local_position() on the foreign tablebase.
 *
 * The only thing I don't like about this function right now is that it returns -1 if there is more
 * than one restricted piece, and we certainly could have liberal tablebases with lots of restricted
 * pieces that we want to back-prop from.
 */

#define NONE 0x80

int translate_foreign_position_to_local_position(tablebase_t *tb1, local_position_t *foreign,
						 tablebase_t *tb2, local_position_t *local,
						 int invert_colors)
{
    int foreign_piece;
    int piece;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    short pieces_processed_bitvector = 0;

    memset(local, 0, sizeof(local_position_t));

    for (piece = 0; piece < tb2->num_pieces; piece ++)
	local->piece_position[piece] = -1;

    local->en_passant_square = foreign->en_passant_square;
    local->side_to_move = foreign->side_to_move;

    if (invert_colors) flip_side_to_move_local(local);

    for (foreign_piece = 0; foreign_piece < tb1->num_pieces; foreign_piece ++) {

	int sq = foreign->piece_position[foreign_piece];

	if (invert_colors) sq = square(7 - ROW(sq), COL(sq));

	for (piece = 0; piece < tb2->num_pieces; piece ++) {

	    if ((tb1->piece_type[foreign_piece] == tb2->piece_type[piece])
		&& (invert_colors
		    ? (tb1->piece_color[foreign_piece] != tb2->piece_color[piece])
		    : (tb1->piece_color[foreign_piece] == tb2->piece_color[piece]))
		&& !(pieces_processed_bitvector & (1 << piece))) {

		local->piece_position[piece] = sq;
		local->board_vector |= BITVECTOR(sq);
		if (tb2->piece_color[piece] == local->side_to_move)
		    local->PTM_vector |= BITVECTOR(sq);

		pieces_processed_bitvector |= (1 << piece);

		break;
	    }
	}

	if (piece == tb2->num_pieces) {
	    if (extra_piece != NONE) {
		fprintf(stderr, "More than one extra piece in translation\n");
		return -1;
	    }
	    extra_piece = foreign_piece;
	}
    }


    /* Make sure all the pieces but one have been accounted for.  We count a piece as "free" if
     * either it hasn't been processed at all, or if it was processed but was outside its move
     * restriction.
     */

    for (piece = 0; piece < tb2->num_pieces; piece ++) {
	if (!(pieces_processed_bitvector & (1 << piece))) {
	    if (missing_piece1 == NONE) {
		missing_piece1 = piece;
	    } else if (missing_piece2 == NONE) {
		if (tb2->piece_type[piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = piece;
		} else {
		    missing_piece2 = piece;
		}
	    } else {
		fprintf(stderr, "More than one missing piece in translation\n");
		return -1;
	    }
	} else if (!(tb2->piece_legal_squares[piece] & BITVECTOR(local->piece_position[piece]))) {
	    if (restricted_piece == NONE) restricted_piece = piece;
	    else {
		/* This can happen if the futurebase is more liberal */
		/* fprintf(stderr, "More than one restricted piece in translation\n"); */
		return -1;
	    }
	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);

}

int translate_foreign_index_to_local_position(tablebase_t *tb1, index_t index1,
					      tablebase_t *tb2, local_position_t *local, int invert_colors)
{
    local_position_t foreign_position;

    if (! index_to_local_position(tb1, index1, &foreign_position)) return -1;

    return translate_foreign_position_to_local_position(tb1, &foreign_position, tb2, local, invert_colors);
}

/* This function works just like previous one.  So much so that I've considered wrapping them
 * together, but since this one is already written, I'll just leave it alone for now.
 *
 * It's only use now is by the probing code (see next function).
 */

index_t global_position_to_local_position(tablebase_t *tb, global_position_t *global, local_position_t *local)
{
    int piece;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    int square;
    short pieces_processed_bitvector = 0;

    memset(local, 0, sizeof(local_position_t));

    for (piece = 0; piece < tb->num_pieces; piece ++)
	local->piece_position[piece] = -1;

    local->en_passant_square = global->en_passant_square;
    local->side_to_move = global->side_to_move;

    for (square = 0; square < NUM_SQUARES; square ++) {
	if ((global->board[square] != 0) && (global->board[square] != ' ')) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		if ((global->board[square] == global_pieces[tb->piece_color[piece]][tb->piece_type[piece]])
		    && !(pieces_processed_bitvector & (1 << piece))) {

		    local->piece_position[piece] = square;
		    local->board_vector |= BITVECTOR(square);
		    if (tb->piece_color[piece] == local->side_to_move)
			local->PTM_vector |= BITVECTOR(square);

		    pieces_processed_bitvector |= (1 << piece);

		    break;
		}
	    }
	    if (piece == tb->num_pieces) {
		if (extra_piece != NONE) {
		    /* This can happen if we're probing a whole bunch of radically different tablebases. */
		    /* fprintf(stderr, "More than one extra piece in translation\n"); */
		    return -1;
		}
		/* XXX I'd like to change this (for consistency) to be the piece index in the
		 * futurebase, but since there is still an intermediate global position, that will
		 * have to wait.
		 */
		extra_piece = square;
	    }
	}
    }


    /* Make sure all the pieces but one have been accounted for.  We count a piece as "free" if
     * either it hasn't been processed at all, or if it was processed but was outside its move
     * restriction.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (!(pieces_processed_bitvector & (1 << piece))) {
	    if (missing_piece1 == NONE) {
		missing_piece1 = piece;
	    } else if (missing_piece2 == NONE) {
		if (tb->piece_type[piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = piece;
		} else {
		    missing_piece2 = piece;
		}
	    } else {
		/* This can happen if we're probing a whole bunch of radically different tablebases. */
		/* fprintf(stderr, "More than one missing piece in translation\n"); */
		return -1;
	    }
	} else if (!(tb->piece_legal_squares[piece] & BITVECTOR(local->piece_position[piece]))) {
	    if (restricted_piece == NONE) restricted_piece = piece;
	    else {
		/* This can happen if we're probing a whole bunch of radically different tablebases. */
		/* fprintf(stderr, "More than one restricted piece in translation\n"); */
		return -1;
	    }
	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);
}

index_t global_position_to_index(tablebase_t *tb, global_position_t *global)
{
    local_position_t local;

    if (global_position_to_local_position(tb, global, &local) != 0x80808080) return -1;

    return local_position_to_index(tb, &local);
}

/* index_to_global_position()
 *
 * Used during Nalimov tablebase verification (by running through all indices in a tablebase), as
 * well as during probe code to consider possible captures and promotions because they may lead out
 * of the current tablebase.
 *
 * Massively simplified from an earlier implementation because I want to contain the details of
 * indexing to the local position routines.  Probably a little bit slower now, but not too much.
 *
 * Seems never to be used on a tablebase under construction; only on a finished one.
 */

boolean index_to_global_position(tablebase_t *tb, index_t index, global_position_t *global)
{
    local_position_t local;
    int piece;

    memset(global, 0, sizeof(global_position_t));

    if (! index_to_local_position(tb, index, &local)) return 0;

    global->side_to_move = local.side_to_move;
    global->en_passant_square = local.en_passant_square;

    for (piece = 0; piece < tb->num_pieces; piece++) {
	global->board[local.piece_position[piece]]
	    = global_pieces[tb->piece_color[piece]][tb->piece_type[piece]];
    }

    return 1;
}


/***** PARSING FEN TO/FROM POSITION STRUCTURES *****/

boolean place_piece_in_local_position(tablebase_t *tb, local_position_t *pos, int square, int color, int type)
{
    int piece;

    if (pos->board_vector & BITVECTOR(square)) return 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == type) && (tb->piece_color[piece] == color)) {
	    pos->piece_position[piece] = square;
	    pos->board_vector |= BITVECTOR(square);
	    if (color == pos->side_to_move) pos->PTM_vector |= BITVECTOR(square);
	    return 1;
	}
    }

    return 0;
}

boolean place_piece_in_global_position(global_position_t *position, int square, int color, int type)
{
    position->board[square] = global_pieces[color][type];
    return 1;
}

boolean parse_FEN_to_local_position(char *FEN_string, tablebase_t *tb, local_position_t *pos)
{
    int row, col;

    memset(pos, 0, sizeof(local_position_t));
    pos->en_passant_square = -1;

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_local_position(tb, pos, square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_local_position(tb, pos, square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

boolean parse_FEN_to_global_position(char *FEN_string, global_position_t *pos)
{
    int row, col;

    memset(pos, 0, sizeof(global_position_t));
    pos->en_passant_square = -1;

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_global_position(pos, square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_global_position(pos, square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

/* Note that the buffer in this function is static... */

char * global_position_to_FEN(global_position_t *position)
{
    static char buffer[256];
    char *ptr = buffer;
    int empty_squares;
    int row, col;

    for (row=7; row>=0; row--) {
	empty_squares=0;
	for (col=0; col<=7; col++) {
	    if ((position->board[square(row, col)] == ' ') || (position->board[square(row,col)] == 0)) {
		empty_squares++;
	    } else {
		if (empty_squares > 0) {
		    *(ptr++) = '0' + empty_squares;
		    empty_squares = 0;
		}
		*(ptr++) = position->board[square(row,col)];
	    }
	}
	if (empty_squares > 0) {
	    *(ptr++) = '0' + empty_squares;
	}
	if (row > 0) *(ptr++) = '/';
    }

    *(ptr++) = ' ';

    *(ptr++) = (position->side_to_move == WHITE) ? 'w' : 'b';

    /* no castling rights */

    *(ptr++) = ' ';
    *(ptr++) = '-';
    *(ptr++) = ' ';

    if (position->en_passant_square == -1) {
	*(ptr++) = '-';
    } else {
	*(ptr++) = 'a' + COL(position->en_passant_square);
	*(ptr++) = '1' + ROW(position->en_passant_square);
    }

    *(ptr++) = '\0';

    return buffer;
}

/* This routine looks at "movestr" to try and figure out if it is a valid move from this global
 * position.  If so, it changes the global position to reflect the move and returns true.
 * Otherwise, it leaves the global position alone and returns false.
 */

boolean parse_move_in_global_position(char *movestr, global_position_t *global)
{
    int origin_square, destination_square;
    int is_capture = 0;
    unsigned char promotion_piece = '\0';

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	origin_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == 'x') {
	is_capture = 1;
	movestr ++;
    }

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	destination_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == '=') {
	movestr ++;
	promotion_piece = movestr[0];
    }

    if (!(global->board[origin_square] >= 'A' && global->board[origin_square] <= 'Z')
	&& global->side_to_move == WHITE)
	return 0;

    if (!(global->board[origin_square] >= 'a' && global->board[origin_square] <= 'z')
	&& global->side_to_move == BLACK)
	return 0;

    if (global->board[destination_square] >= 'A' && !is_capture) return 0;

    if (!(global->board[destination_square] >= 'A' && global->board[destination_square] <= 'Z')
	&& is_capture && global->side_to_move == BLACK)
	return 0;

    if (!(global->board[destination_square] >= 'a' && global->board[destination_square] <= 'z')
	&& is_capture && global->side_to_move == WHITE)
	return 0;

    global->board[destination_square] = promotion_piece ? promotion_piece : global->board[origin_square];
    global->board[origin_square] = 0;
    if (global->side_to_move == WHITE)
	global->side_to_move = BLACK;
    else
	global->side_to_move = WHITE;

    global->en_passant_square = -1;

    if ((global->board[destination_square] == 'P') && (origin_square == destination_square - 16)) {
	global->en_passant_square = destination_square - 8;
    }
    if ((global->board[destination_square] == 'p') && (origin_square == destination_square + 16)) {
	global->en_passant_square = destination_square + 8;
    }

    return 1;
}


/* ENTRY RING BUFFERS
 *
 * In order to avoid copying file buffers in the kernel, which would really hurt our performance, we
 * turn off kernel buffering on the entries and proptable files by passing O_DIRECT to open().  This
 * makes disk read/write DMA operations go directly to user space buffers (which must now be page
 * aligned) and avoids any copying in the kernel.  It also means that we must now do our own
 * buffering, making extensive use of POSIX asynchronous I/O operations.  For the entries file,
 * which we update in memory and so must write back to disk, I use a ring buffering scheme.
 *
 * Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed) uses four colors to
 * illustrate the concept.  I'll use five - blue (input started but not yet complete), green (input
 * complete), yellow (currently processing), red (output started but not yet complete), and purple
 * (output done; input not yet started).  In our case, the buffers turn from blue to green and from
 * red to purple by themselves and we can detect the color difference between blue and green and
 * between red and purple by looking to see if their asynchronous read or write operation completed.
 * So we need two pointers, one to the single yellow buffer, and one to the first red or purple
 * buffer.  If the red/purple pointer catches up to the yellow pointer, then it means that there are
 * no read or purple buffers at the moment.
 *
 * The only functions "exported" from this section are the singly called init_entry_buffers() and
 * fetch_fourbyte_entry(), which is passed a tablebase pointer and an index and is expected to
 * return a pointer to the correct struct fourbyte_entry, which can be either read or written
 * without any further ado.
 *
 * I'm aiming right now for a target buffer size of 128 KB, since that's my kernel's maximum
 * internal request size.  So, 128 KB / 4 byte entries = 32 K entries = 1<<15
 */

#define NUM_ENTRY_BUFFERS 4
#define ENTRY_BUFFER_ENTRIES (1<<15)
#define ENTRY_BUFFER_BYTES (ENTRY_BUFFER_ENTRIES * sizeof(struct fourbyte_entry))

struct entry_buffer {
    struct fourbyte_entry *buffer;
    index_t start;
    struct aiocb aiocb;
};

struct entry_buffer entry_buffers[NUM_ENTRY_BUFFERS];

int yellow_entry_buffer = 0;
int first_purple_red_entry_buffer = 0;

/* Arrange to read buffernum (i.e, turn it blue).  'buffer' must be allocated (and page aligned),
 * and 'start' must indicate the index number (not the byte number) at which we want to start our
 * read, always of ENTRY_BUFFER_BYTES bytes.
 */

void turn_entry_buffer_blue(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= entry_buffers[buffernum].start * sizeof(struct fourbyte_entry);

    if (aio_read(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_read for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_green(int buffernum)
{
    const struct aiocb * aiocbs[1];
    int retval;

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer read to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_read_stall_time, &tv2);
	entries_read_stalls ++;
    }

    retval = aio_return(&entry_buffers[buffernum].aiocb);

    if (retval == 0) {
	/* zero byte read - this is OK the first time through */
	memset(entry_buffers[buffernum].buffer, 0, ENTRY_BUFFER_BYTES);
    } else if ((retval != ENTRY_BUFFER_BYTES)
	       && (retval != sizeof(struct fourbyte_entry)
		   * ((proptable_tb->max_index - 1) % ENTRY_BUFFER_ENTRIES)))  {
	fprintf(stderr, "entry buffer aio_read didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

/* Arrange to write buffernum (i.e, turn it red).  Again, 'buffer' must be allocated and 'start'
 * must indicate the index number at which we want to start our write.
 */

void turn_entry_buffer_red(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= entry_buffers[buffernum].start * sizeof(struct fourbyte_entry);

    if (aio_write(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_write for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_purple(int buffernum)
{
    const struct aiocb * aiocbs[1];

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer write to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_write_stall_time, &tv2);
	entries_write_stalls ++;
    }

    if (aio_return(&entry_buffers[buffernum].aiocb) != ENTRY_BUFFER_BYTES) {
	fprintf(stderr, "entry buffer aio_write didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

void init_entry_buffers(tablebase_t *tb)
{
    int alignment = fpathconf(tb->entries_fd, _PC_REC_XFER_ALIGN);
    int buffernum;

    for (buffernum = 0; buffernum < NUM_ENTRY_BUFFERS; buffernum ++) {
	if (posix_memalign((void **) &entry_buffers[buffernum], alignment, ENTRY_BUFFER_BYTES) != 0) {
	    fprintf(stderr, "Can't posix_memalign entries buffer\n");
	    exit(EXIT_FAILURE);
	}
	entry_buffers[buffernum].start = buffernum * ENTRY_BUFFER_ENTRIES;
	turn_entry_buffer_blue(tb->entries_fd, buffernum);
    }

    wait_for_entry_buffer_green(0);
}

struct fourbyte_entry * fetch_fourbyte_entry(tablebase_t *tb, index_t index)
{
    if (tb->entries != NULL) {

	/* entries array exists in memory - so just return a pointer into it */
	return &tb->entries[index];

    } else if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	/* The index we're looking for isn't in the yellow buffer.  Play Twister. */

	int next_entry_buffer = yellow_entry_buffer + 1;
	if (next_entry_buffer >= NUM_ENTRY_BUFFERS) next_entry_buffer = 0;

	/* Have we caught up with our first purple/red buffer?  Wait until the write has finished
	 * and start the read.
	 */

	if (next_entry_buffer == first_purple_red_entry_buffer) {

	    wait_for_entry_buffer_purple(first_purple_red_entry_buffer);

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* Now, next_entry_buffer is at least blue.  Wait for it to turn green. */

	wait_for_entry_buffer_green(next_entry_buffer);

	/* Check to see if any of the trailing red buffers have turned purple.  If so, turn them
	 * blue.  We do this towards the end here, because if we had to block waiting for
	 * next_entry_buffer to become green, some of the reds might have turned purple.
	 */

	while ((first_purple_red_entry_buffer != yellow_entry_buffer)
	       && (aio_error(&entry_buffers[first_purple_red_entry_buffer].aiocb) != EINPROGRESS)) {

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* queue a write operation for yellow_entry_buffer (i.e, turn it red) */

	turn_entry_buffer_red(tb->entries_fd, yellow_entry_buffer);

	/* Move on to the next buffer to be processed.  We waited for it to be green, remember? */

	yellow_entry_buffer = next_entry_buffer;
    }

    /* Now, as silly as this sounds, we might have done all of that and still not have a valid
     * buffer if the calling routine isn't going through the index numbers in order.  Complain, and
     * wait for a special read to finish on the buffer.  We don't bother with a write because we
     * just flipped buffers above, so our yellow buffer was green a split second ago.
     */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	fprintf(stderr, "fetch_fourbyte_entry(): special read; needed %d had %d\n",
		index, entry_buffers[yellow_entry_buffer].start);  /* BREAKPOINT */

	entry_buffers[yellow_entry_buffer].start = (index / ENTRY_BUFFER_ENTRIES) * ENTRY_BUFFER_ENTRIES;

	turn_entry_buffer_blue(tb->entries_fd, yellow_entry_buffer);

	wait_for_entry_buffer_green(yellow_entry_buffer);
    }

    /* If we STILL don't have a valid buffer, well, give up, I guess. */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {
	fprintf(stderr, "Can't fetch in fetch_fourbyte_entry\n");
    }

    return &entry_buffers[yellow_entry_buffer].buffer[index - entry_buffers[yellow_entry_buffer].start];
}


/* MORE TABLEBASE OPERATIONS - those that probe and manipulate individual position entries
 *
 * "Designed to multi-thread"
 *
 * Keep atomic operations confined to single functions.  Design functions so that functions calling
 * them don't need to know the details of table format, either.
 *
 * These "add one" functions (atomically) add one to the count in question, subtract one from the
 * total move count, and flag the position as 'ready for propagation' (maybe this is just a move
 * count of zero) if the total move count goes to zero.
 *
 * PTM = Player to Move
 * PNTM = Player not to Move
 *
 */

inline short does_PTM_win(struct fourbyte_entry *entry)
{
    return (entry->dtm > 0);
}

inline short does_PNTM_win(struct fourbyte_entry *entry)
{
    return ((entry->movecnt & 127) == 0) && (entry->dtm < 0);
}

inline boolean is_position_valid(tablebase_t *tb, index_t index)
{
    if (tb->entries != NULL) return (get_DTM(tb,index) != 1);
    else return (fetch_DTM_from_disk(tb,index) != 1);
}

inline int get_DTC(tablebase_t *tb, index_t index)
{
    struct fourbyte_entry *entry;

    entry = fetch_fourbyte_entry(tb, index);
    return entry->dtc;
}

/* Get the result in a format suitable for a one-byte DTM tablebase
 *
 * 0 = draw
 * 1 = PNTM in check (illegal position)
 * N = mate in N-1
 * -1 = PTM checkmated
 * -N = PNTM will have a mate in N-1 after this move
 */

int get_entry_DTM(struct fourbyte_entry *entry)
{
    return (does_PTM_win(entry) || does_PNTM_win(entry)) ? entry->dtm : 0;
}

int get_DTM(tablebase_t *tb, index_t index)
{
    struct fourbyte_entry *entry;

    entry = fetch_fourbyte_entry(tb, index);
    return get_entry_DTM(entry);
}

/* DEBUG_MOVE can be used to print more verbose debugging information about what the program is
 * doing to process a single move.
 */

/* #define DEBUG_MOVE 1029 */

/* Four possible ways we can initialize a tablebase entry for a position:
 *  - it's illegal
 *  - PNTM's mated
 *  - stalemate
 *  - any other position, with 'movecnt' possible moves out the position
 */

void initialize_entry(tablebase_t *tb, struct fourbyte_entry *entry, int movecnt, int dtm)
{
    entry->movecnt = movecnt;
    entry->dtm = dtm;
    entry->dtc = 0;
}

void initialize_entry_as_illegal(tablebase_t *tb, struct fourbyte_entry *entry)
{
    initialize_entry(tb, entry, 0, 0);
}

void initialize_entry_with_PNTM_mated(tablebase_t *tb, struct fourbyte_entry *entry)
{
    initialize_entry(tb, entry, 0, 1);
    total_legal_positions ++;
    total_PNTM_mated_positions ++;
}

void initialize_entry_with_stalemate(tablebase_t *tb, struct fourbyte_entry *entry)
{
    /* use movecnt 127 as stalemate for now */
    initialize_entry(tb, entry, 127, 0);
    total_legal_positions ++;
    total_stalemate_positions ++;
}

void initialize_entry_with_movecnt(tablebase_t *tb, struct fourbyte_entry *entry, int movecnt)
{
    initialize_entry(tb, entry, movecnt, 0);
    total_legal_positions ++;
}

inline void PTM_wins(struct fourbyte_entry *entry, int dtm, int dtc)
{

    if (dtm < 0) {
	fprintf(stderr, "Negative distance to mate in PTM_wins!?\n"); /* BREAKPOINT */
    } else if ((dtm < entry->dtm) || (entry->dtm <= 0)) {
	entry->dtm = dtm;
	entry->dtc = dtc;
    }
}

inline void add_one_to_PNTM_wins(struct fourbyte_entry *entry, int dtm, int dtc)
{

    if (dtm > 0) {
	fprintf(stderr, "Positive distance to mate in PNTM_wins!?\n"); /* BREAKPOINT */
    } else {
	entry->movecnt --;
	if ((dtm < entry->dtm) && (entry->dtm <= 0)) {
	    /* Since this is PNTM wins, PTM will make the move leading to the slowest mate. */
	    /* XXX need to think more about the stalemates */
	    entry->dtm = dtm;
	    entry->dtc = dtc;
	}

	if ((entry->movecnt == 0) && (entry->dtm == -1)) {

	    /* In this case, the only moves at PTM's disposal move him into check (DTM is now one,
	     * so it would drop to zero on next move).  So we need to distinguish here between being
	     * in check (it's checkmate) and not being in check (stalemate).  I went to the trouble
	     * in initialize_tablebase() to check for this (no pun intended) and set the high order
	     * bit of movecnt on in-check positions.  So the only way movecnt has actually made it
	     * to zero here is if we're not in check, so this is stalemate...
	     */

	    total_stalemate_positions ++;

	    entry->dtm = 0;
	    entry->dtc = 0;
	}

	/* XXX not sure about this stalemate code */
	if (dtc < entry->dtc) {
	    entry->dtc = dtc;
	}
    }
}


/***** MOVEMENT VECTORS *****/

/* The idea here is to calculate piece movements, and to do it FAST.
 *
 * We build a table of "movements" organized into "directions".  Each direction is just that - the
 * direction that a piece (like a queen) moves.  When we want to check for what movements are
 * possible in a given direction, we run through the direction until we "hit" another pieces - until
 * the bit in the vector matches something already in the position vector.  At the end of the
 * direction, an all-ones vector will "hit" the end of the board and end the direction.  I know,
 * kinda confusing.  It's because it's designed to be fast; we have to do this a lot.
 */

struct movement {
    int64 vector;
    short square;
};

/* we add one to NUM_MOVEMENTS to leave space at the end for the all-ones bitmask that signals the
 * end of the list
 */

struct movement movements[NUM_PIECES][NUM_SQUARES][NUM_DIR][NUM_MOVEMENTS+1];

/* Pawns are, of course, special.  We have seperate vectors for different types of pawn movements.
 * Each array is indexed first by square number, then by side (WHITE or BLACK - this doesn't exist
 * for other pieces), then by the number of possibilities (at most two normal movements, at most two
 * captures, and one more for the all-ones bitvector to terminate)
 *
 * All of these are FORWARD motions.
 */

struct movement normal_pawn_movements[NUM_SQUARES][2][3];
struct movement capture_pawn_movements[NUM_SQUARES][2][3];

struct movement normal_pawn_movements_bkwd[NUM_SQUARES][2][3];
struct movement capture_pawn_movements_bkwd[NUM_SQUARES][2][3];

/* How many different directions can each piece move in?  Knights have 8 directions because they
 * can't be blocked in any of them.  Pawns are handled separately.
 */

int number_of_movement_directions[NUM_PIECES] = {8,8,4,4,8,0};
int maximum_movements_in_one_direction[NUM_PIECES] = {1,7,7,7,1,0};

enum {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR, KNIGHTmove}
movementdir[5][8] = {
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* King */
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* Queen */
    {RIGHT, LEFT, UP, DOWN},						/* Rook */
    {DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},				/* Bishop */
    {KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove},	/* Knights are special... */
};



char algebraic_notation[64][3];

void init_movements()
{
    int square, piece, dir, mvmt, color;

    for (square=0; square < NUM_SQUARES; square++) {
	bitvector[square] = 1ULL << square;
	algebraic_notation[square][0] = 'a' + square%8;
	algebraic_notation[square][1] = '1' + square/8;
	algebraic_notation[square][2] = '\0';
    }

    for (piece=KING; piece <= KNIGHT; piece++) {

	for (square=0; square < NUM_SQUARES; square++) {

	    for (dir=0; dir < number_of_movement_directions[piece]; dir++) {

		int current_square = square;

		for (mvmt=0; mvmt < maximum_movements_in_one_direction[piece]; mvmt ++) {

#define RIGHT_MOVEMENT_POSSIBLE ((current_square%8)<7)
#define RIGHT2_MOVEMENT_POSSIBLE ((current_square%8)<6)
#define LEFT_MOVEMENT_POSSIBLE ((current_square%8)>0)
#define LEFT2_MOVEMENT_POSSIBLE ((current_square%8)>1)
#define UP_MOVEMENT_POSSIBLE (current_square<56)
#define UP2_MOVEMENT_POSSIBLE (current_square<48)
#define DOWN_MOVEMENT_POSSIBLE (current_square>7)
#define DOWN2_MOVEMENT_POSSIBLE (current_square>15)

		    switch (movementdir[piece][dir]) {
		    case RIGHT:
			if (RIGHT_MOVEMENT_POSSIBLE) {
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case LEFT:
			if (LEFT_MOVEMENT_POSSIBLE) {
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case UP:
			if (UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DOWN:
			if (DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UL:
			if (LEFT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UR:
			if (RIGHT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DL:
			if (LEFT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DR:
			if (RIGHT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case KNIGHTmove:
			current_square=square;
			switch (dir) {
			case 0:
			    if (RIGHT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 1:
			    if (RIGHT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 2:
			    if (LEFT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 3:
			    if (LEFT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 4:
			    if (RIGHT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 5:
			    if (RIGHT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 6:
			    if (LEFT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 7:
			    if (LEFT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			}
			break;

		    }
		}

		/* Always put an allones_bitvector at the end of the movement vector
		 * to make sure we stop!
		 */

		movements[piece][square][dir][mvmt].square = -1;
		movements[piece][square][dir][mvmt].vector = allones_bitvector;

	    }
	}
    }

    /* Now for the pawns... */

    for (square=0; square < NUM_SQUARES; square ++) {

	for (color = WHITE; color <= BLACK; color ++) {

	    int forwards_pawn_move = ((color == WHITE) ? 8 : -8);
	    int backwards_pawn_move = ((color == WHITE) ? -8 : 8);

	    /* Forward pawn movements
	     *
	     * An ordinary pawn move... unless its a white pawn on the second rank, or a black
	     * pawn on the seventh.  In these two cases, there is a possible double move as
	     * well.
	     */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		normal_pawn_movements[square][color][mvmt].square = square + forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + forwards_pawn_move);

		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 1)) || ((color == BLACK) && (ROW(square) == 6))) {

		normal_pawn_movements[square][color][mvmt].square = square + 2*forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + 2*forwards_pawn_move);

		mvmt ++;

	    }

	    normal_pawn_movements[square][color][mvmt].square = -1;
	    normal_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn movements */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + backwards_pawn_move);
		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 3)) || ((color == BLACK) && (ROW(square) == 4))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + 2*backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + 2*backwards_pawn_move);
		mvmt ++;
	    }

	    normal_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    normal_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	    /* Forward pawn captures. */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		if (COL(square) > 0) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move - 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move + 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements[square][color][mvmt].square = -1;
	    capture_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn captures */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		if (COL(square) > 0) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move - 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move + 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    capture_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	}

    }

}

/* This routine is pretty fast, so I just call it once every time the program runs.  It has to be
 * used after any changes to the code above to verify that those complex movement vectors are
 * correct, or at least consistent.  We're using this in a game situation.  We can't afford bugs in
 * this code.
 */

void verify_movements()
{
    int piece;
    int squareA, squareB;
    int dir;
    int color;
    struct movement * movementptr;
    int pawn_option;

    /* For everything except pawns, if it can move from A to B, then it better be able to move from
     * B to A...
     */

    for (piece=KING; piece <= KNIGHT; piece ++) {

	for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

	    for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		int movement_possible = 0;
		int reverse_movement_possible = 0;

		/* check for possible self-movement, if A and B are the same square */

		if (squareA == squareB) {
		    for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {
			for (movementptr = movements[piece][squareA][dir];
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fprintf(stderr, "Self movement possible!? %s %d %d\n",
				    piece_name[piece], squareA, movementptr->square);
			}
		    }
		    continue;
		}

		/* check for possible A to B move */

		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareA][dir];
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fprintf(stderr, "Bad movement square: %s %d %d %d\n",
				    piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fprintf(stderr, "-1 movement lacks allones_bitvector: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fprintf(stderr, "Bad movement square: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fprintf(stderr, "bitvector does not match destination square: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fprintf(stderr, "multiple idential destinations from same origin: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fprintf(stderr, "allones_bitvector on a legal movement: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    }
		}


		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareB][dir];
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;
		}


		if (movement_possible && !reverse_movement_possible) {
		    fprintf(stderr, "reverse movement impossible: %s %d %d\n",
			    piece_name[piece], squareA, squareB);
		}

	    }
	}
    }

    /* Pawns are special */

    piece = PAWN;

    for (pawn_option = 0; pawn_option < 4; pawn_option ++) {

	struct movement * fwd_movement;
	struct movement * rev_movement;

	for (color = WHITE; color <= BLACK; color ++) {

	    /* fprintf(stderr, "Pawn option %d; color %s\n", pawn_option, colors[color]); */

	    for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

		for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		    int movement_possible = 0;
		    int reverse_movement_possible = 0;

		    switch (pawn_option) {
		    case 0:
			fwd_movement = normal_pawn_movements[squareA][color];
			rev_movement = normal_pawn_movements_bkwd[squareB][color];
			break;
		    case 1:
			fwd_movement = normal_pawn_movements_bkwd[squareA][color];
			rev_movement = normal_pawn_movements[squareB][color];
			break;
		    case 2:
			fwd_movement = capture_pawn_movements[squareA][color];
			rev_movement = capture_pawn_movements_bkwd[squareB][color];
			break;
		    case 3:
			fwd_movement = capture_pawn_movements_bkwd[squareA][color];
			rev_movement = capture_pawn_movements[squareB][color];
			break;
		    }

		    /* check for self-movement */

		    if (squareA == squareB) {
			for (movementptr = fwd_movement;
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fprintf(stderr, "Self movement possible!? PAWN %d %d\n",
				    squareA, movementptr->square);
			}
		    }

		    /* check for possible A to B move */

		    for (movementptr = fwd_movement;
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fprintf(stderr, "Bad movement square: %s %d %d %d\n",
				    piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fprintf(stderr, "-1 movement lacks allones_bitvector: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fprintf(stderr, "Bad movement square: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fprintf(stderr, "bitvector does not match destination square: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fprintf(stderr, "multiple idential destinations from same origin: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fprintf(stderr, "allones_bitvector on a legal movement: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    }


		    /* check for possible B to A reverse move */

		    for (movementptr = rev_movement;
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;

		    if (movement_possible && !reverse_movement_possible) {
			fprintf(stderr, "reverse movement impossible: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    }
		}
	    }
	}
    }
}


/***** PROPAGATION TABLE *****/

int proptable_entries = 0;
int proptable_merges = 0;

/* We insert into the propagation table using an "address calculation insertion sort".
 */

void insert_at_propentry(int propentry, index_t index, short dtm, unsigned char dtc,
			 futurevector_t futurevector)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("insert_at_propentry; index=%d; propentry=%d; dtm=%d\n", index, propentry, dtm);
#endif

    proptable_entries ++;

    proptable[propentry].index = index;
    proptable[propentry].dtm = dtm;
    proptable[propentry].dtc = dtc;
    proptable[propentry].movecnt = 1;
    proptable[propentry].futurevector = futurevector;
}

void merge_propentrys(proptable_entry_t *dest, proptable_entry_t *src)
{
    if (src->dtm > 0) {
	/* DTM > 0 - this move lets PTM mate from this position.  Update the proptable entry if
	 * either we don't have any PTM mates yet (table's dtm <= 0), or if this new mate is faster
	 * than the old one.
	 */
	if ((dest->dtm <= 0) || (src->dtm < dest->dtm)) {
	    dest->dtm = src->dtm;
	    dest->dtc = src->dtc;
	}
    } else if (src->dtm < 0) {
	/* DTM < 0 - this move lets PNTM mate from this position.  Update the proptable entry only
	 * if we don't have any PTM mates (table's dtm <= 0) and this PNTM mate is slower than the
	 * old one.
	 */
	if ((dest->dtm <= 0) && (src->dtm < dest->dtm)) {
	    dest->dtm = src->dtm;
	    dest->dtc = src->dtc;
	}
    }

    dest->movecnt += src->movecnt;

    if (dest->futurevector & src->futurevector) {
	global_position_t global;
	index_to_global_position(proptable_tb, dest->index, &global);
	fprintf(stderr, "Futuremoves multiply handled: %s\n", global_position_to_FEN(&global)); /* BREAKPOINT */
    }

    dest->futurevector |= src->futurevector;
}

void merge_at_propentry(int propentry, short dtm, unsigned char dtc, futurevector_t futurevector)
{
    proptable_entry_t src;

    proptable_merges ++;

    /* merge_propentrys() never uses the source index, because it's assumed to be identical to the
     * destination index (it's a merge, after all)
     */
    /* src.index = index; */
    src.dtm = dtm;
    src.dtc = dtc;
    src.movecnt = 1;
    src.futurevector = futurevector;

    merge_propentrys(&proptable[propentry], &src);
}

int num_proptables = 0;
int proptable_output_fd = -1;

/* proptable_full() - dump out to disk and empty table
 */

void proptable_full(void)
{
    char outfilename[256];
    struct timeval tv1, tv2;
    xmlNodePtr node;
    char strbuf[256];

    if (proptable_entries == 0) return;

#if SEPERATE_PROPTABLE_FILES
    sprintf(outfilename, "propfile%04d_out", num_proptables);
#else
    sprintf(outfilename, "propfile_out");
#endif

    if (proptable_output_fd == -1) {
	proptable_output_fd = open(outfilename, O_WRONLY | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
    }
    if (proptable_output_fd == -1) {
	fprintf(stderr, "Can't open '%s' for writing propfile\n", outfilename);
	return;
    }

    gettimeofday(&tv1, NULL);

    xmlNodeAddContent(proptable_tb->current_pass_stats, BAD_CAST "\n      ");
    node = xmlNewChild(proptable_tb->current_pass_stats, NULL, BAD_CAST "proptable", NULL);
    sprintf(strbuf, "%d", proptable_entries);
    xmlNewProp(node, BAD_CAST "entries", BAD_CAST strbuf);
    sprintf(strbuf, "%d", proptable_merges);
    xmlNewProp(node, BAD_CAST "merges", BAD_CAST strbuf);
    sprintf(strbuf, "%d%%", (100*proptable_entries)/num_propentries);
    xmlNewProp(node, BAD_CAST "occupancy", BAD_CAST strbuf);

    /* xmlElemDump(stderr, proptable_tb->xml, node); */
    /* fputc('\n', stderr); */

    fprintf(stderr, "Writing proptable block %d with %d entries (%d%% occupancy)\n",
	    num_proptables, proptable_entries, (100*proptable_entries)/num_propentries);

    /* XXX hitting a disk full condition is by no means out of the question here! */
    do_write(proptable_output_fd, proptable, num_propentries * sizeof(proptable_entry_t));
    memset(proptable, 0, num_propentries * sizeof(proptable_entry_t));

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_write_time, &tv2);
    proptable_writes ++;

    num_proptables ++;
    proptable_entries = 0;
    proptable_merges = 0;

#if SEPERATE_PROPTABLE_FILES
    close(proptable_output_fd);
    proptable_output_fd = -1;
#endif
}

void commit_proptable_entry(proptable_entry_t *propentry, struct fourbyte_entry *entry)
{
    int dtm = propentry->dtm;
    int i;

    /* Skip everything if the position isn't valid.  In particular, we don't track futuremove
     * propagation for illegal positions.
     */

    if (entry->dtm == 1) return;

    if (dtm > 0) {
	PTM_wins(entry, dtm, propentry->dtc);
    } else if (dtm < 0) {
	for (i=0; i<propentry->movecnt; i++) {
	    add_one_to_PNTM_wins(entry, dtm, propentry->dtc);
	}
    }
}

/* proptable_finalize()
 *
 * Start a new set of proptables and commit the old set into the entries array.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int dtm, int dtc);

/* fetch_next_propentry()
 *
 * proptable_buffer[propbuf(tablenum, buffernum)]
 *         a malloc'ed buffer of PROPTABLE_BUFFER_SIZE bytes
 * proptable_buffer_index[tablenum]
 *         the local (relative to buffer) entry number of the NEXT entry in the buffer to be read
 * proptable_input_fds[tablenum]
 *         file descriptor of this proptable
 * proptable_current_buffernum[tablenum]
 *         current buffernum (from 0 to BUFFERS_PER_PROPTABLE) for this table
 */

int *proptable_input_fds;
proptable_entry_t **proptable_buffer;
struct aiocb *proptable_aiocb;
int *proptable_buffer_index;
int *proptable_current_buffernum;

/* Proptable buffering settings.
 *
 * Based on a paper I read about disk throughput using Linux asynchronous I/O, 256 KB seems to be a
 * good target buffer size to shoot for.  Also, there's currently nothing in the code to deal with
 * the case where the buffers are so large relative to the proptable that the first set of AIO reads
 * more than completely consumes the proptable.  Since the smallest proptable we can specify (the -P
 * option) is 1 MB, and I'm currently using 4 BUFFERS_PER_PROPTABLE, 256 KB is also the largest
 * buffer size we can use with our smallest proptable size and not break the code.  Since
 * proptable_entry_t is currently hardwired at 16 bytes, 1<<14 (16 K) entries per buffer gives 256
 * KB buffers.
 *
 * Adjusting these numbers is actually quite tricky.  Make the buffers too small or too few, and
 * you'll be stalling because you've emptied your pipeline.  Make the buffers too big or too many,
 * and you'll stall because your pipeline is full of big, slow reads that you don't need yet.
 * Probably want to look at adjusting these things dynamically at some point; perhaps keep the
 * buffer size constant and adjust on the fly the number of buffers in the rings.
 *
 * I _assume_ that these numbers read full disk blocks on disk block multiples (otherwise the direct
 * I/O stuff will scream and fail).  I've also found out from the linux-kernel mailing list that
 * /sys/block/DEV/queue/max_sectors_kb gives the maximum size (in KB) of the kernel internal
 * requests.  My disk shows 128 KB there, so I've bumped 256 KB down to 128 KB.  (1<<13 entries)
 */

#define PROPTABLE_BUFFER_ENTRIES (1<<13)
#define PROPTABLE_BUFFER_BYTES (PROPTABLE_BUFFER_ENTRIES * sizeof(proptable_entry_t))
#define BUFFERS_PER_PROPTABLE 4

#define propbuf(tablenum, buffernum) (((tablenum) * BUFFERS_PER_PROPTABLE) + buffernum)

#define current_propbuf(tablenum) propbuf(tablenum, proptable_current_buffernum[tablenum])

void fetch_next_propentry(int tablenum, proptable_entry_t *dest)
{
    const struct aiocb * aiocbs[1];
    int32 offset;
    int ret;

    do {

	/* First, look for additional entries in the in-memory buffer.  Entries with zero
	 * index are empty slots and are skipped.
	 */

	while (proptable_buffer_index[tablenum] < PROPTABLE_BUFFER_ENTRIES) {

	    if (proptable_buffer[current_propbuf(tablenum)][proptable_buffer_index[tablenum]].index != 0) {
		*dest = proptable_buffer[current_propbuf(tablenum)][proptable_buffer_index[tablenum]];
		proptable_buffer_index[tablenum] ++;
		return;
	    }

	    proptable_buffer_index[tablenum] ++;
	}

	/* Finished with this buffer.  Issue a read request for what its next contents should be
	 * (unless we've reached EOF).
	 */

	/* I'm reading Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed).
	 * He uses three colors to illustrate the operation of these things - red (read not yet
	 * complete), green (read complete), and yellow (currently processing).  In our case, the
	 * buffers turn from red to green themselves and we can detect their color (by looking to
	 * see if their asynchronous read operation completed).  So we only need a single pointer,
	 * to the single yellow buffer.
	 */

	offset = proptable_aiocb[current_propbuf(tablenum)].aio_offset
	    + PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE;
	if (offset % (num_propentries * sizeof(proptable_entry_t))
	    < PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE) offset = 0;

	memset(&proptable_aiocb[current_propbuf(tablenum)], 0, sizeof(struct aiocb));
	proptable_aiocb[current_propbuf(tablenum)].aio_fildes = proptable_input_fds[tablenum];
	proptable_aiocb[current_propbuf(tablenum)].aio_buf = proptable_buffer[current_propbuf(tablenum)];
	proptable_aiocb[current_propbuf(tablenum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	proptable_aiocb[current_propbuf(tablenum)].aio_sigevent.sigev_notify = SIGEV_NONE;
	proptable_aiocb[current_propbuf(tablenum)].aio_offset = offset;

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    if (aio_read(& proptable_aiocb[current_propbuf(tablenum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }

	}

	/* On to the next buffer. */

	proptable_current_buffernum[tablenum] ++;
	proptable_current_buffernum[tablenum] %= BUFFERS_PER_PROPTABLE;

	/* Wait for it to finish its disk read, if necessary */

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    ret = aio_error(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret == EINPROGRESS) {
		struct timeval tv1, tv2;
		gettimeofday(&tv1, NULL);

		/* fprintf(stderr, "Waiting for proptable buffer read to complete\n"); */
		aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
		aio_suspend(aiocbs, 1, NULL);

		gettimeofday(&tv2, NULL);
		subtract_timeval(&tv2, &tv1);
		add_timeval(&proptable_read_stall_time, &tv2);
		proptable_read_stalls ++;
	    } else if (ret != 0) {
		fprintf(stderr, "Error return %d from proptable aio_read\n", ret);
	    }

	    ret = aio_return(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret != PROPTABLE_BUFFER_BYTES) {
		fprintf(stderr, "proptable aio_read returned %d, not PROPTABLE_BUFFER_BYTES\n", ret);
		kill(getpid(), SIGSTOP);
	    }
	}

	/* Start at the beginning of the buffer, and keep looking */

	proptable_buffer_index[tablenum] = 0;

    } while (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0);

    /* No, we're really at the end! */

    dest->index = proptable_tb->max_index + 1;
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index, struct fourbyte_entry *entry);
void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector);

int proptable_finalize(int target_dtm)
{
    int i;
    int tablenum, bufnum;
    int num_input_proptables;
    struct timeval tv1, tv2;

    proptable_entry_t *sorting_network;
    int *proptable_num;
    int highbit;
    int network_node;

#if SEPERATE_PROPTABLE_FILES
    char infilename[256];
    char outfilename[256];
#else
    int proptable_input_fd;
#endif

    index_t index;
    int positions_finalized = 0;

    /* Flush out anything in the last proptable */
    proptable_full();

    num_input_proptables = num_proptables;

    if (proptable_output_fd != -1) {
	close(proptable_output_fd);
	proptable_output_fd = -1;
    }

    num_proptables = 0;

    for (highbit = 1; highbit <= num_input_proptables; highbit <<= 1);

    proptable_buffer = (proptable_entry_t **)
	malloc(BUFFERS_PER_PROPTABLE * num_input_proptables * sizeof(proptable_entry_t *));
    proptable_aiocb = (struct aiocb *)
	calloc(BUFFERS_PER_PROPTABLE * num_input_proptables, sizeof(struct aiocb));
    proptable_buffer_index = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_current_buffernum = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_input_fds = (int *) calloc(num_input_proptables, sizeof(int));

    if ((proptable_buffer == NULL) || (proptable_input_fds == NULL)
	|| (proptable_buffer_index == NULL)) {
	fprintf(stderr, "Can't malloc proptable buffers in proptable_finalize()\n");
	return 0;
    }

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	rename("propfile_out", "propfile_in");
	proptable_input_fd = open("propfile_in", O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fd == -1) {
	    fprintf(stderr, "Can't open 'propfile_in' for reading propfile\n"); /* BREAKPOINT */
	    return 0;
	}
    }
#endif

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
#if SEPERATE_PROPTABLE_FILES
	sprintf(infilename, "propfile%04d_in", tablenum);
	sprintf(outfilename, "propfile%04d_out", tablenum);
	rename(outfilename, infilename);
	proptable_input_fds[tablenum] = open(infilename, O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fds[tablenum] == -1) {
	    fprintf(stderr, "Can't open '%s' for reading propfile\n", infilename);
	    return 0;
	}
#else
	proptable_input_fds[tablenum] = proptable_input_fd;
#endif
    }

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	int alignment = fpathconf(proptable_input_fds[tablenum], _PC_REC_XFER_ALIGN);

	for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	    if (posix_memalign((void **) &proptable_buffer[propbuf(tablenum, bufnum)],
			       alignment, PROPTABLE_BUFFER_BYTES) != 0) {
		fprintf(stderr, "Can't posix_memalign proptable buffer\n");
		return 0;
	    }
	}
    }

    /* I run this loop in the opposite direction from the last one because I want the reads
     * for the initial buffers for all the tables to be first in the queue.
     */

    for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_fildes = proptable_input_fds[tablenum];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_buf = proptable_buffer[propbuf(tablenum, bufnum)];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_sigevent.sigev_notify = SIGEV_NONE;
#if SEPERATE_PROPTABLE_FILES
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset = PROPTABLE_BUFFER_BYTES * bufnum;
#else
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset
		= tablenum * num_propentries * sizeof(proptable_entry_t) + PROPTABLE_BUFFER_BYTES * bufnum;
#endif

	    if (aio_read(& proptable_aiocb[propbuf(tablenum, bufnum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }
	}
    }

    /* Wait for initial read to finish on each input proptable */

    gettimeofday(&tv1, NULL);

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	const struct aiocb * aiocbs[1];
	aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
	aio_suspend(aiocbs, 1, NULL);
    }

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_preload_time, &tv2);

    sorting_network = malloc(2*highbit * sizeof(proptable_entry_t));
    proptable_num = malloc(2*highbit * sizeof(int));

    if ((sorting_network == NULL) || (proptable_num == NULL)) {
	fprintf(stderr, "Can't malloc sorting network in proptable_finalize()\n");
	return 0;
    }

    /* Initialize the sorting network.
     *
     * First, fill in the upper half of the network with either the first entry from a proptable,
     * or an "infinite" entry for slots with no proptables.  Then, sort into the lower half
     * of the network.
     */

    for (i = 0; i < highbit; i ++) {
	if (i < num_input_proptables) {
	    fetch_next_propentry(i, &sorting_network[highbit + i]);
	    proptable_num[highbit + i] = i;
	} else {
	    sorting_network[highbit + i].index = proptable_tb->max_index + 1;
	    proptable_num[highbit + i] = -1;
	}
    }

    for (network_node = highbit-1; network_node > 0; network_node --) {
	if (sorting_network[2*network_node].index < sorting_network[2*network_node+1].index) {
	    sorting_network[network_node] = sorting_network[2*network_node];
	    proptable_num[network_node] = proptable_num[2*network_node];
	} else {
	    sorting_network[network_node] = sorting_network[2*network_node+1];
	    proptable_num[network_node] = proptable_num[2*network_node+1];
	}
    }

    /* Now, process the data through the sorting network. */

    for (index = 0; index <= proptable_tb->max_index; index ++) {

	struct fourbyte_entry *fourbyte_entry = fetch_fourbyte_entry(proptable_tb, index);
	futurevector_t futurevector = 0;
	futurevector_t possible_futuremoves;

	if (sorting_network[1].index < index) {
	    fprintf(stderr, "Out-of-order entries in sorting network\n");   /* BREAKPOINT */
	}

	if (target_dtm == 0) {
	    possible_futuremoves = initialize_tablebase_entry(proptable_tb, index, fourbyte_entry);
	}

	while (sorting_network[1].index == index ) {

	    commit_proptable_entry(&sorting_network[1], fourbyte_entry);

	    if (sorting_network[1].futurevector & futurevector) {
		global_position_t global;
		index_to_global_position(proptable_tb, sorting_network[1].index, &global);
		fprintf(stderr, "Futuremoves multiply handled: %s\n", global_position_to_FEN(&global));
	    }

	    futurevector |= sorting_network[1].futurevector;

	    fetch_next_propentry(proptable_num[1], &sorting_network[highbit + proptable_num[1]]);

	    network_node = highbit + proptable_num[1];

	    while (network_node > 1) {
		network_node >>= 1;
		if (sorting_network[2*network_node].index < sorting_network[2*network_node+1].index) {
		    sorting_network[network_node] = sorting_network[2*network_node];
		    proptable_num[network_node] = proptable_num[2*network_node];
		} else {
		    sorting_network[network_node] = sorting_network[2*network_node+1];
		    proptable_num[network_node] = proptable_num[2*network_node+1];
		}
	    }
	}

	/* Don't track futuremoves for illegal (DTM 1) positions */

	if ((target_dtm == 0) && (get_entry_DTM(fourbyte_entry) != 1)) {

	    if ((futurevector & possible_futuremoves) != futurevector) {
		global_position_t global;
		index_to_global_position(proptable_tb, index, &global);
		fprintf(stderr, "Futuremove discrepancy: %s\n", global_position_to_FEN(&global)); /* BREAKPOINT */
	    }

	    finalize_futuremove(proptable_tb, index, possible_futuremoves ^ futurevector);
	}

	if ((target_dtm != 0) && (get_entry_DTM(fourbyte_entry) == target_dtm)) {
	    back_propagate_index_within_table(proptable_tb, index, target_dtm, fourbyte_entry->dtc);
	    positions_finalized ++;
	}

    }

    for (i = 0; i < num_input_proptables * BUFFERS_PER_PROPTABLE; i ++) {
	free(proptable_buffer[i]);
    }

    free(proptable_buffer_index);
    free(proptable_buffer);
    free(proptable_input_fds);

    free(sorting_network);
    free(proptable_num);

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	close(proptable_input_fd);
	unlink("propfile_in");
    }
#else
    for (i = 0; i < num_input_proptables; i ++) {
	close(proptable_input_fds[i]);
	sprintf(infilename, "propfile%04d_in", i);
	unlink(infilename);
    }
#endif

    /* Flush out anything in the last proptable */
    proptable_full();

    return positions_finalized;
}

/* target_dtm == 0 is special because the initialization / futurebase back prop pass
 *
 * Among other things, for pass 0 we've already set the start time when we began the futurebase back
 * prop.
 */

int propagation_pass(int target_dtm)
{
    int positions_finalized = 0;
    struct timeval pass_end_time;
    char strbuf[256];
    index_t index;

    total_passes ++;

    if (target_dtm != 0) {
	gettimeofday(&pass_start_time, NULL);
	xmlNodeAddContent(proptable_tb->per_pass_stats, BAD_CAST "\n   ");
	proptable_tb->current_pass_stats
	    = xmlNewChild(proptable_tb->per_pass_stats, NULL, BAD_CAST "pass", NULL);
    }

    sprintf(strbuf, "%d", target_dtm);
    xmlNewProp(proptable_tb->current_pass_stats, BAD_CAST "dtm", BAD_CAST strbuf);

    /* xmlElemDump(stderr, proptable_tb->xml, proptable_tb->current_pass_stats); */
    /* fputc('\n', stderr); */

    backproped_moves = 0;

    if (num_propentries != 0) {
	positions_finalized = proptable_finalize(target_dtm);
    } else {

	for (index = 0; index <= proptable_tb->max_index; index ++) {

	    struct fourbyte_entry *fourbyte_entry = fetch_fourbyte_entry(proptable_tb, index);

	    if ((target_dtm != 0) && (get_entry_DTM(fourbyte_entry) == target_dtm)) {
		back_propagate_index_within_table(proptable_tb, index, target_dtm, fourbyte_entry->dtc);
		positions_finalized ++;
	    }
	}

    }

    gettimeofday(&pass_end_time, NULL);
    subtract_timeval(&pass_end_time, &pass_start_time);

    sprint_timeval(strbuf, &pass_end_time);
    xmlNewProp(proptable_tb->current_pass_stats, BAD_CAST "time", BAD_CAST strbuf);

    if (target_dtm != 0) {
	sprintf(strbuf, "%d", positions_finalized);
	xmlNewProp(proptable_tb->current_pass_stats, BAD_CAST "positions-finalized", BAD_CAST strbuf);
	sprintf(strbuf, "%lld", backproped_moves);
	xmlNewProp(proptable_tb->current_pass_stats, BAD_CAST "backprop-moves-generated", BAD_CAST strbuf);
    }

    if (((backproped_moves != 0) || (target_dtm == 0)) && (num_propentries != 0)) {
	xmlNodeAddContent(proptable_tb->current_pass_stats, BAD_CAST "\n   ");
    }

    total_backproped_moves += backproped_moves;

    fprintf(stderr, "Pass %3d complete; %d positions finalized\n", target_dtm, positions_finalized);
    /* fprint_system_time(); */

    return positions_finalized;
}

void insert_into_proptable(index_t index, short dtm, unsigned char dtc, futurevector_t futurevector)
{
    int propentry;
    int zerooffset;
    static int scaling_factor = 0;

    backproped_moves ++;

    if (num_propentries == 0) {
	proptable_entry_t entry;

	entry.index = index;
	entry.dtm = dtm;
	entry.dtc = dtc;
	entry.movecnt = 1;

	commit_proptable_entry(&entry, fetch_fourbyte_entry(proptable_tb, index));

	/* Don't track futuremoves for illegal (DTM 1) positions */

	if ((proptable_tb->futurevectors != NULL) && (get_DTM(proptable_tb, index) != 1)) {

	    if ((futurevector & proptable_tb->futurevectors[index]) != futurevector) {
		global_position_t global;
		index_to_global_position(proptable_tb, index, &global);
		fprintf(stderr, "Futuremove discrepancy: %s\n", global_position_to_FEN(&global)); /* BREAKPOINT */
	    }

	    proptable_tb->futurevectors[index] ^= futurevector;
	}

	return;
    }

    /* I had a bug here with the scaling_factor rounding down - that's why we increment by one */

    if (scaling_factor == 0) {
	scaling_factor = proptable_tb->max_index / num_propentries;
	scaling_factor ++;
	fprintf(stderr, "Scaling factor %d\n", scaling_factor);
    }

 retry:

    /* We need an index into the proptable that maintains the index sort order of the entries. */

    propentry = index / scaling_factor;

    if (proptable[propentry].index == 0) {
	/* empty slot: insert at propentry */
	insert_at_propentry(propentry, index, dtm, dtc, futurevector);
	return;
    } else if (proptable[propentry].index == index) {
	/* entry at slot with identical index: merge at propentry */
	merge_at_propentry(propentry, dtm, dtc, futurevector);
	return;
    } else if (proptable[propentry].index > index) {
	/* entry at slot greater than index to be inserted */
	while ((proptable[propentry].index > index) && (propentry > 0)) propentry --;
	if (proptable[propentry].index == 0) {
	    /* empty slot at lower end of a block all gt than index: insert there */
	    insert_at_propentry(propentry, index, dtm, dtc, futurevector);
	    return;
	} else if (proptable[propentry].index == index) {
	    /* identical slot in a block: merge there */
	    merge_at_propentry(propentry, dtm, dtc, futurevector);
	    return;
	} else if (proptable[propentry].index > index) {
	    /* we're at the beginning of the table and the first entry is gt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (proptable[zerooffset].index == 0) {
		    memmove(proptable + 1, proptable,
			    (zerooffset) * sizeof(proptable_entry_t));
		    insert_at_propentry(0, index, dtm, dtc, futurevector);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* still in the block; propentry is lt index and propentry+1 is gt index: fall through */
	}
    } else {
	/* entry at slot less than index to be inserted */
	while ((proptable[propentry].index != 0) && (proptable[propentry].index < index)
	       && (propentry < num_propentries - 1)) propentry ++;
	if (proptable[propentry].index == 0) {
	    /* empty slot at upper end of a block all lt than index: insert there */
	    insert_at_propentry(propentry, index, dtm, dtc, futurevector);
	    return;
	} else if (proptable[propentry].index == index) {
	    /* identical slot in a block: merge there */
	    merge_at_propentry(propentry, dtm, dtc, futurevector);
	    return;
	} else if (proptable[propentry].index < index) {
	    /* we're at the end of the table and the last entry is lt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (proptable[num_propentries - 1 - zerooffset].index == 0) {
		    memmove(proptable + num_propentries - 1 - zerooffset,
			    proptable + num_propentries - zerooffset,
			    (zerooffset) * sizeof(proptable_entry_t));
		    insert_at_propentry(num_propentries - 1, index, dtm, dtc, futurevector);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* propentry is gt index and propentry-1 is lt index */
	    propentry --;
	}
    }

    /* We found a boundary within a block: propentry is lt index and propentry+1 is gt index */

    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
	if ((propentry + zerooffset < num_propentries - 1)
	    && (proptable[propentry+zerooffset].index == 0)) {
	    memmove(proptable + propentry + 2, proptable + propentry + 1,
		    (zerooffset-1) * sizeof(proptable_entry_t));
	    insert_at_propentry(propentry+1, index, dtm, dtc, futurevector);
	    return;
	}
	if ((propentry - zerooffset >= 0)
	    && (proptable[propentry-zerooffset].index == 0)) {
	    memmove(proptable + propentry - zerooffset, proptable + propentry - zerooffset + 1,
		    zerooffset * sizeof(proptable_entry_t));
	    insert_at_propentry(propentry, index, dtm, dtc, futurevector);
	    return;
	}
    }

    /* zerooffset > MAX_ZEROOFFSET: ran of space - table is "full" */
    proptable_full();
    goto retry;
}


/***** FUTUREBASES *****/

/* Subroutines to backpropagate an individual index, or an individual local position (these are the
 * "mini" routines), or a set of local positions that differ only in the en passant square.
 *
 * The idea behind the en passant handling is this.  If we back propagate a position with the en
 * passant square set, then that's the only position we process.  If we back prop a position without
 * the en passant square set, then we process not only that position, but also any positions just
 * like it that have en passant set.  The idea being that we set en passant if we actually need it,
 * and we clear it if we don't need it, so if it's clear we need to process positions where it was
 * set, but we didn't use it.
 */

void propagate_index_from_futurebase(tablebase_t *tb, int dtm, int dtc,
				     int futuremove, index_t current_index, int *dtm_limit)
{
    if (futuremove == -1) {
	static int errors = 0;
	global_position_t global;

	index_to_global_position(tb, current_index, &global);
	fprintf(stderr, "Futuremove never assigned: %s %s\n",
		global_position_to_FEN(&global), movestr[futuremove]);

	if (errors++ == 10) exit(EXIT_FAILURE);
	return;
    }

    /* We insert even if dtm is zero because we have to track futuremoves */

    if (dtm > 0) {
	insert_into_proptable(current_index, -dtm, dtc, FUTUREVECTOR(futuremove));
    } else if (dtm < 0) {
	insert_into_proptable(current_index, -dtm+1, dtc+1, FUTUREVECTOR(futuremove));
    } else {
	insert_into_proptable(current_index, 0, 0, FUTUREVECTOR(futuremove));
    }

    /* This is pretty primitive, but we need to track the deepest mates during futurebase back prop
     * in order to know how deep we have to look during intra-table propagation.  We could improve
     * on this by only bumping dtm_limit if we called PTM_wins(), or if we called
     * add_one_to_PNTM_wins() and the move count went to zero.
     */

    if ((dtm > 0) && (*dtm_limit < dtm)) *dtm_limit = dtm;
    if ((dtm < 0) && (*dtm_limit < -dtm)) *dtm_limit = -dtm;
}

void propagate_minilocal_position_from_futurebase(tablebase_t *tb, int dtm, int dtc,
						  int futuremove, local_position_t *current_position,
						  int *dtm_limit)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");  /* BREAKPOINT */
	return;
    }

    propagate_index_from_futurebase(tb, dtm, dtc, futuremove, current_index, dtm_limit);
}

void propagate_local_position_from_futurebase(tablebase_t *tb, int dtm, int dtc,
					      int futuremove, local_position_t *position,
					      int *dtm_limit)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_minilocal_position_from_futurebase(tb, dtm, dtc, futuremove, position, dtm_limit);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_minilocal_position_from_futurebase(tb, dtm, dtc, futuremove, position, dtm_limit);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_minilocal_position_from_futurebase(tb, dtm, dtc, futuremove, position, dtm_limit);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* Back propagate promotion moves
 *
 * Passed a piece (a global position character) that the pawn is promoting into.  Searches
 * futurebase for positions with that piece on the last rank and back-props.
 */

void propagate_moves_from_promotion_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					       int invert_colors_of_futurebase,
					       int pawn,
					       int *dtm_limit)
{
    index_t future_index;
    int dtm;
    local_position_t foreign_position;
    local_position_t position;
    int32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int true_pawn;

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	dtm = fetch_next_DTM_from_disk(futurebase);

	/* Take the position from the futurebase and translate it into a local position for the
	 * current tablebase.  If the futurebase index was illegal, the function will return -1.
	 * Otherwise, there should be one piece missing from the local position (the pawn that
	 * promoted) and one piece extra (what it promoted into).  There can be no pieces on
	 * restricted squares.
	 */

	if (! index_to_local_position(futurebase, future_index, &foreign_position)) continue;

	conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									 tb, &position,
									 invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((extra_piece == NONE) || missing_piece1 != pawn) {
		fprintf(stderr, "Conversion error during promotion back-prop\n");  /* BREAKPOINT */
		continue;
	    }

	    /* This can happen if the futurebase is more liberal than the current tablebase. */

	    if (restricted_piece != NONE) continue;

	    /* Since the last move had to have been a promotion move, there is absolutely no way we
	     * could have en passant capturable pawns in the futurebase position.
	     */

	    if (position.en_passant_square != -1) continue;

	    /* Whatever color the promoted piece is, after the promotion it must be the other side
	     * to move.
	     */

	    if (position.side_to_move == promotion_color) continue;

	    /* We're going to back step a half move now */

	    flip_side_to_move_local(&position);

	    /* We need an extra loop in here to handle futurebases with multiple identical pieces.
	     * Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.  If we've got
	     * a futurebase position with both queens on the back rank, then we have to consider the
	     * possibility that the pawn could promote into either of them.
	     *
	     * Move restrictions can really mess with this, but right now we don't compute
	     * tablebases with non-identical overlapping move restrictions on otherwise identical
	     * pieces, and with that caveat we're OK.  If the move restrictions don't overlap, then
	     * there's no way the pieces can swap with each other.  And if the move restrictions are
	     * identical, then that will be noted in the last_identical_piece array that we use
	     * below.
	     */

	    do {

		int promotion_sq = foreign_position.piece_position[extra_piece];

		if (invert_colors_of_futurebase)
		    promotion_sq = square(7 - ROW(promotion_sq), COL(promotion_sq));

		/* The extra piece has to be on the back rank.  We can safely 'break' here due to
		 * identical pieces being sorted into ascending square number.  If we've backed up
		 * to an extra piece that isn't on the back rank, then there can't be any more
		 * identical pieces on the back rank.
		 */

		if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
		    break;

		/* There has to be an empty square right behind where the pawn came from, and it has
		 * to be a legal (i.e, non-restricted) square for the pawn in our tablebase.
		 */

		if (!(position.board_vector & BITVECTOR(promotion_sq - promotion_move))
		    && (tb->piece_legal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move))) {

		    /* Because the promoted piece was 'extra' it doesn't appear in the local
		     * position, so we don't have to worry about taking it off the board.  Put the
		     * missing pawn on the seventh (or second).
		     */

		    position.piece_position[pawn] = promotion_sq - promotion_move;
		    position.board_vector |= BITVECTOR(position.piece_position[pawn]);

		    /* Back propagate the resulting position */

		    /* When we convert the position to an index (in local_position_to_index()),
		     * we'll make a copy of the position and normalize it by sorting the identical
		     * pieces so that they are in ascending order.  But we have to at least be aware
		     * of this here, in order to figure out which pawn "actually" promoted (we're
		     * always called with pawn set to the last piece number of any identical
		     * pieces), so we can figure out which futuremove number to use.
		     */

		    true_pawn = pawn;
		    while ((tb->last_identical_piece[true_pawn] != -1)
			   && (position.piece_position[pawn]
			       < position.piece_position[tb->last_identical_piece[true_pawn]])) {
			true_pawn = tb->last_identical_piece[true_pawn];
		    }

		    /* This function also back props any similar positions with one of the pawns from
		     * the side that didn't promote in an en passant state.  DTC is zero because
		     * this is a pawn move.
		     */

		    propagate_local_position_from_futurebase(tb, dtm, 0,
							     promotions[true_pawn]
							     + futurebase->piece_type[extra_piece] - 1,
							     &position, dtm_limit);

		    /* We may be about to use this position again, so put the board_vector back... */

		    position.board_vector &=~ BITVECTOR(position.piece_position[pawn]);
		}

		/* If there's an piece identical to the extra piece in the futurebase's position,
		 * then figure out which of our pieces it was mapped to, swap them, and try again.
		 */

		if (futurebase->last_identical_piece[extra_piece] != -1) {

		    int piece;

		    int new_promotion_sq
			= foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

		    if (invert_colors_of_futurebase)
			new_promotion_sq = square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

		    for (piece = 0; piece < tb->num_pieces; piece ++) {
			if (position.piece_position[piece] == new_promotion_sq) {
			    position.piece_position[piece] = promotion_sq;
			    break;
			}
		    }

		    if (piece == tb->num_pieces) {
			fprintf(stderr, "Couldn't back up to an identical piece in promotion back prop\n");
			break;
		    }
		}

		extra_piece = futurebase->last_identical_piece[extra_piece];

	    } while (extra_piece != -1);

	}
    }
}

void propagate_moves_from_promotion_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
						       int invert_colors_of_futurebase,
						       int pawn,
						       int *dtm_limit)
{
    index_t future_index;
    int dtm;
    local_position_t foreign_position;
    local_position_t position;
    int32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int true_captured_piece;
    int true_pawn;

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	dtm = fetch_next_DTM_from_disk(futurebase);

	/* Take the position from the futurebase and translate it into a local position for the
	 * current tablebase.  If the futurebase index was illegal, the function will return -1.
	 * Otherwise, there should be two pieces missing from the local position (the pawn that
	 * promoted and the piece it captured) and one piece extra (what it promoted into).  There
	 * can be no pieces on restricted squares.
	 */

	if (! index_to_local_position(futurebase, future_index, &foreign_position)) continue;

	conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									 tb, &position,
									 invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((extra_piece == NONE) || (missing_piece1 != pawn) || (missing_piece2 == NONE)) {
		fprintf(stderr, "Conversion error during promotion capture back-prop\n");  /* BREAKPOINT */
		continue;
	    }

	    /* This can happen if the futurebase is more liberal than the current tablebase. */

	    if (restricted_piece != NONE) continue;

	    /* Since the last move had to have been a promotion move, there is absolutely no way we
	     * could have en passant capturable pawns in the futurebase position.
	     */

	    if (position.en_passant_square != -1) continue;

	    /* Whatever color the promoted piece is, after the promotion it must be the other side
	     * to move.
	     */

	    if (position.side_to_move == promotion_color) continue;

	    /* We're going to back step a half move now */

	    flip_side_to_move_local(&position);

	    /* We need an extra loop in here to handle futurebases with multiple identical pieces.
	     * Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.  If we've got
	     * a futurebase position with both queens on the back rank, then we have to consider the
	     * possibility that the pawn could promote into either of them.
	     *
	     * Move restrictions can really mess with this, but right now we don't compute
	     * tablebases with non-identical overlapping move restrictions on otherwise identical
	     * pieces, and with that caveat we're OK.  If the move restrictions don't overlap, then
	     * there's no way the pieces can swap with each other.  And if the move restrictions are
	     * identical, then that will be noted in the last_identical_piece array that we use
	     * below.
	     */

	    do {

		int promotion_sq = foreign_position.piece_position[extra_piece];

		if (invert_colors_of_futurebase)
		    promotion_sq = square(7 - ROW(promotion_sq), COL(promotion_sq));

		/* The extra piece has to be on the back rank.  We can safely 'break' here due to
		 * identical pieces being sorted into ascending square number.  If we've backed up
		 * to an extra piece that isn't on the back rank, then there can't be any more
		 * identical pieces on the back rank.
		 */


		if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
		    break;

		/* Put the piece that was captured onto the board on the promotion square. */

		position.piece_position[missing_piece2] = promotion_sq;
		position.board_vector |= BITVECTOR(promotion_sq);

		/* When we finally convert the position to an index (in local_position_to_index()),
		 * we'll make a copy of the position and normalize it by sorting the identical
		 * pieces so that they are in ascending order.  But we have to at least be aware of
		 * this here, in order to figure out which piece "actually" got captured (we're
		 * always called with captured_piece set to the last piece number of any identical
		 * pieces), so we can figure out which futuremove number to use.
		 */

		true_captured_piece = missing_piece2;
		while ((tb->last_identical_piece[true_captured_piece] != -1)
		       && (position.piece_position[missing_piece2]
			   < position.piece_position[tb->last_identical_piece[true_captured_piece]])) {
		    true_captured_piece = tb->last_identical_piece[true_captured_piece];
		}

		/* Consider first a capture to the left (white's left).  There has to be an empty
		 * square where the pawn came from, and it has to be a legal (i.e, non-restricted)
		 * square for the pawn in our tablebase.
		 */

		if ((COL(promotion_sq) != 0)
		    && !(position.board_vector & BITVECTOR(promotion_sq - promotion_move - 1))
		    && (tb->piece_legal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move - 1))) {

		    /* Because the promoted piece was 'extra' it doesn't appear in the local
		     * position, so we don't have to worry about taking it off the board.  Put the
		     * missing pawn on the seventh (or second).
		     */

		    position.piece_position[pawn] = promotion_sq - promotion_move - 1;
		    position.board_vector |= BITVECTOR(position.piece_position[pawn]);

		    /* Back propagate the resulting position */

		    /* When we convert the position to an index (in local_position_to_index()),
		     * we'll make a copy of the position and normalize it by sorting the identical
		     * pieces so that they are in ascending order.  But we have to at least be aware
		     * of this here, in order to figure out which pawn "actually" promoted (we're
		     * always called with pawn set to the last piece number of any identical
		     * pieces), so we can figure out which futuremove number to use.
		     */

		    true_pawn = pawn;
		    while ((tb->last_identical_piece[true_pawn] != -1)
			   && (position.piece_position[pawn]
			       < position.piece_position[tb->last_identical_piece[true_pawn]])) {
			true_pawn = tb->last_identical_piece[true_pawn];
		    }

		    /* This function also back props any similar positions with one of the pawns
		     * from the side that didn't promote in an en passant state.  DTC is zero
		     * because this is a pawn move.
		     */

		    propagate_local_position_from_futurebase(tb, dtm, 0,
							     futurecaptures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
							     &position, dtm_limit);

		    /* We're about to use this position again, so put the board_vector back... */

		    position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		}

		/* Now consider a capture to the right (white's right).  Again, there has to be an
		 * empty square where the pawn came from, and it has to be a legal (i.e,
		 * non-restricted) square for the pawn in our tablebase.
		 */

		if ((COL(promotion_sq) != 7)
		    && !(position.board_vector & BITVECTOR(promotion_sq - promotion_move + 1))
		    && (tb->piece_legal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move + 1))) {

		    /* Because the promoted piece was 'extra' it doesn't appear in the local
		     * position, so we don't have to worry about taking it off the board.  Put the
		     * missing pawn on the seventh (or second).
		     */

		    position.piece_position[pawn] = promotion_sq - promotion_move + 1;
		    position.board_vector |= BITVECTOR(position.piece_position[pawn]);

		    /* Back propagate the resulting position */

		    /* When we convert the position to an index (in local_position_to_index()),
		     * we'll make a copy of the position and normalize it by sorting the identical
		     * pieces so that they are in ascending order.  But we have to at least be aware
		     * of this here, in order to figure out which pawn "actually" promoted (we're
		     * always called with pawn set to the last piece number of any identical
		     * pieces), so we can figure out which futuremove number to use.
		     */

		    true_pawn = pawn;
		    while ((tb->last_identical_piece[true_pawn] != -1)
			   && (position.piece_position[pawn]
			       < position.piece_position[tb->last_identical_piece[true_pawn]])) {
			true_pawn = tb->last_identical_piece[true_pawn];
		    }

		    /* This function also back props any similar positions with one of the pawns
		     * from the side that didn't promote in an en passant state.  DTC is zero
		     * because this is a pawn move.
		     */

		    propagate_local_position_from_futurebase(tb, dtm, 0,
							     futurecaptures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
							     &position, dtm_limit);

		    /* We're about to use this position again, so put the board_vector back... */

		    position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		}

		/* Remove the piece from the promotion square, at least in board_vector.  We'll
		 * change its position next time around this do/while loop, if there's another
		 * possibility for the "extra" piece.
		 */

		position.board_vector &= ~BITVECTOR(promotion_sq);

		/* If there's an piece identical to the extra piece in the futurebase's position,
		 * then figure out which of our pieces it was mapped to, swap them, and try again.
		 */

		if (futurebase->last_identical_piece[extra_piece] != -1) {

		    int piece;

		    int new_promotion_sq
			= foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

		    if (invert_colors_of_futurebase)
			new_promotion_sq = square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

		    for (piece = 0; piece < tb->num_pieces; piece ++) {
			if (position.piece_position[piece] == new_promotion_sq) {
			    position.piece_position[piece] = promotion_sq;
			    break;
			}
		    }

		    if (piece == tb->num_pieces) {
			fprintf(stderr, "Couldn't back up to an identical piece in promotion back prop\n");
			break;
		    }
		}

		extra_piece = futurebase->last_identical_piece[extra_piece];

	    } while (extra_piece != -1);

	}
    }
}

/* Propagate moves from a futurebase that resulted from capturing one of the pieces in the current
 * tablebase.
 *
 * I'm thinking of changing that "invert_colors_of_futurebase" flag to be a subroutine that gets
 * passed in.  It could be a pointer to invert_colors_of_global_position to do what it does now.  Or
 * it could be a "reflect board around vertical axis" to move a d4 pawn to e4.  Also see my comments
 * on invert_colors_of_global position.
 */

void consider_possible_captures(tablebase_t *tb, int dtm,
				local_position_t *position,
				int capturing_piece, int captured_piece, int *dtm_limit)
{
    int dir;
    struct movement *movementptr;
    int true_captured_piece;
    int true_capturing_piece;

    /* We only want to consider pieces of the side which captured... */

    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) return;

    /* Put the captured piece on the capturing piece's square (from the future position).  */

    position->piece_position[captured_piece] = position->piece_position[capturing_piece];

    /* When we finally convert the position to an index (in local_position_to_index()), we'll make a
     * copy of the position and normalize it by sorting the identical pieces so that they are in
     * ascending order.  But we have to at least be aware of this here, in order to figure out which
     * piece "actually" got captured (we're always called with captured_piece set to the last piece
     * number of any identical pieces), so we can figure out which futuremove number to use.
     */

    true_captured_piece = captured_piece;
    while ((tb->last_identical_piece[true_captured_piece] != -1)
	   && (position->piece_position[captured_piece]
	       < position->piece_position[tb->last_identical_piece[true_captured_piece]])) {
	true_captured_piece = tb->last_identical_piece[true_captured_piece];
    }

    /* Now consider all possible backwards movements of the capturing piece. */

    if (tb->piece_type[capturing_piece] != PAWN) {

	/* If the square we put the captured piece on isn't legal for it, then don't consider this
	 * capturing piece in this future position any more.  This is after the "if" instead of
	 * before it because an en passant pawn capture is special, since then the capturing piece
	 * ends up on a different square from the captured piece.
	 */

	if (!(tb->piece_legal_squares[captured_piece]
	      & BITVECTOR(position->piece_position[captured_piece]))) {
	    return;
	}

	for (dir = 0; dir < number_of_movement_directions[tb->piece_type[capturing_piece]]; dir++) {

	    /* Make sure we start each movement of the capturing piece from the capture square */

	    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

	    for (movementptr = movements[tb->piece_type[capturing_piece]][position->piece_position[capturing_piece]][dir];
		 (movementptr->vector & position->board_vector) == 0;
		 movementptr++) {

		/* We already checked that the captured piece was on a legal square
		 * for it.  Now check the capturing piece.
		 */

		if (! (tb->piece_legal_squares[capturing_piece] & movementptr->vector)) continue;

		/* Move the capturing piece... */

		/* I update board_vector here because I want to check for en passant legality before
		 * I call local_position_to_index().  It just makes the code a little more robust at
		 * this point, because then there should be no reason for local_position_to_index()
		 * to return -1.
		 *
		 * By the way, the piece didn't "come from" anywhere other than the capture square,
		 * which will have the captured piece on it (this is back prop), so we don't need to
		 * clear anything in board_vector.
		 */

		position->piece_position[capturing_piece] = movementptr->square;
		position->board_vector |= BITVECTOR(movementptr->square);

		/* Again, when we convert the position to an index (in local_position_to_index()),
		 * we'll make a copy of the position and normalize it by sorting the identical
		 * pieces so that they are in ascending order.  Now we have to figure out the "true"
		 * capturing piece, which could either be forwards or backwards in the piece list.
		 */

		true_capturing_piece = capturing_piece;
		while ((tb->last_identical_piece[true_capturing_piece] != -1)
		       && (movementptr->square
			   < position->piece_position[tb->last_identical_piece[true_capturing_piece]])) {
		    true_capturing_piece = tb->last_identical_piece[true_capturing_piece];
		}
		while ((tb->next_identical_piece[true_capturing_piece] != -1)
		       && (movementptr->square
			   > position->piece_position[tb->next_identical_piece[true_capturing_piece]])) {
		    true_capturing_piece = tb->next_identical_piece[true_capturing_piece];
		}

		/* This function also back props any similar positions with one of the pawns from
		 * the side that didn't capture in an en passant state.  DTC is zero because this is
		 * a capture.
		 */

		propagate_local_position_from_futurebase(tb, dtm, 0,
							 futurecaptures[true_capturing_piece][true_captured_piece],
							 position, dtm_limit);


		position->board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

    } else {

	/* Yes, pawn captures are special */

	for (movementptr = capture_pawn_movements_bkwd[position->piece_position[capturing_piece]][tb->piece_color[capturing_piece]];
	     movementptr->square != -1;
	     movementptr++) {

	    /* Is there anything on the square the pawn had to capture from? */

	    if ((movementptr->vector & position->board_vector) != 0) continue;

	    /* Move back the capturing pawn and see if it came from a legal square for it. */

	    position->piece_position[capturing_piece] = movementptr->square;
	    if (! (tb->piece_legal_squares[capturing_piece] & movementptr->vector)) continue;

	    /* And if the captured piece is also on a legal square for it... */

	    if ((tb->piece_legal_squares[captured_piece]
		 & BITVECTOR(position->piece_position[captured_piece]))) {

		/* I update board_vector here because I want to check for en passant legality before
		 * I call local_position_to_index().  It just makes the code a little more robust at
		 * this point, because then there should be no reason for local_position_to_index()
		 * to return -1.
		 *
		 * By the way, the piece didn't "come from" anywhere other than the capture square,
		 * which will have the captured piece on it (this is back prop), so we don't need to
		 * clear anything in board_vector.
		 */

		position->board_vector |= BITVECTOR(movementptr->square);

		/* Again, when we convert the position to an index (in local_position_to_index()),
		 * we'll make a copy of the position and normalize it by sorting the identical
		 * pieces so that they are in ascending order.  Now we have to figure out the "true"
		 * capturing piece, which could either be forwards or backwards in the piece list.
		 */

		true_capturing_piece = capturing_piece;
		while ((tb->last_identical_piece[true_capturing_piece] != -1)
		       && (movementptr->square
			   < position->piece_position[tb->last_identical_piece[true_capturing_piece]])) {
		    true_capturing_piece = tb->last_identical_piece[true_capturing_piece];
		}
		while ((tb->next_identical_piece[true_capturing_piece] != -1)
		       && (movementptr->square
			   > position->piece_position[tb->next_identical_piece[true_capturing_piece]])) {
		    true_capturing_piece = tb->next_identical_piece[true_capturing_piece];
		}

		/* This function also back props any similar positions with one of the pawns from
		 * the side that didn't capture in an en passant state.  DTC is zero because
		 * this is a capture (and a pawn move).
		 */

		propagate_local_position_from_futurebase(tb, dtm, 0,
							 futurecaptures[true_capturing_piece][true_captured_piece],
							 position, dtm_limit);

		position->board_vector &= ~BITVECTOR(movementptr->square);

	    }

	    /* The en passant special case: if both the piece that captured and the piece that was
	     * captured are both pawns, and either a white pawn captured from the fifth rank, or a
	     * black pawn captured from the fourth, then there are two possible back prop positions
	     * - the obvious one we just handled, and the one where the captured pawn was in an en
	     * passant state.  We also make sure right away that the rank is clear where the pawn
	     * had to come from, and the rank is clear where the pawn had to go to, ensuring that an
	     * en passant move was even possible.
	     */

	    if ((tb->piece_type[captured_piece] == PAWN)
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]-8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]+8))) {

		if ((tb->piece_color[capturing_piece] == BLACK) && (ROW(movementptr->square) == 3)) {

		    /* A black pawn capturing a white one (en passant)
		     *
		     * The white pawn is actually a rank higher than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] += 8;

		    if ((tb->piece_legal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			/* Since the captured piece is on a different square, we do this again. */

			true_captured_piece = captured_piece;
			while ((tb->last_identical_piece[true_captured_piece] != -1)
			       && (position->piece_position[captured_piece]
				   < position->piece_position[tb->last_identical_piece[true_captured_piece]])) {
			    true_captured_piece = tb->last_identical_piece[true_captured_piece];
			}

			/* Again, when we convert the position to an index (in
			 * local_position_to_index()), we'll make a copy of the position and
			 * normalize it by sorting the identical pieces so that they are in
			 * ascending order.  Now we have to figure out the "true" capturing piece,
			 * which could either be forwards or backwards in the piece list.
			 */

			true_capturing_piece = capturing_piece;
			while ((tb->last_identical_piece[true_capturing_piece] != -1)
			       && (movementptr->square
				   < position->piece_position[tb->last_identical_piece[true_capturing_piece]])) {
			    true_capturing_piece = tb->last_identical_piece[true_capturing_piece];
			}
			while ((tb->next_identical_piece[true_capturing_piece] != -1)
			       && (movementptr->square
				   > position->piece_position[tb->next_identical_piece[true_capturing_piece]])) {
			    true_capturing_piece = tb->next_identical_piece[true_capturing_piece];
			}

			propagate_local_position_from_futurebase(tb, dtm, 0,
								 futurecaptures[true_capturing_piece][true_captured_piece],
								 position, dtm_limit);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] -= 8;
		}

		if ((tb->piece_color[capturing_piece] == WHITE) && (ROW(movementptr->square) == 4)) {

		    /* A white pawn capturing a black one (en passant)
		     *
		     * The black pawn is actually a rank lower than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] -= 8;

		    if ((tb->piece_legal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			/* Since the captured piece is on a different square, we do this again. */

			true_captured_piece = captured_piece;
			while ((tb->last_identical_piece[true_captured_piece] != -1)
			       && (position->piece_position[captured_piece]
				   < position->piece_position[tb->last_identical_piece[true_captured_piece]])) {
			    true_captured_piece = tb->last_identical_piece[true_captured_piece];
			}

			/* Again, when we convert the position to an index (in
			 * local_position_to_index()), we'll make a copy of the position and
			 * normalize it by sorting the identical pieces so that they are in
			 * ascending order.  Now we have to figure out the "true" capturing piece,
			 * which could either be forwards or backwards in the piece list.
			 */

			true_capturing_piece = capturing_piece;
			while ((tb->last_identical_piece[true_capturing_piece] != -1)
			       && (movementptr->square
				   < position->piece_position[tb->last_identical_piece[true_capturing_piece]])) {
			    true_capturing_piece = tb->last_identical_piece[true_capturing_piece];
			}
			while ((tb->next_identical_piece[true_capturing_piece] != -1)
			       && (movementptr->square
				   > position->piece_position[tb->next_identical_piece[true_capturing_piece]])) {
			    true_capturing_piece = tb->next_identical_piece[true_capturing_piece];
			}

			propagate_local_position_from_futurebase(tb, dtm, 0,
								 futurecaptures[true_capturing_piece][true_captured_piece],
								 position, dtm_limit);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] += 8;
		}
	    }

	}

    }

    /* Put the capturing piece back where it came from (on the capture square) so that we can use
     * this local position again (on another call to this function) to consider other potential
     * capturing pieces without having to copy or recreate the entire local position structure.
     */


    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

}

void propagate_moves_from_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					     int invert_colors_of_futurebase, int captured_piece, int *dtm_limit)
{
    index_t future_index;
    int dtm;
    local_position_t current_position;
    int piece;
    int32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	dtm = fetch_next_DTM_from_disk(futurebase);

	/* Take the position from the futurebase and translate it into a local position for the
	 * current tablebase.  If the futurebase index was illegal, the function will return -1.
	 * Otherwise, there should be one piece missing from the local position: the piece that was
	 * captured.  There could possibly be one piece on a restricted square, as well.  If so,
	 * then it must be the piece that moved in order to capture.
	 */

	/* XXX If the futurebase is more liberal than the tablebase, then there will be positions
	 * with multiple restricted pieces that should be quietly ignored.
	 */

	conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
								      tb, &current_position,
								      invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((extra_piece != NONE) || (missing_piece1 != captured_piece) || (missing_piece2 != NONE)) {
		fprintf(stderr, "Conversion error during capture back-prop\n");  /* BREAKPOINT */
		continue;
	    }

	    /* Since the last move had to have been a capture move, there is absolutely no way we
	     * could have en passant capturable pawns in the futurebase position.
	     */

	    if (current_position.en_passant_square != -1) continue;

	    /* Since the position resulted from a capture, we only want to consider future positions
	     * where the side to move is not the side that captured.
	     */

	    if (current_position.side_to_move != tb->piece_color[captured_piece])
		continue;

	    /* We're going to back step a half move now */

	    flip_side_to_move_local(&current_position);

	    if (restricted_piece == NONE) {

		/* No pieces were on restricted squares.  Check them all. */

		for (piece = 0; piece < tb->num_pieces; piece++) {

		    consider_possible_captures(tb, dtm, &current_position,
					       piece, captured_piece, dtm_limit);
		}

	    } else {

		/* One piece was on a restricted square.  It's the only possible capturing piece. */

		consider_possible_captures(tb, dtm, &current_position,
					   restricted_piece, captured_piece, dtm_limit);

	    }

	}
    }
}

/* A "normal" futurebase is one that's identical to our own in terms of the number and types
 * of pieces.  It differs only in the frozen positions of the pieces.
 */

void propagate_moves_from_normal_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					    int invert_colors_of_futurebase, int *dtm_limit)
{
    index_t future_index;
    int dtm;
    int dtc;
    local_position_t parent_position;
    local_position_t current_position; /* i.e, last position that moved to parent_position */
    int32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int piece;
    int dir;
    struct movement *movementptr;
    int origin_square;

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* Translate the futurebase index into a local position.  We have exactly the same number
	 * and type of pieces here, but exactly one of them is on a restricted square (according to
	 * the current tablebase).  If more than one of them was on a restricted square, then
	 * there'd be no way we could get to this futurebase with a single move.  On the other hand,
	 * if none of them were on restricted squares, then this would be a position in the current
	 * tablebase.
	 */

	dtm = fetch_next_DTM_from_disk(futurebase);

	/* XXX have to fetch DTC as well */

	dtc = 0;

	/* XXX If the futurebase is more liberal than the tablebase, then there will be positions
	 * with multiple restricted pieces that should be quietly ignored.
	 */

	conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
								      tb, &current_position,
								      invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((missing_piece1 != NONE) || (extra_piece != NONE) || (restricted_piece == NONE)) {
		fprintf(stderr, "Conversion error during normal back-prop\n"); /* BREAKPOINT */
		continue;
	    }

	    piece = restricted_piece;

	    origin_square = current_position.piece_position[piece];

	    /* We've moving BACKWARDS in the game, so this has to be a piece of the player who is
	     * NOT TO PLAY here - this is the LAST move we're considering, not the next move.
	     */

	    if (tb->piece_color[piece] == current_position.side_to_move)
		continue;


	    /* If there are any en passant capturable pawns in the position, then the last move had
	     * to have been a pawn move.  In fact, in this case, we already know exactly what the
	     * last move had to have been.
	     */

	    if (current_position.en_passant_square != -1) {

		if (tb->piece_type[piece] != PAWN) continue;

		if (((tb->piece_color[piece] == WHITE)
		     && (current_position.piece_position[piece] != current_position.en_passant_square + 8))
		    || ((tb->piece_color[piece] == BLACK)
			&& (current_position.piece_position[piece] != current_position.en_passant_square - 8))) {

		    /* No reason to complain here.  Maybe some other pawn was the en passant pawn. */
		    continue;
		}

		flip_side_to_move_local(&current_position);
		current_position.en_passant_square = -1;

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);
		if (tb->piece_color[piece] == WHITE)
		    current_position.piece_position[piece] -= 16;
		else
		    current_position.piece_position[piece] += 16;

		current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		/* We never back out into a restricted position.  Since we've already decided
		 * that this is the only legal back-move from this point, well...
		 */

		if (! (tb->piece_legal_squares[piece]
		       & BITVECTOR(current_position.piece_position[piece]))) {
		    continue;
		}

		/* DTC is zero because this is a pawn move */

		propagate_local_position_from_futurebase(tb, dtm, 0,
							 futuremoves[piece][origin_square],
							 &current_position, dtm_limit);

		continue;

	    }

	    /* Abuse of notation here.  We just want to keep a copy of current_position because we
	     * change it around a lot during the loops below.
	     */

	    parent_position = current_position;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    /* What about captures?  Well, first of all, there are no captures here!  We're
		     * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		     * Captures are handled by back-propagation from futurebases, not here in the
		     * movement code.  The piece moving had to come from somewhere, and that
		     * somewhere will now be an empty square, so once we've hit another piece along
		     * a movement vector, there's absolutely no need to consider anything further.
		     */

		    for (movementptr
			     = movements[tb->piece_type[piece]][parent_position.piece_position[piece]][dir];
			 (movementptr->vector & parent_position.board_vector) == 0;
			 movementptr++) {

			/* We never back out into a restricted position (obviously) */

			if (! (tb->piece_legal_squares[piece] & movementptr->vector)) continue;

			/* Back stepping a half move here involves several things: flipping the
			 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
			 * the piece (backwards), and considering a bunch of additional positions
			 * identical to the base position except that a single one of the pawns on the
			 * fourth or fifth ranks was capturable en passant.
			 *
			 * Of course, the only way we could have gotten an en passant pawn is if THIS
			 * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
			 * additional en passant positions is taken care of in
			 * propagate_one_move_within_table()
			 */

			flip_side_to_move_local(&current_position);

			/* I go to the trouble to update board_vector here so we can check en passant
			 * legality in propagate_one_move_within_table().
			 */

			current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

			current_position.piece_position[piece] = movementptr->square;

			current_position.board_vector |= BITVECTOR(movementptr->square);

			propagate_local_position_from_futurebase(tb, dtm, dtc,
								 futuremoves[piece][origin_square],
								 &current_position, dtm_limit);
		    }
		}

	    } else {

		/* Usual special case for pawns */

		for (movementptr = normal_pawn_movements_bkwd[parent_position.piece_position[piece]][tb->piece_color[piece]];
		     (movementptr->vector & parent_position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->piece_legal_squares[piece] & movementptr->vector)) continue;

		    /* Do we have a backwards pawn move here?
		     *
		     * Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		     * created it.  We handle that as a special case above, so we shouldn't have to
		     * worry about clearing en passant pawns here - there should be none.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     *
		     * But we start with an extra check to make sure this isn't a double pawn move, it
		     * which case it would result in an en passant position, not the non-en passant
		     * position we are in now (en passant got taken care of in the special case above).
		     */

		    if (((movementptr->square - parent_position.piece_position[piece]) == 16)
			|| ((movementptr->square - parent_position.piece_position[piece]) == -16)) {
			continue;
		    }

		    current_position = parent_position;

		    flip_side_to_move_local(&current_position);

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

		    current_position.piece_position[piece] = movementptr->square;

		    current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		    propagate_local_position_from_futurebase(tb, dtm, 0,
							     futuremoves[piece][origin_square],
							     &current_position, dtm_limit);

		}
	    }
	}
    }
}

/* compute_extra_and_missing_piece()
 *
 * See comments for translate_foreign_position_to_local_position(), since this function mimicks that
 * one, except that this function works on an entire tablebase, while the other one works on a
 * single position within the tablebase.
 */

boolean compute_extra_and_missing_pieces(tablebase_t *tb, tablebase_t *futurebase, char *filename)
{
    int piece;
    int future_piece;
    int piece_vector;
    int color;

    futurebase->extra_piece = -1;
    futurebase->missing_pawn = -1;
    futurebase->missing_non_pawn = -1;

    /* Check futurebase to make sure its move restriction(s) match our own */

    for (color = 0; color < 2; color ++) {
	if ((futurebase->move_restrictions[color] != RESTRICTION_NONE)
	    && (futurebase->move_restrictions[color]
		!= tb->move_restrictions[futurebase->invert_colors ? 1 - color : color])) {
	    fprintf(stderr, "'%s': Futurebase doesn't match move restrictions!\n", filename);
	    return 0;
	}
    }

    /* The futurebase can have different pieces than the current tablebase.  There can be a single
     * extra piece, as well as a missing pawn and/or a missing non-pawn.  Find them.
     */

    /* piece_vector - set a bit for every piece in current tablebase */
    piece_vector = (1 << tb->num_pieces) - 1;

    for (future_piece = 0; future_piece < futurebase->num_pieces; future_piece ++) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (! (piece_vector & (1 << piece))) continue;
	    if ((tb->piece_type[piece] == futurebase->piece_type[future_piece])
		&& ((!futurebase->invert_colors &&
		     (tb->piece_color[piece] == futurebase->piece_color[future_piece]))
		    || (futurebase->invert_colors &&
			(tb->piece_color[piece] != futurebase->piece_color[future_piece])))) {
		if ((tb->piece_legal_squares[piece] & futurebase->piece_legal_squares[future_piece])
		    != tb->piece_legal_squares[piece]) {
		    /* This can be OK if we have piece and/or move restrictions in effect */
		    /* fprintf(stderr, "WARNING: matched a piece but futurebase is more restrictive\n"); */
		    piece_vector ^= (1 << piece);
		    break;
		} else {
		    piece_vector ^= (1 << piece);
		    break;
		}
	    }
	}
	if (piece == tb->num_pieces) {
	    if ((futurebase->extra_piece == -1) && (futurebase->piece_type[future_piece] != PAWN)) {
		futurebase->extra_piece = future_piece;
	    } else {
		fprintf(stderr, "'%s': Couldn't find future piece in tablebase\n", filename);
		return 0;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] != PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_non_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    if (piece_vector != 0) {
	fprintf(stderr, "'%s': Too many missing pieces in futurebase\n", filename);
	return 0;
    }

    return 1;
}

/* Back propagates from all the futurebases.
 *
 * Should be called after the tablebase has been initialized, but before intra-table propagation.
 *
 * Runs through the parsed XML control file, pulls out all the futurebases, and back-propagates each
 * one.
 *
 * Returns maximum mate_in value, or -1 if something went wrong
 */

int back_propagate_all_futurebases(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int dtm_limit = 0;

    /* Fetch the futurebases from the XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression((const xmlChar *) "//futurebase", context);
    if ((tb->num_pieces > 2) && xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fprintf(stderr, "No futurebases!\n");
    } else {
	int i;

	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * filename;
	    xmlChar * type;
	    xmlChar * colors_property;
	    tablebase_t * futurebase;
	    int piece;

	    filename = xmlGetProp(result->nodesetval->nodeTab[i], (const xmlChar *) "filename");

	    futurebase = preload_futurebase_from_file((char *) filename);

	    /* load_futurebase_from_file() already printed some kind of error message */
	    if (futurebase == NULL) return -1;

	    futurebase->invert_colors = 0;
	    colors_property = xmlGetProp(result->nodesetval->nodeTab[i], (const xmlChar *) "colors");
	    if (colors_property != NULL) {
		if (!strcasecmp((char *) colors_property, "invert")) futurebase->invert_colors = 1;
		xmlFree(colors_property);
	    }

	    if (! compute_extra_and_missing_pieces(tb, futurebase, (char *) filename)) return -1;

	    /* Various combinations of missing/extra pieces are legal for different futurebase
	     * types.
	     */

	    type = xmlGetProp(result->nodesetval->nodeTab[i], (const xmlChar *) "type");

	    if ((type != NULL) && !strcasecmp((char *) type, "capture")) {

		/* It's a capture futurebase.  Futurebase should have exactly one less piece than
		 * the current tablebase.
		 */

		if (futurebase->extra_piece != -1) {
		    fprintf(stderr, "'%s': Extra piece in capture futurebase\n", filename);
		    return -1;
		}

		if ((futurebase->missing_pawn != -1) && (futurebase->missing_non_pawn != -1)) {
		    fprintf(stderr, "'%s': Too many missing pieces in capture futurebase\n", filename);
		}

		if ((futurebase->missing_pawn == -1) && (futurebase->missing_non_pawn == -1)) {
		    fprintf(stderr, "'%s': No missing pieces in capture futurebase\n", filename);
		}

		piece = (futurebase->missing_pawn != -1)
		    ? futurebase->missing_pawn : futurebase->missing_non_pawn;

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_capture_futurebase(tb, futurebase, futurebase->invert_colors, piece, &dtm_limit);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "promotion")) {

		/* It's a promotion futurebase.  Futurebase should have exactly the same number of
		 * pieces as the current tablebase, and one of our pawns should have promoted into
		 * something else.  Determine what the pawn promoted into.
		 */

		if (futurebase->extra_piece == -1) {
		    fprintf(stderr, "'%s': No extra piece in promotion futurebase\n", filename);
		    return -1;
		}

		if (futurebase->missing_non_pawn != -1) {
		    fprintf(stderr, "'%s': Missing non-pawn in promotion futurebase\n", filename);
		}

		if (futurebase->missing_pawn == -1) {
		    fprintf(stderr, "'%s': No missing pawn in promotion futurebase\n", filename);
		}

		/* Ready to go. */

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_promotion_futurebase(tb, futurebase, futurebase->invert_colors,
							  futurebase->missing_pawn, &dtm_limit);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "promotion-capture")) {

		/* It's a promotion capture futurebase.  Futurebase should have exactly one less
		 * piece than the current tablebase, and one of our pawns should have promoted into
		 * something else.
		 */

		if (futurebase->extra_piece == -1) {
		    fprintf(stderr, "'%s': No extra piece in promotion capture futurebase\n", filename);
		    return -1;
		}

		if (futurebase->missing_non_pawn == -1) {
		    fprintf(stderr, "'%s': No missing non-pawn in promotion capture futurebase\n", filename);
		}

		if (futurebase->missing_pawn == -1) {
		    fprintf(stderr, "'%s': No missing pawn in promotion capture futurebase\n", filename);
		}


		/* Ready to go. */

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_promotion_capture_futurebase(tb, futurebase, futurebase->invert_colors,
								  futurebase->missing_pawn,
								  &dtm_limit);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "normal")) {

		if (futurebase->extra_piece != -1) {
		    fprintf(stderr, "'%s': Extra piece in normal futurebase\n", filename);
		    return -1;
		}

		if ((futurebase->missing_pawn != -1) || (futurebase->missing_non_pawn != -1)) {
		    fprintf(stderr, "'%s': Missing pieces in normal futurebase\n", filename);
		}

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_normal_futurebase(tb, futurebase, futurebase->invert_colors, &dtm_limit);

	    } else {

		fprintf(stderr, "'%s': Unknown back propagation type (%s)\n",
			(char *) filename, (char *) type);
		return -1;

	    }

	    unload_futurebase(futurebase);
	}
    }

    xmlXPathFreeContext(context);

    return dtm_limit;

}

/***** PRUNING *****/

/* If we don't want to fully analyze out the tree past the table we're now building, we prune some
 * possible futuremoves.  Of course, this will affect the accuracy of the table; the table is a
 * result of BOTH the position it was set up for AND the pruning decisions (and any pruning
 * decisions made on the futurebases used to calculate this one).
 *
 * We specify pruning in a simple way - by omitting future tables for moves we don't want to
 * consider.  This can be dangerous, so we require this feature to be specifically enabled.  Right
 * now, there are two possibilities we can specify in the XML control file; one to allow moves to be
 * DISCARDED; the other to allow victory to be CONCEDED to the side that makes the move.
 *
 * So, if we are white, and assuming that this is a table with a frozen white pawn on e3, we can
 * prune by simply ignoring Pe4 as a possible move.  If there is a black pawn on the g-file, and we
 * don't want to compute out what happens after it queens, we can prune by treating Pg1=X as a forced
 * win for black.
 *
 * We might want to "partially" prune a move like Pg1=X by looking a half-move into the future to
 * see if we can immediately take the new piece and simplify that way.  To do so, we would construct
 * a futurebase for the piece combination resulting after Pg1=X, probably leaving X frozen on g1,
 * make one pass through that futurebase (this is currently unimplemented) and flag everything else
 * a win for black.  This approach avoids having to step a half-move into the future during back
 * propagation.  The advantages of this are three-fold.  First, it simplifies the program, and
 * that's a big plus from a quality control standpoint.  Second, it avoids the random accesses that
 * would be required to probe into the tablebase, replacing them with a series of sequential sweeps,
 * and for a big tablebase that's probably a significant performance win.  Finally, it's a lot more
 * flexible.  We can make two, or three, or five sweeps through that tablebase, looking a few more
 * moves into the future for forced reductions.
 *
 * For example, let's say we're looking at a Q-and-P vs. Q-and-P endgame.  There are four completely
 * mobile pieces (2 Ks and 2 Qs), and this is easy.  But if one of the pawns queens, then we've got
 * a more complex game with five mobile pieces, and that's too complex.  But we don't want to
 * completely discard all possible enemy promotions, if we can immediately capture the new queen (or
 * the old one).  So we construct a special tablebase for a queen frozen on the queening square,
 * back prop a tablebase for a Q-and-P vs. Q endgame into it, make a pass or two through it, then
 * feed it into our current tablebase.
 *
 * And finally, we want to label in the file header that this pruning was done.  In particular, if
 * we use a pruned tablebase to compute another (earlier) pruned tablebase, we want to make sure the
 * pruning is consistent, i.e. "our" side has to stay the same.  This is guaranteed by explicitly
 * flagging in the XML header which sides can be pruned in which way (concede or discard).
 */

int all_futuremoves_handled = 1;
int max_complaints = 10;
futurevector_t unpruned_futuremoves;

void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector) {

    int futuremove;

    if (futurevector & unpruned_futuremoves) {
	global_position_t global;
	index_to_global_position(tb, index, &global);
	if (all_futuremoves_handled)
	    fprintf(stderr, "ERROR: Some futuremoves not handled under move restrictions!\n");
	fprintf(stderr, "%s", global_position_to_FEN(&global));
	for (futuremove = 0; futuremove < num_futuremoves; futuremove ++) {
	    if (futurevector & unpruned_futuremoves & FUTUREVECTOR(futuremove)) {
		fprintf(stderr, " %s", movestr[futuremove]);
	    }
	}
	fprintf(stderr, "\n");
	if ((-- max_complaints) == 0) exit(EXIT_FAILURE);
	all_futuremoves_handled = 0;		/* BREAKPOINT */
    }

    /* concede - we treat these unhandled futuremoves as forced wins for PTM */

    if (futurevector & conceded_futuremoves) {
	/* PTM_wins(tb, index, 1, 1); */
	/* We insert here with DTM=2 (mate in one) and DTC=1 (XXX) */
	insert_into_proptable(index, 2, 1, 0);
    }

    /* discard - we ignore these unhandled futuremoves by decrementing movecnt */

    if (futurevector & discarded_futuremoves) {
	for (futuremove = 0; futuremove < num_futuremoves; futuremove ++) {
	    if (futurevector & discarded_futuremoves & FUTUREVECTOR(futuremove)) {
		/* tb->entries[index].movecnt --; */
		/* XXX this isn't handled right - a draw is different from a discard */
		insert_into_proptable(index, 0, 0, 0);
	    }
	}
    }
}

boolean have_all_futuremoves_been_handled(tablebase_t *tb) {

    index_t index;

    for (index = 0; index <= tb->max_index; index ++) {
	finalize_futuremove(tb, index, tb->futurevectors[index]);
    }

    return all_futuremoves_handled;
}

/* assign_numbers_to_futuremoves()
 *
 * We could just dismiss any moves that aren't handled by our futurebases, but I've found this to be
 * a source of error, since moves tend to get overlooked this way.  We're also concerned with the
 * more sobering possibility of a single move getting processed twice.
 *
 * So we assign numbers, bit positions in a bit vector, actually, to each futuremove.  When we
 * initialize the tablebase, we set bits in the vector (each position has its own vector) for each
 * futuremove possible from that position.  As we back propagate futuremoves, we check the bit to
 * make sure it's still set, then clear it.  After we've back propagated all the futurebases, we run
 * through the entire tablebase, making sure that the only bits that remain set correspond to prune
 * statements.
 */

void assign_numbers_to_futuremoves(tablebase_t *tb) {

    int64 frozen_vector = 0LL;
    int piece;
    int captured_piece;
    int capturing_piece;
    int sq;
    int dir;
    struct movement *movementptr;


    /* First, compute a bitvector for all the pieces that are frozen on single squares. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (sq = 0; sq < 64; sq ++) {
	    if (BITVECTOR(sq) == tb->piece_legal_squares[piece]) {
		frozen_vector |= tb->piece_legal_squares[piece];
		break;
	    }
	}
    }

    /* Next, consider all possible pairs of pieces that might capture, and assign a number (in the
     * futurecaptures array) to each pair.  We'll ultimately use this number as an index into a bit
     * vector to determine if this capture has been handled in any particular position.  However,
     * there's a common enough "special" case: the two pieces are frozen (or at least sufficiently
     * restricted) so that the capture can never occur.  Go to the trouble of checking for this.
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    futurecaptures[capturing_piece][captured_piece] = -1;

	    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) continue;

	    /* We run through the board either from end to start (if the capturing piece is white)
	     * or from start to end (if it's black) in order to make sure that pawn captures that
	     * result in promotions are considered before any other pawn captures, since promotion
	     * captures are treated as multiple moves, not just one.
	     */

	    for (sq = (tb->piece_color[capturing_piece] == WHITE ? 63 : 0);
		 tb->piece_color[capturing_piece] == WHITE ? (sq >= 0) : (sq <= 63);
		 tb->piece_color[capturing_piece] == WHITE ? sq-- : sq++) {

		if (tb->piece_legal_squares[capturing_piece] & BITVECTOR(sq)) {
		    if (tb->piece_type[capturing_piece] != PAWN) {
			for (dir = 0; dir < number_of_movement_directions[tb->piece_type[capturing_piece]]; dir++) {
			    for (movementptr = movements[tb->piece_type[capturing_piece]][sq][dir];
				 movementptr->square != -1; movementptr++) {
				if (movementptr->vector & tb->piece_legal_squares[captured_piece]) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
				/* If we hit a frozen piece, then this movement direction ends here */
				if (movementptr->vector & frozen_vector) break;
			    }
			}
		    } else {
			for (movementptr = capture_pawn_movements[sq][tb->piece_color[capturing_piece]];
			     movementptr->square != -1; movementptr++) {

			    if (movementptr->vector & tb->piece_legal_squares[captured_piece]) {

				futurecaptures[capturing_piece][captured_piece] = num_futuremoves;

				/* a pawn capture that results in promotion - PROMOTION_POSSIBILTIES moves */

				if ((ROW(movementptr->square) == 0) || (ROW(movementptr->square) == 7)) {
				    num_futuremoves += PROMOTION_POSSIBILITIES;
				} else {
				    num_futuremoves ++;
				}
				goto next_pair_of_pieces;
			    }

			    /* if it's a pawn-takes-pawn situation, check for en passant as well */

			    if (tb->piece_type[captured_piece] == PAWN) {

				if ((tb->piece_type[capturing_piece] == WHITE) && (ROW(sq) == 4)
				    && (tb->piece_legal_squares[captured_piece]
					& BITVECTOR(movementptr->square - 8))) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
				if ((tb->piece_type[capturing_piece] == BLACK) && (ROW(sq) == 3)
				    && (tb->piece_legal_squares[captured_piece]
					& BITVECTOR(movementptr->square + 8))) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
			    }

			}
		    }
		}
	    }
	next_pair_of_pieces: ;
	}
    }

    /* We also want to consider all promotions.  We don't wrap this into the pawn code that follows
     * because we want to count all promotions together, not a set for each destination square.
     * This is a special case of a more general problem that this code doesn't address yet.  We want
     * to minimize the assigned numbers to keep the futuremove bit vector small, so we want to reuse
     * those numbers if we're sure that two moves can't happen from different squares.  I.e, if a
     * king is restricted to the f1/h3 rectangle, then it can move to e1 from f1 and it can move to
     * h4 from h3, but there is no single position from which it can move to both e1 and h4.  So we
     * can use the same position in the bit vector for Ke1 and Kh4.  But we don't (yet).
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	promotions[piece] = -1;
	if (tb->piece_type[piece] == PAWN) {
	    for (sq = (tb->piece_color[piece] == WHITE ? 48 : 8);
		 sq <= (tb->piece_color[piece] == WHITE ? 55 : 15); sq++) {
		if (tb->piece_legal_squares[piece] & BITVECTOR(sq)) {
		    promotions[piece] = num_futuremoves;
		    num_futuremoves += PROMOTION_POSSIBILITIES;
		    break;
		}
	    }
	}
    }

    /* And now all piece moves outside their restriction.  We record a futuremove for each possible
     * destination square that the piece can reach outside its move restriction.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	for (sq = 0; sq < 64; sq ++) futuremoves[piece][sq] = -1;

	for (sq = 0; sq < 64; sq ++) {

	    if (! (tb->piece_legal_squares[piece] & BITVECTOR(sq))) continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			 movementptr->square != -1; movementptr++) {

			/* If we hit a frozen piece, movement has to stop.  We don't consider
			 * captures here; they were handled above.
			 */

			if (movementptr->vector & frozen_vector) break;

			/* If the piece is moving outside its restricted squares, it's a futuremove */

			if (!(tb->piece_legal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square] = num_futuremoves;
				num_futuremoves ++;
			    }
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[sq][tb->piece_color[piece]];
		     movementptr->square != -1; movementptr++) {

		    /* If we hit a frozen piece, movement has to stop.  We don't consider captures
		     * here; they were handled above.
		     */

		    if (movementptr->vector & frozen_vector) break;

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			/* might want to put the promotion code here */

		    } else {

			/* If the pawn is moving outside its restricted squares, it's a futuremove */

			if (!(tb->piece_legal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square] = num_futuremoves;
				num_futuremoves ++;
			    }
			}
		    }
		}
	    }
	}
    }

    fprintf(stderr, "%d possible futuremoves\n", num_futuremoves);
    if (num_futuremoves > (sizeof(futurevector_t)*8)) {
	fprintf(stderr, "Too many!  (%d max)\n", sizeof(futurevector_t)*8);
	exit(EXIT_FAILURE);
    }
}

/* assign_pruning_statement() - a helper function for compute_pruned_futuremoves()
 *
 * searches the tablebase's XML pruning statements for one matching (more or less identically) the
 * specified color and string.  If there is a match, set the corresponding bit in the
 * pruned_futuremoves bit vector.  The function can be called more than once for a given bit.  For
 * example, the function might be called on the same bit for both "Pf6" and "Pany" (assuming there
 * is a white pawn frozen on f5).  If there are multiple prune statements that match a given bit, it
 * is currently undefined what happens, so we print an error message.
 */

void assign_pruning_statement(tablebase_t *tb, int color, char *pruning_statement, int futuremove)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int type;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression((const xmlChar *) "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   (const xmlChar *) "color");
	xmlChar * prune_move = xmlGetProp(result->nodesetval->nodeTab[prune],
					  (const xmlChar *) "move");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  (const xmlChar *) "type");

	if (find_name_in_array((char *) prune_color, colors) != color) continue;

	type = find_name_in_array((char *) prune_type, restriction_types);

	if (!strcasecmp((char *) prune_move, pruning_statement)) break;
    }

    if (prune != result->nodesetval->nodeNr) {
	if (pruned_futuremoves & FUTUREVECTOR(futuremove)) {
	    fprintf(stderr, "WARNING: Multiple pruning statements ('%s') match a futuremove\n",
		    pruning_statement);
	}
	pruned_futuremoves |= FUTUREVECTOR(futuremove);
	if (type == RESTRICTION_CONCEDE) {
	    conceded_futuremoves |= FUTUREVECTOR(futuremove);
	}
	if (type == RESTRICTION_DISCARD) {
	    discarded_futuremoves |= FUTUREVECTOR(futuremove);
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);
}

/* This is where we parse pruning statements.  Fill in the pruned_futuremoves bit vector with bits
 * set for the various pruned moves.
 */

void compute_pruned_futuremoves(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int i;
    char movestr2[16];


    /* Check pruning statements for consistency */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression((const xmlChar *) "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   (const xmlChar *) "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  (const xmlChar *) "type");
	int color = find_name_in_array((char *) prune_color, colors);
	int type = find_name_in_array((char *) prune_type, restriction_types);

	if (type != tb->move_restrictions[color]) {
	    fprintf(stderr, "Pruning restrictions don't match tablebase restrictions\n");
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* for each possible captured_piece (i.e, everything but the two kings in piece numbers 0 and 1)
     * check for capture futurebases
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    if (futurecaptures[capturing_piece][captured_piece] != -1) {

		sprintf(movestr[futurecaptures[capturing_piece][captured_piece]], "%cx%c",
			piece_char[tb->piece_type[capturing_piece]],
			piece_char[tb->piece_type[captured_piece]]);

		assign_pruning_statement(tb, tb->piece_color[capturing_piece],
					 movestr[futurecaptures[capturing_piece][captured_piece]],
					 futurecaptures[capturing_piece][captured_piece]);
	    }
	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	if (tb->piece_type[pawn] != PAWN) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->piece_legal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->piece_legal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->piece_legal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->piece_legal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    if (futurecaptures[pawn][captured_piece] == -1) continue;

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		sprintf(movestr[futurecaptures[pawn][captured_piece] + i], "Px%c=%c",
			piece_char[tb->piece_type[captured_piece]],
			piece_char[promoted_pieces[i]]);

		assign_pruning_statement(tb, tb->piece_color[pawn],
					 movestr[futurecaptures[pawn][captured_piece] + i],
					 futurecaptures[pawn][captured_piece] + i);
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    sprintf(movestr[promotions[pawn] + i], "P=%c", piece_char[promoted_pieces[i]]);

	    assign_pruning_statement(tb, tb->piece_color[pawn], movestr[promotions[pawn] + i],
				     promotions[pawn] + i);
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (sq = 0; sq < 64; sq ++) {
	    if (futuremoves[piece][sq] != -1) {

		sprintf(movestr[futuremoves[piece][sq]], "%c%c%c", piece_char[tb->piece_type[piece]],
			'a' + COL(sq), '1' + ROW(sq));
		sprintf(movestr2, "%cany", piece_char[tb->piece_type[piece]]);

		assign_pruning_statement(tb, tb->piece_color[piece], movestr[futuremoves[piece][sq]],
					 futuremoves[piece][sq]);
		assign_pruning_statement(tb, tb->piece_color[piece], movestr2, futuremoves[piece][sq]);
	    }
	}
    }

    unpruned_futuremoves = ~pruned_futuremoves;
}


/* check_pruning()
 *
 * We run this function after we've assigned numbers to the futuremoves, but before we initialize
 * the tablebase.
 *
 * Check the futurebases to see if there are any for a given futuremove.  If not, check to make sure
 * the futuremove is pruned.  Otherwise, signal an error and exit right now.  Just because this test
 * is passed doesn't mean a particular futuremove is handled in a particular position (that's why we
 * use the bit vector), but if the test fails, well, then we know (almost) for sure that we'd get to
 * the end of program with unhandled futurebases, so we can save ourselves a long computation by
 * making this basic check now.
 *
 * There is an off chance that piece restrictions will prevent a futuremove from taking place, but
 * this code will conclude nevertheless that it is possible and demand either a prune statement or a
 * futurebase.  In this rare case, introducing an extraneous prune statement or two should solve the
 * problem.
 */

boolean check_pruning(tablebase_t *tb) {

    tablebase_t **futurebases;
    int num_futurebases;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int fbnum;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int futurebase_cnt;
    int i;


    /* First, preload all futurebases */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression((const xmlChar *) "//futurebase", context);
    num_futurebases = result->nodesetval->nodeNr;
    futurebases = malloc(sizeof(tablebase_t *) * num_futurebases);
    if (futurebases == NULL) {
	fprintf(stderr, "Can't malloc futurebases array\n");
	return 0;
    }

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	xmlChar * filename;
	xmlChar * colors_property;

	filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], (const xmlChar *) "filename");
	futurebases[fbnum] = preload_futurebase_from_file((char *) filename);

	/* load_futurebase_from_file() already printed some kind of error message */
	if (futurebases[fbnum] == NULL) return 0;

	futurebases[fbnum]->invert_colors = 0;
	colors_property = xmlGetProp(result->nodesetval->nodeTab[fbnum], (const xmlChar *) "colors");
	if (colors_property != NULL) {
	    if (!strcasecmp((char *) colors_property, "invert")) futurebases[fbnum]->invert_colors = 1;
	    xmlFree(colors_property);
	}

	compute_extra_and_missing_pieces(tb, futurebases[fbnum], (char *)filename);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* for each possible captured_piece (i.e, everything but the two kings in piece numbers 0 and 1)
     * check for capture futurebases
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	futurebase_cnt = 0;

	/* If we've going to consider a captured piece identical to this one, skip it.  Remember
	 * that compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to skip
	 * everything before it.
	 */
	if (tb->next_identical_piece[captured_piece] != -1) continue;

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if (tb->piece_type[captured_piece] == PAWN) {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
	    } else {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_non_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_pawn == -1)) futurebase_cnt ++;
	    }
	}

	/* If no such futurebase exists, then for every other piece, see if the piece restrictions
	 * would permit it to capture the original piece in question.  If so, there must be a prune
	 * statement, or it's an error.
	 */

	if (futurebase_cnt == 0) {

	    for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

		/* If we've going to consider a capturing piece identical to this one, skip it.
		 * Again, compute_extra_and_missing_pieces() uses the LAST identical piece, so we
		 * want to skip everything before it.
		 */
		if (tb->next_identical_piece[capturing_piece] != -1) continue;

		if (futurecaptures[capturing_piece][captured_piece] != -1) {

		    if (! (pruned_futuremoves & (1 << futurecaptures[capturing_piece][captured_piece]))) {
			fprintf(stderr, "No futurebase or pruning for %s move %s\n",
				colors[tb->piece_color[capturing_piece]],
				movestr[futurecaptures[capturing_piece][captured_piece]]);
			return 0;
		    }
		}
	    }

	} else if (futurebase_cnt > 1) {

	    /* Otherwise, a futurebase matched the capture.  Did more than one?  This is an error
	     * because then we might have two futurebases that would back prop into the same
	     * position with the same move.  Since we determine PNTM mates by counting down moves,
	     * this could result in the same move getting counted down twice.  We deal with this by
	     * making sure that only one futurebase of any given piece combo can exist.
	     *
	     * Once we get the bitvector working, we'll be able to make this check during
	     * move back propagation and won't need this code anymore.
	     */

	    fprintf(stderr, "Multiple futurebases for capturing %s's %s\n",
		    colors[tb->piece_color[captured_piece]],
		    piece_name[tb->piece_type[captured_piece]]);
	    return 0;

	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	int promoted_pieces_handled;

	if (tb->piece_type[pawn] != PAWN) continue;

	/* Again, compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to
	 * skip everything before it.
	 */

	if (tb->next_identical_piece[pawn] != -1) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	    /* If we've going to consider a captured piece identical to this one, skip it.  Again,
	     * compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to skip
	     * everything before it.
	     */

	    if (tb->next_identical_piece[captured_piece] != -1) continue;

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->piece_legal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->piece_legal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->piece_legal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->piece_legal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    promoted_pieces_handled = 0;

	    if (futurecaptures[pawn][captured_piece] == -1) continue;

	    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
		if ((futurebases[fbnum]->extra_piece != -1)
		    && (futurebases[fbnum]->missing_non_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_pawn == pawn)) {
		    if (promoted_pieces_handled
			& (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece])) {
			fprintf(stderr, "Multiple promotion capture futurebases for %s's Px%c=%c\n",
				colors[tb->piece_color[pawn]],
				piece_char[tb->piece_type[futurebases[fbnum]->missing_non_pawn]],
				piece_char[futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]]);
			return 0;
		    }
		    promoted_pieces_handled
			|= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);
		}
	    }

	    /* If no such futurebase exists, then for every other piece, see if the piece
	     * restrictions would permit it to capture the original piece in question.  If so, there
	     * must be a prune statement, or it's an error.
	     */

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		if (promoted_pieces_handled & (1 << promoted_pieces[i])) break;

		if (! (pruned_futuremoves & (1 << (futurecaptures[pawn][captured_piece] + i)))) {
		    fprintf(stderr, "No futurebase or pruning for %s move %s\n",
			    colors[tb->piece_color[pawn]],
			    movestr[futurecaptures[pawn][captured_piece] + i]);
		    return 0;
		}
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	promoted_pieces_handled = 0;

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if ((futurebases[fbnum]->extra_piece != -1)
		&& (futurebases[fbnum]->missing_non_pawn == -1)
		&& (futurebases[fbnum]->missing_pawn == pawn)) {
		if (promoted_pieces_handled
		    & (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece])) {
		    fprintf(stderr, "Multiple promotion futurebases for %s's P=%c\n",
			    colors[tb->piece_color[pawn]],
			    piece_char[futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]]);
		    return 0;
		}
		promoted_pieces_handled
		    |= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);
	    }
	}

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    if (promoted_pieces_handled & (1 << promoted_pieces[i])) break;

	    if (! (pruned_futuremoves & (1 << (promotions[pawn] + i)))) {

		fprintf(stderr, "No futurebase or pruning for %s move %s\n",
			colors[tb->piece_color[pawn]], movestr[promotions[pawn] + i]);
		return 0;
	    }
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    futurebase_cnt = 0;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	if ((futurebases[fbnum]->extra_piece == -1)
	    && (futurebases[fbnum]->missing_pawn == -1)
	    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
    }

    if (futurebase_cnt == 0) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (sq = 0; sq < 64; sq ++) {
		if (futuremoves[piece][sq] != -1) {

		    if (! (pruned_futuremoves & (1 << (futuremoves[piece][sq])))) {
			fprintf(stderr, "No futurebase or pruning for %s move %s\n",
				colors[tb->piece_color[piece]], movestr[futuremoves[piece][sq]]);
			return 0;
		    }
		}
	    }
	}
    } else if (futurebase_cnt > 1) {
	fprintf(stderr, "Multiple futurebases for restricted moves\n");
	return 0;
    }

    /* Unload the futurebases (for now; we'll need them again later) */

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	unload_futurebase(futurebases[fbnum]);
    }

    return 1;
}


/***** INTRA-TABLE MOVE PROPAGATION *****/

/* We've got a move that needs to be propagated, so we back out one half-move to all of the
 * positions that could have gotten us here and update their counters in various obscure ways.
 */

void propagate_one_minimove_within_table(tablebase_t *tb, int dtm, int dtc, local_position_t *current_position)
{
    index_t current_index;

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup position in intratable propagation!\n");  /* BREAKPOINT */
	return;
    }

#ifdef DEBUG_MOVE
    if (current_index == DEBUG_MOVE)
	printf("propagate_one_minimove_within_table:  current_index=%d; dtm=%d\n", current_index, dtm);
#endif

    /* Parent position is the FUTURE position.  We now back-propagate to
     * the current position, which is the PAST position.
     *
     * If the player to move in the FUTURE position wins, then we add one to that
     * player's win count in the PAST position.  On other other hand, if the player not
     * to move in the FUTURE position wins, then the player to move in the PAST position
     * has a winning move (the one we're considering).
     *
     * These stalemate and mate counts increment by one every HALF MOVE.
     */

    if (dtm > 0) {
	insert_into_proptable(current_index, -dtm, dtc, 0);
    } else if ((dtm < 0) && (dtc < STALEMATE_COUNT)) {
	insert_into_proptable(current_index, -dtm+1, dtc+1, 0);
    }

}

void propagate_one_move_within_table(tablebase_t *tb, int dtm, int dtc, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_one_minimove_within_table(tb, dtm, dtc, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I've taken care to update board_vector in the routine that calls here specifically so
	     * we can check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_one_minimove_within_table(tb, dtm, dtc, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_one_minimove_within_table(tb, dtm, dtc, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* back_propagate_index_within_table()
 *
 * Once the final status of an index has been determined, this function back propagates all moves
 * (within the tablebase) from the corresponding position.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int dtm, int dtc)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    index_to_local_position(tb, index, &position);

    flip_side_to_move_local(&position);

    /* If there are any en passant capturable pawns in the position, then the last move had to
     * have been a pawn move.  In fact, in this case, we already know exactly what the last move
     * had to have been.
     */

    if (position.en_passant_square != -1) {

	int en_passant_pawn = -1;

	for (piece = 0; piece < tb->num_pieces; piece++) {

	    if (tb->piece_color[piece] != position.side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    if (((tb->piece_color[piece] == WHITE)
		 && (position.piece_position[piece] - 8 == position.en_passant_square))
		|| ((tb->piece_color[piece] == BLACK)
		    && (position.piece_position[piece] + 8 == position.en_passant_square))) {
		if (en_passant_pawn != -1) fprintf(stderr, "Two en passant pawns in back prop?!\n");
		en_passant_pawn = piece;
	    }
	}
	if (en_passant_pawn == -1) {
	    fprintf(stderr, "No en passant pawn in back prop!?\n");
	} else {

	    position.en_passant_square = -1;

	    /* I go to the trouble to update board_vector here so we can check en passant
	     * legality in propagate_one_move_within_table().
	     */

	    position.board_vector &= ~BITVECTOR(position.piece_position[en_passant_pawn]);

	    if (tb->piece_color[en_passant_pawn] == WHITE)
		position.piece_position[en_passant_pawn] -= 16;
	    else
		position.piece_position[en_passant_pawn] += 16;

	    position.board_vector |= BITVECTOR(position.piece_position[en_passant_pawn]);

	    /* We never back out into a restricted position.  Since we've already decided that this
	     * is the only legal back-move from this point, well...
	     */

	    if (! (tb->piece_legal_squares[en_passant_pawn]
		   & BITVECTOR(position.piece_position[en_passant_pawn]))) {
		return;
	    }

	    propagate_one_move_within_table(tb, dtm, dtc, &position);
	}

	return;
    }

    /* foreach (mobile piece of player NOT TO PLAY) { */

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We've moving BACKWARDS in the game, so we want the pieces of the player who is NOT TO
	 * PLAY here - this is the LAST move we're considering, not the next move.
	 */

	if (tb->piece_color[piece] != position.side_to_move)
	    continue;

	origin_square = position.piece_position[piece];

	position.board_vector &= ~BITVECTOR(origin_square);

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		/* What about captures?  Well, first of all, there are no captures here!  We're
		 * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		 * Captures are handled by back-propagation from futurebases, not here in the
		 * movement code.  The piece moving had to come from somewhere, and that somewhere
		 * will now be an empty square, so once we've hit another piece along a movement
		 * vector, there's absolutely no need to consider anything further.
		 */

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->piece_legal_squares[piece] & movementptr->vector)) continue;

		    /* Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS
		     * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     */

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    position.piece_position[piece] = movementptr->square;

		    position.board_vector |= BITVECTOR(movementptr->square);

		    propagate_one_move_within_table(tb, dtm, dtc, &position);

		    position.board_vector &= ~BITVECTOR(movementptr->square);
		}
	    }

	} else {

	    /* Usual special case for pawns */

	    for (movementptr = normal_pawn_movements_bkwd[origin_square][tb->piece_color[piece]];
		 (movementptr->vector & position.board_vector) == 0;
		 movementptr++) {

		/* We never back out into a restricted position (obviously) */

		if (! (tb->piece_legal_squares[piece] & movementptr->vector)) continue;

		/* Do we have a backwards pawn move here?
		 *
		 * Back stepping a half move here involves several things: flipping the
		 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		 * the piece (backwards), and considering a bunch of additional positions
		 * identical to the base position except that a single one of the pawns on the
		 * fourth or fifth ranks was capturable en passant.
		 *
		 * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		 * created it.  We handle that as a special case above, so we shouldn't have to
		 * worry about clearing en passant pawns here - there should be none.  Checking
		 * additional en passant positions is taken care of in
		 * propagate_one_move_within_table()
		 *
		 * But we start with an extra check to make sure this isn't a double pawn move, it
		 * which case it would result in an en passant position, not the non-en passant
		 * position we are in now (en passant got taken care of in the special case above).
		 */

		if (((movementptr->square - position.piece_position[piece]) == 16)
		    || ((movementptr->square - position.piece_position[piece]) == -16)) {
		    continue;
		}

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		position.piece_position[piece] = movementptr->square;

		position.board_vector |= BITVECTOR(movementptr->square);

		propagate_one_move_within_table(tb, dtm, dtc, &position);

		position.board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

	position.piece_position[piece] = origin_square;
	position.board_vector |= BITVECTOR(origin_square);
    }
}

/* initialize_tablebase()
 *
 * This is another critical function; don't be deceived by the tame word 'initialize'.
 *
 * We determine that a position is won for the player not to move (PNTM) if all possible moves (of
 * the player to move) lead to a won game for PNTM.  We count down this total during back
 * propagation, so it stands to reason that we need an accurate count to start with.  Thus the
 * importance of this function.
 *
 * Basically, there are two types of moves we need to consider in each position:
 *
 * 1. non-capture, non-promotion, non-restricted moves
 *
 * We just add these up and then count them down during intra-table propagation, depending on the
 * integrity of the program's algorithm to make sure that every move counted forward gets considered
 * as a move backward.
 *
 * 2. everything else (futuremoves)
 *
 * These always lead to a different tablebase (a futurebase).  The only way we handle them is
 * through inter-table back propagation.  We keep a seperate count of futuremoves because, unlike
 * intratable moves, we might miss some of these moves if we don't have a complete set of
 * futurebases.  So we count futuremoves by themselves (as well as part of the standard count), and
 * count them down normally during a single sweep through our futurebases.  If that takes care of
 * everything fine.  Otherwise, during our first pass through the current tablebase, we'll find that
 * some of the futuremoves remain unaccounted for.  If they occur with the "good guys" as PTM, we
 * just double-check that the restriction is OK, subtract the remaining futuremoves out from the
 * standard count, and keep going.  But if the "bad guys" are PTM, then some more work is needed.
 * The position is marked won for PTM, unless we want to step forward another half move.  In this
 * case, we compute all possible next moves (or maybe just captures), and search for them in our
 * tablebases.  If any of them are marked drawn or won, we can safely back-propagate this.
 * Otherwise, the position has to be marked won for PTM, as before.
 *
 * There's a real serious speed penalty here, because this half-move-forward algorithm requires
 * random access lookups in the futurebases.  A possible way to address this would be to create an
 * intermediate tablebase for the half move following the capture/promotion.  This could be done by
 * building a tablebase with a queen (and another one with a knight) frozen on the queening square.
 * Any possible move of the queen or knight would result in a win for the moving side.  A similar
 * shortcut could be done for a capture, though the only real justification (from a performance
 * perspective) would be on promotions.
 *
 */

int in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    struct movement *movementptr;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is NOT to move... */

	if (tb->piece_color[piece] == position->side_to_move) continue;

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][position->piece_position[piece]][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[position->piece_position[piece]][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

	    }
	}
    }

    return 0;
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index, struct fourbyte_entry *entry)
{
    local_position_t position;
    int piece;
    int dir;
    struct movement *movementptr;
    int i;

    if (! index_to_local_position(tb, index, &position)) {

	initialize_entry_as_illegal(tb, entry);
	return 0;

    } else {

	/* Now we need to count moves.  FORWARD moves. */
	int movecnt = 0;
	int futuremovecnt = 0;
	futurevector_t futurevector = 0;

	/* En passant:
	 *
	 * We're just counting moves here.  In particular, we don't compute the indices of the
	 * resulting positions.  If we did, we'd have to worry about clearing en passant status
	 * from any of fourth or fifth rank pawns, but we don't have to worry about it.
	 *
	 * We do have to count one or two possible extra en passant pawn captures, though...
	 */


	for (piece = 0; piece < tb->num_pieces; piece++) {

	    /* We only want to consider pieces of the side which is to move... */

	    if (tb->piece_color[piece] != position.side_to_move)
		continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][position.piece_position[piece]][dir];
			 (movementptr->vector & position.board_vector) == 0;
			 movementptr++) {

			/* If a piece is moving outside its restricted squares, we regard this
			 * as a futurebase (since it will require back prop from futurebases)
			 */

			if (!(tb->piece_legal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			    }
			    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
			    futuremovecnt ++;
			}

			movecnt ++;

		    }

		    /* Now check to see if the movement ended because we hit against another piece
		     * of the opposite color.  If so, add another move for the capture.
		     *
		     * Actually, we check to see that we DIDN'T hit a piece of our OWN color.  The
		     * difference is that this way we don't register a capture if we hit the end of
		     * the list of movements in a given direction.
		     *
		     * We also check to see if the capture was against the enemy king! in which case
		     * this position is a "mate in 0" (i.e, illegal)
		     */

		    if ((movementptr->vector & position.PTM_vector) == 0) {
			movecnt ++;
			for (i = 0; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if ((i == BLACK_KING) || (i == WHITE_KING)) {
				    initialize_entry_with_PNTM_mated(tb, entry);
				    return 0;
				}
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match capture!\n"); /* BREAKPOINT */
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[position.piece_position[piece]][tb->piece_color[piece]];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* If the piece is a pawn and we're moving to the last rank, then this has
		     * to be a promotion move, in fact, PROMOTION_POSSIBILITIES moves.  (queen,
		     * knight, maybe rook and bishop).  As such, they will require back
		     * propagation from futurebases and must therefore be flagged as
		     * futuremoves.
		     */

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			if (futurevector & FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES)) {
			    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			}
			futurevector |= FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES);
			futuremovecnt += PROMOTION_POSSIBILITIES;

			movecnt += PROMOTION_POSSIBILITIES;

		    } else {

			/* If a piece is moving outside its restricted squares, we regard this
			 * as a futurebase (since it will require back prop from futurebases)
			 */

			if (!(tb->piece_legal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			    }
			    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
			    futuremovecnt ++;
			}

			movecnt ++;

		    }

		}


		/* Pawn captures.
		 *
		 * In this part of the code, we're just counting forward moves, and all captures
		 * are futurebase moves, so the only difference to us whether this is a
		 * promotion move or not is how many futuremoves get recorded.
		 */

		for (movementptr = capture_pawn_movements[position.piece_position[piece]][tb->piece_color[piece]];
		     movementptr->square != -1;
		     movementptr++) {

		    /* A special check for en passant captures.  */

		    if (movementptr->square == position.en_passant_square) {
			movecnt ++;
			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square + (tb->piece_color[piece] == WHITE ? -8 : 8)
				== position.piece_position[i]) {
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			continue;
		    }

		    if (((movementptr->vector & position.board_vector) == 0)
			|| ((movementptr->vector & position.PTM_vector) != 0)) continue;

		    /* Same check as above for a mated situation */

		    if (position.side_to_move == WHITE) {
			if (movementptr->square == position.piece_position[BLACK_KING]) {
			    initialize_entry_with_PNTM_mated(tb, entry);
			    return 0;
			}
		    } else {
			if (movementptr->square == position.piece_position[WHITE_KING]) {
			    initialize_entry_with_PNTM_mated(tb, entry);
			    return 0;
			}
		    }

		    /* If the piece is a pawn and we're moving to the last rank, then this has
		     * to be a promotion move, in fact, PROMOTION_POSSIBILITIES moves.  (queen,
		     * knight, maybe rook and bishop).  As such, they will require back
		     * propagation from futurebases and must therefore be flagged as
		     * futuremoves.
		     */

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			movecnt += PROMOTION_POSSIBILITIES;

			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if (futurevector & FUTUREVECTORS(futurecaptures[piece][i],
								 PROMOTION_POSSIBILITIES)) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTORS(futurecaptures[piece][i],
							      PROMOTION_POSSIBILITIES);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match promotion capture!\n"); /* BREAKPOINT */
			}

		    } else {

			movecnt ++;

			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match pawn capture!\n"); /* BREAKPOINT */
			}

		    }

		}

	    }

	}

	/* Finally, we want to determine is if we're in check.  This is significant because if
	 * and when we decide there are no valid moves out of this position, being in check is
	 * the difference between this being checkmate or stalemate.  We note being in check by
	 * setting the high order bit in the unsigned char movecnt.
	 */

	if (movecnt == 0) {
	    initialize_entry_with_stalemate(tb, entry);
	    return 0;
	} else {
	    initialize_entry_with_movecnt(tb, entry,
					  in_check(tb, &position) ? 128 + movecnt : movecnt);
	    total_moves += movecnt;
	    total_futuremoves += futuremovecnt;
	    return futurevector;
	}
    }
}

void initialize_tablebase(tablebase_t *tb)
{
    index_t index;

    for (index=0; index <= tb->max_index; index++) {
	tb->futurevectors[index] = initialize_tablebase_entry(tb, index, fetch_fourbyte_entry(tb, index));
    }
}

/* Intra-table propagation is almost trivial.  Keep making passes over the tablebase first until
 * we've hit dtm_limit, which means we've processed everything from the futurebases, then until no
 * more progress is made on a given pass.
 */

void propagate_all_moves_within_tablebase(tablebase_t *tb, int dtm_limit)
{
    int dtm = 1;

    while (dtm <= dtm_limit) {

	/* PTM wins */
	propagation_pass(dtm);

	/* PNTM wins */
	propagation_pass(-dtm);

	dtm ++;
    }

    while (1) {

	/* PTM wins */
	if (propagation_pass(dtm) == 0) break;

	/* PNTM wins */
	if (propagation_pass(-dtm) == 0) break;

	dtm ++;
    }

}

/* The "master routine" for tablebase generation.
 *
 * Many of these subroutines have already printed error messages of their own if they return
 * an error indication, which is why we just silently return in many cases.
 */

boolean generate_tablebase_from_control_file(char *control_filename, char *output_filename, char *options) {

    tablebase_t *tb;
    int dtm_limit;

    tb = parse_XML_control_file(control_filename);
    if (tb == NULL) return 0;

    tb->per_pass_stats = xmlNewChild(xmlDocGetRootElement(tb->xml), NULL,
				     BAD_CAST "per-pass-statistics", NULL);
    xmlNodeAddContent(tb->per_pass_stats, BAD_CAST "\n   ");
    tb->current_pass_stats = xmlNewChild(tb->per_pass_stats, NULL, BAD_CAST "pass", NULL);

    if (num_propentries != 0) {
	tb->entries_fd = open("entries", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
	if (tb->entries_fd == -1) {
	    fprintf(stderr, "Can't open 'entries' for read-write\n");
	    return 0;
	}
	init_entry_buffers(tb);
    } else {
	tb->entries = (struct fourbyte_entry *) calloc(tb->max_index + 1, sizeof(struct fourbyte_entry));
	if (tb->entries == NULL) {
	    fprintf(stderr, "Can't malloc tablebase entries\n");
	}
    }

    if (num_propentries != 0) {
#if 0
	proptable = calloc(num_propentries, sizeof(proptable_entry_t));
	if (proptable == NULL) {
	    fprintf(stderr, "Can't calloc proptable\n");
	    return 0;
	}
#else
	/* This is here so we can use O_DIRECT when writing the proptable out to disk.  1024 is a guess. */
	if (posix_memalign((void **) &proptable, 1024, num_propentries * sizeof(proptable_entry_t)) != 0) {
	    fprintf(stderr, "Can't posix_memalign proptable\n");
	    return 0;
	}
	/* POSIX doesn't guarantee that the memory will be zeroed (but Linux seems to zero it) */
	memset(proptable, 0, num_propentries * sizeof(proptable_entry_t));
#endif
    }
    /* Need this no matter what.  I want to replace it with a global static tablebase for everything. */
    proptable_tb = tb;

    assign_numbers_to_futuremoves(tb);
    compute_pruned_futuremoves(tb);
    if (! check_pruning(tb)) return 0;

    gettimeofday(&pass_start_time, NULL);

    if (num_propentries == 0) {

	/* No proptables.  Allocate a futurevectors array, initialize the tablebase, back propagate
	 * the futurebases (noting which futuremoves have been handled in the futurevectors array),
	 * and run through the futurevectors array checking for unhandled futuremoves.
	 */

	tb->futurevectors = (futurevector_t *) calloc(tb->max_index + 1, sizeof(futurevector_t));
	if (tb->futurevectors == NULL) {
	    fprintf(stderr, "Can't malloc tablebase futurevectors\n");
	    return 0;
	}

	fprintf(stderr, "Initializing tablebase\n");
	initialize_tablebase(tb);

	fprintf(stderr, "Total legal positions: %lld\n", total_legal_positions);
	fprintf(stderr, "Total moves: %lld\n", total_moves);

	check_1000_indices(tb);

	dtm_limit = back_propagate_all_futurebases(tb);
	if (dtm_limit == -1) return 0;

	fprintf(stderr, "Checking futuremoves...\n");
	propagation_pass(0);
	if (! have_all_futuremoves_been_handled(tb)) return 0;
	fprintf(stderr, "All futuremoves handled under move restrictions\n");

	free(tb->futurevectors);
	tb->futurevectors=NULL;

    } else {

	/* Using proptables.  No futurevectors array.  We back propagate the futurebases into the
	 * proptable, then in a single pass initialize the entries array and commit the proptable
	 * into it, checking each position move as we go to make sure its futuremoves are handled.
	 */

	dtm_limit = back_propagate_all_futurebases(tb);
	if (dtm_limit == -1) return 0;
	proptable_full();  /* flush moves out to disk */

	fprintf(stderr, "Initializing tablebase...\n");
	propagation_pass(0);
	proptable_full();  /* flush moves out to disk */

	/* fprintf(stderr, "Total legal positions: %lld\n", total_legal_positions); */
	/* fprintf(stderr, "Total moves: %lld\n", total_moves); */
	/* fprint_system_time(); */

	fprintf(stderr, "All futuremoves handled under move restrictions\n");

    }

    /* We add one to dtm_limit here because, even if there are intra-table passes with no
     * progress made, we want to process at least one pass beyond the maximum mate-in value we
     * saw during futurebase back-prop.
     */

    fprintf(stderr, "Intra-table propagating\n");
    propagate_all_moves_within_tablebase(tb, dtm_limit+1);

    write_tablebase_to_file(tb, output_filename, options);

    return 1;
}

/***** PROBING NALIMOV TABLEBASES *****/

#ifdef USE_NALIMOV

int EGTBProbe(int wtm, unsigned char board[64], int sqEnP, int *score);

int IInitializeTb(char *pszPath);

int FTbSetCacheSize(void    *pv, unsigned long   cbSize );

#define EGTB_CACHE_DEFAULT (1024*1024)

void *EGTB_cache;

char *nalimov_path = ".";

void init_nalimov_code(void)
{
    int nalimov_num;

    nalimov_num = IInitializeTb(nalimov_path);
    printf("%d piece Nalimov tablebases found\n", nalimov_num);
    EGTB_cache = malloc(EGTB_CACHE_DEFAULT);
    if (EGTB_cache == NULL) {
	fprintf(stderr, "Can't malloc EGTB cache\n");
    } else {
	FTbSetCacheSize(EGTB_cache, EGTB_CACHE_DEFAULT);
    }
}

char * nalimov_to_english(int score)
{
    static char buffer[256];

    if (score > 0) {
	sprintf(buffer, "mate in %d", ((65536-4)/2)-score+1);
    } else if (score < 0) {
	sprintf(buffer, "mated in %d", ((65536-4)/2)+score);
    } else {
	sprintf(buffer, "draw");
    }

    return buffer;
}

void verify_tablebase_against_nalimov(tablebase_t *tb)
{
    index_t index;
    global_position_t global;
    int score;

    fprintf(stderr, "Verifying tablebase against Nalimov\n");

    for (index = 0; index <= tb->max_index; index++) {
	if (index_to_global_position(tb, index, &global)) {

	    int dtm = fetch_DTM_from_disk(tb, index);

	    if (dtm == 1) {

		/* I've learned the hard way not to probe a Nalimov tablebase for an illegal position... */

	    } else if ((global.en_passant_square != -1)
		       && ((global.board[global.en_passant_square - 9] != 'P')
			   || (global.en_passant_square == 40)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square - 7] != 'P')
			   || (global.en_passant_square == 47)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square + 7] != 'p')
			   || (global.en_passant_square == 16)
			   || (global.side_to_move == WHITE))
		       && ((global.board[global.en_passant_square + 9] != 'p')
			   || (global.en_passant_square == 23)
			   || (global.side_to_move == WHITE))) {

		/* Nor does Nalimov like it if the en passant pawn can't actually be captured by
		 * another pawn.
		 */

	    } else if (EGTBProbe(global.side_to_move == WHITE, global.board, global.en_passant_square, &score) == 1) {

		/* Make sure dtm is greater than one here, since the Nalimov tablebase doesn't
		 * appear to handle illegal positions.  PTM wins in 0 (dtm 1) would mean that PNTM
		 * is in check, so the king can just be captured.
		 */

		if (dtm > 1) {
		    if ((dtm-1) != ((65536-4)/2)-score+1) {
			printf("%s (%d): Nalimov says %s (%d), but we say mate in %d\n",
			       global_position_to_FEN(&global), index,
			       nalimov_to_english(score), score, dtm-1);
		    }
		} else if (dtm < 0) {
		    if ((-dtm-1) != ((65536-4)/2)+score) {
			printf("%s (%d): Nalimov says %s (%d), but we say mated in %d\n",
			       global_position_to_FEN(&global), index,
			       nalimov_to_english(score), score, -dtm-1);
		    }
		} else if (dtm == 0) {
		    if (score != 0) {
			printf("%s (%d): Nalimov says %s (%d), but we say draw\n",
			       global_position_to_FEN(&global), index,
			       nalimov_to_english(score), ((65536-4)/2)+score);
		    }
		}
	    } else {
		if (dtm == 1) {
		    fprintf(stderr, "%s (%d): Nalimov says illegal, but we say %d\n",
			    global_position_to_FEN(&global), index, dtm);
		}
	    }
	}
    }
}

#endif /* USE_NALIMOV */


/* Search an array of tablebases for a global position.  Array should be terminated with a NULL ptr.
 */

boolean search_tablebases_for_global_position(tablebase_t **tbs, global_position_t *global_position,
					      tablebase_t **tbptr, index_t *indexptr)
{
    index_t index;

    for (; *tbs != NULL; tbs++) {
	index = global_position_to_index(*tbs, global_position);
	if (index != -1) {
	    *tbptr = *tbs;
	    *indexptr = index;
	    return 1;
	}
    }

    return 0;
}

void print_score(tablebase_t *tb, index_t index, char *ptm, char *pntm)
{
    int dtm = fetch_DTM_from_disk(tb, index);

    if (dtm == 0) {
	printf("Draw\n");
    } else if (dtm == 1) {
	printf("Illegal position\n");
    } else if (dtm > 1) {
	printf("%s moves and wins in %d\n", ptm, dtm-1);
    } else if (dtm < 0) {
	printf("%s wins in %d\n", pntm, -dtm-1);
    }
}

int main(int argc, char *argv[])
{
    /* Make sure this tablebase array is one bigger than we need, so it can be NULL terminated */
    tablebase_t *tb, **tbs;
    global_position_t global_position;
    boolean global_position_valid = 0;
    int argi;
    int i;
    int c;
    int generating=0;
    int probing=0;
    int verify=0;
    char *output_filename = NULL;
    extern char *optarg;
    extern int optind;
    char options_string[256];
    char *options_string_ptr = options_string;

    /* Figure how we were called.  This is just to record in the XML output for reference purposes. */

    for (i=0; i<argc; i++) {
	strncpy(options_string_ptr, argv[i], options_string + sizeof(options_string) - options_string_ptr);
	options_string_ptr += strlen(argv[i]);
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
	*options_string_ptr = ' ';
	options_string_ptr ++;
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
    }
    options_string[sizeof(options_string) - 1] = '\0';

    gettimeofday(&program_start_time, NULL);

    init_movements();
    verify_movements();

    initialize_byte_transform();

    while (1) {
	c = getopt(argc, argv, "gpvo:n:P:");

	if (c == -1) break;

	switch (c) {

	case 'g':
	    generating = 1;
	    break;
	case 'p':
	    probing = 1;
	    break;
	case 'v':
	    verify = 1;
	    break;
	case 'n':
	    nalimov_path = optarg;
	    break;
	case 'o':
	    output_filename = optarg;
	    break;
	case 'P':
	    /* set size of proptable in megabytes */
	    num_propentries = strtol(optarg, NULL, 0) * 1024 * 1024 / sizeof(proptable_entry_t);
	    break;
	}
    }

    if (generating && probing) {
	fprintf(stderr, "Only one of the generating (-g) and probing (-p) options can be specified\n");
	exit(EXIT_FAILURE);
    }

    if (!generating && !probing && !verify) {
	fprintf(stderr, "At least one of generating (-g), probing (-p), or verify (-v) must be specified\n");
	exit(EXIT_FAILURE);
    }

    if (generating && (output_filename == NULL)) {
	fprintf(stderr, "An output filename must be specified to generate\n");
	exit(EXIT_FAILURE);
    }

    if (!generating && (output_filename != NULL)) {
	fprintf(stderr, "An output filename can not be specified when probing or verifying\n");
	exit(EXIT_FAILURE);
    }

    /* Generating */

    if (generating) {
	exit(generate_tablebase_from_control_file(argv[optind], output_filename, options_string)
	     ? EXIT_SUCCESS : EXIT_FAILURE);
    }

    /* Probing / Verifying */

#ifdef USE_NALIMOV
    init_nalimov_code();
#endif

    i = 0;
    /* calloc (unlike malloc) zeros memory */
    tbs = calloc(argc - optind + 1, sizeof(tablebase_t *));

    for (argi=optind; argi<argc; argi++) {
	fprintf(stderr, "Loading '%s'\n", argv[argi]);
	tbs[i] = preload_futurebase_from_file(argv[argi]);
	if (tbs[i] == NULL) {
	    fprintf(stderr, "Error loading '%s'\n", argv[argi]);
	} else {
#ifdef USE_NALIMOV
	    if (verify) verify_tablebase_against_nalimov(tbs[i]);
#endif
	    i++;
	}
    }

    if (!probing) exit(EXIT_SUCCESS);

    /* Probing only */

    read_history(".hoffman_history");

    while (1) {
	char *buffer;
	local_position_t pos;
	local_position_t nextpos;
	int piece, dir;
	struct movement * movementptr;
	global_position_t global_capture_position;
	int score;
	index_t index;

	buffer = readline(global_position_valid ? "FEN or move? " : "FEN? ");
	if (buffer == NULL) break;
	if (*buffer == '\0') continue;
	add_history(buffer);

	if (!(global_position_valid && parse_move_in_global_position(buffer, &global_position))
	    && !parse_FEN_to_global_position(buffer, &global_position)) {
	    printf(global_position_valid ? "Bad FEN or move\n\n" : "Bad FEN\n\n");
	    continue;
	}

	global_position_valid = 1;

	if (search_tablebases_for_global_position(tbs, &global_position, &tb, &index)) {

	    index_t index2;
	    char *ptm, *pntm;

	    /* 'index' is the index of the current position; 'index2' will be the index
	     * of the various next positions that we'll consider
	     */

	    printf("FEN %s\n", global_position_to_FEN(&global_position));
	    printf("Index %d\n", index);

	    if (global_position.side_to_move == WHITE) {
		ptm = "White";
		pntm = "Black";
	    } else {
		ptm = "Black";
		pntm = "White";
	    }

	    print_score(tb, index, ptm, pntm);

#ifdef USE_NALIMOV
		if (EGTBProbe(global_position.side_to_move == WHITE, global_position.board, -1, &score) == 1) {
		    printf("\nNalimov score: ");
		    if (score > 0) {
			printf("%s moves and wins in %d\n", ptm, ((65536-4)/2)-score+1);
		    } else if (score < 0) {
			printf("%s wins in %d\n", pntm, ((65536-4)/2)+score);
		    } else {
			printf("DRAW\n");
		    }
		}
#endif

	    /* Now we want to print a move list */

	    for (piece = 0; piece < tb->num_pieces; piece++) {

		/* We only want to consider pieces of the side which is to move... */

		if (tb->piece_color[piece] != global_position.side_to_move)
		    continue;

		if (tb->piece_type[piece] != PAWN) {

		    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

			index_to_local_position(tb, index, &pos);

			nextpos = pos;

			flip_side_to_move_local(&nextpos);
			nextpos.en_passant_square = -1;

			for (movementptr = movements[tb->piece_type[piece]][pos.piece_position[piece]][dir];
			     (movementptr->vector & pos.board_vector) == 0;
			     movementptr++) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			}

			/* Now we consider possible captures */

			index_to_global_position(tb, index, &global_capture_position);

			if ((movementptr->vector & pos.PTM_vector) == 0) {

			    if ((movementptr->square == pos.piece_position[BLACK_KING])
				|| (movementptr->square == pos.piece_position[WHITE_KING])) {

				/* printf("MATE\n"); */

			    } else {
				tablebase_t *tb2;
				global_position_t reversed_position;

				global_capture_position.board[pos.piece_position[piece]] = 0;
				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       tb->piece_type[piece]);

				if (global_capture_position.side_to_move == WHITE)
				    global_capture_position.side_to_move = BLACK;
				else
				    global_capture_position.side_to_move = WHITE;

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s   ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s   NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square]);
				}
			    }
			}
			/* end of capture search */
		    }

		} else {

		    /* PAWNs */

		    index_to_local_position(tb, index, &pos);
		    nextpos = pos;
		    flip_side_to_move_local(&nextpos);

		    /* normal pawn moves */

		    for (movementptr = normal_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 (movementptr->vector & pos.board_vector) == 0;
			 movementptr++) {

			if ((ROW(movementptr->square) != 0) && (ROW(movementptr->square) != 7)) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			} else {

			    /* non-capture promotion */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %s%s=%c  ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %s%s=%c  NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }
			}
		    }

		    /* capture pawn moves */

		    for (movementptr = capture_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 movementptr->square != -1;
			 movementptr++) {

			if (movementptr->square == pos.en_passant_square) {

			    /* en passant capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    if (tb->piece_color[piece] == WHITE) {
				global_capture_position.board[pos.en_passant_square - 8] = 0;
			    } else {
				global_capture_position.board[pos.en_passant_square + 8] = 0;
			    }

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }

			    continue;
			}

			if ((movementptr->vector & pos.PTM_vector) != 0) continue;

			if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			    /* promotion capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s=%c ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s=%c NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }

			    continue;
			}

			if ((movementptr->square == pos.piece_position[BLACK_KING])
			    || (movementptr->square == pos.piece_position[WHITE_KING])) {

			    /* printf("MATE\n"); */

			} else {
			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }
			}
		    }
		    /* end of capture search */


		}

	    }
	}
    }
    write_history(".hoffman_history");
    printf("\n");

    exit(EXIT_SUCCESS);
}
