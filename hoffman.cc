/* -*- mode: C; fill-column: 100; c-basic-offset: 4; -*-
 *
 * HOFFMAN - a chess endgame tablebase builder
 *
 * by Brent Baccala
 *
 * begun coding    August, 2006
 * last modified   February, 2009
 *
 * no rights reserved; you may freely copy, modify, or distribute HOFFMAN
 *
 * written in C for speed (but still needs a lot of work to reach that goal)
 *
 * This program is formated for a (minimum) 100 character wide display.
 *
 * INTRODUCTION
 *
 * This program calculates chess tablebases, which are large files containing all possible
 * configurations of chess pieces in an endgame and the best play to either win or draw.  Unlike a
 * conventional chess engine, which uses a heuristic evaluation function, a retrograde engine is
 * almost completely non-heuristic.  When it labels a position as a win, it is because it has
 * considered all possibles lines, be they 10, 20, or 100 moves long, and determined that the win is
 * forced, even with best play by the opposing side.  Some chess-like games, such as the Japanese
 * game Shogi, are not suitable for retrograde analysis because pieces never leave the game
 * (captured pieces in Shogi can be put back into play by the capturing player).  Yet for chess, the
 * frequent reduction of games to positions where only a handful of pieces remain has created an
 * entire subfield of endgame analysis.
 *
 * Systematic analysis of chess endgames dates at least to the ninth century.  Pioneering work in
 * computer retrograde analysis was done in the 1980s by Ken Thompson, of UNIX fame, and
 * S.J. Edwards, but the most popular tablebases today are those generated by a program written by
 * E.V. Nalimov.  Suffice it to say that while Nalimov's program has completely solved all chess
 * endgames with six or fewer pieces remaining, and while Nalimov tablebases are widely available on
 * the Internet, the Nalimov approach of solving an endgame completely results in very slow run
 * times and exceptionally large tablebases.  The K+P+P vs K+P endgame, for example, due to the
 * possibility of all pawns queening, requires the K+Q+Q vs K+Q endgame to be solved before it can
 * be calculated.  The Nalimov kppkp tablebase occupies 64MB; Hoffman's current, less efficient
 * storage scheme requires 225MB for the same tablebase.
 *
 * Hoffman takes a somewhat different approach, one pioneered by Eiko Bleicher's Freezer, now a
 * commercial program. When faced with something like K+P+P vs K+P, rather than calculate all
 * possible resulting positions, it may ignore the possibility of more than two pawns queening at
 * the same time, thus computing nothing more complex than K+Q+P vs K+Q.  While incomplete, such a
 * tablebase is nevertheless useful.  For the player with two pawns, if the tablebase finds a
 * winning line subject to the queening restrictions, then that line is still playable for a win,
 * even though a faster winning line may exist.  From the opposing point of view, if the tablebase
 * treats any position where the third pawn queens as a loss, then the player can be confident that
 * any drawing line can not be improved upon by the superior side.  From a computational
 * perspective, we have reduced the complexity requirements to a point where the calculation can be
 * performed in a reasonable amount of time.  While still too slow for over-the-board use, we now
 * have a useful tool for the analysis of more complex endgames, useful for either static analysis,
 * or for the slow time controls of correspondence games.
 *
 * Hoffman improves upon Freezer with a more sophisticated method of chaining one endgame analysis
 * into another, allowing more realistic modeling of queening combinations and exchanges.  For
 * example, in a bishop vs knight endgame (with pawns), we can (if we wish) analyze first the king
 * and pawn endgame resulting after a trade of the minors, then use this information to analyze a
 * similar set of king vs knight and king vs bishop endgames, and finally combine all this
 * information together to analyze the original endgame.  While the current version of Freezer can
 * only regard the capture of the knight or bishop as a forced win for one side or the other,
 * Hoffman can look through the exchange to determine the result more accurately.
 *
 * Hoffman thus attempts to combine the best of Nalimov and Freezer.  Unlike Freezer, the program is
 * powerful enough to solve any endgame completely (given enough computing resources), reproducing
 * any Nalimov tablebase.  Unlike Nalimov, the program is capable of pruning pawn moves, queening
 * combinations, movement options and exchanges, giving it Freezer's ability to solve complex
 * endgames in a reasonable amount of time.  The exact tradeoff between the two extremes is made
 * using a XML-based configuration that can seem daunting at first, but ultimately offers the user
 * the ability to extensively tailor the program's operation.  Combined with a human being's common
 * sense and chess judgement, it is my hope that this flexibility with ultimately make the program
 * more useful for endgame retrograde analysis than either Nalimov or Freezer.
 *
 * For those not up on Americana, the program is named after Trevor Hoffman, an All Star baseball
 * pitcher who specializes in "closing" games.  It was written specifically for The World vs. Arno
 * Nickel game (ultimately won by the World team with no help needed from Hoffman).
 *
 *
 * Basic Usage: hoffman -g <xml-control-file>                           (generate mode)
 *              hoffman -v <tablebase> ...                              (verification mode)
 *              hoffman -p <tablebase> ...                              (probe mode)
 */

#include "config.h"	/* GNU configure script figures out our build options and writes them here */

#ifdef HAVE_LIBTPIE
#define TPL_LOGGING 0
#include <tpie/tpie.h>			// for tpie_init
#include <tpie/tpie_log.h>
#include <tpie/priority_queue.h>	// for tpie::priority_queue
#endif

extern "C" {

#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE	/* because some of our files will require 64-bit offsets */
#endif

#ifndef _GNU_SOURCE
#define _GNU_SOURCE		/* to get strsignal() and FNM_CASEFOLD */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>		/* for write(), lseek(), gethostname() */
#include <math.h>		/* for sqrt(), which is used only once */
#include <time.h>		/* for putting timestamps on the output tablebases */
#include <fcntl.h>		/* for O_RDONLY */
#include <netdb.h>		/* for gethostbyname() */
#include <inttypes.h>		/* C99 integer types */

#include <fnmatch.h>		/* for glob matching of pruning statements */

#include <signal.h>		/* so user interrupts and internal errors are reported to the error URL */

#include <sys/time.h>		/* for reporting resource utilization */
#include <sys/resource.h>

#include <errno.h>		/* for errno and strerror() */

#ifdef HAVE_LIBREADLINE
#include <readline.h>		/* The GNU readline library (optional) */
#include <history.h>
#endif

#include <libxml/parser.h>	/* The GNOME XML library (required) */
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xmlsave.h>

#define STRICT_ZLIB_OPEN_DECLARATION 1
#include "zlib_fopen.h"		/* My wrapper around the ZLIB compression library (required) */

#ifdef USE_LIBCURL
#include "url_fopen.h"		/* My wrapper around libcurl (optional, for http: URL support) */
#endif

#ifdef HAVE_LIBFTP
#include "ftp_fopen.h"		/* My wrapper around ftplib (option, for ftp: URL support) */
#endif

#include "bitlib.h"

/* Our DTD.  We compile it into the program because we want to validate our input against the
 * version of the DTD that the program was compiled with, not some newer version from the network.
 */

#include "tablebase_dtd.h"

/* O_LARGEFILE - if it's defined, then sometimes we might need it, like when working with an entries
 * file for a 5-piece tablebase under construction.  I use it almost everywhere.  If it's not
 * defined, then just define it to 0 here so we can use it without (too many) worries.
 */

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif


typedef int_fast8_t boolean;

#ifndef PRIu32
#define PRIu32 "u"
#define PRIx32 "x"
#define PRIu64 "llu"
#define PRIx64 "llx"
#endif

typedef uint32_t index_t;
#define PRIindex PRIu32
#define INVALID_INDEX 0xffffffff

/* If we're going to run multi-threaded, we need the POSIX threads library */

#ifdef USE_THREADS
#include <pthread.h>
int num_threads = 1;
long contended_locks = 0;
long contended_indices = 0;
#endif

/* If we're multithreaded, we use gcc 4's built-ins for atomic memory access, which are identical to
 * Intel's.  If the compiler doesn't feature these built-ins, then the simplest way to fix that is
 * to turn off multithreading, and use these functions here instead.  I distinguish between
 * __sync_fetch_and_XXX and __sync_XXX because the first variant returns the original, unmodified
 * value, and the second variant (of my own creation) returns nothing.  Naming them differently
 * hopefully helps make the code clearer and less error prone.  We condition on
 * HAVE_INTEL_ATOMIC_OPS instead of USE_THREADS because even if we're not using threads, the builtin
 * functions might still be defined.
 */

#ifdef HAVE_INTEL_ATOMIC_OPS

#define __sync_or __sync_fetch_and_or
#define __sync_xor __sync_fetch_and_xor
#define __sync_add __sync_fetch_and_add
#define __sync_and __sync_fetch_and_and

#else

#define __sync_or(ptr, val) (*(ptr) |= (val))
#define __sync_xor(ptr, val) (*(ptr) ^= (val))
#define __sync_add(ptr, val) (*(ptr) += (val))
#define __sync_and(ptr, val) (*(ptr) &= (val))

#define __sync_fetch_and_and  __non_builtin_sync_fetch_and_and

inline uint32_t __sync_fetch_and_and(uint32_t *ptr, uint32_t val) {
    uint32_t tmp = *ptr;
    *(ptr) &= (val);
    return tmp;
}

#endif

/* I don't have an 8-byte sync_fetch_and_add on i686, so I use this instead. */

#if defined(USE_THREADS) && !defined(HAVE_SYNC_FETCH_AND_ADD_8)
inline uint64_t __sync_fetch_and_add_8(uint64_t *ptr, uint64_t val) {
    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    uint64_t ret;
    pthread_mutex_lock(&lock);
    ret = *ptr;
    *ptr += val;
    pthread_mutex_unlock(&lock);
    return ret;
}
#endif


/***** GLOBAL CONSTANTS *****/

/* Maximum number of pieces; used to simplify various arrays
 *
 * Since this includes frozen as well as mobile pieces, "16" may seem absurd, but it's probably
 * about right.  4 fully mobile pieces are easily doable in memory.  5 mobiles can often be done in
 * memory if you use either symmetry or a machine with lots of RAM.  6 mobiles requires sweeping
 * passes across a file on disk.  7 or more mobiles are only doable with severe restrictions on the
 * movements of the pieces.
 */

#define MAX_PIECES 16

/* Maximum number of possibilities for pawn promotions (see promotion_possibilities below). */

#define MAX_PROMOTION_POSSIBILITIES 5

/* seven possible pieces: KQRBNP; 64 possible squares, up to 8 directions per piece, up to 7
 * movements in one direction
 */

#define NUM_PIECES 6
#define NUM_SQUARES 64
#define NUM_DIR 8
#define NUM_MOVEMENTS 7

/* Variables for gathering statistics */

uint64_t total_legal_positions = 0;
uint64_t total_PNTM_mated_positions = 0;
uint64_t total_stalemate_positions = 0;
uint64_t total_moves = 0;
uint64_t total_futuremoves = 0;
uint64_t total_backproped_moves = 0;
uint64_t player_wins[2];
int max_dtm = 0;
int min_dtm = 0;

/* How we were called - XXX hardwired max */
char options_string[256];

struct timeval program_start_time;
struct timeval program_end_time;

/* per-pass statistics */

int total_passes = 0;
int max_passes = 0;

const char ** pass_type = NULL;
int * pass_target_dtms = NULL;
int * positions_finalized = NULL;
uint64_t * backproped_moves = NULL;

int min_tracked_dtm = -2;
int max_tracked_dtm = 2;
uint8_t * positive_passes_needed = NULL;
uint8_t * negative_passes_needed = NULL;


/***** DATA STRUCTURES *****/

/* Futuremoves are moves like captures and promotions that lead to a different tablebase.
 * 'futurevectors' are bit vectors used to track which futuremoves have been handled in a particular
 * position.  They are of type futurevector_t, and the primary operations used to construct them are
 * FUTUREVECTOR(move) to get a futurevector with a bit set in move's position, and
 * FUTUREVECTORS(move,n) to get a futurevector with n bits set starting with move, although the
 * actual tables are now stored in a more compact format that only uses as many bits as are needed
 * for the particular tablebase being generated.
 */

typedef uint32_t futurevector_t;
#define get_futurevector_t_field get_uint32_t_field
#define set_futurevector_t_field set_uint32_t_field
#define FUTUREVECTOR_HEX_FORMAT "0x%" PRIx32
#define FUTUREVECTOR(move) (1ULL << (move))
#define FUTUREVECTORS(move, n) (((1ULL << (n)) - 1) << (move))
#define NO_FUTUREMOVE -1
#define DISCARD_FUTUREMOVE -2
#define CONCEDE_FUTUREMOVE -3
#define RESIGN_FUTUREMOVE -4

/* These arrays hold the bit locations in the futurevector of various posible futuremoves -
 * captures, capture-promotions, promotions, and normal movements of a piece to all 64 squares.  The
 * values are either a bit location (starting at 0), or one of four negative numbers: -1 means that
 * the move in question isn't a futuremove in the given tablebase (for example, promotion of a
 * non-pawn, or movement of a piece to a legal square) and that any attempt to assign that
 * futuremove is therefore an error.  -2 means that no futurebase exists for the futuremove, and
 * that a 'discard' pruning statement exists for it, so the futuremove can be immediately discarded
 * when it is encountered during initialization.  -3 means that no futurebase exists and a 'concede'
 * pruning statement is present, so the futuremove results in an immediate win during
 * initialization.  -4 means that no futurebase exists and a 'resign' pruning statement is present
 * (useful only for suicide analysis), resulting in an immediate lose during initialization.
 *
 * XXX We don't actually have a 'resign' option on a prune statement, but RESIGN_FUTUREMOVE is used
 * implicitly if a player's last piece is captured in a suicide analysis.
 *
 * num_futuremoves[WHITE] and num_futuremoves[BLACK] are the total number of futurevector bits
 * assigned for each color, NOT the total number of possible futuremoves, since futuremoves can be
 * multiply assigned to bits (if two futuremoves can't both happen from the same position, they can
 * be safely assigned to the same bit), or completely pruned with a -2, -3, or -4 (no bit position).
 *
 * There is one place in the code (propagate_moves_from_promotion_futurebase) that assumes that the
 * piece ordering in the last array index of promotions and promotion_captures matches the piece
 * ordering in piece_name and piece_char.
 */

unsigned int num_futuremoves[2] = {0, 0};
int futurecaptures[MAX_PIECES][MAX_PIECES];
int promotion_captures[MAX_PIECES][MAX_PIECES][MAX_PROMOTION_POSSIBILITIES];
int promotions[MAX_PIECES][MAX_PROMOTION_POSSIBILITIES];
int futuremoves[MAX_PIECES][64];

/* XXX hardwired 100 futuremove max per color here */
#define MOVESTR_CHARS 16
char movestr[2][100][MOVESTR_CHARS];

/* Pairs of futurevectors (one for each color) indicating which futuremoves have been pruned by
 * either conceding or discarding them.  pruned_futuremoves = conceded_futuremoves |
 * discarded_futuremoves, and unpruned_futuremoves = ~pruned_futuremoves.  optimized_futuremoves
 * indicates futuremoves that have been flagged for optimization, as they have no futurebases that
 * could match them and can thus be handled during initialization.
 */

futurevector_t pruned_futuremoves[2] = {0, 0};
futurevector_t unpruned_futuremoves[2] = {0, 0};
futurevector_t conceded_futuremoves[2] = {0, 0};
futurevector_t discarded_futuremoves[2] = {0, 0};
futurevector_t optimized_futuremoves[2] = {0, 0};

/* position - the data structures that represents a board position
 *
 * There are two kinds of positions: local and global.  Locals are faster but are tied to a specific
 * tablebase.  Globals are more general and are used for probing.
 *
 * Both types use a 64-bit board_vector with one bit for each board position, in addition to a flag
 * to indicate which side is to move and the en passant capture square (or -1 if no en passant
 * capture is possible).  We use board_vector to easily check if possible moves are legal by looking
 * for pieces that block our moving piece.  This is done during futurebase propagation, during
 * intratable propagation, and during initialization.  It could be used to check if en passant
 * positions are legal (are the two squares behind the pawn blocked or not), but that is problematic
 * now because the board_vector isn't correct at the point where we need to make that check.
 *
 * Local positions use numbers (0-63) indicating the positions of the pieces, and also have a quick
 * way to check captures using a PTM_vector (pieces of the Player to Move).  You have to look into
 * the tablebase structure to figure out what piece corresponds to each number.  PTM_vector is only
 * used during tablebase initialization and in the probe code.
 *
 * It makes sense to include these vectors in the position structures because it's easiest to
 * compute them in the routines that convert indices to positions, but if you alter the position,
 * then they get out of sync, and its tempting to just leave them that way because you rarely need
 * them to be right at that point.  This really came back to haunt me when implementing en passant.
 *
 * "Multiplicity" is used in conjunction with symmetric indices, and indicates the actual number of
 * board positions that corresponds to this one.
 *
 * Global positions contain an 8x8 unsigned char array with ASCII characters representing each
 * piece.
 *
 * Sometimes I allow the board and PTM vectors to get out of sync with the position (for speed).
 * This can be a problem, so it has to be done really carefully.
 *
 * We don't worry about moving a piece that's pinned on our king, for example.  The resulting
 * position will already have been flagged illegal in the table.
 *
 */

typedef struct {
    struct tablebase *tb;
    uint64_t board_vector;
    uint64_t PTM_vector;
    uint8_t piece_position[MAX_PIECES];
    uint8_t permuted_piece[MAX_PIECES];
    uint8_t side_to_move;
    uint8_t en_passant_square;
    uint8_t multiplicity;
    uint8_t reflection;
} local_position_t;

#define ILLEGAL_POSITION 0xff

/* This is a global position, that doesn't depend on a particular tablebase.  It's slower to
 * manipulate, but is suitable for probing tablebases.  Each char in the array is either 0 for an
 * empty square, and one of the FEN characters for a chess piece.
 */

typedef struct {
    unsigned char board[64];
    short side_to_move;
    short en_passant_square;
    short variant;
} global_position_t;


/* pawn can't be on the first or last eight squares of the board */
#define ALL_ONES_BITVECTOR   0xffffffffffffffffLL
#define LEGAL_PAWN_BITVECTOR 0x00ffffffffffff00LL

#define BITVECTOR(square) (1ULL << (square))


#define REFLECTION_NONE 0
#define REFLECTION_HORIZONTAL 1
#define REFLECTION_VERTICAL 2
#define REFLECTION_DIAGONAL 4

/* tablebase - the data structure used to hold tablebases
 *
 * WHITE and BLACK are also used for the side_to_move variable in the position type above
 */

#define KING 0
#define QUEEN 1
#define ROOK 2
#define BISHOP 3
#define KNIGHT 4
#define PAWN 5

const char * piece_name[NUM_PIECES+1] = {"KING", "QUEEN", "ROOK", "BISHOP", "KNIGHT", "PAWN", NULL};
const char piece_char[NUM_PIECES+1] = {'K', 'Q', 'R', 'B', 'N', 'P', 0};

const char * colors[3] = {"WHITE", "BLACK", NULL};

unsigned char global_pieces[2][NUM_PIECES] = {{'K', 'Q', 'R', 'B', 'N', 'P'},
					      {'k', 'q', 'r', 'b', 'n', 'p'}};

#define WHITE 0
#define BLACK 1

/* Possibilities for pawn promotions.  "2" means queen and knight, but that can cause some problems,
 * as I've learned the hard (and embarrassing) way.  "4" is typical, but "5" is used for suicide
 * analysis, where promotion to king is allowed.
 */

int promotion_possibilities = 4;
int promoted_pieces[] = {QUEEN, ROOK, BISHOP, KNIGHT, KING};


/* Hoffman uses "dynamic structures" extensively, for its entries and proptable arrays.  A dynamic
 * structure is one whose bit layout is specified at run time by the XML control file.  Since we
 * can't use standard C structures (they require bit layouts to be set at compile time), we've got
 * to jump through hoops.  A lot of this is handled by 'bitlib'.
 *
 * Does it slow down the program?  You bet.  But for larger tablebases, which are disk bound and not
 * CPU bound, this actually speeds things up by giving us the flexibility of setting structure
 * layouts based on the needs of individual tablebases, and not having to use generic structures
 * big enough to accommodate every possibility.
 *
 * A 'struct format' gives the layout of such a dynamic structure.
 */

struct format {
    uint8_t bits;
    uint8_t bytes;
    int locking_bit_offset;
    uint32_t dtm_mask;
    int dtm_offset;
    uint8_t dtm_bits;
    uint32_t movecnt_mask;
    int movecnt_offset;
    uint8_t movecnt_bits;
    uint32_t index_mask;
    int index_offset;
    uint8_t index_bits;
    uint64_t futurevector_mask;
    int futurevector_offset;
    uint8_t futurevector_bits;
    int flag_offset;
    int flag_type;
    int PTM_wins_flag_offset;
    int basic_offset;
    int capture_possible_flag_offset;
};

const char * format_fields[] = {"dtm", "movecnt", "index-field", "futurevector", "flag", "ptm-wins-flag",
				"locking-bit", "basic", "capture-possible-flag", NULL};

#define FORMAT_FIELD_DTM 0
#define FORMAT_FIELD_MOVECNT 1
#define FORMAT_FIELD_INDEX 2
#define FORMAT_FIELD_FUTUREVECTOR 3
#define FORMAT_FIELD_FLAG 4
#define FORMAT_FIELD_PTM_WINS_FLAG 5
#define FORMAT_FIELD_LOCKING_BIT 6
#define FORMAT_FIELD_BASIC 7
#define FORMAT_FIELD_CAPTURE_POSSIBLE_FLAG 8

const char * format_flag_types[] = {"", "white-wins", "white-draws", NULL};

#define FORMAT_FLAG_NONE 0
#define FORMAT_FLAG_WHITE_WINS 1
#define FORMAT_FLAG_WHITE_DRAWS 2

#define MAX_FORMAT_BYTES 16

/* entries_format is the format that we use for in-memory tablebase arrays, and proptable_format is
 * the format for proptable entries.  Basically, the are C structures whose fields can be adjusted
 * at run-time.  If USE_CONST_FORMATS is set, then they're set at compile-time: 'const' for
 * efficiency, in a separate file for convenience, and if the program wants them changed, it will
 * let you know ;-)
 *
 * If the control file doesn't specify an entry (or proptable) format, we use a compiled-in default
 * from the 'formats.xml' file that got converted to a string in the 'tablebase_dtd.h' file.
 */

#define USE_CONST_FORMATS 0

#if USE_CONST_FORMATS
#include "formats.h"
#else
struct format entries_format;
struct format proptable_format;
#endif

#define ENTRIES_FORMAT_BITS (entries_format.bits)
#define ENTRIES_FORMAT_BYTES (entries_format.bytes)
#define ENTRIES_FORMAT_LOCKING_BIT_OFFSET (entries_format.locking_bit_offset)
#define ENTRIES_FORMAT_DTM_MASK (entries_format.dtm_mask)
#define ENTRIES_FORMAT_DTM_OFFSET (entries_format.dtm_offset)
#define ENTRIES_FORMAT_DTM_BITS (entries_format.dtm_bits)
#define ENTRIES_FORMAT_MOVECNT_MASK (entries_format.movecnt_mask)
#define ENTRIES_FORMAT_MOVECNT_OFFSET (entries_format.movecnt_offset)
#define ENTRIES_FORMAT_MOVECNT_BITS (entries_format.movecnt_bits)
#define ENTRIES_FORMAT_FLAG_OFFSET (entries_format.flag_offset)
#define ENTRIES_FORMAT_CAPTURE_POSSIBLE_FLAG_OFFSET (entries_format.capture_possible_flag_offset)

#define PROPTABLE_FORMAT_BYTES (proptable_format.bytes)
#define PROPTABLE_FORMAT_INDEX_MASK (proptable_format.index_mask)
#define PROPTABLE_FORMAT_INDEX_OFFSET (proptable_format.index_offset)
#define PROPTABLE_FORMAT_FUTUREVECTOR_BITS (proptable_format.futurevector_bits)
#define PROPTABLE_FORMAT_FUTUREVECTOR_MASK (proptable_format.futurevector_mask)
#define PROPTABLE_FORMAT_FUTUREVECTOR_OFFSET (proptable_format.futurevector_offset)
#define PROPTABLE_FORMAT_DTM_BITS (proptable_format.dtm_bits)
#define PROPTABLE_FORMAT_DTM_MASK (proptable_format.dtm_mask)
#define PROPTABLE_FORMAT_DTM_OFFSET (proptable_format.dtm_offset)
#define PROPTABLE_FORMAT_MOVECNT_MASK (proptable_format.movecnt_mask)
#define PROPTABLE_FORMAT_MOVECNT_OFFSET (proptable_format.movecnt_offset)
#define PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET (proptable_format.PTM_wins_flag_offset)


/* This is the "one-byte-dtm" format */

struct format one_byte_dtm_format = {3,1, -1, 0xff,0,8, 0,-1,0, 0,-1,0, 0,-1,0, -1,FORMAT_FLAG_NONE, -1, -1};

typedef void entry_t;


/* tablebase_t
 *
 * The 'xml' in the tablebase is authoritative; much of the other info is extracted from it
 * for efficiency.
 *
 * To make this work for either white or black positions, let's adopt the notation PTM (Player to
 * move) and PNTM (Player not to move)
 *
 * 'movecnt' is is the number of moves FORWARD from this position that haven't been analyzed yet,
 * with the high bit (128) set if PTM is in check.
 *
 * 'dtm' (Distance to Mate) is the number of moves required to force a mate.  It is positive
 * for a PTM mate and negative for a PNTM mate.
 *
 * Now PTM can mate with even a single move out of a position, so a postive dtm means PTM mates.
 * PNTM can only mate if PTM has no possible move that leads to mate, so a negative dtm coupled with
 * a 0 or 128 movecnt means PNTM mates.
 *
 * So, if we backtrace from a single PTM WINS, then this position becomes PTM WINS.  If we backtrace
 * from PNTM WINS, we decrement movecnt and adjust dtm to the lowest value (the slowest mate).  If
 * movecnt reaches 0 or 128, then the position becomes PNTM WINS.  When we're all done backtracing
 * possible wins, anything left with a non-zero movecnt, or a zero dtm, is a DRAW.
 *
 * We also need a mate-in count and a stalemate (conversion) count.
 *
 */

#define RESTRICTION_NONE 0
#define RESTRICTION_DISCARD 1
#define RESTRICTION_CONCEDE 2

const char * restriction_types[4] = {"NONE", "DISCARD", "CONCEDE", NULL};

#define FORMAT_FOURBYTE 0
#define FORMAT_ONE_BYTE_DTM 1

const char * formats[] = {"fourbyte", "one-byte-dtm", NULL};

#define NAIVE_INDEX 0
#define NAIVE2_INDEX 1
#define SIMPLE_INDEX 2
#define COMPACT_INDEX 3
#define NO_EN_PASSANT_INDEX 4
#define COMBINADIC_INDEX 5
#define COMBINADIC2_INDEX 6
#define COMBINADIC3_INDEX 7

const char * index_types[] = {"naive", "naive2", "simple", "compact", "no-en-passant", "combinadic", "combinadic2", "combinadic3"};

const char * futurebase_types[] = {"capture", "promotion", "capture-promotion", "normal"};

#define FUTUREBASE_CAPTURE 0
#define FUTUREBASE_PROMOTION 1
#define FUTUREBASE_CAPTURE_PROMOTION 2
#define FUTUREBASE_NORMAL 3

const char * variant_names[] = {"normal", "suicide"};

#define VARIANT_NORMAL 0
#define VARIANT_SUICIDE 1

typedef struct tablebase {
    int variant;
    int sub_variant;
    int index_type;
    index_t index_offset;
    index_t max_index;
    index_t max_uninverted_index;
    index_t modulus;
    int positions_with_adjacent_kings_are_illegal;
    int symmetry;

    /* Pieces are grouped into encoding groups to form indices */
    int total_legal_piece_positions[MAX_PIECES];
    int piece_position[MAX_PIECES][64];
    index_t piece_index[MAX_PIECES][64];
    int prev_piece_in_encoding_group[MAX_PIECES];
    int next_piece_in_encoding_group[MAX_PIECES];

    /* Kings are usual encoded together to take advantage of them never being adjacent */
    int white_king;
    int black_king;
    uint8_t white_king_position[64*64];
    uint8_t black_king_position[64*64];
    index_t king_index[64][64];
    uint total_legal_king_positions;

    struct format format;

    /* for futurebases only */
    void * file;
    char * filename;
    int futurebase_type;
    index_t next_read_index;
    off_t offset;
    int max_dtm;
    int min_dtm;
    int invert_colors;
    int extra_piece;
    int missing_pawn;
    int missing_non_pawn;

    xmlDocPtr xml;

    /* Pieces can restricted according to which squares they are allowed to move on.
     *
     * Legal squares are just that.
     *
     * "Semilegal" squares are squares that might be legal for a given piece, but we can't be sure
     * until we've considered other pieces in the position as well.  This becomes a factor when
     * we've got multiple identical pieces with overlapping, non-identical move restrictions.
     * Consider, for example, a tablebase with two rooks: one unrestricted, the other restricted to
     * its back rank.  Let's say we're moving a rook off the back rank.  If the other rook is on the
     * back rank, then the move is legal.  If the other rook is somewhere else, then the move would
     * be illegal.  So we make the entire board "semilegal" for both rooks, process the move
     * normally, and only when it's time to convert the entire position to an index in the tablebase
     * do we actually decide if the position is fully legal.
     *
     * "Identical" pieces are, well, identical - same color, same type, though if two otherwise
     * identical pieces have move restrictions that don't overlap (so they can't exchange places),
     * they're not considered identical.
     *
     * "Grouped" pieces are those encoded together, only their positions are encoded, not their
     * identities within the group.  They are usually identical pieces, but in the 'no-en-passant'
     * and 'combinadic3' schemes, pawns restricted to a single file using plus syntax are grouped,
     * even if they are not the same color.
     */

    int num_pieces;
    short num_pieces_by_color[2];
    short piece_type[MAX_PIECES];
    short piece_color[MAX_PIECES];
    uint64_t legal_squares[MAX_PIECES];
    uint64_t semilegal_squares[MAX_PIECES];
    uint64_t frozen_pieces_vector;
    int blocking_piece[MAX_PIECES];
    uint64_t illegal_black_king_squares;
    uint64_t illegal_white_king_squares;
    int last_identical_piece[MAX_PIECES];
    int next_identical_piece[MAX_PIECES];
    int reverse_index_ordering[MAX_PIECES];
    int *permutations[MAX_PIECES];

    int last_overlapping_piece[MAX_PIECES];

    int prune_enable[2];		/* one for each color */
    int stalemate_prune_type;		/* only RESTRICTION_NONE (0) or RESTRICTION_CONCEDE (2) allowed */
    int stalemate_prune_color;

    void * entries;

    char *futurevectors;
    int futurevector_bits;
} tablebase_t;

int zeros_fd = -1;

tablebase_t *current_tb = NULL;

tablebase_t **futurebases;
int num_futurebases;

    int using_proptables = 0;		/* Proptables (see below) */
int proptables_initialized = 0;
int proptable_MBs = 0;

int do_restart = 0;
int last_dtm_before_restart;

xmlNodePtr generation_statistics;
xmlNodePtr checkpoint_time;
xmlNodePtr positive_passes_needed_node, negative_passes_needed_node;
xmlNodePtr positive_passes_needed_text_node, negative_passes_needed_text_node;

xmlNodePtr user_time, system_time, real_time;
xmlNodePtr page_faults, page_reclaims;
xmlNodePtr contended_locks_node, contended_indices_node;


/* PROPTABLE_BITS for 16 byte entries:
 *
 * 8 = 256 entries = 4KB (testing)
 * 16 = 64K entries (what I've been using)
 * 20 = 1M entries = 16MB
 * 24 = 16M entries = 256MB
 */

#define LOCK_MEMORY 0

#define CHECK_KING_LEGALITY_EARLY 1

int verbose = 1;

/* Use '-d' option to set debug_move to an index in the current tablebase, or the negative of an
 * index in a futurebase to print more verbose debugging information about what the program is doing
 * to process a single move.
 */

index_t debug_move = INVALID_INDEX;
index_t debug_futuremove = INVALID_INDEX;
#define DEBUG_MOVE debug_move
#define DEBUG_FUTUREMOVE debug_futuremove


/***** UTILITY FUNCTIONS *****/

int fatal_errors = 0;

char * error_report_url = NULL;
char * completion_report_url = NULL;

#define MAX_FATAL_ERRORS 10

 __attribute__((noreturn)) void terminate (void)
{
#ifdef USE_LIBCURL
    void * file;
    xmlChar *buf;
    int size;
#endif

#ifdef HAVE_LIBTPIE
    if (proptables_initialized) tpie::tpie_finish();
#endif

    if (fatal_errors > 0) {
#ifdef USE_LIBCURL
	if (error_report_url != NULL) {
	    file = url_open(error_report_url, "w");
	    if ((current_tb != NULL) && (current_tb->xml != NULL)) {
		xmlDocDumpMemory(current_tb->xml, &buf, &size);
		url_write(file, (char *) buf, size);
		xmlFree(buf);
	    }
	    url_close(file);
	}
#endif
	exit(EXIT_FAILURE);
    } else {
#ifdef USE_LIBCURL
	if (completion_report_url != NULL) {
	    file = url_open(completion_report_url, "w");
	    if ((current_tb != NULL) && (current_tb->xml != NULL)) {
		xmlDocDumpMemory(current_tb->xml, &buf, &size);
		url_write(file, (char *) buf, size);
		xmlFree(buf);
	    }
	    url_close(file);
	}
#endif
	exit(EXIT_SUCCESS);
    }
}

void fatal (const char * format, ...)
{
    va_list va;
    static char strbuf[256] = {'\0'};

    /* BREAKPOINT */
    if (index(format, '\n') != NULL) fatal_errors ++;

    va_start(va, format);
    vfprintf(stderr, format, va);
    va_end(va);

    va_start(va, format);

    if ((current_tb != NULL) && (current_tb->xml != NULL)) {
	vsnprintf(strbuf + strlen(strbuf), sizeof(strbuf) - strlen(strbuf), format, va);
	if (index(strbuf, '\n') != NULL) {
	    xmlNodePtr tablebase = xmlDocGetRootElement(current_tb->xml);

	    *index(strbuf, '\n') = '\0';
	    xmlNodeAddContent(tablebase, BAD_CAST "   ");
	    xmlNewChild(tablebase, NULL, BAD_CAST "error", BAD_CAST strbuf);
	    xmlNodeAddContent(tablebase, BAD_CAST "\n");

	    memset(strbuf, 0, sizeof(strbuf));
	}
    }

    va_end(va);

    if (fatal_errors >= MAX_FATAL_ERRORS) terminate();
}

void warning (const char * format, ...)
{
    va_list va;

    va_start(va, format);
    fputs("WARNING: ", stderr);
    vfprintf(stderr, format, va);
    va_end(va);
}

void info (const char * format, ...)
{
    va_list va;

    va_start(va, format);
    if (verbose) vfprintf(stderr, format, va);
    va_end(va);
}

void sigaction_user_interrupt (int signal, siginfo_t * siginfo, void * ucontext)
{
    fatal("Interrupted by user\n");
    terminate();
}

void sigaction_internal_error (int signal, siginfo_t * siginfo, void * ucontext)
{
    fatal("Internal error: %s at 0x%08x\n", strsignal(signal), siginfo->si_addr);
    terminate();
}

/* Matches a string against a NULL-terminated array of strings using case insensitive match.
 * Returns index in array of matching string, or -1 if there was no match.
 */

int find_name_in_array(char * name, const char * array[])
{
    int i=0;

    if (name == NULL) return -1;

    while (*array != NULL) {
	if (!strcasecmp(name, *array)) return i;
	array ++;
	i ++;
    }

    return -1;
}

/* do_write() is like the system call write(), but keeps repeating until the write is complete */

int do_write(int fd, void *ptr, int length)
{
    char * cptr = (char *) ptr;

    while (length > 0) {
	int writ = write(fd, cptr, length);
	if (writ == -1) {
	    perror("do_write");
	    return -1;
	}
	cptr += writ;
	length -= writ;
    }
    return 0;
}

/* do_write_or_suspend() is like do_write(), but suspends the program on an error (like ENOSPC) */

int do_write_or_suspend(int fd, void *ptr, int length)
{
    char * cptr = (char *) ptr;

    while (length > 0) {
	int writ = write(fd, cptr, length);
	if (writ == -1) {
	    perror("do_write");
	    kill(getpid(), SIGSTOP);
	} else {
	    cptr += writ;
	    length -= writ;
	}
    }
    return 0;
}

/* These next few functions are here to make sure we don't get into pointer size issues on different
 * architectures, since the compression library interface in zlib_fopen.c takes pointers, and if
 * we're working with native files (and not a network URL), we just want to use file descriptors.
 */

ssize_t read_ptr(void * ptr, char * buf, size_t count)
{
    int fd = (size_t) ptr;
    return read(fd, buf, count);
}

ssize_t write_ptr(void * ptr, const char * buf, size_t count)
{
    int fd = (size_t) ptr;
    return write(fd, buf, count);
}

off_t lseek_ptr(void * ptr, off_t offset, int whence)
{
    int fd = (size_t) ptr;
    return lseek(fd, offset, whence);
}

ssize_t close_ptr(void * ptr)
{
    int fd = (size_t) ptr;
    return close(fd);
}

#define ROW(square) ((square) / 8)
#define COL(square) ((square) % 8)

inline int rowcol2square(int row, int col)
{
    return (col + row*8);
}

/* diagonal_reflection() flips along the a1/h8 diagonal by simply interchanging the row and column */

int diagonal_reflection(int square)
{
    return rowcol2square(COL(square), ROW(square));
}

int horizontal_reflection(int square)
{
    return rowcol2square(ROW(square), 7-COL(square));
}

int vertical_reflection(int square)
{
    return rowcol2square(7-ROW(square), COL(square));
}

void subtract_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec -= src->tv_sec;
    if (dest->tv_usec >= src->tv_usec) {
	dest->tv_usec -= src->tv_usec;
    } else {
	dest->tv_usec = 1000000 + dest->tv_usec - src->tv_usec;
	dest->tv_sec --;
    }
}

void add_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec += src->tv_sec;
    dest->tv_usec += src->tv_usec;
    if (dest->tv_usec >= 1000000) {
	dest->tv_usec -= 1000000;
	dest->tv_sec ++;
    }
}

void sprint_timeval(char *strbuf, struct timeval *timevalp)
{
    if (timevalp->tv_sec < 60) {
	sprintf(strbuf, "%ld.%03lds", timevalp->tv_sec, timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 3600) {
	sprintf(strbuf, "%ldm%02ld.%03lds", timevalp->tv_sec/60, timevalp->tv_sec%60,
		timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 24*3600) {
	sprintf(strbuf, "%ldh%02ldm%02ld.%03lds", timevalp->tv_sec/3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    } else {
	sprintf(strbuf, "%ldd%02ldh%02ldm%02ld.%03lds",
		timevalp->tv_sec/(24*3600), (timevalp->tv_sec/3600)%24,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    }
}

void fprint_system_time(void)
{
    struct rusage rusage;
    char strbuf[256];

    getrusage(RUSAGE_SELF, &rusage);
    sprint_timeval(strbuf, &rusage.ru_stime);
    fprintf(stderr, "System time: %s\n", strbuf);
}

void expand_per_pass_statistics(void)
{
    if (max_passes == 0) max_passes = 100;
    else max_passes *= 2;

    pass_type = (const char **) realloc(pass_type, max_passes * sizeof(const char *));
    pass_target_dtms = (int *) realloc(pass_target_dtms, max_passes * sizeof(int));
    positions_finalized = (int *) realloc(positions_finalized, max_passes * sizeof(int));
    backproped_moves = (uint64_t *) realloc(backproped_moves, max_passes * sizeof(uint64_t));

    /* not all of these arrays are cumulative, but just zero them all to be on the safe size */
    bzero(pass_type + total_passes, (max_passes-total_passes)*sizeof(char *));
    bzero(pass_target_dtms + total_passes, (max_passes-total_passes)*sizeof(int));
    bzero(positions_finalized + total_passes, (max_passes-total_passes)*sizeof(int));
    bzero(backproped_moves + total_passes, (max_passes-total_passes)*sizeof(uint64_t));
}

#ifdef USE_THREADS

inline void pthread_mutex_lock_instrumented(pthread_mutex_t * mutex)
{
    if (pthread_mutex_trylock(mutex) != 0) {
	pthread_mutex_lock(mutex);

	/* contended_locks ++; */
	(void) __sync_add(&contended_locks, 1);
    }
}

#endif

/***** MOVEMENT VECTORS *****/

/* The idea here is to calculate piece movements, and to do it FAST.
 *
 * We build a table of "movements" organized into "directions".  Each direction is just that - the
 * direction that a piece (like a queen) moves.  When we want to check for what movements are
 * possible in a given direction, we run through the direction until we "hit" another pieces - until
 * the bit in the vector matches something already in the position vector.  At the end of the
 * direction, an all-ones vector will "hit" the end of the board and end the direction.  I know,
 * kinda confusing.  It's because it's designed to be fast; we have to do this a lot.
 */

struct movement {
    uint64_t vector;
    short square;
};

/* we add one to NUM_MOVEMENTS to leave space at the end for the all-ones bitmask that signals the
 * end of the list
 */

struct movement movements[NUM_PIECES][NUM_SQUARES][NUM_DIR][NUM_MOVEMENTS+1];

/* Pawns are, of course, special.  We have seperate vectors for different types of pawn movements.
 * Each array is indexed first by square number, then by side (WHITE or BLACK - this doesn't exist
 * for other pieces), then by the number of possibilities (at most two normal movements, at most two
 * captures, and one more for the all-ones bitvector to terminate)
 *
 * All of these are FORWARD motions.
 */

struct movement normal_pawn_movements[NUM_SQUARES][2][3];
struct movement capture_pawn_movements[NUM_SQUARES][2][3];

struct movement normal_pawn_movements_bkwd[NUM_SQUARES][2][3];
struct movement capture_pawn_movements_bkwd[NUM_SQUARES][2][3];

/* How many different directions can each piece move in?  Knights have 8 directions because they
 * can't be blocked in any of them.  Pawns are handled separately.
 */

int number_of_movement_directions[NUM_PIECES] = {8,8,4,4,8,0};
int maximum_movements_in_one_direction[NUM_PIECES] = {1,7,7,7,1,0};

enum {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR, KNIGHTmove}
movementdir[5][8] = {
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* King */
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* Queen */
    {RIGHT, LEFT, UP, DOWN},						/* Rook */
    {DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},				/* Bishop */
    {KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove},	/* Knights are special... */
};



char algebraic_notation[64][3];

void init_movements()
{
    int square, piece, dir, mvmt, color;

    for (square=0; square < NUM_SQUARES; square++) {
	algebraic_notation[square][0] = 'a' + square%8;
	algebraic_notation[square][1] = '1' + square/8;
	algebraic_notation[square][2] = '\0';
    }

    for (piece=KING; piece <= KNIGHT; piece++) {

	for (square=0; square < NUM_SQUARES; square++) {

	    for (dir=0; dir < number_of_movement_directions[piece]; dir++) {

		int current_square = square;

		for (mvmt=0; mvmt < maximum_movements_in_one_direction[piece]; mvmt ++) {

#define RIGHT_MOVEMENT_POSSIBLE ((current_square%8)<7)
#define RIGHT2_MOVEMENT_POSSIBLE ((current_square%8)<6)
#define LEFT_MOVEMENT_POSSIBLE ((current_square%8)>0)
#define LEFT2_MOVEMENT_POSSIBLE ((current_square%8)>1)
#define UP_MOVEMENT_POSSIBLE (current_square<56)
#define UP2_MOVEMENT_POSSIBLE (current_square<48)
#define DOWN_MOVEMENT_POSSIBLE (current_square>7)
#define DOWN2_MOVEMENT_POSSIBLE (current_square>15)

		    switch (movementdir[piece][dir]) {
		    case RIGHT:
			if (RIGHT_MOVEMENT_POSSIBLE) {
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case LEFT:
			if (LEFT_MOVEMENT_POSSIBLE) {
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case UP:
			if (UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case DOWN:
			if (DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case DIAG_UL:
			if (LEFT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case DIAG_UR:
			if (RIGHT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case DIAG_DL:
			if (LEFT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case DIAG_DR:
			if (RIGHT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;
			}
			break;
		    case KNIGHTmove:
			current_square=square;
			switch (dir) {
			case 0:
			    if (RIGHT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 1:
			    if (RIGHT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 2:
			    if (LEFT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 3:
			    if (LEFT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 4:
			    if (RIGHT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 5:
			    if (RIGHT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 6:
			    if (LEFT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			case 7:
			    if (LEFT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = ALL_ONES_BITVECTOR;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = ALL_ONES_BITVECTOR;
			    }
			    break;
			}
			break;

		    }
		}

		/* Always put an ALL_ONES_BITVECTOR at the end of the movement vector
		 * to make sure we stop!
		 */

		movements[piece][square][dir][mvmt].square = -1;
		movements[piece][square][dir][mvmt].vector = ALL_ONES_BITVECTOR;

	    }
	}
    }

    /* Now for the pawns... */

    for (square=0; square < NUM_SQUARES; square ++) {

	for (color = WHITE; color <= BLACK; color ++) {

	    int forwards_pawn_move = ((color == WHITE) ? 8 : -8);
	    int backwards_pawn_move = ((color == WHITE) ? -8 : 8);

	    /* Forward pawn movements
	     *
	     * An ordinary pawn move... unless its a white pawn on the second rank, or a black
	     * pawn on the seventh.  In these two cases, there is a possible double move as
	     * well.
	     */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		normal_pawn_movements[square][color][mvmt].square = square + forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + forwards_pawn_move);

		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 1)) || ((color == BLACK) && (ROW(square) == 6))) {

		normal_pawn_movements[square][color][mvmt].square = square + 2*forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + 2*forwards_pawn_move);

		mvmt ++;

	    }

	    normal_pawn_movements[square][color][mvmt].square = -1;
	    normal_pawn_movements[square][color][mvmt].vector = ALL_ONES_BITVECTOR;

	    /* Backwards pawn movements */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + backwards_pawn_move);
		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 3)) || ((color == BLACK) && (ROW(square) == 4))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + 2*backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + 2*backwards_pawn_move);
		mvmt ++;
	    }

	    normal_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    normal_pawn_movements_bkwd[square][color][mvmt].vector = ALL_ONES_BITVECTOR;

	    /* Forward pawn captures. */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		if (COL(square) > 0) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move - 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move + 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements[square][color][mvmt].square = -1;
	    capture_pawn_movements[square][color][mvmt].vector = ALL_ONES_BITVECTOR;

	    /* Backwards pawn captures */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		if (COL(square) > 0) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move - 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move + 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    capture_pawn_movements_bkwd[square][color][mvmt].vector = ALL_ONES_BITVECTOR;

	}

    }

}

/* This routine is pretty fast, so I just call it once every time the program runs.  It has to be
 * used after any changes to the code above to verify that those complex movement vectors are
 * correct, or at least consistent.  We're using this in a game situation.  We can't afford bugs in
 * this code.
 */

void verify_movements()
{
    int piece;
    int squareA, squareB;
    int dir;
    int color;
    struct movement * movementptr;
    int pawn_option;

    /* For everything except pawns, if it can move from A to B, then it better be able to move from
     * B to A...
     */

    for (piece=KING; piece <= KNIGHT; piece ++) {

	for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

	    for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		int movement_possible = 0;
		int reverse_movement_possible = 0;

		/* check for possible self-movement, if A and B are the same square */

		if (squareA == squareB) {
		    for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {
			for (movementptr = movements[piece][squareA][dir];
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != ALL_ONES_BITVECTOR)) {
			    fatal("Self movement possible!? %s %d %d\n",
				  piece_name[piece], squareA, movementptr->square);
			}
		    }
		    continue;
		}

		/* check for possible A to B move */

		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareA][dir];
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fatal("Bad movement square: %s %d %d %d\n",
				  piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != ALL_ONES_BITVECTOR) {
			    fatal("-1 movement lacks ALL_ONES_BITVECTOR: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fatal("Bad movement square: %s %d %d\n", piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fatal("bitvector does not match destination square: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fatal("multiple idential destinations from same origin: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == ALL_ONES_BITVECTOR) {
			    fatal("ALL_ONES_BITVECTOR on a legal movement: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    }
		}


		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareB][dir];
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;
		}


		if (movement_possible && !reverse_movement_possible) {
		    fatal("reverse movement impossible: %s %d %d\n", piece_name[piece], squareA, squareB);
		}

	    }
	}
    }

    /* Pawns are special */

    piece = PAWN;

    for (pawn_option = 0; pawn_option < 4; pawn_option ++) {

	struct movement * fwd_movement;
	struct movement * rev_movement;

	for (color = WHITE; color <= BLACK; color ++) {

	    /* fprintf(stderr, "Pawn option %d; color %s\n", pawn_option, colors[color]); */

	    for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

		for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		    int movement_possible = 0;
		    int reverse_movement_possible = 0;

		    switch (pawn_option) {
		    case 0:
			fwd_movement = normal_pawn_movements[squareA][color];
			rev_movement = normal_pawn_movements_bkwd[squareB][color];
			break;
		    case 1:
			fwd_movement = normal_pawn_movements_bkwd[squareA][color];
			rev_movement = normal_pawn_movements[squareB][color];
			break;
		    case 2:
			fwd_movement = capture_pawn_movements[squareA][color];
			rev_movement = capture_pawn_movements_bkwd[squareB][color];
			break;
		    case 3:
			fwd_movement = capture_pawn_movements_bkwd[squareA][color];
			rev_movement = capture_pawn_movements[squareB][color];
			break;
		    default:
			fatal("Internal error: pawn_option not in [0,3]");
			return;
		    }

		    /* check for self-movement */

		    if (squareA == squareB) {
			for (movementptr = fwd_movement;
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != ALL_ONES_BITVECTOR)) {
			    fatal("Self movement possible!? PAWN %d %d\n", squareA, movementptr->square);
			}
		    }

		    /* check for possible A to B move */

		    for (movementptr = fwd_movement;
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fatal("Bad movement square: %s %d %d %d\n",
				  piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != ALL_ONES_BITVECTOR) {
			    fatal("-1 movement lacks ALL_ONES_BITVECTOR: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fatal("Bad movement square: %s %d %d\n", piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fatal("bitvector does not match destination square: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fatal("multiple idential destinations from same origin: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == ALL_ONES_BITVECTOR) {
			    fatal("ALL_ONES_BITVECTOR on a legal movement: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    }


		    /* check for possible B to A reverse move */

		    for (movementptr = rev_movement;
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;

		    if (movement_possible && !reverse_movement_possible) {
			fatal("reverse movement impossible: %s %d %d\n",
			      piece_name[piece], squareA, squareB);
		    }
		}
	    }
	}
    }
}


/***** INDICES *****/

/* Basically there are two functions here - one converts an index to a local position, the other
 * converts a local position to an index - but they exist in several different versions, depending
 * on the type of index we're using for a particular tablebase.  These functions are used
 * extensively during all types of back propagation.
 *
 * local_position_to_index() returns either an index into the table, or -1 if the position is
 * illegal.  The only change it makes to the position is to set the multiplicity.
 *
 * index_to_local_position(), given an index, fills in a board position.  Obviously has to correspond
 * to local_position_to_index() and it's a big bug if it doesn't.  The boolean that gets returned is
 * TRUE if the operation succeeded and FALSE if the index was illegal.
 *
 * Several issues crop up for all index types.
 *
 * What exactly is an illegal position?  Well, for starters, one that index_to_local_position()
 * reports as illegal, because that's the function that initialize_tablebase() uses to figure which
 * positions are flagged illegal, as well as which positions to consider during back prop, and the
 * program screams if you try to back prop into an illegal position.  So the two functions have to
 * agree on illegality.  But there's also a subtle interaction between the legality tests here and
 * the move counting code in initialize_tablebase().  If we count a move, and it's not considered a
 * futuremove, then it'd better lead to a legal position, because we'll never backprop from an
 * illegal one, and that would imbalance the forward and reverse move counting.  For speed purposes,
 * the move counting code currently does not actually check positions to see if they are illegal.
 *
 * En passant.  This is another case where subtle concepts of "legality" show up.  When we back
 * propagate a local position from either a futurebase or intratable, we generate en passant
 * positions simply by running through the pawns on the fourth and fifth ranks.  We look then to see
 * if there was a piece behind the "en passant" pawn (that would have prevented it from moving), but
 * (unlike Nalimov) we don't check if there is an enemy pawn that actually could have captured.
 * Again, the code has to match up between the two places, or we would try to back propagate to a
 * position that had been labeled illegal during initialization by index_to_local_position().
 *
 * Identical pieces.  Identical positions need to generate identical indices.  If we have two
 * identical pieces, then transposing them in a position can't affect the outcome of
 * local_position_to_index().  Right now, I deal with this by making a copy of the local position
 * and sorting identical pieces into ascending position numbers.
 *
 * So how about a static 64-bit vector with bits set for pieces frozen on a single square?
 * Everytime we call index_to_local_position, copy from the static vector into the position
 * structure.  Then we compute the positions of the mobile pieces and plug their bits into the
 * structure's vector at the right places.  Might implement this some day.
 */

boolean check_king_legality(int kingA, int kingB) {
    if ((ROW(kingA) < ROW(kingB) - 1) || (ROW(kingA) > ROW(kingB) + 1)) return 1;
    if ((COL(kingA) < COL(kingB) - 1) || (COL(kingA) > COL(kingB) + 1)) return 1;
    return 0;
}

/* Later in the program, I'll use these indices as the keys in an address calculation insertion
 * sort.  This kind of sort performs well if the keys are evenly distributed, and performs horribly
 * if the keys are clumped together.  Since checkmates occur in groups of similar positions,
 * something has to be done.  "Something" is inversion of the indices in a finite field,
 * specifically a modulo ring with a prime modulus.  The modulus is either specified in the XML
 * configuration or computed automatically.
 *
 * Originally, I used the HalfExtendedEuclidian algorithm from Manuel Bronstein's book "Symbolic
 * Integration I".  In the hopes a speed improvement, I switched to using a binary extended GCD
 * algorithm on the advice of Prof. Christof Paar.  The speed improvement wasn't there, but I've
 * stuck with the newer algorithm because it avoids multiplications and divisions, using only right
 * shifts and subtractions, and should therefore be easier to implement for 64-bit indices on a
 * 32-bit architecture.  Also, I've since realized that because we only use this algorithm when the
 * program becomes disk-bound, the speed issue is (mostly) negligible.
 *
 * The binary extended GCD algorithm is based on computing a GCD by repeatedly subtracting the
 * smaller number from the larger one.  A consideration of the equation c = a - b shows that a
 * common multiple of any two of the numbers must be a common multiple of the third (unless it is
 * zero).  Therefore, subtracting preserves common multiples in the result and does not introduce
 * any new common multiples.  Because we are working with a binary architecture, detecting multiples
 * of two is easy, and we can eliminate them by right shifting.  Since subtracting two odd numbers
 * gives an even number, we can right shift by at least one bit per iteration.  Combining the two
 * operations of subtraction and right shifting, we get a GCD algorithm (14.61 in Menezes' Handbook
 * of Applied Cryptography) that requires more iterations than the extended Euclidian algorithm, but
 * still completes in a reasonable time and avoids both multiplication and division.
 *
 * Consider an array of number x[n].  To compute gcd(a,b), we set up x[0]=a and x[1]=b, then
 * repeatedly apply the algorithm below, which preserves the gcd at each step, i.e, each x[n] is a
 * multiple of gcd(a,b).  Each x[n] can be written in terms of a and b: x[n] = a[n] * a + b[n] * b.
 * If a was the prime modulus of our finite field, then finally x[n] = gcd(a,b) = 1, so:
 *
 *        1 = a[n] * a + b[n] * b
 *
 *        1 = b[n] * b  (mod a)
 *
 * i.e, b[n] is the multiplicative inverse of b (mod a).
 *
 * So we need to track the b[n] part of x[n] = a[n] * a + b[n] * b until we reach the GCD of 1.
 *
 * Subtracting (x[n+1] = x[n] - x[n-1]) is easy:
 *
 *                a[n+1] = a[n] - a[n-1]    and    b[n+1] = b[n] - b[n-1]
 *
 * Right shifting (division by 2) is only a little more difficult.  Let's first note that if x[n] is
 * even (the only case in which we'd be right shifting) and a is odd (it's a prime modulus, after
 * all), then either a[n] is even or a[n] and b[n] must both be odd.  So if b[n] is even, then a[n]
 * is also even and we can right shift everything: x[n]/2 = a[n]/2 * a + b[n]/2 * b, while if
 * b[n] is odd, we can add and subtract a * b to obtain:
 *
 *             x[n] = (a[n] + b) * a + (b[n] - a) * b
 *
 *             x[n]/2 = (a[n] + b)/2 * a + (b[n] - a)/2 * b
 *
 * Remember that a[n] gets discarded; b[n] is all we care about computing.
 *
 * So our operations are:
 *
 *    subtract (x > y)    x = x - y                            b[x] = (b[x] - b[y]) mod m
 *
 *    subtract (y > x)    y = y - x                            b[y] = (b[y] - b[x]) mod m
 *
 *    right shift x (b[x] even)     x = x / 2                  b[x] = b[x] / 2
 *
 *    right shift x (b[x] odd)      x = x / 2                  b[x] = ((b[x] - m) / 2) mod m
 *
 *                                                         or  b[x] = ((b[x] + m) / 2) mod m
 *
 * m    -> EAX
 * x    -> EBX
 * y    -> ECX
 * (m+1)/2 -> EDX
 * b[x] -> ESI
 * b[y] -> EDI
 *
 * This is a GNU compiler, so we use AT&T assembler syntax - the destination comes second.
 */

#ifdef i386

uint32_t invert_in_finite_field(uint32_t b, uint32_t m)
{
    asm("                                                                                       \
                /* Input                                                                    */  \
                /*                                                                          */  \
                /* EAX - modulus                                                            */  \
                /* ECX - index                                                              */  \
                                                                                                \
                mov %%eax, %%ebx;                                                               \
                mov $0, %%esi;                                                                  \
                mov $1, %%edi;                                                                  \
                                                                                                \
                mov %%eax, %%edx;                                                               \
                add $1, %%edx;                                                                  \
                shr %%edx;                                                                      \
                                                                                                \
                /* while ((y&1) == 0)                                                       */  \
                                                                                                \
           1:   test $1, %%ecx;                                                                 \
                jne 2f;                                                                         \
                                                                                                \
                /*     y >>= 1;                                                             */  \
                shr %%ecx;                                                                      \
                                                                                                \
                /*     if ((by&1) == 0) {                                                   */  \
                /*        by >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        by = ((by + m)/2) mod m;                                          */  \
                /*        by = (((by-1 + m+1)/2) mod m;                                     */  \
                /*        by = ((by-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%edi;                                                                      \
                jnc 1b;                                                                         \
                add %%edx, %%edi;                                                               \
                cmp %%eax, %%edi;                                                               \
                jc  1b;                                                                         \
                sub %%eax, %%edi;                                                               \
                jmp 1b;                                                                         \
                                                                                                \
           2:   /* Is x = y ?  Is x > y ?                                                   */  \
                cmp %%ecx, %%ebx;                                                               \
                jz  6f;                                                                         \
                jc  4f;                                                                         \
                                                                                                \
                /* Yes, x > y                                                               */  \
                /* Set x = x - y                                                            */  \
                sub %%ecx, %%ebx;                                                               \
                                                                                                \
                /* Set b[x] = (b[x] - b[y]) mod m                                           */  \
                sub %%edi, %%esi;                                                               \
                jnc 3f;                                                                         \
                add %%eax, %%esi;                                                               \
                                                                                                \
                /* while ((x&1) == 0)                                                       */  \
                                                                                                \
           3:   test $1, %%ebx;                                                                 \
                jne 2b;                                                                         \
                                                                                                \
                /*     x >>= 1;                                                             */  \
                shr %%ebx;                                                                      \
                                                                                                \
                /*     if ((bx&1) == 0) {                                                   */  \
                /*        bx >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        bx = ((bx + m)/2) mod m;                                          */  \
                /*        bx = (((bx-1 + m+1)/2) mod m;                                     */  \
                /*        bx = ((bx-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%esi;                                                                      \
                jnc 3b;                                                                         \
                add %%edx, %%esi;                                                               \
                cmp %%eax, %%esi;                                                               \
                jc  3b;                                                                         \
                sub %%eax, %%esi;                                                               \
                jmp 3b;                                                                         \
                                                                                                \
                /* y > x                                                                    */  \
                /* Set y = y - x                                                            */  \
           4:   sub %%ebx, %%ecx;                                                               \
                                                                                                \
                /* Set b[y] = (b[y] - b[x]) mod m                                           */  \
                sub %%esi, %%edi;                                                               \
                jnc 1b;                                                                         \
                add %%eax, %%edi;                                                               \
                                                                                                \
                jmp 1b;                                                                         \
                                                                                                \
           6:   mov %%edi, %%ecx;                                                               \
                                                                                                \
                          " : "+c" (b) : "a" (m) : "bx", "dx", "di", "si", "cc");
    return b;
}

#else

uint32_t invert_in_finite_field(uint32_t b, uint32_t m)
{
    uint32_t x = m;
    uint32_t y = b;
    uint32_t bx = 0;
    uint32_t by = 1;

    while ((y&1) == 0) {
	y >>= 1;
	if ((by&1) == 0) {
	    by >>= 1;
	} else {
	    by = ((by + m)/2)%m;
	}
    }

    while (x != y) {
	if (x > y) {
	    x = x - y;

	    if (bx > by) bx = (bx - by)%m;
	    else bx = (m + bx - by)%m;

	    while ((x&1) == 0) {
		x >>= 1;
		if ((bx&1) == 0) {
		    bx >>= 1;
		} else {
		    bx = ((bx + m)/2)%m;
		}
	    }
	} else {
	    y = y - x;

	    if (by > bx) by = (by - bx)%m;
	    else by = (m + by - bx)%m;

	    while ((y&1) == 0) {
		y >>= 1;
		if ((by&1) == 0) {
		    by >>= 1;
		} else {
		    by = ((by + m)/2)%m;
		}
	    }
	}
    }
    if (x != 1) fatal("x != 1 in invert_finite_field\n");

    return by;
}

#endif

/* Inversion in a finite field only works if the modulus is prime, so we need some routines to test
 * a number for primality and to round a number up to the next prime.  Because our numbers are all
 * fairly small (as prime numbers go), and since these routines are run at most once per tablebase
 * load, some very simple algorithms suffice.
 */

boolean is_prime(uint32_t test_number)
{
    uint32_t divisor, sqrt_test_number;

    /* Quick, easy check to see if it's even (and thus can't be prime) */
    if ((test_number % 2) == 0) return 0;

    /* Now, check all odd numbers from 3 up to its square root to see if any divide it */
    sqrt_test_number = (uint32_t) sqrt((double) test_number);
    for (divisor = 3; divisor <= sqrt_test_number; divisor += 2) {
	if ((test_number % divisor) == 0) return 0;
    }

    /* OK, it's prime */
    return 1;
}

uint32_t round_up_to_prime(uint32_t starting_number)
{
    uint32_t number = starting_number;

    if (number % 2 == 0) number ++;

    while (! is_prime(number)) number += 2;

    if (number < starting_number) {
	fatal("Wraparound in round_up_to_next_prime\n");
    }

    return number;
}

/* "Naive" index.  Just assigns a number from 0 to 63 to each square on the board and multiplies
 * them together for the various pieces.  Simple and fast.  Actually is now a little more complex in
 * its white king encoding, since it works with 2-way and 4-way symmetry.
 */

index_t local_position_to_naive_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index |= COL(pos->en_passant_square) << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else if ((piece == tb->white_king) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == tb->white_king) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else {
	    index |= pos->piece_position[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	}
    }

    return index;
}

boolean naive_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square;

	if ((tb->symmetry == 2) && (piece == tb->white_king)) {
	    square = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == tb->white_king)) {
	    square = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else {
	    square = index & 63;
	    index >>= 6;
	}

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which indices are legal and which are
	 * not.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Naive2" index.  Assigns a number from 0 to 63 to each square on the board and multiplies them
 * together for the various pieces.  Differs from "naive" in its handling of multiple identical
 * pieces, which it stores as a base and an offset, thus saving a single bit.  Currently, only
 * pairs of identical pieces are correctly handled.
 */

index_t local_position_to_naive2_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;
    uint8_t vals[MAX_PIECES];

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = COL(pos->en_passant_square);
	} else {
	    vals[piece] = pos->piece_position[piece];
	}
    }

    /* What's all this?
     *
     * The idea is to encode two identical pieces using one less bit than needed for encoding them
     * separately, because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (tb->next_piece_in_encoding_group[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_piece_in_encoding_group[piece]])
		 && (vals[piece] + 32 < vals[tb->next_piece_in_encoding_group[piece]]))
		|| ((vals[tb->next_piece_in_encoding_group[piece]] < vals[piece])
		    && (vals[tb->next_piece_in_encoding_group[piece]] + 32 >= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_piece_in_encoding_group[piece]];
		vals[tb->next_piece_in_encoding_group[piece]] = val;
	    }
	}

	if ((piece == tb->white_king) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == tb->white_king) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if (tb->prev_piece_in_encoding_group[piece] == -1) {
	    index |= vals[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else {
	    if (vals[piece] > vals[tb->prev_piece_in_encoding_group[piece]]) {
		index |= (vals[piece] - vals[tb->prev_piece_in_encoding_group[piece]] - 1) << shift_count;
	    } else {
		index |= (64 + vals[piece] - vals[tb->prev_piece_in_encoding_group[piece]] - 1) << shift_count;
	    }
	    shift_count += 5; /* the whole point of "naive2" */
	}
    }

    return index;
}

boolean naive2_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8_t vals[MAX_PIECES];

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	if ((tb->symmetry == 2) && (piece == tb->white_king)) {
	    vals[piece] = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == tb->white_king)) {
	    vals[piece] = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else if (tb->prev_piece_in_encoding_group[piece] == -1) {
	    vals[piece] = index & 63;
	    index >>= 6;
	} else {
	    vals[piece] = (vals[tb->prev_piece_in_encoding_group[piece]] + (index & 31) + 1) % 64;
	    index >>= 5;

	    if (vals[piece] < vals[tb->prev_piece_in_encoding_group[piece]]) {
		unsigned char val;

		/* One of the important tasks of any index_to_local_position() function is to return
		 * false on all but one of the indices that correspond to identical positions.
		 * Here, that can only happen when two grouped pieces are exactly 32 squares apart,
		 * which can be encoded using either piece first.  In this case, we toss out the
		 * index with the larger of the two squares encoded as the base value, and make sure
		 * that the "<" and the ">=" match up just right in the previous function.
		 */

		if (vals[tb->prev_piece_in_encoding_group[piece]] - vals[piece] == 32) return 0;

		val = vals[piece];
		vals[piece] = vals[tb->prev_piece_in_encoding_group[piece]];
		vals[tb->prev_piece_in_encoding_group[piece]] = val;
	    }
	}

    }

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square = vals[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which indices are legal and which are
	 * not.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Simple" index.  Like naive, but only assigns numbers to squares that are legal for a particular
 * piece.  Slower to compute than naive, but more compact for tablebases with lots of movement
 * restrictions on the pieces.
 */

index_t local_position_to_simple_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	index *= tb->total_legal_piece_positions[piece];

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index += tb->piece_index[piece][COL(pos->en_passant_square)];
	} else {
	    index += tb->piece_index[piece][pos->piece_position[piece]];
	}
    }

    /* We've still got code that assumes flipping the index's LSB flip side-to-move */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean simple_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index % 2;
    index /= 2;

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = tb->piece_position[piece][index % tb->total_legal_piece_positions[piece]];
	index /= tb->total_legal_piece_positions[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* This should never happen. */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    fatal("Illegal piece position in simple_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }

    if (index != 0) {
	fatal("index != 0 at end of simple_index_to_local_position!\n");
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "compact" index
 *
 * A combination of the delta encoding for identical pieces used in "naive2", the encoding of
 * restricted pieces used in "simple", plus a paired encoding of the kings so they can never be
 * adjacent.
 *
 * Pairs of identical pieces can be handled in at least three ways that I can think of:
 *
 * 1. Treat the pieces as paired and encode using the full semilegal range for each of them, using
 * delta encoding to cut the total size in half, and then throw out as illegal those positions where
 * the pieces can't be put onto legal squares.  Makes the most sense if the move restrictions are
 * completely overlapping.
 *
 * 2. Treat the pieces as independent and encode each using its legal range, and then throw out as
 * illegal half of those positions where both the pieces are on interchangable legal squares.  Makes
 * the most sense if one of the move restrictions is significantly smaller than the other.
 *
 * 3. Build an array in memory like we do with the kings to encode only the legal possibilities.  No
 * bogus illegal positions here, but doesn't really scale to more than two pieces.
 *
 * 4. Use a combinadic encoding that encodes n selections from k objects, without replacement,
 * unordered.
 *
 * Right now, we use method (1) in the 'compact', 'naive2', and 'no-en-passant' schemes, method (4)
 * in the combinadic schemes, and method (2) everywhere else.
 *
 * Some additional things could be done to make an even more compact encoding:
 *
 * Take advantage of previous pieces occupying squares to cut encoding down from 64*64*64*...  to
 * 64*63*62*...  Actually, since we've already got the kings encoded pretty compactly, it would be
 * cutting down from 64*64*64*... to 62*61*60*...  Move restrictions would complicate this; maybe
 * only do it for pieces whose move restriction can be fit entirely in the move restrictions of
 * previous pieces.
 *
 * Encode en passant position-wide instead of adding an extra square for each pawn.  Would be a win
 * in positions with lots of pawns.
 *
 * The 'compact' routines are also used for the 'no-en-passant' index type, which is identical to
 * compact except that opposing plus-pawns are encoded in the same group.  So long as we leave en
 * passant out of the picture, opposing plus-pawns occupy an identical range of squares and, so long
 * as we know which two squares are occupied, we can always figure out which pawn is white and which
 * is black because they can't jump over each other.  En passant would complicate this, because then
 * the two pawns wouldn't be identical in their ranges.
 */

index_t local_position_to_compact_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;
    uint8_t vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = tb->piece_index[piece][COL(pos->en_passant_square)];
	} else {
	    vals[piece] = tb->piece_index[piece][pos->piece_position[piece]];
	}
    }

    /* Compute the index.
     *
     * We encode two identical pieces using one less bit than needed for encoding them separately,
     * because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if (piece == tb->white_king) {
	    index *= tb->total_legal_king_positions;
	    index += tb->king_index[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->next_piece_in_encoding_group[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_piece_in_encoding_group[piece]])
		 && (vals[piece] + tb->total_legal_piece_positions[piece]/2
		     < vals[tb->next_piece_in_encoding_group[piece]]))
		|| ((vals[tb->next_piece_in_encoding_group[piece]] < vals[piece])
		    && (vals[tb->next_piece_in_encoding_group[piece]] + tb->total_legal_piece_positions[piece]/2
			>= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_piece_in_encoding_group[piece]];
		vals[tb->next_piece_in_encoding_group[piece]] = val;
	    }
	}

	if (tb->prev_piece_in_encoding_group[piece] == -1) {
	    index *= tb->total_legal_piece_positions[piece];
	    index += vals[piece];
	} else {
	    index *= tb->total_legal_piece_positions[piece] / 2;

	    if (vals[piece] > vals[tb->prev_piece_in_encoding_group[piece]]) {
		index += (vals[piece] - vals[tb->prev_piece_in_encoding_group[piece]] - 1);
	    } else {
		index += (tb->total_legal_piece_positions[piece] + vals[piece] - vals[tb->prev_piece_in_encoding_group[piece]] - 1);
	    }
	}
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean compact_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8_t vals[MAX_PIECES];
    int king_index = 0;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index % 2;
    index /= 2;

    /* First, split index into an array of encoding values. */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if (piece == tb->white_king) {
	    king_index = index % tb->total_legal_king_positions;
	    index /= tb->total_legal_king_positions;
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->prev_piece_in_encoding_group[piece] == -1) {
	    vals[piece] = index % tb->total_legal_piece_positions[piece];
	    index /= tb->total_legal_piece_positions[piece];
	} else {
	    vals[piece] = index % (tb->total_legal_piece_positions[piece]/2);
	    index /= tb->total_legal_piece_positions[piece]/2;
	}
    }

    /* Next, back out any delta encoding and convert the encoding numbers to square numbers on the
     * board.  This loop has to run in reverse order over the pieces, since the delta encodings are
     * based on previous encoding numbers, and we're converting to square numbers as we go.  We run
     * a seperate loop here because we might need previous encoding values to back out the deltas.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->prev_piece_in_encoding_group[piece] != -1) {

	    vals[piece] += vals[tb->prev_piece_in_encoding_group[piece]] + 1;
	    vals[piece] %= tb->total_legal_piece_positions[piece];

	    /* One of the important tasks of any index_to_local_position() function is to return
	     * false on all but one of the indices that correspond to identical positions.  Here,
	     * that can only happen when two grouped pieces are exactly half their total legal piece
	     * positions squares apart, which can be encoded using either piece first.  In this
	     * case, we toss out the index with the larger of the two squares encoded as the base
	     * value, and make sure that the "<" and the ">=" match up just right in the previous
	     * function.
	     */

	    if (vals[tb->prev_piece_in_encoding_group[piece]] - vals[piece]
		== tb->total_legal_piece_positions[piece]/2) return 0;
	}

	vals[piece] = tb->piece_position[piece][vals[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (vals[piece] < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 2*8;
		vals[piece] += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 5*8;
		vals[piece] += 4*8;
	    }
	}

    }

    /* Now we have to decide the actual ordering in the piece array.  Right now, since we only use
     * this code for pairs of identical pieces, we swap if the higher numbered piece is first, then
     * swap (maybe again) if the pieces aren't on legal squares.  The net result is to put them both
     * on legal squares, if possible, and to put the lower numbered square first if both
     * possibilities are legal.
     *
     * This loop also has to run in reverse order for the swap code to work right.  We run a
     * seperate loop here because the legality checks are based on square numbers and not encoding
     * values, and we need for all the previous encoding values to have been converted into square
     * numbers first.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->prev_piece_in_encoding_group[piece] != -1) {

	    if (vals[piece] < vals[tb->prev_piece_in_encoding_group[piece]]) {
		uint8_t val = vals[piece];
		vals[piece] = vals[tb->prev_piece_in_encoding_group[piece]];
		vals[tb->prev_piece_in_encoding_group[piece]] = val;
	    }

	    if (! (tb->legal_squares[piece] & BITVECTOR(vals[piece]))
		|| ! (tb->legal_squares[tb->prev_piece_in_encoding_group[piece]]
		      & BITVECTOR(vals[tb->prev_piece_in_encoding_group[piece]]))) {

		uint8_t val = vals[piece];
		vals[piece] = vals[tb->prev_piece_in_encoding_group[piece]];
		vals[tb->prev_piece_in_encoding_group[piece]] = val;
	    }
	}
    }

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = vals[piece];

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in compact_index_to_local_position!\n"); */
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    p->piece_position[tb->white_king] = tb->white_king_position[king_index];
    p->piece_position[tb->black_king] = tb->black_king_position[king_index];
    if (p->board_vector & BITVECTOR(p->piece_position[tb->white_king])) return 0;
    if (p->board_vector & BITVECTOR(p->piece_position[tb->black_king])) return 0;
    p->board_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    p->board_vector |= BITVECTOR(p->piece_position[tb->black_king]);
    if (p->side_to_move == WHITE)
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    else
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->black_king]);

#if 0
    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }
#endif

    if (index != 0) {
	fatal("index != 0 at end of compact_index_to_local_position!\n");
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "combinadic" index
 *
 * The encoding of restricted pieces used in "simple", paired encoding of the kings so they can
 * never be adjacent, and a combinatorial-based encoding of identical pieces.
 */

void transpose_array(uint8_t *array, int index1, int index2)
{
    uint8_t tmp = array[index2];
    array[index2] = array[index1];
    array[index1] = tmp;
}

index_t local_position_to_combinadic_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;
    uint8_t vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    /* vals[piece] = tb->piece_index[piece][COL(pos->en_passant_square)]; */
	    vals[piece] = COL(pos->en_passant_square);
	} else {
	    /* vals[piece] = tb->piece_index[piece][pos->piece_position[piece]]; */
	    vals[piece] = pos->piece_position[piece];
	}
    }

    /* Sort identical pieces so that the lowest values always come first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	int piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (vals[piece2] < vals[tb->last_identical_piece[piece2]])) {
	    transpose_array(vals, piece2, tb->last_identical_piece[piece2]);
	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* Kings have their own encoding table */

	if (piece == tb->white_king) {
	    index += 2 * tb->king_index[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	index += tb->piece_index[piece][vals[piece]];
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean combinadic_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index % 2;
    index -= p->side_to_move;

    /* Each piece will have position values assigned to it multiplied by a multiplier for the set of
     * identical pieces.  We search for the largest value in piece_index[] that is less
     * than the index and convert the encoding numbers to square numbers on the board.  This works
     * if identical pieces are grouped together.  This loop has to run in reverse order over the
     * pieces, since a combinadic encoding should be backed out from the largest piece first.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square;

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
	     (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
	     (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

	    if ((tb->piece_index[piece][square] != INVALID_INDEX)
		&& (tb->piece_index[piece][square] <= index)) {
		p->piece_position[piece] = square;
	    }
	}

	index -= tb->piece_index[piece][p->piece_position[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (p->piece_position[piece] < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = p->piece_position[piece] + 2*8;
		p->piece_position[piece] += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = p->piece_position[piece] + 5*8;
		p->piece_position[piece] += 4*8;
	    }
	}

    }

    index /= 2;

    if (index >= tb->total_legal_king_positions) {
	fatal("index >= total legal king positions in combinadic_index_to_local_position!\n");
	return 0;
    }

    p->piece_position[tb->white_king] = tb->white_king_position[index];
    p->piece_position[tb->black_king] = tb->black_king_position[index];

    /* Now we have to decide the actual ordering in the piece array.  Use our recorded
     * permutations to put pieces on legal squares, if possible.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->permutations[piece] != NULL) {
	    int perm = 0;

	    while (tb->permutations[piece][perm] != 0) {

		int piece2;

		/* check for legality of all pieces in this set */
		for (piece2 = piece; piece2 != -1; piece2 = tb->next_identical_piece[piece2]) {
		    if (! (tb->legal_squares[piece2] & BITVECTOR(p->piece_position[piece2]))) {
			break;
		    }
		}

		if (piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* permute */
		transpose_array(p->piece_position,
				tb->permutations[piece][perm] & 0xff, tb->permutations[piece][perm] >> 8);
		perm ++;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	int square = p->piece_position[piece];

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in combinadic_index_to_local_position!\n"); */
	    return 0;
	}

	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "combinadic2" index
 *
 * Like combinadic, except that later pieces wholly contained within the semilegal positions of
 * earlier pieces are encoded using fewer positions.
 */

index_t local_position_to_combinadic2_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece, piece2;
    uint8_t vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    /* vals[piece] = tb->piece_index[piece][COL(pos->en_passant_square)]; */
	    vals[piece] = COL(pos->en_passant_square);
	} else {
	    /* vals[piece] = tb->piece_index[piece][pos->piece_position[piece]]; */
	    vals[piece] = pos->piece_position[piece];
	}

	/* Remove positions for overlapping pieces, but we don't touch the kings, and we don't
	 * consider anything in the current identical pieces group.  For all other overlapping
	 * pieces before us in the piece list, if that piece is earlier than us in board order,
	 * decrement our position by one.
	 *
	 * It works exclusively by comparing positions, not encoded values, so it can use pawns as
	 * overlapping pieces, but it can't encode pawns because of the ambiguity created by en
	 * passant positions.  We deal with this (currently) by never assigning a "last overlapping
	 * piece" to a pawn.
	 */

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	for (piece2 = piece; tb->last_identical_piece[piece2] != -1; piece2 = tb->last_identical_piece[piece2]);

	for (piece2 = tb->last_overlapping_piece[piece2]; piece2 != -1; piece2 = tb->last_overlapping_piece[piece2]) {
	    if (pos->piece_position[piece] > pos->piece_position[piece2]) vals[piece] --;
	}
    }

    /* Sort identical pieces so that the lowest values always come first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (vals[piece2] < vals[tb->last_identical_piece[piece2]])) {
	    transpose_array(vals, piece2, tb->last_identical_piece[piece2]);
	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* Kings have their own encoding table */

	if (piece == tb->white_king) {
	    index += 2 * tb->king_index[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	index += tb->piece_index[piece][vals[piece]];
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean combinadic2_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    p->side_to_move = index % 2;
    index -= p->side_to_move;

    /* Each piece will have position values assigned to it multiplied by a multiplier for the set of
     * identical pieces.  We search for the largest value in piece_index[] that is less
     * than the index and convert the encoding numbers to square numbers on the board.  This works
     * if identical pieces are grouped together.  This loop has to run in reverse order over the
     * pieces, since a combinadic encoding should be backed out from the largest piece first.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square;

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
	     (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
	     (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

	    if ((tb->piece_index[piece][square] != INVALID_INDEX)
		&& (tb->piece_index[piece][square] <= index)) {
		p->piece_position[piece] = square;
	    }
	}

	index -= tb->piece_index[piece][p->piece_position[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (p->piece_position[piece] < 8)) {
	    if (p->en_passant_square != ILLEGAL_POSITION) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = p->piece_position[piece] + 2*8;
		p->piece_position[piece] += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = p->piece_position[piece] + 5*8;
		p->piece_position[piece] += 4*8;
	    }
	}

    }

    index /= 2;

    if (index >= tb->total_legal_king_positions) {
	fatal("index >= total legal king positions in combinadic2_index_to_local_position!\n");
	return 0;
    }

    p->piece_position[tb->white_king] = tb->white_king_position[index];
    p->piece_position[tb->black_king] = tb->black_king_position[index];

    /* Now we have to decide the actual ordering in the piece array.  Use our recorded
     * permutations to put pieces on legal squares, if possible.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	int piece2;
	uint8_t smallest_position, next_smallest_position;

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* "You've got to be kidding me"
	 *
	 * We fix up the positions by going back through the earlier overlapping pieces and
	 * incrementing our position if we're past them.  This has to be done in order from the
	 * smallest position to the largest.  Consider unrestricted pieces; kings on squares 12 and
	 * 33, and a queen on square 34 that got encoded as 32.  We need to increment 32 to 33 for
	 * 12, then increment 33 to 34 for 33, and if we try to handle the king on 33 first, we
	 * won't increment because 32<33.
	 */

	smallest_position = ILLEGAL_POSITION;

	do {
	    next_smallest_position = ILLEGAL_POSITION;

	    for (piece2 = piece; tb->last_identical_piece[piece2] != -1; piece2 = tb->last_identical_piece[piece2]);

	    for (piece2 = tb->last_overlapping_piece[piece2]; piece2 != -1; piece2 = tb->last_overlapping_piece[piece2]) {
		if (p->piece_position[piece2] <= p->piece_position[piece]) {
		    if ((smallest_position == ILLEGAL_POSITION) || (p->piece_position[piece2] > smallest_position)) {
			if ((next_smallest_position == ILLEGAL_POSITION) || (p->piece_position[piece2] < next_smallest_position)) {
			    next_smallest_position = p->piece_position[piece2];
			}
		    }
		}
	    }

	    if (next_smallest_position != ILLEGAL_POSITION) {
		p->piece_position[piece] ++;
		smallest_position = next_smallest_position;
	    }

	} while (next_smallest_position != ILLEGAL_POSITION);

	if (p->piece_position[piece] >= 64) return 0;

	if (tb->permutations[piece] != NULL) {
	    int perm = 0;

	    while (tb->permutations[piece][perm] != 0) {

		/* check for legality of all pieces in this set */
		for (piece2 = piece; piece2 != -1; piece2 = tb->next_identical_piece[piece2]) {
		    if (! (tb->legal_squares[piece2] & BITVECTOR(p->piece_position[piece2]))) {
			break;
		    }
		}

		if (piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* permute */
		transpose_array(p->piece_position,
				tb->permutations[piece][perm] & 0xff, tb->permutations[piece][perm] >> 8);
		perm ++;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	int square = p->piece_position[piece];

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in combinadic2_index_to_local_position!\n"); */
	    return 0;
	}

	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "combinadic3" index
 *
 * Like combinadic, except that later pieces wholly contained within the semilegal positions of
 * earlier pieces are encoded using fewer positions.  Pawns require special consideration, as we
 * encode en-passant capturable pawns using the squares on the first rank.  When using a pawn to
 * reduce the encoding value of a later piece, we ignore the en-passant status of the pawn and use
 * its board position.  When reducing the encoding value of a pawn, we use the encoding value, with
 * en-passant factored in.
 */

index_t local_position_to_combinadic3_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece, piece2;
    uint8_t vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != ILLEGAL_POSITION)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = COL(pos->en_passant_square);
	    /* continue;  Probably can do this, as we never change en-passant values */
	} else {
	    vals[piece] = pos->piece_position[piece];
	}

	/* Remove positions for overlapping pieces, but we don't touch the kings, and we don't
	 * consider anything in the current encoding group, because the combinadic encoding already
	 * takes care of them.  For all other overlapping pieces before us in the piece list, if
	 * that piece is earlier than us in board order, decrement our position by one.
	 *
	 * Pawns require special consideration, as we encode en-passant capturable pawns using the
	 * squares on the first rank.  When using a pawn to reduce the encoding value of a later
	 * piece, we ignore the en-passant status of the pawn and use its board position.  When
	 * reducing the encoding value of a pawn, we use the encoding value, with en-passant
	 * factored in.  A consequence of this is that we never change the value of an en-passant
	 * encoded pawn.
	 *
	 * XXX we move backwards constructing this... is this right?
	 */

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	for (piece2 = piece; tb->prev_piece_in_encoding_group[piece2] != -1; piece2 = tb->prev_piece_in_encoding_group[piece2]);

	for (piece2 = tb->last_overlapping_piece[piece2]; piece2 != -1; piece2 = tb->last_overlapping_piece[piece2]) {
	    if (vals[piece] > pos->piece_position[piece2]) vals[piece] --;
	}
    }

    /* Sort encoding groups so that the lowest values always come first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->prev_piece_in_encoding_group[piece2] != -1)
	       && (vals[piece2] < vals[tb->prev_piece_in_encoding_group[piece2]])) {
	    transpose_array(vals, piece2, tb->prev_piece_in_encoding_group[piece2]);
	    piece2 = tb->prev_piece_in_encoding_group[piece2];
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* Kings have their own encoding table */

	if (piece == tb->white_king) {
	    index += 2 * tb->king_index[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	index += tb->piece_index[piece][vals[piece]];
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean combinadic3_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    int en_passant_pawn = -1;
    int en_passant_color = 0;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = ILLEGAL_POSITION;

    /* Working backwards through the piece array, search for the largest value in
     * piece_index[] that is less than the (running) index, subtract it out of the index,
     * and store the (tenative) piece positions.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square;

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
	     (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
	     (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

	    if ((tb->piece_index[piece][square] != INVALID_INDEX)
		&& (tb->piece_index[piece][square] <= index)) {
		p->piece_position[piece] = square;
	    }
	}

	index -= tb->piece_index[piece][p->piece_position[piece]];

	if ((tb->piece_type[piece] == PAWN) && (p->piece_position[piece] < 8)) {
	    if (en_passant_pawn != -1) return 0;  /* can't have two en passant pawns */
	    en_passant_pawn = piece;
	}

    }

    p->side_to_move = index % 2;
    index /= 2;

    if (tb->variant != VARIANT_SUICIDE) {

	if (index >= tb->total_legal_king_positions) {
	    fatal("index >= total legal king positions in combinadic3_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[tb->white_king] = tb->white_king_position[index];
	p->piece_position[tb->black_king] = tb->black_king_position[index];

    } else {

	if (index != 0) {
	    fatal("index > 0 in combinadic3_index_to_local_position!\n");
	    return 0;
	}

    }

    /* Fix the en passant pawn, which was encoded on the first row */

    if (en_passant_pawn != -1) {

	/* If there's an en passant pawn, it must be the opposite color of PTM */
	en_passant_color = 1 - p->side_to_move;

	if (en_passant_color == WHITE) {
	    p->en_passant_square = p->piece_position[en_passant_pawn] + 2*8;
	    p->piece_position[en_passant_pawn] += 3*8;
	} else {
	    p->en_passant_square = p->piece_position[en_passant_pawn] + 5*8;
	    p->piece_position[en_passant_pawn] += 4*8;
	}

    }

    /* "You've got to be kidding me"
     *
     * If we have overlapping pieces, some of the position numbers of the later pieces might have
     * been reduced.  We fix up the positions by going back through the earlier overlapping pieces
     * and incrementing our position if we're past them.  This has to be done in order from the
     * smallest position to the largest.  Consider unrestricted pieces; kings on squares 12 and 33,
     * and a queen on square 34 that got encoded as 32.  We need to increment 32 to 33 for 12, then
     * increment 33 to 34 for 33, and if we try to handle the king on 33 first, we won't increment
     * because 32 is less than 33.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	int piece2;
	uint8_t smallest_position, next_smallest_position;

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* En passant positions are never changed, since they are encoded using the first row,
	 * which isn't part of a pawn's legal range, so skip en passant pawns.
	 */

	if (piece == en_passant_pawn) continue;

	smallest_position = ILLEGAL_POSITION;

	do {
	    next_smallest_position = ILLEGAL_POSITION;

	    for (piece2 = piece; tb->prev_piece_in_encoding_group[piece2] != -1; piece2 = tb->prev_piece_in_encoding_group[piece2]);

	    for (piece2 = tb->last_overlapping_piece[piece2]; piece2 != -1; piece2 = tb->last_overlapping_piece[piece2]) {
		if (p->piece_position[piece2] <= p->piece_position[piece]) {
		    if ((smallest_position == ILLEGAL_POSITION) || (p->piece_position[piece2] > smallest_position)) {
			if ((next_smallest_position == ILLEGAL_POSITION) || (p->piece_position[piece2] < next_smallest_position)) {
			    next_smallest_position = p->piece_position[piece2];
			}
		    }
		}
	    }

	    if (next_smallest_position != ILLEGAL_POSITION) {
		p->piece_position[piece] ++;
		smallest_position = next_smallest_position;
	    }

	} while (next_smallest_position != ILLEGAL_POSITION);

	if (p->piece_position[piece] >= 64) return 0;
    }

    /* We've got all the numbers right, but maybe not in the right order, since each encoding group
     * is sorted in ascending order.
     *
     * Now we have to decide the actual ordering in the piece array.  Normalize_position() sorts
     * encoding groups of identical pieces into ascending order, then permutes until all the pieces
     * are on legal squares.  Mimic this action here.
     *
     * XXX don't need to use permutations (at all?) for an encoding group of plus-pawns
     */

    if (en_passant_pawn != -1) {

	/* Remember that en passant pawns always trail.  So, white en passant pawns are still
	 * sorted, but black ones have to be moved to the end of their group.
	 */

	for (piece = tb->next_piece_in_encoding_group[en_passant_pawn];
	     (piece != -1)
		 && (p->piece_position[tb->prev_piece_in_encoding_group[piece]]
		     > p->piece_position[piece]);
	     piece = tb->next_piece_in_encoding_group[piece]) {
	    transpose_array(p->piece_position, piece, tb->prev_piece_in_encoding_group[piece]);
	    en_passant_pawn = piece;
	}

	/* We've figured out which pawn is the en passant pawn, now make sure that it is the right
	 * color.  We earlier decided on en_passant_color based solely on side-to-move.  If we're
	 * encoding a group of plus-pawns of mixed color, then this should always come out right.
	 * Otherwise, our encoding group is of uniform color, and this check will reject
	 * half of our en passant positions, which might be a place for improvement.
	 */

 	if (tb->piece_color[en_passant_pawn] != en_passant_color) {
 	    return 0;
 	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if (tb->permutations[piece] != NULL) {
	    int perm = 0;

	    while (tb->permutations[piece][perm] != 0) {

		int piece2;

		/* check for legality of all pieces in this set */
		for (piece2 = piece; piece2 != -1; piece2 = tb->next_piece_in_encoding_group[piece2]) {
		    if (! (tb->legal_squares[piece2] & BITVECTOR(p->piece_position[piece2]))) {
			break;
		    }
		}

		if (piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* permute */
		transpose_array(p->piece_position,
				tb->permutations[piece][perm] & 0xff, tb->permutations[piece][perm] >> 8);
		perm ++;
	    }
	}
    }

    /* Final checks for an illegally positioned piece, two pieces on the same square,
     * setting bits in the board vectors
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	int square = p->piece_position[piece];

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with, not legal positions.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in combinadic3_index_to_local_position!\n"); */
	    return 0;
	}

	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != ILLEGAL_POSITION) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* Normalization
 *
 * Not all positions are created equal.  For example, interchanging two identical pieces doesn't
 * change the position at all, so a position with rook #1 on e4 and rook #2 on g6 is the same as one
 * with rook #1 on g6 and rook #2 on e4.  When converting to an index, we deal with this by sorting
 * identical pieces so the piece on the lowest numbered square always appears first in the position.
 *
 * But this creates problems when trying to move a piece.  Consider for example, the two rooks.  If
 * we now being moving rook #1 along the e file, it moves to e5, then e6, then e7.  Now, at e7, it
 * has become the rook on the higher numbered square, so the pieces have just "flipped" in the
 * position structure!  Additionally, if we have symmetry involved, then which piece is on the
 * higher numbered square can depend on the reflections required to get the kings to their
 * restricted areas.
 *
 * And we can't simply hide all of this in the guts of the position-to-index functions, because we
 * track futuremoves.  Figuring out "which one" of an identical pair of pieces got captured is
 * critical to figuring out which bit in the futuremoves vector corresponds to this move.
 *
 * So, we deal with this using "normalization".  We call normalize_position() to apply all the
 * reflection and sorting needed to get the position to a point where it can be directly converted
 * to an index.  We record these transformations using the 'reflection' variable and a permutation
 * array in the position structure.
 *
 * We can look into the permutation array to figure out which piece has been swapped where, so we
 * can figure out futuremove bit vectors accordingly.  So the way we move a rook, like in the
 * example above, is to move it e5, normalize, back prop, move it to e6, normalize, back prop, move
 * it to e7, etc.
 *
 * We also recompute the board vector, because the reflections can change it around.
 */

void normalize_position(tablebase_t *tb, local_position_t *position)
{
    int piece, piece2;
    uint8_t permutation[MAX_PIECES];

    /* Reflect the pieces around to get the white king where we want him for symmetry.
     *
     * 2-way symmetry: white king always on left side of board
     *
     * 4-way symmetry: white king always in lower left quarter of board
     *
     * 8-way symmetry: white king always in a1-a4-d4 triangle, and if white king is on a1-d4
     * diagonal, then black king is on or below a1-h8 diagonal
     */

    position->reflection = 0;

    if (tb->symmetry >= 2) {
	if (COL(position->piece_position[tb->white_king]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != ILLEGAL_POSITION) {
		position->en_passant_square = horizontal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 4;
	}
    }

    if (tb->symmetry >= 4) {
	if (ROW(position->piece_position[tb->white_king]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != ILLEGAL_POSITION) {
		position->en_passant_square = vertical_reflection(position->en_passant_square);
	    }
	    position->reflection |= 2;
	}
    }

    if (tb->symmetry == 8) {
	if (ROW(position->piece_position[tb->white_king]) > COL(position->piece_position[tb->white_king])) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != ILLEGAL_POSITION) {
		position->en_passant_square = diagonal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 1;
	}
#if 1
	if (ROW(position->piece_position[tb->white_king]) == COL(position->piece_position[tb->white_king])) {
	    if (ROW(position->piece_position[tb->black_king]) > COL(position->piece_position[tb->black_king])) {
		for (piece = 0; piece < tb->num_pieces; piece ++) {
		    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
		}
		position->reflection |= 1;
	    }
	}
#endif
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	permutation[piece] = piece;
    }

    /* Sort any identical pieces so that the lowest square number always comes first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (position->piece_position[piece2]
		   < position->piece_position[tb->last_identical_piece[piece2]])) {
	    transpose_array(position->piece_position, piece2, tb->last_identical_piece[piece2]);
	    transpose_array(permutation, piece2, tb->last_identical_piece[piece2]);
	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    /* Now permute identical pieces to try and get them onto legal squares (if needed).
     *
     * The order of the permutations is significant only in that identical board positions must
     * always generate identical indices.  So we first sort the pieces into a standard order (the
     * previous step), and then systematically apply permutations until we find the first one that
     * places all the pieces onto legal squares.  If none of the permutations work, we don't care.
     * This position is then illegal and will get rejected when we try to convert it to an index.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* run this loop once for each set of identical pieces */
	if (tb->permutations[piece] != NULL) {
	    int perm = 0;

	    while (tb->permutations[piece][perm] != 0) {

		int piece2;

		/* check for legality of all pieces in this set */
		for (piece2 = piece; piece2 != -1; piece2 = tb->next_identical_piece[piece2]) {
		    if (! (tb->legal_squares[piece2] & BITVECTOR(position->piece_position[piece2]))) {
			break;
		    }
		}

		if (piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* permute */
		transpose_array(position->piece_position,
				 tb->permutations[piece][perm] & 0xff, tb->permutations[piece][perm] >> 8);
		transpose_array(permutation,
				 tb->permutations[piece][perm] & 0xff, tb->permutations[piece][perm] >> 8);
		perm ++;
	    }

	    /* We don't check the final permutation for legality, just leave it alone. */
	}
    }

    /* Finally, reconstruct the board vector and invert the permutation, so that the permuted_piece
     * array in the position gives the new pieces as a function of the old ones.
     */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
	position->permuted_piece[permutation[piece]] = piece;
    }
}

index_t normalized_position_to_index(tablebase_t *tb, local_position_t *position)
{
    index_t index;
    int piece;

    /* This is a good place to make this check, since all of the position-to-index code passes
     * through here.
     */

    if (tb->positions_with_adjacent_kings_are_illegal
	&& ! check_king_legality(position->piece_position[tb->white_king], position->piece_position[tb->black_king]))
	return INVALID_INDEX;

    if ((tb->index_type == NO_EN_PASSANT_INDEX) && (position->en_passant_square != ILLEGAL_POSITION))
	return INVALID_INDEX;

    /* Recompute board_vector, and check for legality of piece positions */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((position->piece_position[piece] < 0) || (position->piece_position[piece] > 63)
	    || !(tb->legal_squares[piece] & BITVECTOR(position->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
	    return INVALID_INDEX;
	}

	/* Blocking pawns.  Reject any position where a pawn has "hopped" over the enemy pawn
	 * blocking it.
	 */

	if ((tb->piece_type[piece] == PAWN) && (tb->blocking_piece[piece] != -1)) {
	    if (tb->piece_color[piece] == WHITE) {
		if (position->piece_position[piece] > position->piece_position[tb->blocking_piece[piece]]) {
		    return INVALID_INDEX;
		}
	    } else {
		if (position->piece_position[piece] < position->piece_position[tb->blocking_piece[piece]]) {
		    return INVALID_INDEX;
		}
	    }
	}

	if (position->board_vector & BITVECTOR(position->piece_position[piece])) return INVALID_INDEX;
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (position->en_passant_square != ILLEGAL_POSITION) {
	if (position->board_vector & BITVECTOR(position->en_passant_square)) return INVALID_INDEX;
	if (position->side_to_move == WHITE) {
	    if (position->board_vector & BITVECTOR(position->en_passant_square + 8)) return INVALID_INDEX;
	} else {
	    if (position->board_vector & BITVECTOR(position->en_passant_square - 8)) return INVALID_INDEX;
	}
    }

    switch (tb->index_type) {
    case NAIVE_INDEX:
	index = local_position_to_naive_index(tb, position);
	break;
    case NAIVE2_INDEX:
	index = local_position_to_naive2_index(tb, position);
	break;
    case SIMPLE_INDEX:
	index = local_position_to_simple_index(tb, position);
	break;
    case COMPACT_INDEX:
    case NO_EN_PASSANT_INDEX:
	index = local_position_to_compact_index(tb, position);
	break;
    case COMBINADIC_INDEX:
	index = local_position_to_combinadic_index(tb, position);
	break;
    case COMBINADIC2_INDEX:
	index = local_position_to_combinadic2_index(tb, position);
	break;
    case COMBINADIC3_INDEX:
	index = local_position_to_combinadic3_index(tb, position);
	break;
    default:
	fatal("Unknown index type in local_position_to_index()\n");
	return INVALID_INDEX;
    }

    index += tb->index_offset;

    if ((index != INVALID_INDEX) && (index != 0) && (tb->modulus != 0)) {
	index = invert_in_finite_field(index, tb->modulus);
    }

    /* Multiplicity - number of non-identical positions that this index corresponds to.  We want to
     * update the original position structure that got passed in.
     */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[tb->white_king]) != COL(position->piece_position[tb->white_king]))
	    || (ROW(position->piece_position[tb->black_king]) != COL(position->piece_position[tb->black_king])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    return index;
}

index_t local_position_to_index(tablebase_t *tb, local_position_t *original)
{
    index_t index;

    /* We don't want to change around the original position, during these next transformations, so
     * we use a copy of it.  We do, however, update the multiplicity in the original structure.
     */

    local_position_t copy = *original;

    normalize_position(tb, &copy);

    index = normalized_position_to_index(tb, &copy);

    original->multiplicity = copy.multiplicity;

    return index;
}

boolean index_to_local_position(tablebase_t *tb, index_t index, int reflection, local_position_t *position)
{
    int ret;
    int piece, piece2;

    if ((index != 0) && (tb->modulus != 0)) {
	index = invert_in_finite_field(index, tb->modulus);
    }

    if (index > tb->max_uninverted_index) return 0;
    if (index < tb->index_offset) return 0;
    index -= tb->index_offset;

    switch (tb->index_type) {
    case NAIVE_INDEX:
	ret = naive_index_to_local_position(tb, index, position);
	break;
    case NAIVE2_INDEX:
	ret = naive2_index_to_local_position(tb, index, position);
	break;
    case SIMPLE_INDEX:
	ret = simple_index_to_local_position(tb, index, position);
	break;
    case COMPACT_INDEX:
    case NO_EN_PASSANT_INDEX:
	ret = compact_index_to_local_position(tb, index, position);
	break;
    case COMBINADIC_INDEX:
	ret = combinadic_index_to_local_position(tb, index, position);
	break;
    case COMBINADIC2_INDEX:
	ret = combinadic2_index_to_local_position(tb, index, position);
	break;
    case COMBINADIC3_INDEX:
	ret = combinadic3_index_to_local_position(tb, index, position);
	break;
    default:
	fatal("Unknown index type in index_to_local_position()\n");
	return 0;
    }

    if (!ret) return 0;

    /* Blocking pawns.  Reject any position where a pawn has "hopped" over the enemy piece blocking
     * it.
     */

    for (piece = 0; piece < tb->num_pieces; piece++) {
	if ((tb->piece_type[piece] == PAWN) && (tb->blocking_piece[piece] != -1)) {
	    if (tb->piece_color[piece] == WHITE) {
		if (position->piece_position[piece] > position->piece_position[tb->blocking_piece[piece]]) {
		    return 0;
		}
	    } else {
		if (position->piece_position[piece] < position->piece_position[tb->blocking_piece[piece]]) {
		    return 0;
		}
	    }
	}
    }

    /* Some of the index types (like 'compact' and 'no-en-passant') never return adjacent kings
     * because they detected the positions_with_adjacent_kings_are_illegal flag during
     * initialization.  The other index types require this check.
     */

    if (tb->positions_with_adjacent_kings_are_illegal
	&& ! check_king_legality(position->piece_position[tb->white_king], position->piece_position[tb->black_king]))
	return 0;

    if ((tb->symmetry == 8)
	&& (ROW(position->piece_position[tb->white_king]) == COL(position->piece_position[tb->white_king]))
	&& (ROW(position->piece_position[tb->black_king]) > COL(position->piece_position[tb->black_king])))
	return 0;

    /* Multiplicity - number of non-identical positions that this index corresponds to */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[tb->white_king]) != COL(position->piece_position[tb->white_king]))
	    || (ROW(position->piece_position[tb->black_king]) != COL(position->piece_position[tb->black_king])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    if (reflection & REFLECTION_DIAGONAL) {
	if (position->multiplicity == 1) return 0;

	/* diagonal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square != ILLEGAL_POSITION)
	    position->en_passant_square = diagonal_reflection(position->en_passant_square);
    }

    if (reflection & REFLECTION_VERTICAL) {
	/* vertical reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square != ILLEGAL_POSITION)
	    position->en_passant_square = vertical_reflection(position->en_passant_square);
    }

    if (reflection & REFLECTION_HORIZONTAL) {
	/* horizontal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square != ILLEGAL_POSITION)
	    position->en_passant_square = horizontal_reflection(position->en_passant_square);
    }

    /* Sort any identical pieces so that the lowest square number always comes first.
     *
     * The various index-to-position routines returned sorted piece arrays, but the various symmetry
     * reflections might have upset this.  Some places, particularly the translate_... routines in
     * futurebase back propagation, depend on the pieces being sorted.
     *
     * Note that we initialize the permuted_piece array AFTER this sort.  That's because
     * permuted_piece is used to track the changes that happen after index-to-position and before
     * position-to-index, NOT the changes that happen internally in index-to-position.
     *
     * Also, I don't even attempt to do this if there is no tablebase symmetry.  Not only is it
     * unnecessary in that case, but this can really screw up overlapping piece restrictions.  Since
     * we don't (currently) allow piece restrictions and symmetry at the same time...
     */

    if (tb->symmetry > 1) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    piece2 = piece;
	    while ((tb->last_identical_piece[piece2] != -1)
		   && (position->piece_position[piece2]
		       < position->piece_position[tb->last_identical_piece[piece2]])) {
		transpose_array(position->piece_position, piece2, tb->last_identical_piece[piece2]);
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->permuted_piece[piece] = piece;
    }
    position->reflection = 0;

#if 0
    /* Maybe should do this here, instead of in the various reflection code above. */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }
#endif

    return 1;
}

index_t max_index(tablebase_t * tb)
{
    return tb->max_index;
}

int index_to_side_to_move(tablebase_t *tb, index_t index)
{
    local_position_t position;

    if (tb->modulus != 0) {
	if (! index_to_local_position(tb, index, REFLECTION_NONE, &position)) return -1;
	else return position.side_to_move;
    } else {
	return (index - tb->index_offset) & 1;
    }
}

/* check_1000_positions(); check_1000_indices() - used just to double check the code above. */

int check_1000_positions(tablebase_t *tb)
{
    local_position_t position1;
    local_position_t position2;
    index_t index;
    int positions;
    int piece;
    int ret = 1;

    for (positions=0; positions < 1000; positions ++) {

	memset(&position1, 0, sizeof(position1));

	position1.side_to_move = rand() % 2;
	position1.en_passant_square = ILLEGAL_POSITION;

    retry:
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    do {
		position1.piece_position[piece] = rand() % 64;
	    } while (! (BITVECTOR(position1.piece_position[piece]) & tb->legal_squares[piece]));
	}

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if ((tb->last_identical_piece[piece] != -1) &&
		(position1.piece_position[piece] <=
		 position1.piece_position[tb->last_identical_piece[piece]])) goto retry;
	}

	normalize_position(tb, &position1);

	/* index_to_local_position is expected to initialize permuted_pieces to default */

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position1.permuted_piece[piece] = piece;
	}

	index = local_position_to_index(tb, &position1);

	if (index != INVALID_INDEX) {

	    if (!index_to_local_position(tb, index, REFLECTION_NONE, &position2)) {
		fatal("Mismatch in check_1000_positions()\n");
		ret = 0;
	    } else {

		/* PTM_vector wasn't set in position1, so don't check it now */

		position2.PTM_vector = 0;
		position2.board_vector = position1.board_vector;
		position2.reflection = position1.reflection;

		if (memcmp(&position1, &position2, sizeof(position1))) {
		    fatal("Mismatch in check_1000_positions()\n");
		    ret = 0;
		}
	    }
	}
    }

    return ret;
}

int check_1000_indices(tablebase_t *tb)
{
    local_position_t position;
    index_t index;
    index_t index2;
    int positions;
    int ret = 1;

    for (positions=0; positions < 1000; positions ++) {

	index = rand() % (tb->max_index + 1);

	if (index_to_local_position(tb, index, REFLECTION_NONE, &position)) {
	    index2 = local_position_to_index(tb, &position);
	    if (index != index2) {
		fatal("Mismatch in check_1000_indices() %" PRIindex "\n", index);
		ret = 0;
	    }
	}
    }

    return ret;
}

/***** XML TABLEBASE INTERACTION *****/

/* parse_format()
 *
 * Parse an XML format specification (for a dynamic structure) into a format structure.  A simple
 * XML format looks something like:
 *
 *   <format>
 *      <dtm bits="8"/>
 *   </format>
 *
 * Essentially, this specifies the layout of a C structure at run-time, and we have to jump through
 * all kinds of obscure nonsense to get dynamic structures.  Basically, we end up doing everything
 * with shifts and masks rather than normal structure operations.
 *
 * The XML format can be specified with either explicit or implicit offsets.  Explicit offsets are
 * just that: <dtm bits="8" offset="8"/> specifies an 8-bit field at an 8-bit offset into the
 * structure.  Implicit offsets assign the offset values counting up from zero (like the first
 * example above).  The two can not be mixed in the same format spec.
 *
 * The total size of a format is silently rounded up to a power-of-two byte boundary.  This is done
 * to make sure that the resulting structures can't straddle buffer boundaries.
 */

boolean parse_format(xmlNodePtr formatNode, struct format *format)
{
    xmlNodePtr child;
    int auto_offset = 0;
    int total_bits = 0;
    int power_of_two;
    int bitnum;
    uint64_t bitmask1 = 0;
    uint64_t bitmask2 = 0;

    memset(format, 0, sizeof(struct format));

    format->locking_bit_offset = -1;
    format->dtm_offset = -1;
    format->movecnt_offset = -1;
    format->index_offset = -1;
    format->futurevector_offset = -1;
    format->flag_offset = -1;
    format->PTM_wins_flag_offset = -1;
    format->basic_offset = -1;
    format->capture_possible_flag_offset = -1;

    for (child = formatNode->children; child != NULL; child = child->next) {
	if (child->type == XML_ELEMENT_NODE) {
	    char * bitstr = (char *) xmlGetProp(child, BAD_CAST "bits");
	    char * offsetstr = (char *) xmlGetProp(child, BAD_CAST "offset");
	    char * typestr;
	    int bits = (bitstr != NULL) ? atoi(bitstr) : 0;
	    int offset = (offsetstr != NULL) ? atoi(offsetstr) : -1;
	    int format_field = find_name_in_array((char *) child->name, format_fields);

	    if (bitstr != NULL) xmlFree(bitstr);
	    if (offsetstr != NULL) xmlFree(offsetstr);

	    if (format_field == -1) {
		fatal("Unknown field in format: %s\n", (char *) child->name);
		return 0;
	    }

	    if ((format_field == FORMAT_FIELD_FLAG)
		|| (format_field == FORMAT_FIELD_PTM_WINS_FLAG)
		|| (format_field == FORMAT_FIELD_LOCKING_BIT)
		|| (format_field == FORMAT_FIELD_CAPTURE_POSSIBLE_FLAG)) {

		if (bitstr == NULL) {
		    bits = 1;
		}
		if (bits != 1) {
		    fatal("Format field '%s' only accepts bits=\"1\"\n", (char *) child->name);
		    return 0;
		}
	    }

	    if (format_field == FORMAT_FIELD_BASIC) {
		if (bitstr == NULL) {
		    bits = 2;
		}
		if (bits != 2) {
		    fatal("Format field '%s' only accepts bits=\"2\"\n", (char *) child->name);
		    return 0;
		}
	    }

	    if (bits == 0) {
		fatal("Non-zero 'bits' value must be specified in format field '%s'\n",
		      (char *) child->name);
		return 0;
	    }
	    if ((offset == -1) && (auto_offset == -1)) {
		fatal("Can't mix explicit and implicit offsets in format\n");
		return 0;
	    }

	    if (offset == -1) {
		offset = auto_offset;
		auto_offset += bits;
	    } else {
		auto_offset = -1;
	    }

	    if ((format_field != FORMAT_FIELD_FUTUREVECTOR) && (offset/32 != (offset+bits-1) / 32)) {
		fatal("Most format fields can't straddle a 32-bit boundary\n");
		return 0;
	    }

	    if (offset/64 != (offset+bits-1) / 64) {
		fatal("Format fields can't straddle a 64-bit boundary\n");
		return 0;
	    }

	    if (offset >= 128) {
		fatal("Formats can't exceed 128 bits\n");
		return 0;
	    }

	    for (bitnum = offset; bitnum < offset + bits; bitnum ++) {
		if (bitnum < 64) {
		    if (bitmask1 & (1LL << bitnum)) {
			fatal("Overlapping format fields (%s)\n", (char *) child->name);
			return 0;
		    }
		    bitmask1 |= (1LL << bitnum);
		} else {
		    if (bitmask2 & (1LL << (bitnum - 64))) {
			fatal("Overlapping format fields (%s)\n", (char *) child->name);
			return 0;
		    }
		    bitmask2 |= (1LL << (bitnum - 64));
		}
	    }

	    if (offset + bits > total_bits) total_bits = offset + bits;

	    switch (format_field) {
	    case FORMAT_FIELD_DTM:
		format->dtm_bits = bits;
		format->dtm_offset = offset;
		format->dtm_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_MOVECNT:
		format->movecnt_bits = bits;
		format->movecnt_offset = offset;
		format->movecnt_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_INDEX:
		format->index_bits = bits;
		format->index_offset = offset;
		if (bits == 64) format->index_mask = 0xffffffffLL;
		else format->index_mask = (1LL << bits) - 1;
		break;
	    case FORMAT_FIELD_FUTUREVECTOR:
		format->futurevector_bits = bits;
		format->futurevector_offset = offset;
		if (bits == 64) format->futurevector_mask = 0xffffffffLL;
		else format->futurevector_mask = (1LL << bits) - 1;
		break;
	    case FORMAT_FIELD_FLAG:
		typestr = (char *) xmlGetProp(child, BAD_CAST "type");
		format->flag_offset = offset;
		format->flag_type = find_name_in_array(typestr, format_flag_types);
		if (typestr != NULL) xmlFree(typestr);
		if (format->flag_type == -1) {
		    fatal("'type' is a required property in format field 'flag'\n");
		    return 0;
		}
		break;
	    case FORMAT_FIELD_BASIC:
		format->basic_offset = offset;
		break;
	    case FORMAT_FIELD_PTM_WINS_FLAG:
		format->PTM_wins_flag_offset = offset;
		break;
	    case FORMAT_FIELD_LOCKING_BIT:
		format->locking_bit_offset = offset;
		break;
	    case FORMAT_FIELD_CAPTURE_POSSIBLE_FLAG:
		format->capture_possible_flag_offset = offset;
		break;
	    default:
		fatal("Unknown field in format\n");
		return 0;
	    }
	}
    }

    /* Round up total number of bytes to a power-of-two boundary.  This should probably be a little
     * less dependant on the assumption that MAX_FORMAT_BYTES is no more than 16.
     */

    for (power_of_two = 0; (1 << power_of_two) < total_bits; power_of_two ++);

    if ((1 << power_of_two) != total_bits) {
	fatal("Total bits in format must be a power of two\n");
	return 0;
    }

    format->bits = power_of_two;

    if (total_bits <= 8) {
	format->bytes = 1;
    } else {
	format->bytes = total_bits/8;
    }

    if (format->bytes > MAX_FORMAT_BYTES) {
	fatal("Maximum number of bytes in format exceeded\n");
	return 0;
    }

    return 1;
}

const char * print_format(const char *name, struct format *format)
{
    static char outstr[256];

    snprintf(outstr, sizeof(outstr),
	     "   const struct format %s = {%d,%d, %d, 0x%" PRIx32 ",%d,%d, 0x%" PRIx32 ",%d,%d, 0x%"
	     PRIx32 ",%d,%d, 0x%" PRIx64 ",%d,%d, %d,%d, %d, %d};\n",

	     name, format->bits, format->bytes, format->locking_bit_offset,
	     format->dtm_mask, format->dtm_offset, format->dtm_bits,
	     format->movecnt_mask, format->movecnt_offset, format->movecnt_bits,
	     format->index_mask, format->index_offset, format->index_bits,
	     format->futurevector_mask, format->futurevector_offset, format->futurevector_bits,
	     format->flag_offset, format->flag_type, format->PTM_wins_flag_offset,
	     format->basic_offset);

    return outstr;
}

/* Parses XML, creates a tablebase structure corresponding to it, and returns it.
 *
 * I use a DTD and validate the XML input, so there's very little error checking here.  The idea is
 * that the validation provides most of the error checks.
 *
 * There's very little difference between the futurebase and generation control file cases, but the
 * second argument is a flag to distinguish between them.
 */

int factorial(int n) {
    return (n <= 2) ? n : (n * factorial(n-1));
}

int choose(int n, int k) {
    long retval = 1;
    int i;

    for (i=0; i<k; i++) retval *= (n-i);
    for (i=1; i<=k; i++) retval /= i;

    return retval;
}

tablebase_t * parse_XML_into_tablebase(xmlDocPtr doc, boolean is_futurebase)
{
    tablebase_t *tb;
    int generating_version = 0;
    xmlXPathContextPtr context, context2;
    xmlXPathObjectPtr result, result2;
    xmlNodePtr tablebase;
    xmlNodePtr index_node;
    xmlChar * format;
    xmlChar * index;
    xmlChar * modulus;
    xmlChar * index_symmetry;
    int piece, piece2, square, white_king_square, black_king_square, dir;
    int pass;
    xmlChar * king_positions;
    int no_frozen_check_king_positions = 0;
    int starting_fatal_errors = fatal_errors;
    int piece_in_set = 1;

    tb = (tablebase_t *) malloc(sizeof(tablebase_t));
    if (tb == NULL) {
	fatal("Can't malloc tablebase\n");
	return NULL;
    }
    memset(tb, 0, sizeof(tablebase_t));

    tb->xml = doc;

    /* Fetch tablebase from XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//tablebase", context);
    tablebase = result->nodesetval->nodeTab[0];
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Figure out which version of chess we're playing... */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//variant", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * variant_name = xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "name");
	tb->variant = find_name_in_array((char *) variant_name, variant_names);
	if (tb->variant == -1) {
	    fatal("Unknown variant '%s' specified\n", variant_name);
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    switch (tb->variant) {

    case VARIANT_NORMAL:
	tb->positions_with_adjacent_kings_are_illegal = 1;
	break;

    case VARIANT_SUICIDE:
	tb->positions_with_adjacent_kings_are_illegal = 0;
	promotion_possibilities = 5;	/* A global var, but all futurebases have to use the same variant */
	break;

    }

    /* If it's a header on a generated tablebase, retrieve the version of Hoffman that created it.
     * The funky syntax on the sscanf is there to ensure that RCS co doesn't muck with THIS version
     * string!
     */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//program", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * content = xmlNodeGetContent(result->nodesetval->nodeTab[0]);
	if (content != NULL) {
	    sscanf((char *) content, "Hoffman %*[$]Revision: 1.%u $", &generating_version);
	    xmlFree(content);
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//@pawngen-condition", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fatal("'pawngen-condition' attribute disallowed by Hoffman; preprocess with pawngen first\n");
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Some statistics we'll use if this is a futurebase */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//max-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * content = xmlNodeGetContent(result->nodesetval->nodeTab[0]);
	if (content != NULL) {
	    tb->max_dtm = atoi((char *) content);
	    xmlFree(content);
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//min-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * content = xmlNodeGetContent(result->nodesetval->nodeTab[0]);
	if (content != NULL) {
	    tb->min_dtm = atoi((char *) content);
	    xmlFree(content);
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* If there's a stalemate prune, fetch it */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune[attribute::move='stalemate']", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "type");
	tb->stalemate_prune_type = find_name_in_array((char *) prune_type, restriction_types);
	tb->stalemate_prune_color = find_name_in_array((char *) prune_color, colors);
	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_type != NULL) xmlFree(prune_type);
	if (tb->stalemate_prune_type != RESTRICTION_CONCEDE) {
	    fatal("Stalemates can only be pruned to 'concede'\n");
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Fetch the pieces from the XML */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//piece", context);

    tb->num_pieces = result->nodesetval->nodeNr;

    if (tb->num_pieces > MAX_PIECES) {
	fatal("Too many pieces (%d compiled-in maximum)!\n", MAX_PIECES);
	return NULL;
    }

    tb->white_king = -1;
    tb->black_king = -1;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	xmlChar * color = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "color");
	xmlChar * type = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "type");
	xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");
	xmlChar * index_ordering = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "index-ordering");

	tb->piece_color[piece] = find_name_in_array((char *) color, colors);
	tb->piece_type[piece] = find_name_in_array((char *) type, piece_name);

	if (location == NULL) {
	    if (tb->piece_type[piece] == PAWN) {
		tb->legal_squares[piece] = LEGAL_PAWN_BITVECTOR;
	    } else {
		tb->legal_squares[piece] = ALL_ONES_BITVECTOR;
	    }
	} else {
	    int j = 0;
	    tb->legal_squares[piece] = 0;
	    while ((location[j] >= 'a') && (location[j] <= 'h')
		   && (location[j+1] >= '1') && (location[j+1] <= '8')) {
		tb->legal_squares[piece]
		    |= BITVECTOR(rowcol2square(location[j+1] - '1', location[j] - 'a'));
		j += 2;
		if ((tb->piece_type[piece] == PAWN) && (j == 2) && (location[j] == '+')) j++;
		while (location[j] == ' ') j ++;
	    }
	    if (location[j] != '\0') {
		fatal("Illegal piece location (%s)\n", location);
	    }
	}

	if ((index_ordering != NULL) && (strcmp((char *) index_ordering, "reverse") == 0)) {
	    tb->reverse_index_ordering[piece] = 1;
	} else {
	    tb->reverse_index_ordering[piece] = 0;
	}

	if ((tb->piece_color[piece] == -1) || (tb->piece_type[piece] == -1)) {
	    fatal("Illegal piece color (%s) or type (%s)\n", color, type);
	}

	tb->num_pieces_by_color[tb->piece_color[piece]] ++;

	if (tb->variant != VARIANT_SUICIDE) {

	    if ((tb->piece_color[piece] == WHITE) && (tb->piece_type[piece] == KING)) {
		if (tb->white_king != -1) {
		    fatal("Must have one white king and one black one!\n");
		} else {
		    tb->white_king = piece;
		}
	    }

	    if ((tb->piece_color[piece] == BLACK) && (tb->piece_type[piece] == KING)) {
		if (tb->black_king != -1) {
		    fatal("Must have one white king and one black one!\n");
		} else {
		    tb->black_king = piece;
		}
	    }

	}

	if (color != NULL) xmlFree(color);
	if (type != NULL) xmlFree(type);
	if (location != NULL) xmlFree(location);
	if (index_ordering != NULL) xmlFree(index_ordering);
    }

    if ((tb->num_pieces_by_color[WHITE] == 0) || (tb->num_pieces_by_color[BLACK] == 0)) {
	fatal("Must have at least one white piece and one black piece!\n");
	return NULL;
    }

    if (tb->variant != VARIANT_SUICIDE) {
	if ((tb->white_king == -1) || (tb->black_king == -1)) {
	    fatal("Must have one white king and one black one!\n");
	    return NULL;
	}
    }


    /* We quietly skipped over any plus signs after pawn locations, which mean that the pawn should
     * be advanced as far as possible along its file.  For example, if there is a white pawn at
     * "h2+" and a black pawn at "h7+", we want the white pawn's legal squares expanded all the way
     * to h6, and the black pawn's legal squares expanded all the way to h3.  We couldn't process
     * them immediately because without having parsed all the pieces we didn't know if anything was
     * blocking the file.
     *
     * Having now parsed all of the pieces, go back and expand the legal squares of any "plus pawns"
     * by first running through the pieces and looking for any blocking the plus pawn.  Then expand
     * the plus-pawn's restrictions up its file until it hits the blocking piece.
     *
     * To handle doubled pawns, we do this twice, figuring that we'll expand the leading pawn first,
     * then pick up the trailing pawn on the second pass.  To handle tripled pawns, we need three
     * passes.  To handled quadrupled (!) pawns, we need four.  Simplest is to just run the loop
     * once for however many pieces we've got.
     *
     * What if we specified a black pawn as "a7+ b4+" and a white pawn as "b2+"?  Then the black
     * pawn would be blocked by at b3 by the white pawn, even though the white pawn could move on
     * past (it wouldn't be blocked by the multiple-file black pawn).  I handle this complex case by
     * not allowing plus pawns to start on more than one square.
     *
     * Perhaps this seems like an absurd amount of complexity to introduce for a special case.  In
     * fact, pawns blocking each other are a not-so-special case and I don't see how they can be
     * handled as efficiently as we'd like without all of this.  In particular, we needn't regard
     * pawn moves onto blocked squares as futuremoves, and by pairing opposing pawns in indices we
     * can cut tablebase sizes by a factor of two for each pair.
     */

    /* First, compute which piece, if any, is blocking each plus-pawn.  We do this by stripping out
     * from the blocking piece's legal squares all possible positions of the plus-pawn as we move it
     * forward.  This ensures that a white pawn restricted to "g2 g3", say, will block a black
     * plus-pawn "g7+".  This is OK for non-pawns, too, since knights are the only pieces that can
     * jump and a knight could never be frozen purely along a single file.  Plus-pawns themselves,
     * since their legal_squares haven't been expanded yet, block other pawn-pawns at their origin
     * square.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	tb->blocking_piece[piece] = -1;

	if (tb->piece_type[piece] == PAWN) {

	    xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");
	    uint64_t pawn_positions = 0xffffffffffffffffLL;

	    if ((location != NULL) && (location[2] == '+')) {

		int square = rowcol2square(location[1] - '1', location[0] - 'a');
		int dir = (tb->piece_color[piece] == WHITE) ? 8 : -8;

		pawn_positions &= ~BITVECTOR(square);
		square += dir;

		while ((square < 56) && (square > 7) && (tb->blocking_piece[piece] == -1)) {
		    for (piece2 = 0; piece2 < tb->num_pieces; piece2 ++) {
			if ((pawn_positions & tb->legal_squares[piece2]) == BITVECTOR(square)) {
			    tb->blocking_piece[piece] = piece2;
			}
		    }
		    pawn_positions &= ~BITVECTOR(square);
		    square += dir;
		}

		/* This next batch of code is here because we (currently) sort 'identical' pieces
		 * into increasing order when we normalize a position.  Since doubled pawns are
		 * 'identical', the easiest way to handle them is to insure that they always appear
		 * in the correct order in the piece list.
		 */

		if ((tb->blocking_piece[piece] != -1) && (tb->piece_type[tb->blocking_piece[piece]] == PAWN)
		    && (tb->piece_color[tb->blocking_piece[piece]] == tb->piece_color[piece])) {
		    if ((tb->piece_color[piece] == WHITE) && (tb->blocking_piece[piece] < piece)) {
			fatal("Doubled pawns must (currently) appear in board order in piece list\n");
		    }
		    if ((tb->piece_color[piece] == BLACK) && (tb->blocking_piece[piece] > piece)) {
			fatal("Doubled pawns must (currently) appear in board order in piece list\n");
		    }
		}

	    } else {
		/* XXX This is a pawn, but it isn't a plus-pawn.  It can be blocked if it is frozen.
		 * This matters because if a pawn is blocked, then we shouldn't complain if there is
		 * no futurebase or pruning statement for its forward move, but it isn't a big deal,
		 * since we can always just add an extra pruning statement for the non-move.
		 */
	    }

	    if (location != NULL) xmlFree(location);
	}
    }

    /* Now advance plus-pawns as far as they can go without hitting the blocking piece. */

    for (pass = 0; pass < tb->num_pieces; pass ++) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_type[piece] == PAWN) {

		xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");

		if ((location != NULL) && (location[2] == '+')) {

		    int square = rowcol2square(location[1] - '1', location[0] - 'a');
		    int dir = (tb->piece_color[piece] == WHITE) ? 8 : -8;

		    square += dir;
		    while ((square < 56) && (square > 7)) {
			if ((tb->blocking_piece[piece] != -1)
			    && (BITVECTOR(square) & tb->legal_squares[tb->blocking_piece[piece]])
			    && !(BITVECTOR(square + dir) & tb->legal_squares[tb->blocking_piece[piece]]))
			    break;
			tb->legal_squares[piece] |= BITVECTOR(square);
			square += dir;
		    }
		}

		if (location != NULL) xmlFree(location);
	    }
	}
    }

    /* Now we need to figure out if there are any other pieces identical to this one, because if so,
     * exchanging the two pieces would not change the position, and that has to be taken into
     * account in several places.  Move restrictions on the pieces complicate this, unless they are
     * completely non-overlapping, in which case we don't treat the pieces as identical because they
     * are then distinguishable (kinda like electrons).  The whole point of this code is to group
     * together identical pieces with overlapping move restrictions, and to compute for each group
     * the logical union of their move restrictions, which become the "semilegal" squares for all
     * the pieces in that group.  See the earlier discussion on semilegal squares.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	tb->last_identical_piece[piece] = -1;
	tb->next_identical_piece[piece] = -1;

	tb->semilegal_squares[piece] = tb->legal_squares[piece];

	for (piece2 = 0; piece2 < piece; piece2 ++) {
	    if ((tb->piece_color[piece2] == tb->piece_color[piece])
		&& (tb->piece_type[piece2] == tb->piece_type[piece])) {

		if (tb->semilegal_squares[piece] & tb->semilegal_squares[piece2]) {
		    tb->last_identical_piece[piece] = piece2;
		    tb->semilegal_squares[piece2] |= tb->semilegal_squares[piece];
		    tb->semilegal_squares[piece] |= tb->semilegal_squares[piece2];
		}
	    }
	}

	if (tb->last_identical_piece[piece] != -1) {
	    tb->next_identical_piece[tb->last_identical_piece[piece]] = piece;
	}
    }

    /* Later, if we're trying to process a position with identical pieces that aren't on legal
     * squares, we permute them and see if we can get them onto legal squares that way.  Now,
     * construct the full set of possible permutations, using an algorithm that generates a series
     * of transpositions that walks the entire set of permutations, and store this as a list
     * attached to the first piece in the set.  We'll also use these permutations when we're
     * translating a foreign position (from a futurebase) into a local position.
     *
     * XXX probably don't need to do this during normalization at all if the semilegal and legal
     * squares are the same, because permuting wouldn't do anything for us then.  Still need
     * it for futurebase translation.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if (tb->last_identical_piece[piece] == -1 && tb->next_identical_piece[piece] != -1) {

	    int identical_pieces = 0;
	    int piece2;

	    int position[MAX_PIECES];
	    int directions[MAX_PIECES];
	    int i;
	    int j;

	    for (piece2 = piece; piece2 != -1; piece2 = tb->next_identical_piece[piece2]) {
		position[identical_pieces] = piece2;
		directions[identical_pieces] = -1;
		identical_pieces ++;
	    }
	    directions[0] = 0;

	    tb->permutations[piece] = (int *) calloc(factorial(identical_pieces), sizeof(int));
	    j = 0;

	    /* Use JohnsonTrotter algorithm to generate all permutations as a series of
	     * transpositions.
	     *
	     * XXX looking at how these permutations get used, maybe we should add a final
	     * transposition to bring us back to the original configuration
	     */

	    while (1) {
		int largest_i_with_nonzero_direction;
		int direction;
		int saved_position;

		largest_i_with_nonzero_direction = -1;

		for (i=0; i<identical_pieces; i++) {
		    if ((directions[i] != 0)
			&& ((largest_i_with_nonzero_direction == -1) 
			    || position[i] > position[largest_i_with_nonzero_direction])) {
			largest_i_with_nonzero_direction = i;
		    }
		}

		if (largest_i_with_nonzero_direction == -1) break;

		tb->permutations[piece][j++] = (position[largest_i_with_nonzero_direction] << 8)
		    | position[largest_i_with_nonzero_direction + directions[largest_i_with_nonzero_direction]];

		direction = directions[largest_i_with_nonzero_direction];

		saved_position = position[largest_i_with_nonzero_direction];
		position[largest_i_with_nonzero_direction] = position[largest_i_with_nonzero_direction + direction];
		position[largest_i_with_nonzero_direction + direction] = saved_position;

		directions[largest_i_with_nonzero_direction] = directions[largest_i_with_nonzero_direction + direction];
		directions[largest_i_with_nonzero_direction + direction] = direction;

		largest_i_with_nonzero_direction += direction;

		if ((largest_i_with_nonzero_direction == 0)
		    || (largest_i_with_nonzero_direction == identical_pieces-1)
		    || (position[largest_i_with_nonzero_direction + directions[largest_i_with_nonzero_direction]] > 
			position[largest_i_with_nonzero_direction])) {
		    directions[largest_i_with_nonzero_direction] = 0;
		}

		for (i=0; i<largest_i_with_nonzero_direction; i++) {
		    if (position[i] > position[largest_i_with_nonzero_direction]) directions[i] = +1;
		}
		for (i=largest_i_with_nonzero_direction; i<identical_pieces; i++) {
		    if (position[i] > position[largest_i_with_nonzero_direction]) directions[i] = -1;
		}
	    }

	    if (j != factorial(identical_pieces)-1) {
		fatal("BUG: did not generate factorial(identical_pieces) permutations\n");
	    }

	}
    }


    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

#if DEBUG
    for (piece = 0; piece < tb->num_pieces; piece ++) {
	fprintf(stderr, "Piece %d: type %s color %s legal_squares %0" PRIx64 " semilegal_squares %0" PRIx64 "\n",
		piece, piece_name[tb->piece_type[piece]], colors[tb->piece_color[piece]],
		tb->legal_squares[piece], tb->semilegal_squares[piece]);
    }
#endif

    /* Fetch the index type */

    index = xmlGetProp(tablebase, BAD_CAST "index");
    index_node = tablebase;  /* XXX here for backwards compatibility */
    if (index == NULL) {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//index", context);
	if (result->nodesetval->nodeNr == 1) {
	    index_node = result->nodesetval->nodeTab[0];
	    index = xmlGetProp(index_node, BAD_CAST "type");
	    xmlChar * index_offset = xmlGetProp(index_node, BAD_CAST "offset");
	    if (index_offset != NULL) {
		tb->index_offset = atoi((char *) index_offset);
		xmlFree(index_offset);
	    }
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }
    if (index == NULL) {
	tb->index_type = NAIVE_INDEX;
	xmlNewProp(tablebase, BAD_CAST "index", BAD_CAST "naive");
	warning("Index type not expressly specified; assuming NAIVE\n");
    } else {
	tb->index_type = find_name_in_array((char *) index, index_types);
	if (tb->index_type == -1) {
	    fatal("Unknown tablebase index type '%s'\n", index);
	    return NULL;
	}
	xmlFree(index);
	index = NULL;
    }

    /* The other encoding schemes depend on a special encoding for the kings, which might not even
     * be present if we're doing a suicide analysis.
     */

    if ((tb->variant == VARIANT_SUICIDE) && (tb->index_type != NAIVE_INDEX)
	&& (tb->index_type != SIMPLE_INDEX) && (tb->index_type != COMBINADIC3_INDEX)) {
	fatal("Only 'naive', 'simple', and 'combinadic3' indices are compatible with 'suicide' variant\n");
	return NULL;
    }

    /* Now, I had this idea that I could completely discard those positions where the king was in
     * check from a frozen piece.  After all, how could a king ever move into check from a frozen
     * piece?  Well, the answer is that if we use this as a futurebase in a later analysis, the king
     * could possibly be in check as we transition between tablebases.  So first I put an option in
     * to turn off this 'feature'.  I'm now convinced that it was such a bad idea that I'm turning
     * it off by default.  So tablebases generated by versions of Hoffman earlier than 1.390 have
     * this on by default; newer versions have it off by default.  Even though we consider positions
     * where the king is in check, we still discard king moves into check by frozen pieces.
     */

    king_positions = xmlGetProp(index_node, BAD_CAST "king-positions");
    if (king_positions != NULL) {
	if (!strcmp((char *) king_positions, "no-frozen-checks")) no_frozen_check_king_positions = 1;
	else no_frozen_check_king_positions = 0;
	xmlFree(king_positions);
    } else {
	if ((generating_version >= 1) && (generating_version <= 390)) no_frozen_check_king_positions = 1;
	else no_frozen_check_king_positions = 0;
    }

    /* Now, compute a bitvector for all the pieces that are frozen on single squares.  This
     * 'frozen_pieces_vector' differs from 'blocked_squares' because a square can be blocked by a
     * pawn that is at least partially mobile on a single file.  Frozen pieces, on the other hand,
     * are completely immobile on a single square.
     *
     * We also use this opportunity to remove from the opposing king's legal squares list any
     * squares that a frozen piece can always capture on.  Due to the possibility of interposition
     * between the frozen piece and the king, this means only the first square in the movement.
     *
     * This doesn't work quite right if we had a non-frozen identical piece overlapping the frozen
     * piece, in which case semilegal_squares has already been expanded out to include the union of
     * the two.  At least this doesn't seem to break anything; just introduce an inefficiency.
     *
     * There is a problem with this that led me to introduce the "king-positions" option to turn
     * this off.  Although a king can never move into check from a frozen piece in the current
     * tablebase, if we're using this as a futurebase, and the piece isn't frozen (or frozen on a
     * different square) in the new tablebase, then a frozen piece move from one tablebase to the
     * other can put the king in check this way.  Still, we'll never back prop out of these
     * positions, only into them, so there might be something to be gained from grouping them all
     * together at the end of the tablebase or something.  Still haven't decided the best
     * way to handle this.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (square = 0; square < 64; square ++) {
	    if (BITVECTOR(square) == tb->semilegal_squares[piece]) {
		if (tb->frozen_pieces_vector & BITVECTOR(square)) {
		    fatal("More than one piece frozen on %c%c", 'a' + COL(square), '1' + ROW(square));
		    return NULL;
		}
		tb->frozen_pieces_vector |= BITVECTOR(square);

		if (no_frozen_check_king_positions) {

		    switch (tb->piece_type[piece]) {
		    case PAWN:
			if (tb->piece_color[piece] == WHITE) {
			    if (COL(square) != 7) tb->illegal_black_king_squares |= BITVECTOR(square + 9);
			    if (COL(square) != 0) tb->illegal_black_king_squares |= BITVECTOR(square + 7);
			} else {
			    if (COL(square) != 7) tb->illegal_white_king_squares |= BITVECTOR(square - 7);
			    if (COL(square) != 0) tb->illegal_white_king_squares |= BITVECTOR(square - 9);
			}
			break;
		    default:
			for (dir=0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {
			    if (movements[tb->piece_type[piece]][square][dir][0].square != -1) {
				if (tb->piece_color[piece] == WHITE) {
				    tb->illegal_black_king_squares
					|= BITVECTOR(movements[tb->piece_type[piece]][square][dir][0].square);
				} else {
				    tb->illegal_white_king_squares
					|= BITVECTOR(movements[tb->piece_type[piece]][square][dir][0].square);
				}
			    }
			}
			break;
		    }
		}

		break;
	    }
	}
    }

    if (tb->variant != VARIANT_SUICIDE) {
	tb->legal_squares[tb->white_king] &= ~ tb->illegal_white_king_squares;
	tb->legal_squares[tb->black_king] &= ~ tb->illegal_black_king_squares;
	tb->semilegal_squares[tb->white_king] &= ~ tb->illegal_white_king_squares;
	tb->semilegal_squares[tb->black_king] &= ~ tb->illegal_black_king_squares;
    }

    /* Strip the locations of frozen pieces off the legal squares bitvectors of all the other
     * pieces.  Like stripping the capture squares off the enemy king's legal bitvector, this is a
     * convenience, so we don't have to list all the free squares for pieces that are not frozen.
     * But we do have to careful about changing this code around, because some index types (like
     * 'simple' and 'compact') implicitly use a piece's legal squares to encode its position, so
     * changing this code can change index encoding.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->semilegal_squares[piece] & tb->frozen_pieces_vector) != tb->semilegal_squares[piece]) {
	    tb->legal_squares[piece] &= ~ tb->frozen_pieces_vector;
	    tb->semilegal_squares[piece] &= ~ tb->frozen_pieces_vector;
	}
    }

    /* get the format */

    format = xmlGetProp(tablebase, BAD_CAST "format");
    if (format != NULL) {
	switch (find_name_in_array((char *) format, formats)) {
	case FORMAT_ONE_BYTE_DTM:
	    tb->format = one_byte_dtm_format;
	    break;
	default:
	    fatal("Unknown tablebase format '%s'\n", format);
	    return NULL;
	}
	xmlFree(format);
    } else {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//format", context);
	if (result->nodesetval->nodeNr == 1) {
	    if (! parse_format(result->nodesetval->nodeTab[0], &tb->format)) return NULL;
	} else {
	    xmlNewProp(tablebase, BAD_CAST "format", BAD_CAST "one-byte-dtm");
	    tb->format = one_byte_dtm_format;
	    warning("Format not expressly specified; assuming ONE-BYTE-DTM\n");
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }

    /* If this is a generation control file, parse any custom formats from the generation controls,
     * and check them against the compiled-in formats.  Even if there's no formats specified in the
     * generation controls, we still want to check to make sure that this version of the program has
     * been compiled with the defaults.  Any mismatch results in a fatal error along with a
     * suggested "formats.h" file to recompile the program with.
     *
     * If all this seems too complicated, then just use the defaults and forget about it...
     */

    if (! is_futurebase) {

	struct format specified_entries_format, specified_proptable_format;
	xmlDocPtr default_formats;
	int format_mismatch = 0;

	/* XXX Will bleed memory during an error return, but this should be global anyway. */

	default_formats = xmlReadMemory(formats_xml, strlen(formats_xml), NULL, NULL, 0);

	/* memcpy(&specified_entries_format, &default_entries_format, sizeof(struct format)); */
	/* memcpy(&specified_proptable_format, &default_proptable_format, sizeof(struct format)); */

	bzero(&specified_entries_format, sizeof(struct format));
	bzero(&specified_proptable_format, sizeof(struct format));

	/* If a custom entries format has been specified, use it */

	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//entries-format", context);
	if (result->nodesetval->nodeNr == 1) {
	    if (! parse_format(result->nodesetval->nodeTab[0], &specified_entries_format)) return NULL;
	    if (specified_entries_format.movecnt_bits == 0) {
		fatal("Entries format must contain a movecnt field\n");
		return NULL;
	    }
	    if ((tb->variant == VARIANT_SUICIDE) && (specified_entries_format.capture_possible_flag_offset == -1)) {
		fatal("Entries format for a suicide analysis must contain a capture-possible-flag\n");
		return NULL;
	    }
	} else {

	    /* Otherwise, use the compiled-in default */

	    context2 = xmlXPathNewContext(default_formats);
	    if (tb->variant == VARIANT_NORMAL) {
		result2 = xmlXPathEvalExpression(BAD_CAST "//default-entries-format", context2);
	    } else {
		result2 = xmlXPathEvalExpression(BAD_CAST "//default-suicide-entries-format", context2);
	    }
	    if (result2->nodesetval->nodeNr == 1) {
		if (! parse_format(result2->nodesetval->nodeTab[0], &specified_entries_format)) {
		    fatal("Can't parse compiled-in default entries format!\n");
		    return NULL;
		}
		if (specified_entries_format.movecnt_bits == 0) {
		    fatal("Compiled-in default entries format does not contain a movecnt field!\n");
		    return NULL;
		}
		if ((tb->variant == VARIANT_SUICIDE) && (specified_entries_format.capture_possible_flag_offset == -1)) {
		    fatal("Compiled-in suicide entries format does not contain a capture-possible-flag!\n");
		    return NULL;
		}
	    } else {
		fatal("No entries-format specified in control file and can't find compiled-in default\n");
		return NULL;
	    }
	    xmlXPathFreeObject(result2);
	    xmlXPathFreeContext(context2);
	}

#if USE_CONST_FORMATS
	if (memcmp(&specified_entries_format, &entries_format, sizeof(struct format))) {
	    fatal("%s entries format incompatible with compiled-in format\n",
		  (result->nodesetval->nodeNr == 1) ? "Specified" : "Default");
	    format_mismatch = 1;
	}
#else
	memcpy(&entries_format, &specified_entries_format, sizeof(struct format));
#endif

	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);

	/* XXX shouldn't bother with any of this proptable stuff if -P flag wasn't specified */

	/* custom proptable format? use it */

	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//proptable-format", context);
	if (result->nodesetval->nodeNr == 1) {
	    if (! parse_format(result->nodesetval->nodeTab[0], &specified_proptable_format)) return NULL;
	    if (specified_proptable_format.index_bits == 0) {
		fatal("Proptable format must contain an index field\n");
		return NULL;
	    }
	} else {

	    /* Otherwise, use the compiled-in default */

	    context2 = xmlXPathNewContext(default_formats);
	    result2 = xmlXPathEvalExpression(BAD_CAST "//default-proptable-format", context2);
	    if (result2->nodesetval->nodeNr == 1) {
		if (! parse_format(result2->nodesetval->nodeTab[0], &specified_proptable_format)) {
		    fatal("Can't parse compiled-in default proptable format!\n");
		    return NULL;
		}
		if (specified_proptable_format.index_bits == 0) {
		    fatal("Compiled-in default proptable format does not contain an index field!\n");
		    return NULL;
		}
	    } else {
		fatal("No proptable-format specified in control file and can't find compiled-in default\n");
		return NULL;
	    }
	    xmlXPathFreeObject(result2);
	    xmlXPathFreeContext(context2);
	}

#if USE_CONST_FORMATS
	if (memcmp(&default_proptable_format, &proptable_format, sizeof(struct format))) {
	    fatal("%s proptable format incompatible with compiled-in format\n",
		  (result->nodesetval->nodeNr == 1) ? "Specified" : "Default");
	    format_mismatch = 1;
	}
#else
	memcpy(&proptable_format, &specified_proptable_format, sizeof(struct format));
#endif

	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);

	xmlFreeDoc(default_formats);

	if (format_mismatch) {
	    fatal("Recompile using this \"formats.h\":\n");
	    fatal(print_format("entries_format", &specified_entries_format));
	    fatal(print_format("proptable_format", &specified_proptable_format));
	    return NULL;
	}
    }

    /* Extract index symmetry (if it was specified) */

    index_symmetry = xmlGetProp(index_node, BAD_CAST "symmetry");
    if (index_symmetry != NULL) {
	tb->symmetry = atoi((char *) index_symmetry);
	if ((tb->symmetry != 1) && (tb->symmetry != 2) && (tb->symmetry != 4) && (tb->symmetry != 8)) {
	    fatal("Bad index symmetry %d\n", tb->symmetry);
	}
	xmlFree(index_symmetry);
    } else {
	tb->symmetry = 1;
    }

    if ((tb->variant == VARIANT_SUICIDE) && (tb->symmetry != 1)) {
	fatal("Can't use symmetry with 'suicide' variant (yet)\n");
	return NULL;
    }

    /* Check piece specification to make sure it matches symmetry
     *
     * XXX Some piece restrictions should be allowed for, so long as the restrictions themselves are
     * symmetric.  For example, a rook restricted to a single row is consistent with 2-way symmetry.
     */

    if ((tb->symmetry == 8) && ((tb->index_type == NAIVE_INDEX) || (tb->index_type == NAIVE2_INDEX))) {
	fatal("8-way symmetry incompatible with naive/naive2 index types\n");
	return NULL;
    }

    if (tb->symmetry >= 4) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (tb->piece_type[piece] == PAWN) {
		fatal("Pawns not allowed with 4/8-way symmetric indices\n");
		return NULL;
	    }
	}
    }

    if (tb->symmetry > 1) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (((tb->piece_type[piece] != PAWN) && (tb->legal_squares[piece] != ALL_ONES_BITVECTOR))
		|| ((tb->piece_type[piece] == PAWN) && (tb->legal_squares[piece] != LEGAL_PAWN_BITVECTOR))) {
		fatal("Piece restrictions not allowed with symmetric indices (yet)\n");
		return NULL;
	    }
	}
    }

    if ((tb->index_type != NO_EN_PASSANT_INDEX) && (tb->index_type != COMPACT_INDEX)) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (tb->legal_squares[piece] != tb->semilegal_squares[piece]) {
		fatal("Non-identical overlapping piece restrictions not allowed with this index type\n");
		return NULL;
	    }
	}
    }

    if (tb->index_type == NO_EN_PASSANT_INDEX) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    int col;
	    int row1 = (tb->piece_color[piece] == WHITE) ? 1 : 6;
	    int row3 = (tb->piece_color[piece] == WHITE) ? 3 : 4;
	    int row4 = (tb->piece_color[piece] == WHITE) ? 4 : 3;
	    if (tb->piece_type[piece] != PAWN) continue;
	    for (col = 0; col < 8; col ++) {
		if (tb->legal_squares[piece]
		    & (BITVECTOR(rowcol2square(row1, col)) | BITVECTOR(rowcol2square(row3, col)))) {
		    for (piece2 = 0; piece2 < tb->num_pieces; piece2 ++) {
			if (tb->piece_type[piece2] != PAWN) continue;
			if (tb->piece_color[piece2] == tb->piece_color[piece]) continue;
			if ((col > 0)
			    && (tb->legal_squares[piece2] & BITVECTOR(rowcol2square(row4, col-1)))) {
			    fatal("Can't use 'no-en-passant' index for a tablebase where en-passant captures are possible\n");
			    return NULL;
			}
			if ((col < 7)
			    && (tb->legal_squares[piece2] & BITVECTOR(rowcol2square(row4, col+1)))) {
			    fatal("Can't use 'no-en-passant' index for a tablebase where en-passant captures are possible\n");
			    return NULL;
			}
		    }
		}
	    }
	}
    }

    /* Compute tb->max_index (but see next section of code where it might be modified) */

    switch (tb->index_type) {
    case NAIVE_INDEX:

	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index = (2<<(6*tb->num_pieces)) - 1;
	    break;
	case 2:
	    tb->max_index = (2<<(6*tb->num_pieces - 1)) - 1;
	    break;
	case 4:
	    tb->max_index = (2<<(6*tb->num_pieces - 2)) - 1;
	    break;
	}
	break;

    case NAIVE2_INDEX:

	tb->max_index = 2;

	/* do the white king "by hand" */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index <<= 6;
	    break;
	case 2:
	    tb->max_index <<= 5;
	    break;
	case 4:
	    tb->max_index <<= 4;
	    break;
	}

	tb->prev_piece_in_encoding_group[tb->white_king] = -1;
	tb->next_piece_in_encoding_group[tb->white_king] = -1;

	/* now do everything else */
	for (piece = 1; piece < tb->num_pieces; piece ++) {

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'naive2' index (yet)\n");
		return NULL;
	    }

	    tb->prev_piece_in_encoding_group[piece] = tb->last_identical_piece[piece];
	    tb->next_piece_in_encoding_group[piece] = tb->next_identical_piece[piece];

	    if (tb->prev_piece_in_encoding_group[piece] == -1) tb->max_index <<= 6;
	    else tb->max_index <<=5;
	}
	tb->max_index --;

	break;

    case SIMPLE_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
		 (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {
		if (! (tb->legal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->piece_position[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->piece_index[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->piece_position[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->piece_index[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    tb->max_index *= tb->total_legal_piece_positions[piece];
	}

	tb->max_index --;
	break;

    case COMPACT_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;

		if (tb->positions_with_adjacent_kings_are_illegal
		    && ! check_king_legality(white_king_square, black_king_square)) continue;

		tb->white_king_position[tb->total_legal_king_positions] = white_king_square;
		tb->black_king_position[tb->total_legal_king_positions] = black_king_square;
		tb->king_index[white_king_square][black_king_square] = tb->total_legal_king_positions;
		tb->total_legal_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_king_positions;

	tb->prev_piece_in_encoding_group[tb->white_king] = -1;
	tb->next_piece_in_encoding_group[tb->white_king] = -1;
	tb->prev_piece_in_encoding_group[tb->black_king] = -1;
	tb->next_piece_in_encoding_group[tb->black_king] = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'compact' index (yet)\n");
		return NULL;
	    }

	    tb->prev_piece_in_encoding_group[piece] = tb->last_identical_piece[piece];
	    tb->next_piece_in_encoding_group[piece] = tb->next_identical_piece[piece];

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.
	     */

	    for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
		 (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;

		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->piece_position[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->piece_index[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->piece_position[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->piece_index[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    if (tb->prev_piece_in_encoding_group[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else if (tb->total_legal_piece_positions[piece]
		       != tb->total_legal_piece_positions[tb->prev_piece_in_encoding_group[piece]]) {
		/* Semilegal positions are the union of legal positions for an entire encoding group */
		fatal("BUG: Encoding group don't have the same number of total semilegal positions\n");
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;

    case COMBINADIC_INDEX:
    case COMBINADIC2_INDEX:
    case COMBINADIC3_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	if (tb->variant != VARIANT_SUICIDE) {
	    for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
		if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
		for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		    if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		    if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		    if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		    if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		    if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
			&& (ROW(black_king_square) > COL(black_king_square))) continue;

		    if (tb->positions_with_adjacent_kings_are_illegal
			&& ! check_king_legality(white_king_square, black_king_square)) continue;

		    tb->white_king_position[tb->total_legal_king_positions] = white_king_square;
		    tb->black_king_position[tb->total_legal_king_positions] = black_king_square;
		    tb->king_index[white_king_square][black_king_square] = tb->total_legal_king_positions;
		    tb->total_legal_king_positions ++;
		}
	    }
	    tb->max_index *= tb->total_legal_king_positions;

	    tb->prev_piece_in_encoding_group[tb->white_king] = -1;
	    tb->next_piece_in_encoding_group[tb->white_king] = -1;
	    tb->prev_piece_in_encoding_group[tb->black_king] = -1;
	    tb->next_piece_in_encoding_group[tb->black_king] = -1;
	}

	/* Assign encoding groups, usually groups of identical pieces. */

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    tb->prev_piece_in_encoding_group[piece] = tb->last_identical_piece[piece];
	    tb->next_piece_in_encoding_group[piece] = tb->next_identical_piece[piece];

	    /* An important special case - handle two opposing plus-pawns by combining their
	     * encoding groups, reducing tablebase size.  This also requires extending the semilegal
	     * range of each group.  Note that we only set blocking_piece for plus-pawns, so if two
	     * pieces are mutually blocking, they must be opposing plus-pawns.
	     */

	    if ((tb->index_type == COMBINADIC3_INDEX)
		&& (tb->blocking_piece[piece] != -1)
		&& (tb->blocking_piece[tb->blocking_piece[piece]] == piece)) {

		int piece2;

		if ((tb->blocking_piece[piece] > piece) && (tb->piece_color[piece] != WHITE)) {
		    fatal("Mutually blocking pawns must currently be specified white pawn first\n");
		    return NULL;
		}

		if (tb->blocking_piece[piece] > piece) {
		    if (tb->next_identical_piece[piece] != -1) {
			/* should never happen, we should be blocked by a pawn of opposite color */
			fatal("BUG: not blocked right\n");
		    } else {
			tb->next_piece_in_encoding_group[piece] = tb->blocking_piece[piece];
			for (piece2 = piece; piece2 != -1; piece2 = tb->prev_piece_in_encoding_group[piece2]) {
			    tb->semilegal_squares[piece2]
				|= tb->semilegal_squares[tb->blocking_piece[piece]];
			}
		    }
		} else {
		    if (tb->last_identical_piece[piece] != -1) {
			/* should never happen, we should be blocked by a pawn of opposite color */
			fatal("BUG: not blocked right\n");
		    } else {
			tb->prev_piece_in_encoding_group[piece] = tb->blocking_piece[piece];
			for (piece2 = piece; piece2 != -1; piece2 = tb->next_piece_in_encoding_group[piece2]) {
			    tb->semilegal_squares[piece2]
				|= tb->semilegal_squares[tb->blocking_piece[piece]];
			}
		    }
		}
	    }
	}

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    /* If our semilegal range completely contains the semilegal range of a earlier piece,
	     * that's overlapping, and we'll be able to remove some of our positions since they must
	     * be occupied by the earlier piece.  Later pieces in a set of identical pieces record
	     * the last identical piece as the last overlapping piece.  We remove indices by backing
	     * out to the beginning of our identical set, then going backwards through the earlier
	     * overlapping pieces, decrementing if our piece position is greater than theirs.
	     *
	     * This is not (and can not be) a doubly linked list, since multiple later pieces can
	     * have the same last_overlapping_piece.  Consider an early piece restricted to d4, e4,
	     * d5, e5, a later piece restricted to de, and another later piece restricted to 45.
	     *
	     * This information is calculated and then ignored for the 'combinadic' index type.
	     *
	     * We never assign a "last overlapping piece" to a pawn because of the difficultly in
	     * handling en passant positions, at until I figured out a simple way of handling them
	     * in 'combinadic3'.
	     */

	    tb->last_overlapping_piece[piece] = -1;

	    if ((tb->piece_type[piece] != PAWN) || (tb->index_type == COMBINADIC3_INDEX)) {
		for (piece2 = piece-1; piece2 >= 0; piece2 --) {
		    if ((tb->semilegal_squares[piece] & tb->semilegal_squares[piece2]) == tb->semilegal_squares[piece2]) {
			tb->last_overlapping_piece[piece] = piece2;
			break;
		    }
		}
	    }

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if (tb->prev_piece_in_encoding_group[piece] == -1) {
		piece_in_set = 1;
	    } else if (tb->prev_piece_in_encoding_group[piece] == piece-1) {
		piece_in_set ++;
	    } else {
		fatal("Combinadic index types requires encoding groups to be adjacent in index\n");
	    }

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.  We also
	     * assign squares for en passant capturable pawns by using square numbers in the first
	     * row (i.e, less than 8), since pawns can never be there.
	     */

	    for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
		 (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if ((tb->semilegal_squares[piece] & BITVECTOR(square))
		    || ((tb->piece_type[piece] == PAWN)
			&& (square < 8)
			&& (tb->semilegal_squares[piece]
			    & BITVECTOR(rowcol2square(tb->piece_color[piece] == WHITE ? 3 : 4, square))))) {

		    tb->piece_index[piece][square]
			= choose(tb->total_legal_piece_positions[piece], piece_in_set) * tb->max_index;
		    tb->total_legal_piece_positions[piece] ++;
		} else {
		    tb->piece_index[piece][square] = INVALID_INDEX;
		}

	    }

	    /* Now back out any positions that we saved with the 'combinadic2' or 'combinadic3' indices */

	    if ((tb->index_type == COMBINADIC2_INDEX) || (tb->index_type == COMBINADIC3_INDEX)) {
		for (piece2 = piece; tb->prev_piece_in_encoding_group[piece2] != -1; piece2 = tb->prev_piece_in_encoding_group[piece2]);
		for (piece2 = tb->last_overlapping_piece[piece2]; piece2 != -1; piece2 = tb->last_overlapping_piece[piece2]) {
		    tb->total_legal_piece_positions[piece] --;
		}
	    }

	    if ((tb->prev_piece_in_encoding_group[piece] != -1)
		&& (tb->total_legal_piece_positions[piece]
		    != tb->total_legal_piece_positions[tb->prev_piece_in_encoding_group[piece]])) {
		fatal("BUG: Identical pieces don't have the same number of total semilegal positions\n");
	    }

	    if (tb->next_piece_in_encoding_group[piece] == -1) {
		tb->max_index *= choose(tb->total_legal_piece_positions[piece], piece_in_set);
	    }

	}

	tb->max_index --;
	break;

    case NO_EN_PASSANT_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;

		if (tb->positions_with_adjacent_kings_are_illegal
		    && ! check_king_legality(white_king_square, black_king_square)) continue;

		tb->white_king_position[tb->total_legal_king_positions] = white_king_square;
		tb->black_king_position[tb->total_legal_king_positions] = black_king_square;
		tb->king_index[white_king_square][black_king_square] = tb->total_legal_king_positions;
		tb->total_legal_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_king_positions;

	tb->prev_piece_in_encoding_group[tb->white_king] = -1;
	tb->next_piece_in_encoding_group[tb->white_king] = -1;
	tb->prev_piece_in_encoding_group[tb->black_king] = -1;
	tb->next_piece_in_encoding_group[tb->black_king] = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'no-en-passant' index (yet)\n");
		return NULL;
	    }

	    tb->prev_piece_in_encoding_group[piece] = tb->last_identical_piece[piece];
	    tb->next_piece_in_encoding_group[piece] = tb->next_identical_piece[piece];

	    /* Note that we only set blocking_piece for plus-pawns, so if two pieces are mutually
	     * blocking, they must be opposing plus-pawns.
	     */

	    if ((tb->blocking_piece[piece] != -1)
		&& (tb->blocking_piece[tb->blocking_piece[piece]] == piece)) {

		if ((tb->prev_piece_in_encoding_group[piece] != -1) || (tb->next_piece_in_encoding_group[piece] != -1)) {
		    fatal("Can't have a doubled pawn opposed by enemy pawn (yet)\n");
		    return NULL;
		}
		if ((tb->blocking_piece[piece] > piece) && (tb->piece_color[piece] != WHITE)) {
		    fatal("Mutually blocking pawns must currently be specified white pawn first\n");
		    return NULL;
		}
		if (tb->blocking_piece[piece] > piece) {
		    tb->next_piece_in_encoding_group[piece] = tb->blocking_piece[piece];
		} else {
		    tb->prev_piece_in_encoding_group[piece] = tb->blocking_piece[piece];
		}
		/* We have to extend the semilegal squares of both blocking pawns because the
		 * pairing is based on 2 pieces on n squares using (n)(n-1)/2 numbers.
		 */
		tb->semilegal_squares[piece] |= tb->semilegal_squares[tb->blocking_piece[piece]];
	    }

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.
	     */

	    for (square = (tb->reverse_index_ordering[piece] ? 63 : 0);
		 (tb->reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (tb->reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;

		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->piece_position[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->piece_index[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* Unlike 'compact', we don't have to consider the en-passant case here because
		 * we've already eliminated that as a possibility.  Also unlike 'compact', we've
		 * grouped opposing pawns on the same file.  So if en-passant were allowed, we would
		 * now have to (like 'compact') add an extra position for it, which could cause the
		 * total number of semilegal positions to be different for two grouped pieces.
		 */
	    }
	    if (tb->prev_piece_in_encoding_group[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else if (tb->total_legal_piece_positions[piece]
		       != tb->total_legal_piece_positions[tb->prev_piece_in_encoding_group[piece]]) {
		/* Semilegal positions are the union of legal positions for an entire encoding group */
		fatal("BUG: Encoding group don't have the same number of total semilegal positions\n");
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;

    }

    tb->max_index += tb->index_offset;
    tb->max_uninverted_index = tb->max_index;

    /* See if an index modulus was specified for inversion in a finite field */

    modulus = xmlGetProp(index_node, BAD_CAST "modulus");
    if (modulus != NULL) {
	if (strcmp((char *) modulus, "auto") == 0) {
	    tb->modulus = round_up_to_prime(tb->max_index + 1);
	    if (! is_futurebase) fprintf(stderr, "Using %d as auto modulus\n", tb->modulus);
	} else {
	    tb->modulus = strtoll((const char *) modulus, NULL, 0);
	    if (! is_prime(tb->modulus)) {
		fatal("modulus %d is not a prime number\n", tb->modulus);
		return NULL;
	    }
	    if (tb->modulus <= tb->max_index) {
		fatal("modulus %d less than max_index %d\n", tb->modulus, tb->max_index);
		return NULL;
	    }
	}
	tb->max_index = tb->modulus - 1;
	xmlFree(modulus);
    }

    if (using_proptables && !is_futurebase) {
	if (tb->max_index > PROPTABLE_FORMAT_INDEX_MASK) {
	    fatal("max_index (%d) doesn't fit in proptable's %d bit index field\n", tb->max_index, proptable_format.index_bits);
	}
    }

    /* Fetch any prune enable elements */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//prune-enable | //move-restriction", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	int i;
	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * color_str;
	    xmlChar * type_str;
	    int color;
	    int type;

	    color_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "color");
	    type_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "type");

	    color = find_name_in_array((char *) color_str, colors);
	    type = find_name_in_array((char *) type_str, restriction_types);
	    if ((color == -1) || (type == -1)) {
		fatal("Illegal prune-enable\n");
	    } else {
		tb->prune_enable[color] |= type;
	    }

	    if (color_str != NULL) xmlFree(color_str);
	    if (type_str != NULL) xmlFree(type_str);
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    return (fatal_errors == starting_fatal_errors) ? tb : NULL;
}

/* Parses an XML control file.
 */

xmlNodePtr create_GenStats_node(const char *name)
{
    xmlNodePtr node;

    xmlNodeAddContent(generation_statistics, BAD_CAST "   ");
    node = xmlNewChild(generation_statistics, NULL, BAD_CAST name, NULL);
    xmlNodeAddContent(generation_statistics, BAD_CAST "\n   ");

    return node;
}

tablebase_t * parse_XML_control_file(char *filename)
{
    xmlParserInputBufferPtr dtd_input_buffer;
    xmlDtdPtr dtd;
    xmlDocPtr doc;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    tablebase_t *tb;

    xmlNodePtr tablebase, node;
    char hostname[256];		/* XXX hardwired max */
    struct hostent *he;
    char strbuf[256];

    /* load the DTD from memory */

    dtd_input_buffer = xmlParserInputBufferCreateMem(tablebase_dtd, strlen(tablebase_dtd),
						     XML_CHAR_ENCODING_ASCII);
    dtd = xmlIOParseDTD(NULL, dtd_input_buffer, XML_CHAR_ENCODING_ASCII);

    /* load the control file from the specified filename or URL */

    doc = xmlReadFile(filename, NULL, 0);

    /* check if parsing suceeded */
    if (doc == NULL) {
	fatal("'%s' failed XML read\n", filename);
	return NULL;
    }

    /* Does the tablebase specify URLs to report errors or successful completion to?  If so, extract
     * them now, as early as possible, because we want to report to the error URL in case validation
     * or parsing fails.
     */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//error-report", context);
    if (result->nodesetval->nodeNr > 0) {
	error_report_url = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url");
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//completion-report", context);
    if (result->nodesetval->nodeNr > 0) {
	completion_report_url = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url");
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* check if validation suceeded */
    if (! xmlValidateDtd(xmlNewValidCtxt(), doc, dtd)) {
	fatal("'%s' failed XML validatation\n", filename);
	return NULL;
    }

    tb = parse_XML_into_tablebase(doc, 0);
    if (tb == NULL) return NULL;

    /* We don't free the XML doc because the tablebase struct contains a pointer to it */

    xmlFreeDtd(dtd);

    /* dtd_input_buffer appears to have been freed by freeing the dtd; at least, malloc complains if
     * we try to free it here.
     */

    /* xmlFreeParserInputBuffer(dtd_input_buffer); */

    /* Now, check to see if we already have a generation-statistics element, which would mean this
     * is a restart.  If so, figure out (XXX) where we're going to restart.  In any event, add a new
     * generation-statistics element for the current run, and populate it.
     */

    tablebase = xmlDocGetRootElement(doc);
    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//generation-statistics", context);

    if (xmlXPathNodeSetIsEmpty(result->nodesetval)) {

	do_restart = 0;

	xmlNodeAddContent(tablebase, BAD_CAST "   ");
	generation_statistics = xmlNewChild(tablebase, NULL, BAD_CAST "generation-statistics", NULL);
	xmlNodeAddContent(tablebase, BAD_CAST "\n");

    } else {

	xmlChar * dtm;

	do_restart = 1;

	node = xmlAddNextSibling(result->nodesetval->nodeTab[result->nodesetval->nodeNr - 1], xmlNewText(BAD_CAST "\n   "));
	generation_statistics = xmlAddNextSibling(node, xmlNewDocNode(tb->xml, NULL, BAD_CAST "generation-statistics", NULL));

	xmlXPathFreeObject(result);
	result = xmlXPathEvalExpression(BAD_CAST "//generation-statistics//pass", context);

	dtm = xmlGetProp(result->nodesetval->nodeTab[result->nodesetval->nodeNr - 1], BAD_CAST "dtm");
	if (dtm == NULL) {
	    /* check for futurebase pass */
	    fatal("Last pass before checkpoint wasn't an intratable pass\n");
	} else {
	    last_dtm_before_restart = strtol((const char *)dtm, NULL, 0);
	    xmlFree(dtm);
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    xmlNodeAddContent(generation_statistics, BAD_CAST "\n   ");

    gethostname(hostname, sizeof(hostname));
    he = gethostbyname(hostname);

    xmlNodeSetContent(create_GenStats_node("host"), BAD_CAST he->h_name);
    xmlNodeSetContent(create_GenStats_node("program"), BAD_CAST "Hoffman $Revision: 1.606 $ $Locker: baccala $");
    xmlNodeSetContent(create_GenStats_node("args"), BAD_CAST options_string);
    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&program_start_time.tv_sec));
    if (! do_restart) {
	xmlNodeSetContent(create_GenStats_node("start-time"), BAD_CAST strbuf);
    } else {
	xmlNodeSetContent(create_GenStats_node("restart-time"), BAD_CAST strbuf);
    }

    checkpoint_time = create_GenStats_node("checkpoint-time");

    /* We now want to add the elements positive-passes-needed and negative-passes-needed in such a
     * way that they can be deleted when we're all done.  The problem is the whitespace used for
     * alignment. Studying the libxml2 documentation shows that the first content added will be
     * merged with the previous text node (from the last call to create_GenStats_node) and freed.
     * Then we record the text nodes used to add the whitespace between and after these elements.
     * The next call to create_GenStats_node will add more whitespace, which will get merged with
     * negative_passes_needed_text_node.  When these nodes here are unlinked, everything lines up.
     */

    xmlNodeAddContent(generation_statistics, BAD_CAST "   ");
    positive_passes_needed_node = xmlNewChild(generation_statistics, NULL, BAD_CAST "positive-passes-needed", NULL);
    positive_passes_needed_text_node = xmlAddChild(generation_statistics, xmlNewText(BAD_CAST "\n      "));
    negative_passes_needed_node = xmlNewChild(generation_statistics, NULL, BAD_CAST "negative-passes-needed", NULL);
    negative_passes_needed_text_node = xmlAddChild(generation_statistics, xmlNewText(BAD_CAST "\n   "));

    /* create global counter nodes */

    user_time = create_GenStats_node("user-time");
    system_time = create_GenStats_node("system-time");
    real_time = create_GenStats_node("real-time");
    page_faults = create_GenStats_node("page-faults");
    page_reclaims = create_GenStats_node("page-reclaims");

#ifdef USE_THREADS
    if (num_threads > 1) {
	contended_locks_node = create_GenStats_node("contended-locks");
	contended_indices_node = create_GenStats_node("contended-indices");
    }
#endif

    return tb;
}

/* preload_futurebase_from_file() reads a tablebase's XML header and parses it, leaving the file
 * open and ready to begin reading the first entry with fetch_next_DTM_from_disk().
 *
 * XXX I save the 'filename' and xmlFree it when I unload the futurebase, but that isn't quite right
 * if we're probing!  Fortunately, if we're probing, we never unload the futurebases...
 */

tablebase_t * preload_futurebase_from_file(char *filename)
{
    void * file = NULL;
    xmlDocPtr doc;
    tablebase_t *tb = NULL;
    xmlNodePtr tablebase;
    xmlChar * offsetstr;

    if (rindex(filename, ':') == NULL) {
	int fd;

	fd = open(filename, O_RDONLY|O_LARGEFILE, 0);
	if (fd != -1) {
	    file = zlib_open((void *)((size_t) fd), read_ptr, write_ptr, lseek_ptr, close_ptr, "r");
	}

    } else if (strncmp(filename, "ftp:", 4) == 0) {
#ifdef HAVE_LIBFTP
	void *ptr = ftp_openurl(filename, "r");
	if (ptr != NULL) {
	    file = zlib_open(ptr, ftp_read, ftp_write, ftp_seek, ftp_close, "r");
	}
#else
	fatal("Compiled without ftplib - ftp: URLs unsupported\n");
#endif
    } else if (strncmp(filename, "http:", 5) == 0) {
	fatal("http: URLs currently unsupported for tablebase I/O\n");
    }

    if (file == NULL) {
	fatal("Can't open tablebase '%s'\n", filename);
	return NULL;
    }

    /* My experiments with xmlReadIO indicate that it only calls its read function enough times to
     * get the XML document, which is good, because we don't want it reading the entire file.
     */
    doc = xmlReadIO(&zlib_read_int, NULL, file, NULL, NULL, 0);

    tb = parse_XML_into_tablebase(doc, 1);

    if (tb == NULL) {
	fatal("Futurebase preload failed: '%s'\n", filename);
	return NULL;
    }

    tb->filename = filename;

    tablebase = xmlDocGetRootElement(doc);

    offsetstr = xmlGetProp(tablebase, BAD_CAST "offset");
    tb->offset = strtol((const char *) offsetstr, NULL, 0);
    if (offsetstr != NULL) xmlFree(offsetstr);

    zlib_close(file);

    return tb;
}

void open_futurebase(tablebase_t * tb)
{
    /* already open? */
    if (tb->file != NULL) return;

    if (rindex(tb->filename, ':') == NULL) {
	int fd;
	fd = open(tb->filename, O_RDONLY|O_LARGEFILE, 0);
	if (fd != -1) {
	    tb->file = zlib_open((void *)((size_t) fd), read_ptr, write_ptr, lseek_ptr, close_ptr, "r");
	}
    } else if (strncmp(tb->filename, "ftp:", 4) == 0) {
#ifdef HAVE_LIBFTP
	void *ptr = ftp_openurl(tb->filename, "r");
	if (ptr != NULL) {
	    tb->file = zlib_open(ptr, ftp_read, ftp_write, ftp_seek, ftp_close, "r");
	}
#else
	fatal("Compiled without ftplib - ftp: URLs unsupported\n");
#endif
    } else if (strncmp(tb->filename, "http:", 5) == 0) {
	fatal("http: URLs currently unsupported for tablebase I/O\n");
    }

    if (tb->file == NULL) {
	fatal("Can't open tablebase '%s'\n", tb->filename);
    }

    if (zlib_seek(tb->file, tb->offset, SEEK_SET) != tb->offset) {
	fatal("Seek failed in open_futurebase()\n");
    }

    tb->next_read_index = 0;
}

void close_futurebase(tablebase_t * tb)
{
    if (tb->file != NULL) {
	if (zlib_close(tb->file) != 0) {
	    warning("zlib_close failed in close_futurebase()\n");
	}
    }
    tb->file = NULL;
}

void unload_futurebase(tablebase_t *tb)
{
    if (tb->filename != NULL) xmlFree(tb->filename);
    tb->filename = NULL;

    if (tb->xml != NULL) xmlFreeDoc(tb->xml);
    tb->xml = NULL;

    close_futurebase(tb);
}

/* compute_extra_and_missing_piece()
 *
 * See comments for translate_foreign_position_to_local_position(), since this function mimicks that
 * one, except that this function works on an entire tablebase, while the other one works on a
 * single position within the tablebase.
 */

boolean compute_extra_and_missing_pieces(tablebase_t *tb, tablebase_t *futurebase, char *filename)
{
    int piece;
    int future_piece;
    int piece_vector;
    int color;

    futurebase->extra_piece = -1;
    futurebase->missing_pawn = -1;
    futurebase->missing_non_pawn = -1;

    /* Check futurebase to make sure its prune enable(s) match our own */

    for (color = 0; color < 2; color ++) {
	if (futurebase->prune_enable[color] & ~(tb->prune_enable[futurebase->invert_colors ? 1 - color : color])) {
	    fatal("'%s': Futurebase doesn't match prune-enables!\n", filename);
	    return 0;
	}
    }

    /* The futurebase can have different pieces than the current tablebase.  There can be a single
     * extra piece, as well as a missing pawn and/or a missing non-pawn.  Find them.
     */

    /* piece_vector - set a bit for every piece in current tablebase */
    piece_vector = (1 << tb->num_pieces) - 1;

    for (future_piece = 0; future_piece < futurebase->num_pieces; future_piece ++) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (! (piece_vector & (1 << piece))) continue;
	    if ((tb->piece_type[piece] == futurebase->piece_type[future_piece])
		&& ((!futurebase->invert_colors &&
		     (tb->piece_color[piece] == futurebase->piece_color[future_piece]))
		    || (futurebase->invert_colors &&
			(tb->piece_color[piece] != futurebase->piece_color[future_piece])))) {
		piece_vector ^= (1 << piece);
		break;
	    }
	}
	if (piece == tb->num_pieces) {
	    if ((futurebase->extra_piece == -1) && (futurebase->piece_type[future_piece] != PAWN)) {
		futurebase->extra_piece = future_piece;
	    } else {
		fatal("'%s': Couldn't find future piece in tablebase\n", filename);
		return 0;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] != PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_non_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    if (piece_vector != 0) {
	fatal("'%s': Too many missing pieces in futurebase\n", filename);
	return 0;
    }

    return 1;
}

int autodetect_futurebase_type(tablebase_t *futurebase)
{
    if (futurebase->extra_piece == -1) {
	if ((futurebase->missing_pawn == -1) && (futurebase->missing_non_pawn == -1)) {
	    return FUTUREBASE_NORMAL;
	} else if ((futurebase->missing_pawn != -1) && (futurebase->missing_non_pawn != -1)) {
	    return -1;
	} else {
	    return FUTUREBASE_CAPTURE;
	}
    } else {
	if (futurebase->missing_pawn == -1) {
	    return -1;
	} else if (futurebase->missing_non_pawn == -1) {
	    return FUTUREBASE_PROMOTION;
	} else {
	    return FUTUREBASE_CAPTURE_PROMOTION;
	}
    }
}

/* preload_all_futurebases()
 *
 * In addition to preloading the futurebases, this function also updates the global variables
 * min_tracked_dtm and max_tracked_dtm.
 */

boolean preload_all_futurebases(tablebase_t *tb)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int fbnum;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//futurebase", context);
    num_futurebases = result->nodesetval->nodeNr;
    futurebases = (tablebase_t **) malloc(sizeof(tablebase_t *) * num_futurebases);
    if (futurebases == NULL) {
	fatal("Can't malloc futurebases array\n");
	return 0;
    }

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	xmlChar * filename;
	xmlChar * colors_property;
	xmlChar * type;

	filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "filename");
	if (filename == NULL) {
	    filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "url");
	}
	if (filename == NULL) {
	    fatal("No filename or URL specified in futurebase element\n");
	    continue;
	}

	futurebases[fbnum] = preload_futurebase_from_file((char *) filename);

	/* load_futurebase_from_file() already printed some kind of error message */
	if (futurebases[fbnum] == NULL) continue;

	if (futurebases[fbnum]->variant != tb->variant) {
	    fatal("Futurebases have to use same 'variant' as tablebase under construction!\n");
	    continue;
	}

	if (futurebases[fbnum]->symmetry < tb->symmetry) {
	    fatal("Futurebases can't be less symmetric than the tablebase under construction\n");
	    continue;
	}

	if (futurebases[fbnum]->max_dtm > max_tracked_dtm) max_tracked_dtm = futurebases[fbnum]->max_dtm;
	if (futurebases[fbnum]->min_dtm < min_tracked_dtm) min_tracked_dtm = futurebases[fbnum]->min_dtm;

	futurebases[fbnum]->invert_colors = 0;
	colors_property = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "colors");
	if (colors_property != NULL) {
	    if (!strcasecmp((char *) colors_property, "invert")) futurebases[fbnum]->invert_colors = 1;
	    xmlFree(colors_property);
	}

	/* We used to have to specify futurebase type in the XML, but now it is autodetected.  Check
	 * for correctness if the XML (optionally now) specified the type.
	 */

	compute_extra_and_missing_pieces(tb, futurebases[fbnum], (char *)filename);
	futurebases[fbnum]->futurebase_type = autodetect_futurebase_type(futurebases[fbnum]);

	if (futurebases[fbnum]->futurebase_type == -1) {
	    fatal("'%s': Can't autodetect futurebase type\n", filename);
	}

	type = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "type");
	if (type != NULL) {
	    if (futurebases[fbnum]->futurebase_type != find_name_in_array((char *) type, futurebase_types)) {
		fatal("'%s': Specified futurebase type '%s' doesn't match autodetected type '%s'\n",
		      filename, type, futurebase_types[futurebases[fbnum]->futurebase_type]);
	    }
	    xmlFree(type);
	}

	/* We can't xmlFree filename here, because it's stashed away in the tablebase structure */
	/* if (filename != NULL) xmlFree(filename); */
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    return (fatal_errors == 0);
}

void unload_all_futurebases(void)
{
    int fbnum;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	unload_futurebase(futurebases[fbnum]);
    }

}

/* finalize_pass_statistics() - this function also collects some of the per-pass statistics,
 * specifically the timings.
 */

void finalize_pass_statistics()
{
    xmlNodePtr passNode;

    static struct timeval last_timeval;
    static struct rusage last_rusage;
    static int last_timings_valid = 0;

    struct timeval timeval;
    struct rusage rusage;

    char strbuf[256];

    /* Update global statistics */

    gettimeofday(&timeval, NULL);
    getrusage(RUSAGE_SELF, &rusage);

    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&timeval.tv_sec));
    xmlNodeSetContent(checkpoint_time, BAD_CAST strbuf);

    sprint_timeval(strbuf, &rusage.ru_utime);
    xmlNodeSetContent(user_time, BAD_CAST strbuf);

    sprint_timeval(strbuf, &rusage.ru_stime);
    xmlNodeSetContent(system_time, BAD_CAST strbuf);

    /* Note that we modified timeval here to compute the real time used by the program */
    subtract_timeval(&timeval, &program_start_time);
    sprint_timeval(strbuf, &timeval);
    xmlNodeSetContent(real_time, BAD_CAST strbuf);

    snprintf(strbuf, sizeof(strbuf), "%ld", rusage.ru_majflt);
    xmlNodeSetContent(page_faults, BAD_CAST strbuf);

    snprintf(strbuf, sizeof(strbuf), "%ld", rusage.ru_minflt);
    xmlNodeSetContent(page_reclaims, BAD_CAST strbuf);

#ifdef USE_THREADS
    if (num_threads > 1) {
	snprintf(strbuf, sizeof(strbuf), "%ld", contended_locks);
	xmlNodeSetContent(contended_locks_node, BAD_CAST strbuf);

	snprintf(strbuf, sizeof(strbuf), "%ld", contended_indices);
	xmlNodeSetContent(contended_indices_node, BAD_CAST strbuf);
    }
#endif

    /* Now add a element with current pass statistics */

    gettimeofday(&timeval, NULL);
    getrusage(RUSAGE_SELF, &rusage);

    xmlNodeAddContent(generation_statistics, BAD_CAST "   ");
    passNode = xmlNewChild(generation_statistics, NULL, BAD_CAST "pass", NULL);
    xmlNodeAddContent(generation_statistics, BAD_CAST "\n   ");

    xmlNewProp(passNode, BAD_CAST "type", BAD_CAST pass_type[total_passes]);

    if (last_timings_valid) {
	subtract_timeval(&timeval, &last_timeval);
	subtract_timeval(&rusage.ru_utime, &last_rusage.ru_utime);
    } else {
	subtract_timeval(&timeval, &program_start_time);
    }

    sprint_timeval(strbuf, &timeval);
    xmlNewProp(passNode, BAD_CAST "real-time", BAD_CAST strbuf);

    sprint_timeval(strbuf, &rusage.ru_utime);
    xmlNewProp(passNode, BAD_CAST "user-time", BAD_CAST strbuf);

    gettimeofday(&last_timeval, NULL);
    getrusage(RUSAGE_SELF, &last_rusage);
    last_timings_valid = 1;

    if (! strcmp(pass_type[total_passes], "intratable")) {
	if (ENTRIES_FORMAT_DTM_BITS > 0) {
	    snprintf(strbuf, sizeof(strbuf), "%d", pass_target_dtms[total_passes]);
	    xmlNewProp(passNode, BAD_CAST "dtm", BAD_CAST strbuf);
	}
	snprintf(strbuf, sizeof(strbuf), "%d", positions_finalized[total_passes]);
	xmlNewProp(passNode, BAD_CAST "positions-finalized", BAD_CAST strbuf);
	snprintf(strbuf, sizeof(strbuf), "%" PRIu64, backproped_moves[total_passes]);
	xmlNewProp(passNode, BAD_CAST "moves-generated", BAD_CAST strbuf);
    }

    if (using_proptables) {
	int i;

	/* update the passes needed nodes */

	xmlNodeSetContent(positive_passes_needed_node, BAD_CAST "");
	for (i = 1; i <= max_tracked_dtm; i ++) {
	    if (positive_passes_needed[i]) {
		snprintf(strbuf, sizeof(strbuf), "%d ", i);
		xmlNodeAddContent(positive_passes_needed_node, BAD_CAST strbuf);
	    }
	}

	xmlNodeSetContent(negative_passes_needed_node, BAD_CAST "");
	for (i = -1; i >= min_tracked_dtm; i --) {
	    if (negative_passes_needed[-i]) {
		snprintf(strbuf, sizeof(strbuf), "%d ", i);
		xmlNodeAddContent(negative_passes_needed_node, BAD_CAST strbuf);
	    }
	}


	xmlSaveFile("checkpoint.xml", current_tb->xml);
    }
}

/* Given a tablebase, change its XML structure to reflect the fact that the tablebase has now
 * actually been built.  Adds a dummy "offset" property to the root element which will be adjusted
 * later to reflect the actual byte offset of the tablebase entries, and a "generated-by" block
 * indicating the program, time, and host that generated the data.
 */

xmlDocPtr finalize_XML_header(tablebase_t *tb)
{
    xmlNodePtr tablebase, node;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    char strbuf[256];

    tablebase = xmlDocGetRootElement(tb->xml);

    xmlNewProp(tablebase, BAD_CAST "offset", BAD_CAST "0x1000");

    /* Add a set of tablebase-statistics.  We prefer to add this before the generation-statistics,
     * because the generation-statistics are long and boring, and because this is how it's always
     * been done.
     */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//generation-statistics", context);
    if (xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	warning("Can't find /generation-statistics in XML\n");

	xmlNodeAddContent(tablebase, BAD_CAST "   ");
	node = xmlNewChild(tablebase, NULL, BAD_CAST "tablebase-statistics", NULL);
    } else {
	node = result->nodesetval->nodeTab[0];
	node = xmlAddPrevSibling(node, xmlNewDocNode(tb->xml, NULL, BAD_CAST "tablebase-statistics", NULL));
	xmlAddNextSibling(node, xmlNewText(BAD_CAST "\n   "));
    }

    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIindex, tb->max_index + 1);
    xmlNewChild(node, NULL, BAD_CAST "indices", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_PNTM_mated_positions);
    xmlNewChild(node, NULL, BAD_CAST "PNTM-mated-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_legal_positions);
    xmlNewChild(node, NULL, BAD_CAST "legal-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_stalemate_positions);
    xmlNewChild(node, NULL, BAD_CAST "stalemate-positions", BAD_CAST strbuf);

    /* If we generating a full tablebase, report both white-wins-positions and black-wins-positions.
     * If we generating a bitbase, report only one or the other of white-wins-positions or
     * white-wins-or-draws-positions.
     */

    if ((tb->format.dtm_bits > 0) || (tb->format.basic_offset != -1) || (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS)) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	snprintf(strbuf, sizeof(strbuf), "%" PRIu64, player_wins[0]);
	xmlNewChild(node, NULL, BAD_CAST "white-wins-positions", BAD_CAST strbuf);
    }
    if ((tb->format.dtm_bits > 0) || (tb->format.basic_offset != -1)) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	snprintf(strbuf, sizeof(strbuf), "%" PRIu64, player_wins[1]);
	xmlNewChild(node, NULL, BAD_CAST "black-wins-positions", BAD_CAST strbuf);
    }
    if (tb->format.flag_type == FORMAT_FLAG_WHITE_DRAWS) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_legal_positions - player_wins[1]);
	xmlNewChild(node, NULL, BAD_CAST "white-wins-or-draws-positions", BAD_CAST strbuf);
    }

    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_moves);
    xmlNewChild(node, NULL, BAD_CAST "forward-moves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    snprintf(strbuf, sizeof(strbuf), "%" PRIu64, total_futuremoves);
    xmlNewChild(node, NULL, BAD_CAST "futuremoves", BAD_CAST strbuf);
    if (tb->format.dtm_bits > 0) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	snprintf(strbuf, sizeof(strbuf), "%d", max_dtm);
	xmlNewChild(node, NULL, BAD_CAST "max-dtm", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	snprintf(strbuf, sizeof(strbuf), "%d", min_dtm);
	xmlNewChild(node, NULL, BAD_CAST "min-dtm", BAD_CAST strbuf);
    }

    xmlNodeAddContent(node, BAD_CAST "\n   ");

    /* Rename the last checkpoint-time to completion-time */

    node = xmlNewDocNode(tb->xml, NULL, BAD_CAST "completion-time", xmlNodeGetContent(checkpoint_time));
    xmlReplaceNode(checkpoint_time, node);

    /* Remove the passes needed nodes from the XML */

    xmlUnlinkNode(positive_passes_needed_node);
    xmlUnlinkNode(negative_passes_needed_node);
    xmlUnlinkNode(positive_passes_needed_text_node);
    xmlUnlinkNode(negative_passes_needed_text_node);

    return tb->xml;
}


/***** INDICES AND POSITIONS *****/

inline void flip_side_to_move_local(local_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

inline void flip_side_to_move_global(global_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

/* invert_colors_of_global_position - just what its name implies
 *
 * We used to use this when propagating from a futurebase, but now it's only use is in the probe
 * code.  It translates a position for a tablebase built for the opposite colors, say a K+R vs K
 * endgame that we now want to probe where the rook is black, not white.  If there are pawns in the
 * game, this function has to reflect the board around a horizontal centerline.
 */

void invert_colors_of_global_position(global_position_t *global)
{
    int squareA;

    for (squareA=0; squareA < NUM_SQUARES/2; squareA++) {
	unsigned char pieceA;
	unsigned char pieceB;
	int squareB = rowcol2square(7-ROW(squareA),COL(squareA));

	pieceA = global->board[squareA];
	pieceB = global->board[squareB];

	if ((pieceA >= 'A') && (pieceA <= 'Z')) {
	    pieceA += 'a' - 'A';
	} else if ((pieceA >= 'a') && (pieceA <= 'z')) {
	    pieceA += 'A' - 'a';
	}

	if ((pieceB >= 'A') && (pieceB <= 'Z')) {
	    pieceB += 'a' - 'A';
	} else if ((pieceB >= 'a') && (pieceB <= 'z')) {
	    pieceB += 'A' - 'a';
	}
	
	global->board[squareA] = pieceB;
	global->board[squareB] = pieceA;
    }

    if (global->side_to_move == WHITE) {
	global->side_to_move = BLACK;
	if (global->en_passant_square != ILLEGAL_POSITION) global->en_passant_square -= 3*8;
    } else {
	global->side_to_move = WHITE;
	if (global->en_passant_square != ILLEGAL_POSITION) global->en_passant_square += 3*8;
    }
}

/* translate_foreign_index_to_local_position() - one of our key, key functions, used extensively
 * during futurebase back propagation.  It takes an index into a foreign tablebase and converts it
 * to a position in the local tablebase (the tablebase we're processing).  Of course, the pieces
 * might not match up between the two tablebases, but there are only a finite number of possible
 * differences:
 *
 * 1. There can be an "extra" piece in the foreign tablebase that doesn't appear in the
 * local tablebase.
 *
 * 2. There can be up to two "missing" pieces in the local tablebase that don't appear in
 * the foreign tablebase.
 *
 * 3. There can be one piece (the "restricted" piece) that matches up, but is on a square flagged
 * illegal for it in the local tablebase.
 *
 * If there are additional differences not covered in this list (more than one extra piece, for
 * example), or if the index isn't legal in the foreign tablebase, the function returns -1.
 * Otherwise, the return value is a 32 bit integer split into four eight bit fields:
 *
 * bits 0-7:   local tb piece number of missing piece #1
 * bits 8-15:  local tb piece number of restricted piece
 * bits 16-23: foreign tb piece number of extra piece
 * bits 24-31: local tb piece number of missing piece #2
 *
 * If any of the fields are unused (because there is no corresponding piece), it's value is 0x80.
 * If there are two missing pieces and only one of them is a pawn, the pawn will always be returned
 * as missing piece #1.  If there are multiple identical missing pieces, the last one will always be
 * returned as the missing piece(s).
 *
 * The function does not depend on the indexing scheme used by the foreign tablebase.  Instead, it
 * uses index_to_local_position() on the foreign tablebase.
 *
 * This function never calls fatal(), returning -1 instead, since it's used while probing a set of
 * tablebases to see which one of them matches a given position.
 *
 * The only thing I don't like about this function right now is that it returns -1 if there is more
 * than one restricted piece, and we certainly could have liberal tablebases with lots of restricted
 * pieces that we want to back-prop from.
 *
 * XXX need to ASSERT that sizeof(..._pieces_processed_bitvector) is at least MAX_PIECES!!
 *
 * XXX newer versions of hoffman precompute missing/extra/restricted pieces as part of futurebase
 * auto-detection (we used to have to explicitly tell the program which kind of futurebase each one
 * was).  There's probably no reason we couldn't precompute an entire piece-to-piece mapping table
 * from the futurebase to the local tablebase, which should speed up this routine dramatically.
 *
 * XXX we assume that int holds at least 32 bits
 */

#define NONE 0x80

int translate_foreign_position_to_local_position(tablebase_t *foreign_tb, local_position_t *foreign_position,
						 tablebase_t *local_tb, local_position_t *local_position,
						 int invert_colors)
{
    int foreign_piece;
    int local_piece, local_piece2, local_piece3;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    short local_pieces_processed_bitvector = 0;
    short foreign_pieces_processed_bitvector = 0;

    memset(local_position, 0, sizeof(local_position_t));

    for (local_piece = 0; local_piece < local_tb->num_pieces; local_piece ++) {
	local_position->piece_position[local_piece] = ILLEGAL_POSITION;
	local_position->permuted_piece[local_piece] = local_piece;
    }

    local_position->en_passant_square = foreign_position->en_passant_square;
    local_position->side_to_move = foreign_position->side_to_move;

    if (invert_colors) flip_side_to_move_local(local_position);

    /* First, see if we can slot foreign pieces into the local tablebase on legal squares.  We start
     * by slotting them onto semilegal squares, then permuting them around if needed to get them
     * onto legal squares.
     *
     * This code could probably be made more efficient by keeping pointers to the semilegal groups
     * of each piece color/type for each square on the board.
     */

    for (foreign_piece = 0; foreign_piece < foreign_tb->num_pieces; foreign_piece ++) {

	int sq = foreign_position->piece_position[foreign_piece];

	if (invert_colors) sq = rowcol2square(7 - ROW(sq), COL(sq));

	for (local_piece = 0; local_piece < local_tb->num_pieces; local_piece ++) {

	    if ((foreign_tb->piece_type[foreign_piece] == local_tb->piece_type[local_piece])
		&& (invert_colors
		    ? (foreign_tb->piece_color[foreign_piece] != local_tb->piece_color[local_piece])
		    : (foreign_tb->piece_color[foreign_piece] == local_tb->piece_color[local_piece]))
		&& (local_tb->semilegal_squares[local_piece] & BITVECTOR(sq))
		&& !(local_pieces_processed_bitvector & (1 << local_piece))) {

		local_position->piece_position[local_piece] = sq;

		local_pieces_processed_bitvector |= (1 << local_piece);
		foreign_pieces_processed_bitvector |= (1 << foreign_piece);

		break;
	    }
	}
    }

    /* Now permute pieces in the local tablebase to try and get them onto legal squares.
     *
     * XXX does the order of permutations in this function have to match up with normalize_position()?
     */

    for (local_piece = 0; local_piece < local_tb->num_pieces; local_piece ++) {

	/* run this loop once for each set of identical pieces */
	if (local_tb->permutations[local_piece] != NULL) {

	    int perm = 0;
	    int saved_position;

	    while (local_tb->permutations[local_piece][perm] != 0) {

		/* all pieces in this set must be on legal squares, or unassigned */
		for (local_piece2 = local_piece; local_piece2 != -1;
		     local_piece2 = local_tb->next_identical_piece[local_piece2]) {
		    if ((local_position->piece_position[local_piece2] != ILLEGAL_POSITION)
			&& ! (local_tb->legal_squares[local_piece2] & BITVECTOR(local_position->piece_position[local_piece2]))) {
			break;
		    }
		}

		if (local_piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* permute */
		transpose_array(local_position->piece_position,
				local_tb->permutations[local_piece][perm] & 0xff, local_tb->permutations[local_piece][perm] >> 8);
		perm ++;
	    }

	    /* Did that work?  If not, we can try something else.  Take one of the pieces back off
	     * the board and try again.  Maybe we can pick it up later as a restricted piece.
	     */

	    for (local_piece2 = local_piece; local_piece2 != -1;
		 local_piece2 = local_tb->next_identical_piece[local_piece2]) {
		if ((local_position->piece_position[local_piece2] != ILLEGAL_POSITION)
		    && ! (local_tb->legal_squares[local_piece2] & BITVECTOR(local_position->piece_position[local_piece2]))) {
		    break;
		}
	    }

	    if (local_piece2 == -1) {
		/* we're legal */
		break;
	    }

	    /* Not legal.  Loop through all positions in this set, take each one off in turn, and see if
	     * we can come up with a legal position.
	     *
	     * What if there are multiple possibilities for this?  Can we take off two different positions
	     * and come up with a legal position each time, but with a different restricted piece?
	     */

	    for (local_piece3 = local_piece; local_piece3 != -1;
		 local_piece3 = local_tb->next_identical_piece[local_piece3]) {

		saved_position = local_position->piece_position[local_piece3];
		local_position->piece_position[local_piece3] = ILLEGAL_POSITION;

		for (perm=0; local_tb->permutations[local_piece][perm] != 0; perm++) {

		    int local_piece2;

		    /* all pieces in this set must be on legal squares, or unassigned */
		    for (local_piece2 = local_piece; local_piece2 != -1;
			 local_piece2 = local_tb->next_identical_piece[local_piece2]) {
			if ((local_position->piece_position[local_piece2] != ILLEGAL_POSITION)
			    && ! (local_tb->legal_squares[local_piece2] & BITVECTOR(local_position->piece_position[local_piece2]))) {
			    break;
			}
		    }

		    if (local_piece2 == -1) {
			/* we're legal */
			break;
		    }

		    /* permute */
		    transpose_array(local_position->piece_position,
				    local_tb->permutations[local_piece][perm] & 0xff, local_tb->permutations[local_piece][perm] >> 8);
		}

		for (local_piece2 = local_piece; local_piece2 != -1;
		     local_piece2 = local_tb->next_identical_piece[local_piece2]) {
		    if ((local_position->piece_position[local_piece2] != ILLEGAL_POSITION)
			&& ! (local_tb->legal_squares[local_piece2] & BITVECTOR(local_position->piece_position[local_piece2]))) {
			break;
		    }
		}

		if (local_piece2 == -1) {
		    /* we're legal */
		    break;
		}

		/* this final permutation should take us back to the original position */
		transpose_array(local_position->piece_position,
				local_piece, local_tb->next_identical_piece[local_piece]);

		local_position->piece_position[local_piece3] = saved_position;
	    }

	    if (local_piece2 == -1) {

		/* Whew!  That worked.  Reset our various bitvectors. */

		local_pieces_processed_bitvector &= ~(1 << local_piece3);

		for (foreign_piece = 0; foreign_piece < foreign_tb->num_pieces; foreign_piece ++) {
		    if (foreign_position->piece_position[foreign_piece] == saved_position) {
			foreign_pieces_processed_bitvector &= ~(1 << foreign_piece);
		    }
		}
	    }
	}
    }

    /* If that didn't work for a foreign piece, see if we can slip it in on an illegal square.  We
     * waited until we ran those first loops so we could tell which pieces are unassigned and thus
     * available for a restricted piece.
     */

    for (foreign_piece = 0; foreign_piece < foreign_tb->num_pieces; foreign_piece ++) {

	int sq = foreign_position->piece_position[foreign_piece];

	if (foreign_pieces_processed_bitvector & (1 << foreign_piece)) continue;

	if (invert_colors) sq = rowcol2square(7 - ROW(sq), COL(sq));

	if (restricted_piece != NONE) {
	    /* more than one restricted piece in translation */
	    return -1;
	}

	for (local_piece = 0; local_piece < local_tb->num_pieces; local_piece ++) {

	    if ((foreign_tb->piece_type[foreign_piece] == local_tb->piece_type[local_piece])
		&& (invert_colors
		    ? (foreign_tb->piece_color[foreign_piece] != local_tb->piece_color[local_piece])
		    : (foreign_tb->piece_color[foreign_piece] == local_tb->piece_color[local_piece]))
		&& !(local_pieces_processed_bitvector & (1 << local_piece))) {

		local_position->piece_position[local_piece] = sq;
		local_position->board_vector |= BITVECTOR(sq);
		if (local_tb->piece_color[local_piece] == local_position->side_to_move)
		    local_position->PTM_vector |= BITVECTOR(sq);

		local_pieces_processed_bitvector |= (1 << local_piece);
		foreign_pieces_processed_bitvector |= (1 << foreign_piece);

		restricted_piece = local_piece;

		break;
	    }
	}

	if (local_piece == local_tb->num_pieces) {
	    if (extra_piece != NONE) {
		/* More than one extra piece in translation */
		return -1;
	    }
	    extra_piece = foreign_piece;
	}
    }


    /* Make sure all the local pieces but one or two have been accounted for,
     * and set up our bitboard vectors.
     */

    for (local_piece = 0; local_piece < local_tb->num_pieces; local_piece ++) {
	if (local_pieces_processed_bitvector & (1 << local_piece)) {

	    local_position->board_vector |= BITVECTOR(local_position->piece_position[local_piece]);
	    if (local_tb->piece_color[local_piece] == local_position->side_to_move)
		local_position->PTM_vector |= BITVECTOR(local_position->piece_position[local_piece]);

	} else {

	    if (missing_piece1 == NONE) {
		missing_piece1 = local_piece;
	    } else if (missing_piece2 == NONE) {
		if (local_tb->piece_type[local_piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = local_piece;
		} else {
		    missing_piece2 = local_piece;
		}
	    } else {
		/* More than one missing piece in translation */
		return -1;
	    }

	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);

}

int translate_foreign_index_to_local_position(tablebase_t *foreign_tb, index_t index1, int reflection,
					      tablebase_t *local_tb, local_position_t *local_position, int invert_colors)
{
    local_position_t foreign_position;

    if (! index_to_local_position(foreign_tb, index1, reflection, &foreign_position)) {
#ifdef DEBUG_FUTUREMOVE
	if (index1 == DEBUG_FUTUREMOVE) {
	    info("translate_foreign_index_to_local_position: index_to_local_position failed\n");
	}
#endif
	return -1;
    }

    return translate_foreign_position_to_local_position(foreign_tb, &foreign_position, local_tb, local_position, invert_colors);
}

/* This function works just like previous one.  So much so that I've considered wrapping them
 * together, but since this one is already written, I'll just leave it alone for now.
 *
 * It's only use now is by the probing code (see next function).
 */

index_t global_position_to_local_position(tablebase_t *tb, global_position_t *global, local_position_t *local)
{
    int square;
    tablebase_t fake_tb;
    local_position_t fake_position;

    memset(&fake_tb, 0, sizeof(fake_tb));
    memset(&fake_position, 0, sizeof(fake_position));

    fake_position.side_to_move = global->side_to_move;
    fake_position.en_passant_square = global->en_passant_square;

    for (square = 0; square < NUM_SQUARES; square ++) {
	if ((global->board[square] != 0) && (global->board[square] != ' ')) {
	    int color;
	    int type;

	    for (color = WHITE; color <= BLACK; color ++) {
		for (type = KING; type <= PAWN; type ++) {

		    if (global->board[square] == global_pieces[color][type]) {
			fake_tb.piece_color[fake_tb.num_pieces] = color;
			fake_tb.piece_type[fake_tb.num_pieces] = type;
			fake_position.piece_position[fake_tb.num_pieces] = square;
			fake_tb.num_pieces ++;
		    }
		}
	    }
	}
    }

    return translate_foreign_position_to_local_position(&fake_tb, &fake_position, tb, local, 0);
}

index_t global_position_to_index(tablebase_t *tb, global_position_t *global)
{
    local_position_t local;

    if (global_position_to_local_position(tb, global, &local) != 0x80808080) return INVALID_INDEX;

    return local_position_to_index(tb, &local);
}

/* index_to_global_position()
 *
 * Used during Nalimov tablebase verification (by running through all indices in a tablebase), as
 * well as during probe code to consider possible captures and promotions because they may lead out
 * of the current tablebase.
 *
 * Massively simplified from an earlier implementation because I want to contain the details of
 * indexing to the local position routines.  Probably a little bit slower now, but not too much.
 *
 * Seems never to be used on a tablebase under construction; only on a finished one.
 */

boolean index_to_global_position(tablebase_t *tb, index_t index, global_position_t *global)
{
    local_position_t local;
    int piece;

    memset(global, 0, sizeof(global_position_t));

    if (! index_to_local_position(tb, index, REFLECTION_NONE, &local)) return 0;

    global->side_to_move = local.side_to_move;
    global->en_passant_square = local.en_passant_square;

    for (piece = 0; piece < tb->num_pieces; piece++) {
	global->board[local.piece_position[piece]]
	    = global_pieces[tb->piece_color[piece]][tb->piece_type[piece]];
    }

    return 1;
}


/***** PARSING FEN TO/FROM POSITION STRUCTURES *****/

boolean place_piece_in_local_position(tablebase_t *tb, local_position_t *pos, int square, int color, int type)
{
    int piece;

    if (pos->board_vector & BITVECTOR(square)) return 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == type) && (tb->piece_color[piece] == color)) {
	    pos->piece_position[piece] = square;
	    pos->board_vector |= BITVECTOR(square);
	    if (color == pos->side_to_move) pos->PTM_vector |= BITVECTOR(square);
	    return 1;
	}
    }

    return 0;
}

boolean place_piece_in_global_position(global_position_t *position, int square, int color, int type)
{
    position->board[square] = global_pieces[color][type];
    return 1;
}

boolean parse_FEN_to_local_position(char *FEN_string, tablebase_t *tb, local_position_t *pos)
{
    int row, col;
    int piece;

    memset(pos, 0, sizeof(local_position_t));
    pos->en_passant_square = ILLEGAL_POSITION;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	pos->piece_position[piece] = ILLEGAL_POSITION;
	pos->permuted_piece[piece] = piece;
    }

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

boolean parse_FEN_to_global_position(char *FEN_string, global_position_t *pos)
{
    int row, col;
    global_position_t localpos;

    memset(&localpos, 0, sizeof(global_position_t));
    localpos.en_passant_square = ILLEGAL_POSITION;

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_global_position(&localpos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      localpos.side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      localpos.side_to_move = BLACK;
    } else {
      return 0;
    }

    FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	localpos.en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    /* the point of using 'localpos' was to only modify pos if the parse succeeded */

    memcpy(pos, &localpos, sizeof(global_position_t));
    return 1;
}

/* Note that the buffer in this function is static... */

char * global_position_to_FEN(global_position_t *position)
{
    static char buffer[256];
    char *ptr = buffer;
    int empty_squares;
    int row, col;

    for (row=7; row>=0; row--) {
	empty_squares=0;
	for (col=0; col<=7; col++) {
	    if ((position->board[rowcol2square(row, col)] == ' ') || (position->board[rowcol2square(row,col)] == 0)) {
		empty_squares++;
	    } else {
		if (empty_squares > 0) {
		    *(ptr++) = '0' + empty_squares;
		    empty_squares = 0;
		}
		*(ptr++) = position->board[rowcol2square(row,col)];
	    }
	}
	if (empty_squares > 0) {
	    *(ptr++) = '0' + empty_squares;
	}
	if (row > 0) *(ptr++) = '/';
    }

    *(ptr++) = ' ';

    *(ptr++) = (position->side_to_move == WHITE) ? 'w' : 'b';

    /* no castling rights */

    *(ptr++) = ' ';
    *(ptr++) = '-';
    *(ptr++) = ' ';

    if (position->en_passant_square == ILLEGAL_POSITION) {
	*(ptr++) = '-';
    } else {
	*(ptr++) = 'a' + COL(position->en_passant_square);
	*(ptr++) = '1' + ROW(position->en_passant_square);
    }

    *(ptr++) = '\0';

    return buffer;
}

char * index_to_FEN(tablebase_t *tb, index_t index)
{
    global_position_t global;
    index_to_global_position(tb, index, &global);
    return global_position_to_FEN(&global);
}

/* This routine looks at "movestr" to try and figure out if it is a valid move from this global
 * position.  If so, it changes the global position to reflect the move and returns true.
 * Otherwise, it leaves the global position alone and returns false.
 */

boolean parse_move_in_global_position(char *movestr, global_position_t *global)
{
    int origin_square, destination_square;
    int is_capture = 0;
    unsigned char promotion_piece = '\0';

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	origin_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == 'x') {
	is_capture = 1;
	movestr ++;
    }

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	destination_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == '=') {
	movestr ++;
	promotion_piece = movestr[0];
    }

    if (!(global->board[origin_square] >= 'A' && global->board[origin_square] <= 'Z')
	&& global->side_to_move == WHITE)
	return 0;

    if (!(global->board[origin_square] >= 'a' && global->board[origin_square] <= 'z')
	&& global->side_to_move == BLACK)
	return 0;

    if (global->board[destination_square] >= 'A' && !is_capture) return 0;

    if (!(global->board[destination_square] >= 'A' && global->board[destination_square] <= 'Z')
	&& is_capture && global->side_to_move == BLACK)
	return 0;

    if (!(global->board[destination_square] >= 'a' && global->board[destination_square] <= 'z')
	&& is_capture && global->side_to_move == WHITE)
	return 0;

    global->board[destination_square] = promotion_piece ? promotion_piece : global->board[origin_square];
    global->board[origin_square] = 0;
    if (global->side_to_move == WHITE)
	global->side_to_move = BLACK;
    else
	global->side_to_move = WHITE;

    global->en_passant_square = ILLEGAL_POSITION;

    if ((global->board[destination_square] == 'P') && (origin_square == destination_square - 16)) {
	if (((destination_square % 8 != 0) && (global->board[destination_square - 8 - 1] == 'p'))
	    || ((destination_square % 8 != 7) && (global->board[destination_square - 8 + 1] == 'p'))) {
	    global->en_passant_square = destination_square - 8;
	}
    }
    if ((global->board[destination_square] == 'p') && (origin_square == destination_square + 16)) {
	if (((destination_square % 8 != 0) && (global->board[destination_square + 8 - 1] == 'P'))
	    || ((destination_square % 8 != 7) && (global->board[destination_square + 8 + 1] == 'P'))) {
	    global->en_passant_square = destination_square + 8;
	}
    }

    return 1;
}


/***** THE ENTRIES TABLE(S) *****/

#define LEFTSHIFT(val,bits) (((bits) > 0) ? ((val) << (bits)) : ((val) >> (-(bits))))

/* Fetch an entry pointer from a preloaded tablebase - we're reading from a compressed file
 * (possibly over the network).
 *
 * There's a whole lot of complexity here to achieve caching and also handle variable size tablebase
 * formats.  We keep a variable sized cache of variable sized entries, and have a version of our
 * fetch routine that writes into one particular numbered cache entry, but only after searching all
 * of them for a matching entry.  Then we have a default version that writes into entry 0 (after
 * searching them all), and that's what we use, except when we're prefetching during a multi-task
 * backprop, when we prefetch into the entry number corresponding to the task that will require the
 * entry later.  That way, we insure that the entry is always there when that particular task
 * requests it later (using the default routine), and also that the actual reads occur in order.
 *
 * I know, there's got to be a better way of doing this... maybe by exposing the buffering a little
 * more, and then either stalling the threads when they get to the end of a buffer and need to
 * decompress the next one, or by having a special thread just to do the decompression and try to
 * keep ahead of the others, though that could probably be implemented by having a double buffer
 * approach, and the last thread out of the tail buffer decompresses a new head buffer.
 */

inline void prefetch_entry_pointer(tablebase_t *tb, index_t index, void *entry)
{

    if (tb->file == NULL) {
	fatal("fetch_entry_pointer() called on a non-preloaded tablebase\n");
	terminate();
    }

    if (tb->format.bits == 3) {

	/* Special case for the very common one-byte-DTM format */

	if (index < tb->next_read_index) {
	    if (zlib_seek(tb->file, tb->offset + (off_t)index, SEEK_SET) != tb->offset + (off_t)index) {
		fatal("Seek failed in fetch_entry_pointer()\n");
	    } else {
		tb->next_read_index = index;
	    }
	}

	do {
	    if (zlib_read(tb->file, (char *) entry, 1) != 1) {
		fatal("fetch_entry_pointer() hit EOF reading from disk\n");
	    }
	    tb->next_read_index ++;
	} while (tb->next_read_index <= index);

    } else {

	if (LEFTSHIFT(index, tb->format.bits - 3)
	    < LEFTSHIFT(tb->next_read_index, tb->format.bits - 3)) {
	    if (zlib_seek(tb->file, tb->offset + LEFTSHIFT((off_t)index, tb->format.bits - 3), SEEK_SET)
		!= tb->offset + LEFTSHIFT((off_t)index, tb->format.bits - 3)) {
		fatal("Seek failed in fetch_entry_pointer()\n");
	    } else {
		switch (tb->format.bits) {
		case 0:
		    tb->next_read_index = index & ~7;
		    break;
		case 1:
		    tb->next_read_index = index & ~3;
		    break;
		case 2:
		    tb->next_read_index = index & ~1;
		    break;
		default:
		    tb->next_read_index = index;
		    break;
		}
	    }
	}

	do {
	    if (zlib_read(tb->file, (char *) entry, tb->format.bytes) != tb->format.bytes) {
		fatal("fetch_entry_pointer() hit EOF reading from disk\n");
	    }

	    switch (tb->format.bits) {
	    case 0:
		tb->next_read_index = (tb->next_read_index + 8) & ~7;
		break;
	    case 1:
		tb->next_read_index = (tb->next_read_index + 4) & ~3;
		break;
	    case 2:
		tb->next_read_index = (tb->next_read_index + 2) & ~1;
		break;
	    default:
		tb->next_read_index = tb->next_read_index + 1;
		break;
	    }
	} while (LEFTSHIFT(index, tb->format.bits - 3)
		 >= LEFTSHIFT(tb->next_read_index, tb->format.bits - 3));
    }
}

tablebase_t *cached_tb = NULL;
void *cached_entries = NULL;
index_t *cached_indices = NULL;
int num_cached_entries = 0;

inline entry_t * fetch_entry_pointer_n(tablebase_t *tb, index_t index, int n)
{
    /* First, check to see if we've got the requested index in ANY cache entry */

    if (cached_tb == tb) {

	int i;

	for (i=0; i<num_cached_entries; i++) {

	    if (index == cached_indices[i])
		return (char *)cached_entries + i*tb->format.bytes;

	    if (LEFTSHIFT(index, tb->format.bits - 3) == LEFTSHIFT(cached_indices[i], tb->format.bits - 3))
		return (char *)cached_entries + i*tb->format.bytes;
	}

    } else if (cached_entries != NULL) {

	/* If we're switching tablebases, discard old cache */

	free(cached_entries);
	free(cached_indices);
	cached_entries = NULL;
	cached_indices = NULL;
	num_cached_entries = 0;
	cached_tb = NULL;
    }

    /* If cache isn't big enough, build it or expand it
     *
     * XXX might have a race condition here, if two threads are trying to expand the cache simultaneously
     */

    if (n >= num_cached_entries) {
	cached_entries = realloc(cached_entries, tb->format.bytes * (n+1));
	cached_indices = (index_t *) realloc(cached_indices, sizeof(index_t) * (n+1));
	memset(cached_indices + num_cached_entries, 0xff, sizeof(index_t) * ((n+1) - num_cached_entries));
	num_cached_entries = n+1;
	cached_tb = tb;
    }

    /* It's not there, so fetch it and cache it */

    prefetch_entry_pointer(tb, index, (char *)cached_entries + n*tb->format.bytes);
    cached_indices[n] = index;

    return (char *)cached_entries + n*tb->format.bytes;
}

inline entry_t * fetch_entry_pointer(tablebase_t *tb, index_t index)
{
    return fetch_entry_pointer_n(tb, index, 0);
}

/* Fetch an entry pointer from the current tablebase - a table that's either in memory or on disk.
 */

int entries_read_fd = -1;
int entries_write_fd = -1;

void * entry_buffer = NULL;
index_t entry_buffer_start = 0;
int entry_buffer_size = 4096;

void initialize_current_entries_file(void)
{
    int ret;

    /* first, malloc the entries buffer if it doesn't already exist */

    if (entry_buffer == NULL) {
	entry_buffer = malloc(entry_buffer_size * ENTRIES_FORMAT_BYTES);
	if (entry_buffer == NULL) {
	    fatal("Can't malloc entries buffer\n");
	    return;
	}
	memset(entry_buffer, 0, entry_buffer_size * ENTRIES_FORMAT_BYTES);
    }

    /* create entries file for writing if it isn't already open */

    if (entries_write_fd == -1) {
	entries_write_fd = open("entries_out", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE, 0666);
	if (entries_write_fd == -1) {
	    fatal("Can't open 'entries_out' for read-write: %s\n", strerror(errno));
	    return;
	}
    }

    /* if we're restarting, there should be an input entries file */
    /* XXX not true if the restart is right after futurebase backprop */

    if (do_restart) {
	entries_read_fd = open("entries_in", O_RDONLY | O_LARGEFILE, 0666);

	if (entries_read_fd == -1) {
	    fatal("Can't open 'entries_in' for reading: %s\n", strerror(errno));
	    return;
	}

	entry_buffer_start = 0;
	ret = read(entries_read_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);
	if (ret != entry_buffer_size * ENTRIES_FORMAT_BYTES) {
	    fatal("initial entries read: %s\n", strerror(errno));
	    return;
	}
    }
}

void reset_current_entries_file(void)
{
    int ret;

    /* we're reseting back to the beginning - write the current buffer out, write out everything
     * else, close and reopen both file descriptors, and read the first buffer in
     */

    do_write(entries_write_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);

    if (entries_read_fd != -1) {
	while ((ret = read(entries_read_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES)) != 0) {
	    if (ret != entry_buffer_size * ENTRIES_FORMAT_BYTES) {
		fatal("entries read: %s\n", strerror(errno));
		return;
	    }
	    do_write(entries_write_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);
	}
    }

    if (entries_read_fd != -1) close(entries_read_fd);
    close(entries_write_fd);

    if (rename("entries_out", "entries_in") != 0) {
	fatal("Can't rename entries_out as entries_in\n");
	return;
    }

    entries_read_fd = open("entries_in", O_RDONLY | O_LARGEFILE, 0666);
    entries_write_fd = open("entries_out", O_RDWR | O_CREAT | O_LARGEFILE, 0666);

    if (entries_read_fd == -1) {
	fatal("Can't open 'entries_in' for reading: %s\n", strerror(errno));
	return;
    }
    if (entries_write_fd == -1) {
	fatal("Can't open 'entries_out' for writing: %s\n", strerror(errno));
	return;
    }

    entry_buffer_start = 0;
    ret = read(entries_read_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);
    if (ret != entry_buffer_size * ENTRIES_FORMAT_BYTES) {
	fatal("initial entries read: %s\n", strerror(errno));
	return;
    }

}

void advance_current_entries_file(index_t index)
{
    int ret;

    /* if we're moving past the entry buffer, write it to disk */

    /* XXX multithreading a problem here? */

    while (index >= entry_buffer_start + entry_buffer_size) {
	do_write(entries_write_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);
	if (entries_read_fd != -1) {
	    ret = read(entries_read_fd, entry_buffer, entry_buffer_size * ENTRIES_FORMAT_BYTES);
	    if (ret != entry_buffer_size * ENTRIES_FORMAT_BYTES) {
		fatal("entries read: %s\n", strerror(errno));
		return;
	    }
	} else {
	    memset(entry_buffer, 0, entry_buffer_size * ENTRIES_FORMAT_BYTES);
	}
	entry_buffer_start += entry_buffer_size;
    }
}

inline void * current_entry_pointer(index_t index)
{
    if (!using_proptables) {

	/* entries array exists in memory - so just return a pointer into it */
	return current_tb->entries;

    } else {

	/* proptables - entries array is on disk, so make sure we've got the right buffer and then return the pointer */

	if (entry_buffer_start > index) reset_current_entries_file();
	if (index >= entry_buffer_start + entry_buffer_size) advance_current_entries_file(index);

	return entry_buffer;
    }
}

inline bitoffset current_entry_bitoffset(index_t index)
{
    if (!using_proptables) {

	/* entries array exists in memory - so just bit index into it */
	return index << ENTRIES_FORMAT_BITS;

    } else {

	/* proptables - entries array is on disk, so make sure we've got the right buffer and then return the pointer */

	if (entry_buffer_start > index) reset_current_entries_file();
	if (index >= entry_buffer_start + entry_buffer_size) advance_current_entries_file(index);

	return (index - entry_buffer_start) << ENTRIES_FORMAT_BITS;
    }
}


/* MORE TABLEBASE OPERATIONS - those that probe and manipulate individual position entries
 *
 * "Designed to multi-thread"
 *
 * Keep atomic operations confined to single functions.  Design functions so that functions calling
 * them don't need to know the details of table format, either.
 *
 * These "add one" functions (atomically) add one to the count in question, subtract one from the
 * total move count, and flag the position as 'ready for propagation' (maybe this is just a move
 * count of zero) if the total move count goes to zero.
 *
 * PTM = Player to Move
 * PNTM = Player not to Move
 *
 */

#define MOVECNT_PTM_WINS_PROPED (ENTRIES_FORMAT_MOVECNT_MASK)
#define MOVECNT_PNTM_WINS_PROPED (ENTRIES_FORMAT_MOVECNT_MASK - 1)
#define MOVECNT_PTM_WINS_UNPROPED (ENTRIES_FORMAT_MOVECNT_MASK - 2)
#define MOVECNT_STALEMATE (ENTRIES_FORMAT_MOVECNT_MASK - 3)
#define MOVECNT_MAX (ENTRIES_FORMAT_MOVECNT_MASK - 4)
#define MOVECNT_PNTM_WINS_UNPROPED (0)

/* If the entries format contains a locking bit, spinlock on it to acquire a lock on an entry;
 * otherwise, we have to lock on the entire entries table.
 */

#ifdef USE_THREADS
pthread_mutex_t entries_lock = PTHREAD_MUTEX_INITIALIZER;
#endif

inline void lock_entry(tablebase_t *tb, index_t index)
{
#ifdef USE_THREADS
    if (num_threads == 1) {
    } else if (ENTRIES_FORMAT_LOCKING_BIT_OFFSET >= 0) {
	if (spinlock_bit_field(current_entry_pointer(index),
			       current_entry_bitoffset(index) + ENTRIES_FORMAT_LOCKING_BIT_OFFSET)) {
	    /* contended_indices ++; */
	    (void) __sync_add(&contended_indices, 1);
	}
    } else {
	pthread_mutex_lock(&entries_lock);
    }
#endif
}

inline void unlock_entry(tablebase_t *tb, index_t index)
{
#ifdef USE_THREADS
    if (num_threads == 1) {
    } else if (ENTRIES_FORMAT_LOCKING_BIT_OFFSET >= 0) {
	set_bit_field(current_entry_pointer(index),
		      current_entry_bitoffset(index) + ENTRIES_FORMAT_LOCKING_BIT_OFFSET, 0);
    } else {
	pthread_mutex_unlock(&entries_lock);
    }
#endif
}

inline int get_raw_DTM(tablebase_t *tb, index_t index)
{
    return get_int_field(fetch_entry_pointer(tb, index),
			 tb->format.dtm_offset + ((index << tb->format.bits) % 8),
			 tb->format.dtm_bits);
}

inline int get_entry_raw_DTM(index_t index)
{
    if (ENTRIES_FORMAT_DTM_BITS == 0) return 0;
    return get_int_field(current_entry_pointer(index),
			 current_entry_bitoffset(index) + ENTRIES_FORMAT_DTM_OFFSET,
			 ENTRIES_FORMAT_DTM_BITS);
}

inline void set_entry_raw_DTM(index_t index, int dtm)
{
    if (ENTRIES_FORMAT_DTM_BITS == 0) return;
    set_int_field(current_entry_pointer(index),
		  current_entry_bitoffset(index) + ENTRIES_FORMAT_DTM_OFFSET,
		  ENTRIES_FORMAT_DTM_BITS,
		  dtm);
}

inline int get_entry_movecnt(index_t index)
{
    return get_unsigned_int_field(current_entry_pointer(index),
				  current_entry_bitoffset(index) + ENTRIES_FORMAT_MOVECNT_OFFSET,
				  ENTRIES_FORMAT_MOVECNT_BITS);
}

inline void set_entry_movecnt(index_t index, unsigned int movecnt)
{
    set_unsigned_int_field(current_entry_pointer(index),
			   current_entry_bitoffset(index) + ENTRIES_FORMAT_MOVECNT_OFFSET,
			   ENTRIES_FORMAT_MOVECNT_BITS,
			   movecnt);
}

inline boolean get_entry_capture_possible_flag(index_t index)
{
    if (ENTRIES_FORMAT_CAPTURE_POSSIBLE_FLAG_OFFSET == -1) return 0;
    return get_bit_field(current_entry_pointer(index),
			 current_entry_bitoffset(index) + ENTRIES_FORMAT_CAPTURE_POSSIBLE_FLAG_OFFSET);
}

inline void set_entry_capture_possible_flag(index_t index, boolean flag)
{
    if (ENTRIES_FORMAT_CAPTURE_POSSIBLE_FLAG_OFFSET == -1) return;
    set_bit_field(current_entry_pointer(index),
		  current_entry_bitoffset(index) + ENTRIES_FORMAT_CAPTURE_POSSIBLE_FLAG_OFFSET,
		  flag);
}

inline boolean get_flag(tablebase_t *tb, index_t index)
{
    return get_bit_field(fetch_entry_pointer(tb, index),
			 tb->format.flag_offset + ((index << tb->format.bits) % 8));
}

inline unsigned int get_basic(tablebase_t *tb, index_t index)
{
    return get_unsigned_int_field(fetch_entry_pointer(tb, index),
				  tb->format.basic_offset + ((index << tb->format.bits) % 8), 3);
}

inline short does_PTM_win(index_t index)
{
    return (get_entry_movecnt(index) == MOVECNT_PTM_WINS_PROPED)
	|| (get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED);
}

inline short does_PNTM_win(index_t index)
{
    return (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_PROPED)
	|| (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED);
}

/* Get the result in a format suitable for a one-byte DTM tablebase
 *
 * 0 = draw
 * 1 = PNTM in check (illegal position)
 * N = mate in N-1
 * -1 = PTM checkmated
 * -N = PNTM will have a mate in N-1 after this move
 *
 * The difference between get_DTM (here) and get_raw_DTM (above) is that if the DTM value is less
 * than zero (PNTM wins), but movecnt is still greater than zero, then there are still moves that
 * might let PTM slip off the hook, so in that case we indicate draw.
 */

int get_entry_DTM(index_t index)
{
    return (does_PTM_win(index) || does_PNTM_win(index)) ? get_entry_raw_DTM(index) : 0;
}

inline boolean is_position_valid(tablebase_t *tb, index_t index)
{
    return (get_raw_DTM(tb, index) != 1);
}

/* Five possible ways we can initialize a tablebase entry for a position:
 *  - it's illegal
 *  - PNTM's mated
 *  - PTM's mated
 *  - stalemate
 *  - any other position, with 'movecnt' possible moves out the position
 */

void initialize_entry(tablebase_t *tb, index_t index, int movecnt, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE) {
	fprintf(stderr, "initialize index %d %s movecnt %d; dtm %d\n",
		index, index_to_FEN(tb, index), movecnt, dtm);
    }
#endif

    /* We always initialize with fairly small DTMs (never bigger than two), so we don't need to
     * check these array bounds for overflow here.
     */
    if (dtm > 0) positive_passes_needed[dtm] = 1;
    if (dtm < 0) negative_passes_needed[-dtm] = 1;

    /* XXX there's a matching "XXX" down below where we malloc the entries table and then zero it
     * with memset.  Might be more efficient to set the entire entry here, making sure that we zero
     * out any fields other than movecnt and DTM.  Might be more efficient not to worry so much
     * about efficiency.  ;-)
     */

    set_entry_movecnt(index, movecnt);
    if (ENTRIES_FORMAT_DTM_BITS > 0) set_entry_raw_DTM(index, dtm);
}

void initialize_entry_as_illegal(tablebase_t *tb, index_t index)
{
    /* An "illegal" position is something like one with two pieces both on the same square.  An
     * illegal position in the chess sense, of PNTM being in check, is handled below.  So this
     * function needs to flag the position in such a way that nothing will ever get done with it; in
     * particular, no attempt will ever be made to back propagate it.  Setting everything to zero
     * does the trick.  The zero movecnt doesn't matter, since we'll never back propagate into this
     * position, and the zero DTM ensures that it will always be treated like a draw during
     * a back prop pass - i.e, no attempt will ever be made to finalize it.
     */

    initialize_entry(tb, index, 0, 0);
}

void initialize_entry_with_PTM_mated(tablebase_t *tb, index_t index)
{
    /* This is a classic checkmate - PTM is in check and has no semi-legal moves, let along legal
     * ones.  The case where PTM has semi-legal but no legal moves is handled below, in
     * add_one_to_PNTM_wins().  DTM is -1 here - PNTM wins.
     */

    initialize_entry(tb, index, MOVECNT_PNTM_WINS_UNPROPED, -1);

    /* total_legal_positions ++; */
    (void) __sync_add(&total_legal_positions, 1);
}

void initialize_entry_with_PNTM_mated(tablebase_t *tb, index_t index)
{
    /* In ordinary chess, this kind of position is illegal - PNTM's king can be captured.  We don't
     * count moves into check as part of "movecnt", so we don't want to back propagate from this
     * position.  So we just flag it as a propagated win and DTM to one here - PTM wins.
     *
     * On the other hand, if we're doing a suicide analysis, a PNTM-mated position is a stalemate in
     * ordinary terms (PTM can't move and therefore wins), so we do want to back propagate.
     */

    if (tb->variant == VARIANT_NORMAL) {
	initialize_entry(tb, index, MOVECNT_PTM_WINS_PROPED, 1);
    } else {
	initialize_entry(tb, index, MOVECNT_PTM_WINS_UNPROPED, 1);
    }

    /* total_PNTM_mated_positions ++; */
    (void) __sync_add(&total_PNTM_mated_positions, 1);
}

void initialize_entry_with_stalemate(tablebase_t *tb, index_t index)
{
    /* The only way this function gets called is if the number of semi-legal moves out of the
     * position is zero and we're not in check.  A "semi-legal" move is one that might not actually
     * be legal (because it would move into check), but will be back-propagated in the tablebase.  A
     * stalemate that arises from a position with semi-legal moves but no legal moves will get
     * handled in add_one_to_PNTM_wins() once all of the semi-legal moves have been eliminated.  In
     * short, because there are no semi-legal moves out of this position, we'll never back propagate
     * into this position, so setting movecnt = 1 is an acceptable way of flagging this as a
     * stalemate, since this position's movecnt should never get decremented.
     */

    if (tb->stalemate_prune_type == RESTRICTION_CONCEDE) {
	if (index_to_side_to_move(tb, index) == tb->stalemate_prune_color) {
	    initialize_entry(tb, index, MOVECNT_PTM_WINS_UNPROPED, 2);
	} else {
	    initialize_entry(tb, index, MOVECNT_PNTM_WINS_UNPROPED, -2);
	}
    } else {
	initialize_entry(tb, index, MOVECNT_STALEMATE, 0);
	/* total_stalemate_positions ++; */
	(void) __sync_add(&total_stalemate_positions, 1);
    }

    /* total_legal_positions ++; */
    (void) __sync_add(&total_legal_positions, 1);
}

void initialize_entry_with_movecnt(tablebase_t *tb, index_t index, unsigned int movecnt)
{
    if (movecnt > MOVECNT_MAX) {
	fatal("Attempting to initialize position with a movecnt that won't fit in field!\n");
    }

    initialize_entry(tb, index, movecnt, 0);

    /* total_legal_positions ++; */
    (void) __sync_add(&total_legal_positions, 1);
}

void initialize_entry_with_DTM(tablebase_t *tb, index_t index, int dtm)
{
#if 0
    if (movecnt > MOVECNT_MAX) {
	fatal("Attempting to initialize position with a movecnt that won't fit in field!\n");
    }
#endif

    if (dtm > 0) {
	initialize_entry(tb, index, MOVECNT_PTM_WINS_UNPROPED, dtm);
    } else {
	initialize_entry(tb, index, MOVECNT_PNTM_WINS_UNPROPED, dtm);
    }

    /* total_legal_positions ++; */
    (void) __sync_add(&total_legal_positions, 1);
}

inline void PTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("PTM_wins; index=%d; dtm=%d; table dtm=%d\n", index, dtm, get_entry_raw_DTM(index));
#endif

    if (dtm < 0) {

	fatal("Negative distance to mate in PTM_wins!?\n");

    } else if ((get_entry_movecnt(index) != MOVECNT_PTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_STALEMATE)) {

	/* In ordinary chess, we should never get here with MOVECNT_PNTM_WINS_UNPROPED (or PROPED)
	 * because we have to have decremented the movecnt already to zero to have gotten either of
	 * those flags.  However, if this is a suicide analysis, we can get a MOVECNT_PNTM_WINS from
	 * a forced capture, so we have to exclude this cases.  In any event, this code fragment
	 * only runs for a "normal" movecnt field - none of the five special cases.
	 */

	set_entry_movecnt(index, MOVECNT_PTM_WINS_UNPROPED);
	set_entry_raw_DTM(index, dtm);
	if (dtm <= max_tracked_dtm) positive_passes_needed[dtm] = 1;

    } else if ((dtm < get_entry_raw_DTM(index))
	       && (get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED)) {

	/* This can happen if we get a PTM mate during futurebase back prop, then, later during
	 * futurebase back prop or during intra-table back prop, improve upon the mate.
	 */

	set_entry_raw_DTM(index, dtm);
	if (dtm <= max_tracked_dtm) positive_passes_needed[dtm] = 1;
    }
}

inline void add_one_to_PNTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("add_one_to_PNTM_wins; index=%d; dtm=%d; table dtm=%d\n", index, dtm, get_entry_raw_DTM(index));
#endif

    if (dtm > 0) {
	fatal("Positive distance to mate in PNTM_wins!?\n");
    } else if ((get_entry_movecnt(index) != MOVECNT_PTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_STALEMATE)) {

	/* Again, this is the code for a "normal" movecnt field. */

	set_entry_movecnt(index, get_entry_movecnt(index) - 1);

	if ((dtm < get_entry_raw_DTM(index)) && (get_entry_raw_DTM(index) <= 0)) {
	    /* Since this is PNTM wins, PTM will make the move leading to the slowest mate. */
	    set_entry_raw_DTM(index, dtm);
	}

	if (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED) {  /* i.e, zero */
	    /* This call pushed movecnt to zero, but the passed-in DTM might not be the best line,
	     * so that's why we fetch entry DTM here.
	     */
	    dtm = get_entry_raw_DTM(index);
#ifdef DEBUG_PASS_DEPENDANCIES
	    if ((dtm >= min_tracked_dtm) && (negative_passes_needed[-dtm] == 0)) {
		global_position_t global;
		index_to_global_position(current_tb, index, &global);
		printf("%d pass needed by %" PRIindex " %s\n",
		       dtm, index, global_position_to_FEN(&global));
	    }
#endif
	    if (dtm >= min_tracked_dtm) negative_passes_needed[-dtm] = 1;
	}
    }
}

/***** INTRA-TABLE BACK PROPAGATION *****/

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int reflection);

void back_propagate_index(index_t index, int target_dtm)
{
    /* Symmetry.
     *
     * The only case we really have to worry about here is diagonal symmetry, because in both
     * horizontal and vertical symmetry all of the positions neatly double up, so anytime we'd have
     * a move backprop into our symmetry restriction from outside it, a matching move will backprop
     * from inside out.
     *
     * For diagonal symmetry however, things aren't so neat, because squares along the diagonal map
     * to themselves.  So positions where both kings are on the diagonal don't have a matching
     * double, while the other positions do.  We deal with this here by backproping both the
     * position itself and its matching pair (if one exists).  If one doesn't exist, then
     * back_propagate_index_within_table() will quickly detect this case (when index_to_position
     * returns false).  We also doubled the movecnt of "paired" positions during initialization,
     * because moves will be backproped twice from doubled positions to doubled positions, not just
     * assumed like the horizontal or vertical cases.
     */

    /* static FILE *outfile = NULL; */
    /* if (outfile == NULL) outfile = fopen("indices", "w"); */

    if (((get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED)
	 || (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED))
	&& ((ENTRIES_FORMAT_DTM_BITS == 0) || (get_entry_DTM(index) == target_dtm))) {

	/* fprintf(outfile, "%d\n", index); */
	back_propagate_index_within_table(current_tb, index, REFLECTION_NONE);
	if (current_tb->symmetry == 8) {
	    back_propagate_index_within_table(current_tb, index, REFLECTION_DIAGONAL);
	}

	/* Track statistics.  If we're multi-threaded, we need to make sure these increments are
	 * done atomically.  For the "player wins" statistics, we don't want to count illegal (PNTM
	 * mated) positions, so we don't increment anything if DTM is 1.
	 */

	(void) __sync_add(&positions_finalized[total_passes], 1);

	if (get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED) {
	    set_entry_movecnt(index, MOVECNT_PTM_WINS_PROPED);
	    if (target_dtm > 1) (void) __sync_add(&player_wins[index_to_side_to_move(current_tb, index)], 1);
	} else {
	    set_entry_movecnt(index, MOVECNT_PNTM_WINS_PROPED);
	    (void) __sync_add(&player_wins[1 - index_to_side_to_move(current_tb, index)], 1);
	}

    }

}

/* If we're not using proptables, then this section of code spawns off a number of threads to run
 * through the entries table, intra-table backpropagating to a single target DTM.
 */

typedef struct {
    index_t start_index;
    index_t end_index;
    int target_dtm;
} intratable_propagation_control_t;

void * back_propagate_section(void * ptr)
{
    intratable_propagation_control_t * control = (intratable_propagation_control_t *) ptr;
    index_t index;

    for (index = control->start_index; index <= control->end_index; index ++) {
	back_propagate_index(index, control->target_dtm);
    }

    return NULL;
}

void non_proptable_pass(int target_dtm)
{
#ifndef USE_THREADS

    index_t index;

    for (index = 0; index <= current_tb->max_index; index ++) {
	back_propagate_index(index, target_dtm);
    }

#else

    intratable_propagation_control_t *controls;
    pthread_t *threads;
    int thread;

    /* XXX check for malloc failure */
    controls = (intratable_propagation_control_t *) malloc(sizeof(intratable_propagation_control_t) * num_threads);
    threads = (pthread_t *) malloc(sizeof(pthread_t) * num_threads);

    for (thread = 0; thread < num_threads; thread ++) {
	controls[thread].target_dtm = target_dtm;
	controls[thread].start_index = ((current_tb->max_index+1)*thread)/num_threads;
	if (thread != num_threads-1) {
	    controls[thread].end_index = ((current_tb->max_index+1)*(thread+1))/num_threads - 1;
	} else {
	    controls[thread].end_index = current_tb->max_index;
	}
	pthread_create(&threads[thread], NULL, &back_propagate_section, &controls[thread]);
    }

    for (thread = 0; thread < num_threads; thread ++) {
	pthread_join(threads[thread], NULL);
    }

    free(threads);
    free(controls);

#endif
}

/***** PROPTABLES *****
 *
 * Proptables are used to optimize back propagation for large tablebases that can not fit into RAM.
 * A proptable is a TPIE priority queue that stores pending updates and then retreives them in index
 * sorted order, allowing a batch of updates to be applied with a single linear pass through the
 * entries array.  We maintain two proptables, the input and the output, and as we make a single
 * pass through the tablebase, we're simultaneously committing changes from the input into the
 * current tablebase, and saving into the output any changes being generated.
 *
 * Or not.  We can disable proptables, which forces the program to use a random access pattern on
 * the entries array.  This is currently faster if the entries array can fit into RAM.  In code,
 * commit_update either calls finalize_update immediately (no proptable; random access) or enqueues
 * the update into the output proptable, so that it will later be retrieved and finalized in the
 * next call to proptable_pass, when the output proptable will have become the input proptable.
 *
 * XXX even though we can specify a proptable format in the XML control file, that information is
 * currently ignored.
 *
 * XXX not sure if we should compress the data stream to disk or not.  Might be best to time it.
 *
 * XXX I used to have an option to store a PTM-wins-flag instead of DTM in the proptable entry to
 * make it smaller.  The only time it makes sense to use a PTM-wins-flag in the proptable is if
 * we're generating a bitbase (because otherwise we need a DTM field in the proptable).  Positive or
 * negative DTM values translate directly through to PTM wins or to its inverse, PNTM wins.  The
 * oddball is zero DTM, a draw, which only happens here if we're back propagating from a DTM
 * futurebase.  In that case, we need to look at the sense of the bitbase (white-wins or
 * white-draws), as well as which player is PTM to decide if we should set or clear the propentry's
 * flag.  I took this code out (for now).
 */

void finalize_update(index_t index, short dtm, short movecnt, int futuremove)
{
    int i;

#if 0
    /* Skip everything if the position isn't valid.  In particular, we don't track futuremove
     * propagation for illegal positions.
     */

    if (get_entry_raw_DTM(index) == 1) return;
#endif

    /* If we're doing a suicide analysis, captures are forced, so we never want to back-propagate a
     * non-capture move into a position where a capture was possible.  For futurebase
     * back-propagation into such a position, the only futuremoves listed as possible correspond to
     * capture moves, so the code that called us should have already rejected non-capture
     * futuremoves into such a position.  Now we check the intra-tablebase case and return if the
     * capture-possible-flag is set.
     */

    if ((current_tb->variant == VARIANT_SUICIDE) && (futuremove == NO_FUTUREMOVE)
	&& get_entry_capture_possible_flag(index)) {
	return;
    }

    /* The guts of committing an update into the entries table. */

    lock_entry(current_tb, index);

    if (dtm > 0) {
	PTM_wins(current_tb, index, dtm);
    } else if (dtm < 0) {
	for (i=0; i<movecnt; i++) {
	    add_one_to_PNTM_wins(current_tb, index, dtm);
	}
    }

    unlock_entry(current_tb, index);
}

#ifdef HAVE_LIBTPIE

class proptable_entry {

 public:
    index_t index;
    int dtm;
    unsigned int movecnt;
    int futuremove;

    bool operator<(const proptable_entry &other) const {
	return index < other.index;
    }
};

typedef tpie::priority_queue<class proptable_entry> proptable;

proptable * input_proptable;
proptable * output_proptable;

void finalize_proptable_entry(class proptable_entry propentry)
{
    finalize_update(propentry.index, propentry.dtm, propentry.movecnt, propentry.futuremove);
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index);
void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector);

/* proptable_pass()
 *
 * Commit an old set of proptables into the entries array while writing a new set.
 */

void proptable_pass(int target_dtm)
{
    index_t index;

    input_proptable = output_proptable;
    output_proptable = new proptable;

    /* fprintf(stderr, "proptable_pass(%d); size of proptable: %llu\n", target_dtm, input_proptable->size()); */

    for (index = 0; index <= max_index(current_tb); index ++) {

	futurevector_t futurevector = 0;
	futurevector_t possible_futuremoves = 0;

	if (target_dtm == 0) {
	    possible_futuremoves = initialize_tablebase_entry(current_tb, index);
	}

	if (! input_proptable->empty()) {

	    if (input_proptable->top().index < index) {
		fatal("Out-of-order entries in proptable\n");
	    }

	    while (! input_proptable->empty() && input_proptable->top().index == index) {

		class proptable_entry pt_entry = input_proptable->top();

		input_proptable->pop();

#ifdef DEBUG_MOVE
		if (index == DEBUG_MOVE)
		    fprintf(stderr, "Commiting proptable entry: index %" PRIindex ", dtm %d, movecnt %u, futuremove %d\n",
			    pt_entry.index, pt_entry.dtm, pt_entry.movecnt, pt_entry.futuremove);
#endif

		if (target_dtm != 0) {

		    finalize_proptable_entry(pt_entry);

		} else if (FUTUREVECTOR(pt_entry.futuremove) & possible_futuremoves) {

		    finalize_proptable_entry(pt_entry);

		    /* XXX This code is commented out because double consideration of a futuremove
		     * can happen for symmetric tablebases.  In this case, two different positions
		     * in the futurebase (or maybe just two different reflections of the same
		     * position) can indicate a result for this entry.  Of course, in this
		     * case the result should be the same.
		     *
		     * On the other hand, if we had two different tablebases indicating different
		     * results for the same futuremove, that should trigger a warning.  We could add
		     * that capability to the proptable code without too much trouble, but if we're
		     * just keeping a bit vector in memory to make sure all the futuremoves have
		     * been handled in some way, we don't have enough information to check all
		     * of that.  Right now, we quietly ignore it.
		     */

#if 0
		    if (FUTUREVECTOR(pt_entry.futuremove) & futurevector) {
			global_position_t global;
			index_to_global_position(current_tb, pt_entry.index, &global);
			fatal("Futuremove %d multiply handled: % " PRIindex " %s\n",
			      pt_entry.futuremove, pt_entry.index, global_position_to_FEN(&global));
		    }
#endif

		    futurevector |= FUTUREVECTOR(pt_entry.futuremove);

		}

	    }
	}

	/* We've committed everything for this index that was in the input proptable.  Now either
	 * check for back-propagation and maybe generate some updates for the output proptable
	 * (intra-table case) or check to make sure that we've handled all the futuremoves that we
	 * needed to, and check for conceded futuremoves, too, all in a subroutine.
	 */

	if (target_dtm != 0) {

	    back_propagate_index(index, target_dtm);

	} else {

	    /* Don't track futuremoves for illegal (DTM 1) positions */
	    if (get_entry_DTM(index) != 1) {

		if ((futurevector & possible_futuremoves) != futurevector) {
		    /* Commented out because if we're not using DTM this code will run for illegal positions */
#if 0
		    global_position_t global;
		    index_to_global_position(current_tb, index, &global);
		    fprintf(stderr, "Futuremove discrepancy: %d %s\n", index, global_position_to_FEN(&global));
#endif
		} else {
		    finalize_futuremove(current_tb, index, possible_futuremoves ^ futurevector);
		}

	    }

	}

    }

    delete input_proptable;
}

void insert_new_propentry(index_t index, int dtm, unsigned int movecnt, int futuremove)
{
    class proptable_entry pt_entry;

    pt_entry.index = index;
    pt_entry.dtm = dtm;
    pt_entry.movecnt = movecnt;
    pt_entry.futuremove = futuremove;

    output_proptable->push(pt_entry);

    /* fprintf(stderr, "Size of proptable: %llu\n", output_proptable->size()); */
}


int initialize_proptable(int proptable_MBs)
{
    tpie::tpie_init();
    tpie::get_memory_manager().set_limit(proptable_MBs * 1024 * 1024);

    /* std::cerr << "sizeof(class proptable_entry) = " << sizeof(class proptable_entry) << " bytes" << std::endl; */

    /* tpie::get_log().set_level(tpie::LOG_DEBUG); */

    output_proptable = new proptable;

    proptables_initialized = 1;

    return 1;
}

#endif /* HAVE_LIBTPIE */

/* If we're running multi-threaded, then there is a possibility that 1) two different positions will
 * try to backprop into the same position (if we're not using proptables), or that 2) two different
 * threads will try to insert into the proptable at the same time (if we're using proptables).
 *
 * The first case is handled by a lock/unlock sequence below; the second case is handled by a mutex
 * lock in insert_new_propentry (currently broken; can't multi-thread yet with TPIE).
 */

void commit_update(index_t index, short dtm, short movecnt, int futuremove)
{

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("insert_or_commit_proptable; index=%d; dtm=%d; movecnt=%d; futuremove=%d\n",
	       index, dtm, movecnt, futuremove);
#endif

    backproped_moves[total_passes] ++;

    if (!using_proptables) {

	if (futuremove != NO_FUTUREMOVE) {

	    /* Futuremove - check off bits in an array that got filled in when we initialized
	     *
	     * Do nothing if the bit is clear, either because we were never to process this
	     * futuremove at all (this is how a suicide analysis rejects non-capture futuremoves
	     * from a position where captures are possible), or because a previous pass through this
	     * code has already processed it.  We can't tell the difference at this point, and
	     * probably need to use proptables for more accurate checking.
	     *
	     * This has to be atomically, because there will be other indices in this bit vector.
	     */

	    long long bit_offset = ((long long)index * current_tb->futurevector_bits);

	    if (! test_and_set_bit_field(current_tb->futurevectors, bit_offset + futuremove, 0)) {
		return;
	    }

	}

	finalize_update(index, dtm, movecnt, futuremove);

    } else {

#ifdef HAVE_LIBTPIE
	insert_new_propentry(index, dtm, movecnt, futuremove);
#else
	fatal("Not compiled with proptable support\n");
#endif
    }

}


/* target_dtm == 0 is special because the initialization / futurebase back prop pass
 *
 */

int propagation_pass(int target_dtm)
{
    if (ENTRIES_FORMAT_DTM_OFFSET != -1) {
	if (((target_dtm > 0) && (target_dtm > (ENTRIES_FORMAT_DTM_MASK >> 1)))
	    || ((target_dtm < 0) && (target_dtm < -(int)(ENTRIES_FORMAT_DTM_MASK >> 1)))) {
	    fatal("DTM entry field size exceeded\n");
	    terminate();
	}
    }

    if (pass_type[total_passes] == NULL) pass_type[total_passes] = "intratable";
    pass_target_dtms[total_passes] = target_dtm;

    if (using_proptables) {
#ifdef HAVE_LIBTPIE
	proptable_pass(target_dtm);
#else
	fatal("Not compiled with proptable support\n");
#endif
    } else {
	non_proptable_pass(target_dtm);
    }

    total_backproped_moves += backproped_moves[total_passes];

    if (positions_finalized[total_passes] > 0) {
	if (target_dtm > max_dtm) max_dtm = target_dtm;
	if (target_dtm < min_dtm) min_dtm = target_dtm;
    }

    finalize_pass_statistics();
    info("Pass %3d complete; %d positions finalized\n", target_dtm, positions_finalized[total_passes]);

    total_passes ++;
    if (total_passes == max_passes) expand_per_pass_statistics();

    return positions_finalized[total_passes-1];
}

/***** FUTUREBASES *****/

/* Subroutines to backpropagate an individual index, or an individual local position (these are the
 * "mini" routines), or a set of local positions that differ only in the en passant square.
 *
 * The idea behind the en passant handling is this.  If we back propagate a position with the en
 * passant square set, then that's the only position we process.  If we back prop a position without
 * the en passant square set, then we process not only that position, but also any positions just
 * like it that have en passant set.  The idea being that we set en passant if we actually need it,
 * and we clear it if we don't need it, so if it's clear we need to process positions where it was
 * set, but we didn't use it.
 */

void propagate_index_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
				     short movecnt, int futuremove, index_t current_index)
{
    if (futuremove == -1) {
	global_position_t global;

	index_to_global_position(tb, current_index, &global);
	fatal("Futuremove never assigned: %s\n", global_position_to_FEN(&global));

	return;
    }

#ifdef DEBUG_FUTUREMOVE
    if (future_index == DEBUG_FUTUREMOVE) {
	global_position_t global;

	index_to_global_position(futurebase, future_index, &global);
	info("propagate_index_from_futurebase; %" PRIindex " from %s %" PRIindex " %s\n",
	     current_index, futurebase->filename, future_index, global_position_to_FEN(&global));
    }
#endif

#ifdef DEBUG_MOVE
    if (current_index == DEBUG_MOVE) {
	global_position_t global;

	index_to_global_position(futurebase, future_index, &global);
	info("propagate_index_from_futurebase; %" PRIindex " from %s %" PRIindex " %s\n",
	     current_index, futurebase->filename, future_index, global_position_to_FEN(&global));
    }
#endif

    /* We insert even if dtm is zero because we have to track futuremoves */

    if (futurebase->format.dtm_bits > 0) {

	int dtm = get_raw_DTM(futurebase, future_index);

	if (dtm > 0) {
	    commit_update(current_index, -dtm, movecnt, futuremove);
	} else if (dtm < 0) {
	    commit_update(current_index, -dtm+1, movecnt, futuremove);
	} else {
	    commit_update(current_index, 0, movecnt, futuremove);
	}

    } else if (futurebase->format.basic_offset != -1) {

	int basic = get_basic(futurebase, future_index);

	if (basic == 1) {
	    commit_update(current_index, -2, movecnt, futuremove);
	} else if (basic == 2) {
	    commit_update(current_index, 2, movecnt, futuremove);
	} else {
	    commit_update(current_index, 0, movecnt, futuremove);
	}

    } else {

	boolean flag = get_flag(futurebase, future_index);
	int stm = index_to_side_to_move(futurebase, future_index);

	/* What happens if we're back propagating a flag from a color-inverted futurebase?
	 *
	 * Well, first of all, a "white-wins" flag in an inverted futurebase becomes a "black-wins"
	 * flag here, which is basically a "NOT white-draws" flag, so we have to be careful to
	 * backprop from draw flags to win flags and from win flags to draw flags if the colors have
	 * been inverted.  Other than that, since the side to move we just fetched is in the
	 * futurebase, the white/black sense of the flag matches with it, so we don't need to invert
	 * anything to figure out if this is a PTM win or a PNTM win.
	 */

	/* I use twos here because there's a lot of stuff that gets cut out for the special case of 1 */

	if ((flag && (stm == WHITE)) || (!flag && (stm == BLACK))) {
	    commit_update(current_index, -2, movecnt, futuremove);
	} else {
	    commit_update(current_index, 2, movecnt, futuremove);
	}

    }
}

void propagate_minilocal_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = local_position_to_index(tb, current_position);

    if (current_index == INVALID_INDEX) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_local_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == ILLEGAL_POSITION) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = ILLEGAL_POSITION;
	}
    }
}

void propagate_mini_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = normalized_position_to_index(tb, current_position);

    if (current_index == INVALID_INDEX) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == ILLEGAL_POSITION) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in normalize_position() to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = ILLEGAL_POSITION;
	}
    }
}

/* Reflections.
 *
 * If the futurebase has greater symmetry than the tablebase under construction, then we have to
 * apply a series of reflections to each futurebase position in order to get all the corresponding
 * positions in the current tablebase.  This utility function computes them.
 *
 * If we're back propagating from a futurebase with greater symmetry, then a single futurebase index
 * will correspond to several positions in the current tablebase.  We'll need to apply some
 * reflections to get those additional positions, so compute here how many of them we'll need.  It's
 * a fairly easy calculation, since our symmetry options are currently limited to 1/2/4/8, so a
 * simple ratio suffices, except if both tablebases have symmetry 8, in which case the more complex
 * effects of diagonal symmetry require a double conversion no matter what.
 */


int compute_reflections(tablebase_t *tb, tablebase_t *futurebase, int *reflections)
{
    int max_reflection;

    max_reflection = futurebase->symmetry / tb->symmetry;
    if ((futurebase->symmetry == 8) && (tb->symmetry == 8)) max_reflection = 2;

    reflections[0] = REFLECTION_NONE;
    if (futurebase->symmetry == 8) reflections[1] = REFLECTION_DIAGONAL;
    if (futurebase->symmetry == 4) reflections[1] = REFLECTION_VERTICAL;
    if (futurebase->symmetry == 2) reflections[1] = REFLECTION_HORIZONTAL;
    if (max_reflection >= 4) {
	if (futurebase->symmetry == 8) {
	    /* This is either the 8 -> 2 or 8 -> 1 cases */
	    reflections[2] = reflections[0] | REFLECTION_VERTICAL;
	    reflections[3] = reflections[1] | REFLECTION_VERTICAL;
	} else {
	    /* This is the 4 -> 1 case */
	    reflections[2] = reflections[0] | REFLECTION_HORIZONTAL;
	    reflections[3] = reflections[1] | REFLECTION_HORIZONTAL;
	}
    }
    if (max_reflection == 8) {
	/* The 8 -> 1 case */
	reflections[4] = reflections[0] | REFLECTION_HORIZONTAL;
	reflections[5] = reflections[1] | REFLECTION_HORIZONTAL;
	reflections[6] = reflections[2] | REFLECTION_HORIZONTAL;
	reflections[7] = reflections[3] | REFLECTION_HORIZONTAL;
    }

    return max_reflection;
}


/* Some variables common to many or all of the futurebase backprop routines */

int max_reflection;
int reflections[8];

int promotion_color;
int first_back_rank_square;
int last_back_rank_square;
int promotion_move;

tablebase_t * futurebase;
int invert_colors_of_futurebase;

index_t next_future_index;

#ifdef USE_THREADS
pthread_mutex_t next_future_index_lock = PTHREAD_MUTEX_INITIALIZER;
#endif

/* The four futurebase back-propagation functions
 *
 * All work the same way - they are passed in the current thread number, cast as a pointer, which is
 * only used to tell fetch_entry_pointer_n which cache entry to use (and that probably could be
 * cleaned up).  These functions handle threading differently from the intra-table case, where we
 * split the tablebase up into N sections for the N threads and let each thread tear into its own
 * section.  This time, we're reading the futurebase from disk, and it might be biiiig, so we want
 * to proceed through it sequentially.  Each thread calls the appropriate one of these functions,
 * and they loop until everything is done.  Right at the beginning of the loop you see that they
 * mutex lock to pick up the next future index that needs to be processed.
 *
 * reflections[] is a global variable that gets computed for every futurebase.  See comments on
 * compute_reflections().
 *
 * For each possible reflection of each possible futuremove, we attempt to translate the futurebase
 * pieces into corresponding local tablebase pieces.  Actually, we did this for the entire
 * futurebase when we loaded it, and those piece assignments should never change within a single
 * futurebase, so all we really do is blunder check.
 */

void * propagate_moves_from_promotion_futurebase(void * ptr)
{
    int threadno = (size_t) ptr;
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    local_position_t normalized_position;
    int conversion_result;
    int pawn, extra_piece, restricted_piece, missing_piece2;
    int true_pawn;
    int reflection;
    int promotion;

    /* Shouldn't really need this silly blunder check, but it's outside the loop and has been here a long time. */

    if ((current_tb->piece_type[futurebase->missing_pawn] != PAWN)
	|| (futurebase->piece_type[futurebase->extra_piece] == PAWN)
	|| (!invert_colors_of_futurebase
	    && (current_tb->piece_color[futurebase->missing_pawn] != futurebase->piece_color[futurebase->extra_piece]))
	|| (invert_colors_of_futurebase
	    && (current_tb->piece_color[futurebase->missing_pawn] == futurebase->piece_color[futurebase->extra_piece]))) {
	fatal("Conversion error during promotion back-prop\n");
	return NULL;
    }

    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
	if (futurebase->piece_type[futurebase->extra_piece] == promoted_pieces[promotion]) break;
    }
    if (promotion == promotion_possibilities) {
	fatal("Couldn't find futurebase's extra piece in promoted_pieces list\n");
	return NULL;
    }

    /* XXX We could limit the range of future_index here to only those positions where the promoted
     * piece appears on the back rank.
     */

    while (1) {

#ifdef USE_THREADS
	pthread_mutex_lock_instrumented(&next_future_index_lock);
#endif

	future_index = next_future_index ++;
	if (future_index <= futurebase->max_index) {
	    fetch_entry_pointer_n(futurebase, future_index, threadno);
	}

#ifdef USE_THREADS
	pthread_mutex_unlock(&next_future_index_lock);
#endif

	if (future_index > futurebase->max_index) break;

	/* It's tempting to break out the loop here if the position isn't a win, but we want to
	 * track futuremoves in order to make sure we don't miss one, so the simplest way to do that
	 * is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position (the pawn that
	     * promoted) and one piece extra (what it promoted into).  There can be no pieces on
	     * restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, reflections[reflection],
					  &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     current_tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		pawn = conversion_result & 0xff;                      /* missing_piece1 */
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece != futurebase->extra_piece) || (pawn != futurebase->missing_pawn) || (missing_piece2 != NONE)) {
		    fatal("Conversion error during promotion back-prop (extra %d; missing1 %d, missing2 %d)\n",
			  extra_piece, pawn, missing_piece2);
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != ILLEGAL_POSITION) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical pieces.
		 * Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.  If we've got
		 * a futurebase position with both queens on the back rank, then we have to consider the
		 * possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.
		     *
		     * I used to (pre 1.547) 'break' here if it wasn't, figuring that since
		     * identical pieces are sorted into ascending square numbers, if we'd backed up
		     * to an extra piece that wasn't on the back rank, then there couldn't be any
		     * more identical pieces on the back rank.
		     *
		     * But Laurent Bartholdi exposed that as a bug.  If black is promoting, then we
		     * start with the piece with the highest square number - that isn't on the back
		     * rank - and have to back up to find one that is.
		     *
		     * We could invert the whole piece processing order to make the original
		     * optimization work, but then when you consider what can happen if there are
		     * movement restrictions in the futurebase, maybe the pieces aren't even going
		     * to show up in the right order.  Better to ditch that whole idea, I think.
		     */

		    if ((promotion_sq >= first_back_rank_square) && (promotion_sq <= last_back_rank_square)) {

			/* There has to be an empty square right behind where the pawn came from, and it
			 * has to be at least semilegal for the pawn.
			 */

			if (!(position.board_vector & BITVECTOR(promotion_sq - promotion_move))
			    && (current_tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move))) {

			    /* Because the promoted piece was 'extra' it doesn't appear in the local
			     * position, so we don't have to worry about taking it off the board.  Put
			     * the missing pawn on the seventh (or second).
			     */

			    position.piece_position[pawn] = promotion_sq - promotion_move;

			    /* Normalize the position, and back prop it. */

			    normalized_position = position;

			    normalize_position(current_tb, &normalized_position);

			    true_pawn = normalized_position.permuted_piece[pawn];

			    propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
									  promotions[true_pawn][promotion],
									  &normalized_position);
			}

		    }

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < current_tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == current_tb->num_pieces) {
			    fatal("Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }

    return NULL;
}

void * propagate_moves_from_promotion_capture_futurebase(void * ptr)
{
    int threadno = (size_t) ptr;
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    local_position_t normalized_position;
    int conversion_result;
    int pawn, extra_piece, restricted_piece, missing_piece2;
    int true_captured_piece;
    int true_pawn;
    int reflection;
    int promotion;

    /* Shouldn't really need this silly blunder check, but it's outside the loop and has been here a long time. */

    if ((current_tb->piece_type[futurebase->missing_pawn] != PAWN)
	|| (futurebase->piece_type[futurebase->extra_piece] == PAWN)
	|| (!invert_colors_of_futurebase
	    && (current_tb->piece_color[futurebase->missing_pawn] != futurebase->piece_color[futurebase->extra_piece]))
	|| (invert_colors_of_futurebase
	    && (current_tb->piece_color[futurebase->missing_pawn] == futurebase->piece_color[futurebase->extra_piece]))) {
	fatal("Conversion error during promotion capture back-prop\n");
	return NULL;
    }

    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
	if (futurebase->piece_type[futurebase->extra_piece] == promoted_pieces[promotion]) break;
    }
    if (promotion == promotion_possibilities) {
	fatal("Couldn't find futurebase's extra piece in promoted_pieces list\n");
	return NULL;
    }

    /* XXX We could limit the range of future_index here to only those positions where the promoted
     * piece appears on the back rank.
     */

    while (1) {

#ifdef USE_THREADS
	pthread_mutex_lock_instrumented(&next_future_index_lock);
#endif

	future_index = next_future_index ++;
	if (future_index <= futurebase->max_index) {
	    fetch_entry_pointer_n(futurebase, future_index, threadno);
	}

#ifdef USE_THREADS
	pthread_mutex_unlock(&next_future_index_lock);
#endif

	if (future_index > futurebase->max_index) break;

	/* It's tempting to break out the loop here if the position isn't a win, but we want to
	 * track futuremoves in order to make sure we don't miss one, so the simplest way to do that
	 * is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be two pieces missing from the local position (the pawn that
	     * promoted and the piece it captured) and one piece extra (what it promoted into).
	     * There can be no pieces on restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, reflections[reflection],
					  &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     current_tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		pawn = conversion_result & 0xff;                      /* missing_piece1 */
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece != futurebase->extra_piece) || (pawn != futurebase->missing_pawn)
		    || (missing_piece2 != futurebase->missing_non_pawn)) {
		    fatal("Conversion error during promotion capture back-prop\n");
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != ILLEGAL_POSITION) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical
		 * pieces.  Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.
		 * If we've got a futurebase position with both queens on the back rank, then we
		 * have to consider the possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.
		     *
		     * I used to (pre 1.547) 'break' here if it wasn't, figuring that since
		     * identical pieces are sorted into ascending square numbers, if we'd backed up
		     * to an extra piece that wasn't on the back rank, then there couldn't be any
		     * more identical pieces on the back rank.
		     *
		     * But Laurent Bartholdi exposed that as a bug.  If black is promoting, then we
		     * start with the piece with the highest square number - that isn't on the back
		     * rank - and have to back up to find one that is.
		     *
		     * We could invert the whole piece processing order to make the original
		     * optimization work, but then when you consider what can happen if there are
		     * movement restrictions in the futurebase, maybe the pieces aren't even going
		     * to show up in the right order.  Better to ditch that whole idea, I think.
		     */

		    if ((promotion_sq >= first_back_rank_square) && (promotion_sq <= last_back_rank_square)) {

			/* Put the piece that was captured onto the board on the promotion square. */

			position.piece_position[missing_piece2] = promotion_sq;

			/* Consider first a capture to the left (white's left).  There has to be an
			 * empty square where the pawn came from, and it has to be at least semilegal.
			 */

			if ((COL(promotion_sq) != 0)
			    && !(position.board_vector & BITVECTOR(promotion_sq - promotion_move - 1))
			    && (current_tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move - 1))) {

			    /* Because the promoted piece was 'extra' it doesn't appear in the local
			     * position, so we don't have to worry about taking it off the board.  Put
			     * the missing pawn on the seventh (or second).
			     */

			    position.piece_position[pawn] = promotion_sq - promotion_move - 1;

			    /* Back propagate the resulting position */

			    normalized_position = position;

			    normalize_position(current_tb, &normalized_position);

			    true_captured_piece = normalized_position.permuted_piece[missing_piece2];
			    true_pawn = normalized_position.permuted_piece[pawn];

			    /* This function also back props any similar positions with one of the pawns
			     * from the side that didn't promote in an en passant state.
			     */

			    propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece][promotion],
									  &normalized_position);

			}

			/* Now consider a capture to the right (white's right).  Again, there has to be
			 * an empty square where the pawn came from, and it has to be semilegal.
			 */

			if ((COL(promotion_sq) != 7)
			    && !(position.board_vector & BITVECTOR(promotion_sq - promotion_move + 1))
			    && (current_tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move + 1))) {

			    /* Because the promoted piece was 'extra' it doesn't appear in the local
			     * position, so we don't have to worry about taking it off the board.  Put
			     * the missing pawn on the seventh (or second).
			     */

			    position.piece_position[pawn] = promotion_sq - promotion_move + 1;

			    normalized_position = position;

			    normalize_position(current_tb, &normalized_position);

			    true_captured_piece = normalized_position.permuted_piece[missing_piece2];
			    true_pawn = normalized_position.permuted_piece[pawn];

			    propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece][promotion],
									  &normalized_position);

			}

		    }

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < current_tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == current_tb->num_pieces) {
			    fatal("Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }

    return NULL;
}

/* Propagate moves from a futurebase that resulted from capturing one of the pieces in the current
 * tablebase.
 *
 * I'm thinking of changing that "invert_colors_of_futurebase" flag to be a subroutine that gets
 * passed in.  It could be a pointer to invert_colors_of_global_position to do what it does now.  Or
 * it could be a "reflect board around vertical axis" to move a d4 pawn to e4.  Also see my comments
 * on invert_colors_of_global position.
 */

void consider_possible_captures(index_t future_index, local_position_t *position,
				int capturing_piece, int captured_piece)
{
    int dir;
    struct movement *movementptr;
    local_position_t normalized_position;
    int true_captured_piece;
    int true_capturing_piece;

    /* We only want to consider pieces of the side which captured... */

    if (current_tb->piece_color[capturing_piece] == current_tb->piece_color[captured_piece]) return;

    /* Put the captured piece on the capturing piece's square (from the future position).  */

    position->piece_position[captured_piece] = position->piece_position[capturing_piece];

    /* When we finally convert the position to an index (in local_position_to_index()), we'll make a
     * copy of the position and normalize it by sorting the identical pieces so that they are in
     * ascending order.  But we have to at least be aware of this here, in order to figure out which
     * piece "actually" got captured (we're always called with captured_piece set to the last piece
     * number of any identical pieces), so we can figure out which futuremove number to use.
     */

    /* Now consider all possible backwards movements of the capturing piece. */

    if (current_tb->piece_type[capturing_piece] != PAWN) {

	/* If the square we put the captured piece on isn't semilegal for it, then don't consider
	 * this capturing piece in this future position any more.  This is after the "if" instead of
	 * before it because an en passant pawn capture is special, since then the capturing piece
	 * ends up on a different square from the captured piece.
	 */

	if (!(current_tb->semilegal_squares[captured_piece]
	      & BITVECTOR(position->piece_position[captured_piece]))) {
	    return;
	}

	for (dir = 0; dir < number_of_movement_directions[current_tb->piece_type[capturing_piece]]; dir++) {

	    for (movementptr = movements[current_tb->piece_type[capturing_piece]][position->piece_position[capturing_piece]][dir];
		 (movementptr->vector & position->board_vector) == 0;
		 movementptr++) {

		/* We already checked that the captured piece was on a semilegal square for it.  Now
		 * check the capturing piece.
		 */

		if (! (current_tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

		/* Move the capturing piece, normalize the position, and back prop it.
		 *
		 * We have to figure out the "true" capturing and captured pieces, which might not
		 * be the pieces we started with (see comments on normalization).
		 */

		normalized_position = *position;

		normalized_position.piece_position[capturing_piece] = movementptr->square;

		normalize_position(current_tb, &normalized_position);

		true_capturing_piece = normalized_position.permuted_piece[capturing_piece];
		true_captured_piece = normalized_position.permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      &normalized_position);
	    }
	}

    } else {

	/* Yes, pawn captures are special */

	for (movementptr = capture_pawn_movements_bkwd[position->piece_position[capturing_piece]][current_tb->piece_color[capturing_piece]];
	     movementptr->square != -1;
	     movementptr++) {

	    /* Is there anything on the square the pawn had to capture from? */

	    if ((movementptr->vector & position->board_vector) != 0) continue;

	    /* Move back the capturing pawn and see if it came from a semilegal square for it. */

	    position->piece_position[capturing_piece] = movementptr->square;
	    if (! (current_tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

	    /* And if the captured piece is also on a semilegal square for it... */

	    if ((current_tb->semilegal_squares[captured_piece]
		 & BITVECTOR(position->piece_position[captured_piece]))) {

		normalized_position = *position;

		normalize_position(current_tb, &normalized_position);

		true_capturing_piece = normalized_position.permuted_piece[capturing_piece];
		true_captured_piece = normalized_position.permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      &normalized_position);

	    }

	    /* The en passant special case: if both the piece that captured and the piece that was
	     * captured are both pawns, and either a white pawn captured from the fifth rank, or a
	     * black pawn captured from the fourth, then there are two possible back prop positions
	     * - the obvious one we just handled, and the one where the captured pawn was in an en
	     * passant state.  We also make sure right away that the rank is clear where the pawn
	     * had to come from, and the rank is clear where the pawn had to go to, ensuring that an
	     * en passant move was even possible.
	     */

	    if ((current_tb->piece_type[captured_piece] == PAWN)
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]-8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]+8))) {

		if ((current_tb->piece_color[capturing_piece] == BLACK) && (ROW(movementptr->square) == 3)) {

		    /* A black pawn capturing a white one (en passant)
		     *
		     * The white pawn is actually a rank higher than usual.
		     */

		    normalized_position = *position;

		    normalized_position.en_passant_square = position->piece_position[captured_piece];
		    normalized_position.piece_position[captured_piece] += 8;

		    if ((current_tb->semilegal_squares[captured_piece]
			 & BITVECTOR(normalized_position.piece_position[captured_piece]))) {

			normalize_position(current_tb, &normalized_position);

			true_capturing_piece = normalized_position.permuted_piece[capturing_piece];
			true_captured_piece = normalized_position.permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
								      futurecaptures[true_capturing_piece][true_captured_piece],
								      &normalized_position);

		    }

		}

		if ((current_tb->piece_color[capturing_piece] == WHITE) && (ROW(movementptr->square) == 4)) {

		    /* A white pawn capturing a black one (en passant)
		     *
		     * The black pawn is actually a rank lower than usual.
		     */

		    normalized_position = *position;

		    normalized_position.en_passant_square = position->piece_position[captured_piece];
		    normalized_position.piece_position[captured_piece] -= 8;

		    if ((current_tb->semilegal_squares[captured_piece]
			 & BITVECTOR(normalized_position.piece_position[captured_piece]))) {

			normalize_position(current_tb, &normalized_position);

			true_capturing_piece = normalized_position.permuted_piece[capturing_piece];
			true_captured_piece = normalized_position.permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(current_tb, futurebase, future_index,
								      futurecaptures[true_capturing_piece][true_captured_piece],
								      &normalized_position);

		    }
		}
	    }

	}

    }

    /* Put the capturing piece back where it came from (on the capture square) so that we can use
     * this local position again (on another call to this function) to consider other potential
     * capturing pieces without having to copy or recreate the entire local position structure.
     */


    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

}

void * propagate_moves_from_capture_futurebase(void * ptr)
{
    int threadno = (size_t) ptr;
    index_t future_index;
    local_position_t position;
    int piece;
    int conversion_result;
    int extra_piece, restricted_piece, captured_piece, missing_piece2;
    int reflection;

    while (1) {

#ifdef USE_THREADS
	pthread_mutex_lock_instrumented(&next_future_index_lock);
#endif

	future_index = next_future_index ++;
	if (future_index <= futurebase->max_index) {
	    fetch_entry_pointer_n(futurebase, future_index, threadno);
	}

#ifdef USE_THREADS
	pthread_mutex_unlock(&next_future_index_lock);
#endif

	if (future_index > futurebase->max_index) break;

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position: the piece that
	     * was captured.  There could possibly be one piece on a restricted square, as well.  If
	     * so, then it must be the piece that moved in order to capture.
	     */

	    /* XXX If the futurebase is more liberal than the tablebase, then there will be
	     * positions with multiple restricted pieces that should be quietly ignored.
	     */

	    conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
									  reflections[reflection],
									  current_tb, &position,
									  invert_colors_of_futurebase);

#ifdef DEBUG_FUTUREMOVE
	    if (future_index == DEBUG_FUTUREMOVE) {
		info("capture backprop; reflection=%d; conversion_result=%x\n", reflection, conversion_result);
	    }
#endif

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		captured_piece = conversion_result & 0xff;           /* missing_piece1 */
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece != NONE) || (captured_piece == NONE) || (missing_piece2 != NONE)) {
#if 0
		    fatal("Conversion error during capture back-prop (extra piece %d; missing_piece1 %d, missing_piece2 %d\n", extra_piece, missing_piece1, missing_piece2);
#endif
		    continue;
		}

		/* Since the last move had to have been a capture move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != ILLEGAL_POSITION) continue;

		/* Since the position resulted from a capture, we only want to consider future
		 * positions where the side to move is not the side that captured.
		 */

		if (position.side_to_move != current_tb->piece_color[captured_piece])
		    continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		if (restricted_piece == NONE) {

		    /* No pieces were on restricted squares.  Consider them all as the possible
		     * capturing piece.
		     */

		    for (piece = 0; piece < current_tb->num_pieces; piece++) {

			consider_possible_captures(future_index, &position, piece, captured_piece);
		    }

		} else {

		    /* One piece was on a restricted square.  It's the obvious capturing piece, but
		     * it's not the only possible one, because it might be possible to swap it with
		     * an identical piece that would put it on a semilegal square and put the other
		     * piece on the restricted square.  The simplest way to understand this is in
		     * terms of semilegal group - each square on the board can only have a single
		     * semilegal group for a given piece type and color.  A restricted piece is on a
		     * square whose semilegal group is already full.  If the square's semilegal
		     * group is in fact empty, then there's only one restricted piece we need to
		     * consider.  Otherwise, we need to consider each piece in the semilegal group
		     * as the possible restricted piece.
		     */

		    int restricted_square = position.piece_position[restricted_piece];

		    consider_possible_captures(future_index, &position, restricted_piece, captured_piece);

		    for (piece = 0; piece < current_tb->num_pieces; piece++) {

			if ((current_tb->piece_color[piece] == current_tb->piece_color[restricted_piece])
			    && (current_tb->piece_type[piece] == current_tb->piece_type[restricted_piece])
			    && (current_tb->semilegal_squares[piece] & BITVECTOR(restricted_square))) {

			    position.piece_position[restricted_piece] = position.piece_position[piece];
			    position.piece_position[piece] = restricted_square;

			    consider_possible_captures(future_index, &position, restricted_piece, captured_piece);

			    position.piece_position[piece] = position.piece_position[restricted_piece];
			}
		    }
		}
	    }
	}
    }

    return NULL;
}

/* A "normal" futurebase is one that's identical to our own in terms of the number and types
 * of pieces.  It differs only in the frozen positions of the pieces.
 *
 * XXX not sure how to handle symmetry changes here.  At the moment it's not an issue, since we
 * don't allow frozen pieces in symmetric tablebases.
 */

void * propagate_moves_from_normal_futurebase(void * ptr)
{
    int threadno = (size_t) ptr;
    index_t future_index;
    local_position_t parent_position;
    local_position_t current_position; /* i.e, last position that moved to parent_position */
    int conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int piece;
    int dir;
    struct movement *movementptr;
    int origin_square;

    while (1) {

#ifdef USE_THREADS
	pthread_mutex_lock_instrumented(&next_future_index_lock);
#endif

	future_index = next_future_index ++;
	if (future_index <= futurebase->max_index) {
	    fetch_entry_pointer_n(futurebase, future_index, threadno);
	}

#ifdef USE_THREADS
	pthread_mutex_unlock(&next_future_index_lock);
#endif

	if (future_index > futurebase->max_index) break;

	/* Translate the futurebase index into a local position.  We have exactly the same number
	 * and type of pieces here, but exactly one of them is on a restricted square (according to
	 * the current tablebase).  If more than one of them was on a restricted square, then
	 * there'd be no way we could get to this futurebase with a single move.  On the other hand,
	 * if none of them were on restricted squares, then this would be a position in the current
	 * tablebase.
	 */

	/* XXX we need to permute the restricted piece around in its semilegal set */

	/* XXX If the futurebase is more liberal than the tablebase, then there will be positions
	 * with multiple restricted pieces that should be quietly ignored.
	 */

	conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
								      REFLECTION_NONE,
								      current_tb, &current_position,
								      invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((missing_piece1 != NONE) || (extra_piece != NONE) || (restricted_piece == NONE)) {
		fatal("Conversion error during normal back-prop; extra %d, restricted %d, missing1 %d, missing2 %d\n",
		      extra_piece, restricted_piece, missing_piece1, missing_piece2);
		continue;
	    }

	    piece = restricted_piece;

	    origin_square = current_position.piece_position[piece];

	    /* We've moving BACKWARDS in the game, so this has to be a piece of the player who is
	     * NOT TO PLAY here - this is the LAST move we're considering, not the next move.
	     */

	    if (current_tb->piece_color[piece] == current_position.side_to_move)
		continue;


	    /* If there are any en passant capturable pawns in the position, then the last move had
	     * to have been a pawn move.  In fact, in this case, we already know exactly what the
	     * last move had to have been.
	     */

	    if (current_position.en_passant_square != ILLEGAL_POSITION) {

		if (current_tb->piece_type[piece] != PAWN) continue;

		if (((current_tb->piece_color[piece] == WHITE)
		     && (current_position.piece_position[piece] != current_position.en_passant_square + 8))
		    || ((current_tb->piece_color[piece] == BLACK)
			&& (current_position.piece_position[piece] != current_position.en_passant_square - 8))) {

		    /* No reason to complain here.  Maybe some other pawn was the en passant pawn. */
		    continue;
		}

		flip_side_to_move_local(&current_position);
		current_position.en_passant_square = ILLEGAL_POSITION;

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);
		if (current_tb->piece_color[piece] == WHITE)
		    current_position.piece_position[piece] -= 16;
		else
		    current_position.piece_position[piece] += 16;

		current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		/* We never back out into a restricted position.  Since we've already decided
		 * that this is the only possible back-move from this point, well...
		 */

		if (! (current_tb->semilegal_squares[piece]
		       & BITVECTOR(current_position.piece_position[piece]))) {
		    continue;
		}

		propagate_local_position_from_futurebase(current_tb, futurebase, future_index,
							 futuremoves[piece][origin_square],
							 &current_position);

		continue;

	    }

	    /* Abuse of notation here.  We just want to keep a copy of current_position because we
	     * change it around a lot during the loops below.
	     */

	    parent_position = current_position;

	    if (current_tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[current_tb->piece_type[piece]]; dir++) {

		    /* What about captures?  Well, first of all, there are no captures here!  We're
		     * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		     * Captures are handled by back-propagation from futurebases, not here in the
		     * movement code.  The piece moving had to come from somewhere, and that
		     * somewhere will now be an empty square, so once we've hit another piece along
		     * a movement vector, there's absolutely no need to consider anything further.
		     */

		    for (movementptr
			     = movements[current_tb->piece_type[piece]][parent_position.piece_position[piece]][dir];
			 (movementptr->vector & parent_position.board_vector) == 0;
			 movementptr++) {

			/* We never back out into a restricted position (obviously) */

			if (! (current_tb->semilegal_squares[piece] & movementptr->vector)) continue;

			/* Back stepping a half move here involves several things: flipping the
			 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
			 * the piece (backwards), and considering a bunch of additional positions
			 * identical to the base position except that a single one of the pawns on the
			 * fourth or fifth ranks was capturable en passant.
			 *
			 * Of course, the only way we could have gotten an en passant pawn is if THIS
			 * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
			 * additional en passant positions is taken care of in
			 * propagate_one_move_within_table()
			 */

			flip_side_to_move_local(&current_position);

			/* I go to the trouble to update board_vector here so we can check en passant
			 * legality in propagate_one_move_within_table().
			 */

			current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

			current_position.piece_position[piece] = movementptr->square;

			current_position.board_vector |= BITVECTOR(movementptr->square);

			propagate_local_position_from_futurebase(current_tb, futurebase, future_index,
								 futuremoves[piece][origin_square],
								 &current_position);
		    }
		}

	    } else {

		/* Usual special case for pawns */

		for (movementptr = normal_pawn_movements_bkwd[parent_position.piece_position[piece]][current_tb->piece_color[piece]];
		     (movementptr->vector & parent_position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (current_tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Do we have a backwards pawn move here?
		     *
		     * Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		     * created it.  We handle that as a special case above, so we shouldn't have to
		     * worry about clearing en passant pawns here - there should be none.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     *
		     * But we start with an extra check to make sure this isn't a double pawn move, it
		     * which case it would result in an en passant position, not the non-en passant
		     * position we are in now (en passant got taken care of in the special case above).
		     */

		    if (((movementptr->square - parent_position.piece_position[piece]) == 16)
			|| ((movementptr->square - parent_position.piece_position[piece]) == -16)) {
			continue;
		    }

		    current_position = parent_position;

		    flip_side_to_move_local(&current_position);

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

		    current_position.piece_position[piece] = movementptr->square;

		    current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		    propagate_local_position_from_futurebase(current_tb, futurebase, future_index,
							     futuremoves[piece][origin_square],
							     &current_position);

		}
	    }
	}
    }

    return NULL;
}

/* Back propagates from all the futurebases.
 *
 * Should be called after the tablebase has been initialized, but before intra-table propagation.
 *
 * Runs through the parsed XML control file, pulls out all the futurebases, and back-propagates each
 * one.
 *
 * Returns true, or false if something went wrong
 */

boolean back_propagate_all_futurebases(tablebase_t *tb) {

    int fbnum;
    void * (* backprop_function)(void *);

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {

	futurebase = futurebases[fbnum];

	open_futurebase(futurebase);

	max_reflection = compute_reflections(tb, futurebase, reflections);
	invert_colors_of_futurebase = futurebase->invert_colors;

	next_future_index = 0;
	backprop_function = NULL;

	switch (futurebase->futurebase_type) {

	case FUTUREBASE_CAPTURE:

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) futurebase->filename);
		backprop_function = &propagate_moves_from_capture_futurebase;
	    }

	    break;

	case FUTUREBASE_PROMOTION:

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) futurebase->filename);

		promotion_color = tb->piece_color[futurebase->missing_pawn];
		first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
		last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
		promotion_move = ((promotion_color == WHITE) ? 8 : -8);

		backprop_function = &propagate_moves_from_promotion_futurebase;
	    }

	    break;

	case FUTUREBASE_CAPTURE_PROMOTION:

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) futurebase->filename);

		promotion_color = tb->piece_color[futurebase->missing_pawn];
		first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
		last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
		promotion_move = ((promotion_color == WHITE) ? 8 : -8);

		backprop_function = &propagate_moves_from_promotion_capture_futurebase;
	    }

	    break;

	case FUTUREBASE_NORMAL:

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) futurebase->filename);
		backprop_function = propagate_moves_from_normal_futurebase;
	    }

	    break;

	default:

	    fatal("Unknown back propagation type for futurebase '%s'\n", futurebase->filename);
	    break;

	}

	if (backprop_function != NULL) {

#ifdef USE_THREADS
	    pthread_t *threads;
	    int thread;

	    /* XXX check for malloc failure */
	    threads = (pthread_t *) malloc(sizeof(pthread_t) * num_threads);

	    for (thread = 0; thread < num_threads; thread ++) {
		pthread_create(&threads[thread], NULL, backprop_function, (void *)((size_t)thread));
	    }
	    for (thread = 0; thread < num_threads; thread ++) {
		pthread_join(threads[thread], NULL);
	    }
#else
	    (*backprop_function)(0);
#endif
	}

	close_futurebase(futurebase);
    }

    return (fatal_errors == 0);
}

/***** PRUNING *****/

/* If we don't want to fully analyze out the tree past the table we're now building, we prune some
 * possible futuremoves.  Of course, this will affect the accuracy of the table; the table is a
 * result of BOTH the position it was set up for AND the pruning decisions (and any pruning
 * decisions made on the futurebases used to calculate this one).
 *
 * We specify pruning in a simple way - by omitting future tables for moves we don't want to
 * consider.  This can be dangerous, so we require this feature to be specifically enabled.  There
 * are two possibilities: moves can be DISCARDED, or victory can be CONCEDED to the side that makes
 * the move.
 *
 * So, if we are white, and assuming that this is a table with a frozen white pawn on e3, we can
 * prune by simply ignoring Pe4 as a possible move.  If there is a black pawn on the g-file, and we
 * don't want to compute out what happens after it queens, we can prune by conceding Pg1=X as a win
 * for black.
 *
 * For example, let's say we're looking at a Q-and-P vs. Q-and-P endgame.  There are four completely
 * mobile pieces (2 Ks and 2 Qs), and this is easy.  But if one of the pawns queens, then we've got
 * a more complex game with five mobile pieces.  But we don't want to completely discard all
 * possible enemy promotions, if we can immediately capture the new queen.  So we construct a
 * special tablebase with a queen frozen on the queening square, concede any move by that queen as a
 * win, then use it as a futurebase.
 *
 * And finally, we want to label in the file header that this pruning was done.  In particular, if
 * we use a pruned tablebase to compute another (earlier) pruned tablebase, we want to make sure the
 * pruning is consistent, i.e. "our" side has to stay the same.  This is guaranteed by explicitly
 * flagging in the XML header which sides can be pruned in which way (concede or discard).
 */

int all_futuremoves_handled = 1;

void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector) {

    unsigned int futuremove;
    int stm = index_to_side_to_move(tb, index);

    if (futurevector & unpruned_futuremoves[stm]) {
	global_position_t global;
	index_to_global_position(tb, index, &global);
	fatal("Futuremoves not handled: %d %s", index, global_position_to_FEN(&global));
	for (futuremove = 0; futuremove < num_futuremoves[stm]; futuremove ++) {
	    if (futurevector & FUTUREVECTOR(futuremove)	& unpruned_futuremoves[stm]) {
		fatal(" %s", movestr[stm][futuremove]);
	    }
	}
	fatal("\n");
	all_futuremoves_handled = 0;
    }

    /* concede - we treat these unhandled futuremoves as forced wins for PTM */

    if (futurevector & conceded_futuremoves[stm]) {
	/* PTM_wins(tb, index, 1, 1); */
	/* We insert here with DTM=2 (mate in one), movecnt=1 (XXX), and no futuremove */
	/* XXX I bet we want to insert with position's multiplicity as movecnt */
	/* XXX we can modify the entry directly here - no need to use a proptable */
	commit_update(index, 2, 1, NO_FUTUREMOVE);
    }

    /* discard - we ignore these unhandled futuremoves by decrementing movecnt */

    if (futurevector & discarded_futuremoves[stm]) {
	for (futuremove = 0; futuremove < num_futuremoves[stm]; futuremove ++) {
	    if (futurevector & FUTUREVECTOR(futuremove) & discarded_futuremoves[stm]) {

		/* tb->entries[index].movecnt --; */
		/* XXX this isn't handled right - a draw is different from a discard */
		/* XXX we can modify the entry directly here - no need to use a proptable */
		commit_update(index, 0, 0, NO_FUTUREMOVE);
	    }
	}
    }
}

boolean have_all_futuremoves_been_handled(tablebase_t *tb) {

    index_t index;

    /* XXX this code is probably inefficient, and though it appears to assume a little-endian
     * architecture, I've tried to do it the same way everywhere, so I think it should work no
     * matter the endianness.  Might have alignment problems, though.
     */

    for (index = 0; index <= tb->max_index; index ++) {
	if (get_entry_DTM(index) != 1) {
	    long long bit_offset = ((long long)index * current_tb->futurevector_bits);
	    futurevector_t futurevector = *((futurevector_t *)(current_tb->futurevectors + (bit_offset >> 3)));

	    futurevector >>= bit_offset & 7;
	    futurevector &= (1 << current_tb->futurevector_bits) - 1;
	    finalize_futuremove(tb, index, futurevector);
	}
    }

    return all_futuremoves_handled;
}

/* assign_pruning_statement() - a helper function for compute_pruned_futuremoves()
 *
 * searches the tablebase's XML pruning statements for one matching (more or less identically) the
 * specified color and string.  If there is a match, set the corresponding bit in the
 * pruned_futuremoves bit vector.  The function can be called more than once for a given bit, but
 * probably shouldn't be.  For example, the function might be called on the same bit for "PxQ=Q" if
 * there are two pawns that can promote into a queen.  UNIX-style wildcards are allowed, so "Kd4"
 * would match against "Kd4", "Kd?", "K?4", "K[a-d]4", or "K*".  The function also allows a trailing
 * "any" in the prune statement to act as a "*" wildcard for backwards compatibility.
 *
 * If there are multiple prune statements that match a given futuremove, it's a warning if they are
 * of the same type; a fatal error if their types are different.
 */

int match_pruning_statement(tablebase_t *tb, int color, char *pruning_statement)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int type = RESTRICTION_NONE;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_move = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "move");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");

	/* Trailing 'any' is an older syntax that means '*' */

	if (!strcasecmp("any", (char *) prune_move + strlen((char *) prune_move) - 3)) {
	    prune_move[strlen((char *) prune_move) - 3] = '*';
	    prune_move[strlen((char *) prune_move) - 2] = '\0';
	}

	if ((find_name_in_array((char *) prune_color, colors) == color)
	    && (fnmatch((char *) prune_move, pruning_statement, FNM_CASEFOLD) == 0)) {

	    if (type == RESTRICTION_NONE) {
		type = find_name_in_array((char *) prune_type, restriction_types);
	    } else if (type != find_name_in_array((char *) prune_type, restriction_types)) {
		fatal("Conflicting %s pruning statements match futuremove %s\n",
		      colors[color], pruning_statement);
	    } else {
		warning("Multiple %s pruning statements match futuremove %s\n",
			colors[color], pruning_statement);
	    }
	}

	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_move != NULL) xmlFree(prune_move);
	if (prune_type != NULL) xmlFree(prune_type);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    return type;
}

void assign_pruning_statement(tablebase_t *tb, int color, int futuremove)
{
    int type;
    char * pruning_statement = movestr[color][futuremove];

    if (futuremove == -1) return;

    pruning_statement = movestr[color][futuremove];

    type = match_pruning_statement(tb, color, pruning_statement);

    if (type != RESTRICTION_NONE) {

	if (pruned_futuremoves[color] & FUTUREVECTOR(futuremove)) {
	    warning("Multiple pruning statements ('%s') match a futuremove\n", pruning_statement);
	}

	pruned_futuremoves[color] |= FUTUREVECTOR(futuremove);

	if (type == RESTRICTION_CONCEDE) {
	    conceded_futuremoves[color] |= FUTUREVECTOR(futuremove);
	    if (discarded_futuremoves[color] & FUTUREVECTOR(futuremove)) {
		fatal("Conflicting pruning statements ('%s') match a futuremove\n",
		      pruning_statement);
	    }
	}
	if (type == RESTRICTION_DISCARD) {
	    discarded_futuremoves[color] |= FUTUREVECTOR(futuremove);
	    if (conceded_futuremoves[color] & FUTUREVECTOR(futuremove)) {
		fatal("Conflicting pruning statements ('%s') match a futuremove\n",
		      pruning_statement);
	    }
	}
    }
}

/* assign_numbers_to_futuremoves()
 *
 * We could just dismiss any moves that aren't handled by our futurebases, but I've found this to be
 * a source of error, since moves tend to get overlooked this way.  We're also concerned with the
 * more sobering possibility of a single move getting processed twice by two different futurebases.
 *
 * So we assign numbers, bit positions in a bit vector, actually, to each futuremove.  When we
 * initialize the tablebase, we set bits in the vector (each position has its own vector) for each
 * futuremove possible from that position.  As we back propagate futuremoves, we check the bit to
 * make sure it's still set, then clear it.  After we've back propagated all the futurebases, we run
 * through the entire tablebase, making sure that the only bits that remain set correspond to prune
 * statements.
 *
 * This function not only assigns the numbers, but also prints an identifying string, such as "KxP"
 * or "Re4", into the movestr array for each number assigned.  This string will then be matched
 * against the pruning statements specified in the configuration file.  Sometimes the strings will
 * repeat.  For example, if we have two pawns and an enemy queen, we'll probably end up with two
 * different bit positions, both assigned as "QxP".  The reason is that there are probably positions
 * where the queen could take either pawn, so both possibilities have to be tracked.
 *
 * Because we need a "futurevector" for each position in the tablebase, we want to keep it as small
 * as possible, so we try to use as few bit positions as possible.  In particular, we track white
 * and black futuremoves seperately (since from a given position only one or the other will be
 * possible) and we try to reuse bit positions for pawn capture-promotions if the pawns are
 * sufficiently restricted so that only one or the other could capture the enemy piece in a given
 * position.
 */

void assign_numbers_to_futuremoves(tablebase_t *tb) {

    int piece;
    int captured_piece;
    int capturing_piece;
    int sq;
    int dir;
    int promotion;
    struct movement *movementptr;
    uint64_t possible_captures[MAX_PIECES];
    char local_movestr[MOVESTR_CHARS];
    int futurebase_cnt;
    int fbnum;

    /* Start by computing a board vector (possible_captures) showing all possible squares where each
     * piece can capture onto.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	possible_captures[piece] = 0;

	for (sq = 0; sq < 64; sq ++) {

	    /* We make the checks here using legal_squares and not semilegal_squares because
	     * we're assigning futuremove numbers to individual pieces that can capture.  The
	     * movements we consider here, being captures, would take us to a futurebase anyway,
	     * so there's no question of whether the resulting position is fully legal or not.
	     */

	    if (tb->legal_squares[piece] & BITVECTOR(sq)) {
		if (tb->piece_type[piece] != PAWN) {
		    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {
			for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			     movementptr->square != -1; movementptr++) {

			    possible_captures[piece] |= movementptr->vector;

			    /* If we hit a frozen piece, then this movement direction ends here */
			    if (movementptr->vector & tb->frozen_pieces_vector) break;
			}
		    }
		} else {
		    for (movementptr = capture_pawn_movements[sq][tb->piece_color[piece]];
			 movementptr->square != -1; movementptr++) {

			possible_captures[piece] |= movementptr->vector;
		    }
		}
	    }
	}
    }

    /* Now, consider all possible pairs of pieces that might capture, and assign a number (in the
     * futurecaptures array) to each pair.  We'll ultimately use this number as an index into a bit
     * vector to determine if this capture has been handled in any particular position.  However,
     * there's a common enough "special" case: the two pieces are frozen (or at least sufficiently
     * restricted) so that the capture can never occur.  Go to the trouble of checking for this.
     */

    for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    /* If this is a suicide analysis and we can capture a player's only (i.e, last) piece,
	     * we lose.  Treat this just like a 'resign' prune, except that we don't need prune or
	     * prune-enable statements, since these are the rules of the game!
	     */

	    if ((tb->variant == VARIANT_SUICIDE) && (tb->num_pieces_by_color[tb->piece_color[captured_piece]] == 1)) {

		futurecaptures[capturing_piece][captured_piece] = RESIGN_FUTUREMOVE;

		for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
		    promotion_captures[capturing_piece][captured_piece][promotion] = RESIGN_FUTUREMOVE;
		}

		continue;
	    }

	    futurecaptures[capturing_piece][captured_piece] = NO_FUTUREMOVE;

	    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
		promotion_captures[capturing_piece][captured_piece][promotion] = NO_FUTUREMOVE;
	    }

	    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) continue;

	    if (tb->piece_type[capturing_piece] != PAWN) {

		if (possible_captures[capturing_piece] & tb->legal_squares[captured_piece]) {

		    char * my_movestr
			= movestr[tb->piece_color[capturing_piece]]
			[num_futuremoves[tb->piece_color[capturing_piece]]];

		    sprintf(my_movestr, "%cx%c",
			    piece_char[tb->piece_type[capturing_piece]],
			    piece_char[tb->piece_type[captured_piece]]);

		    futurecaptures[capturing_piece][captured_piece]
			= num_futuremoves[tb->piece_color[capturing_piece]] ++;
		}

	    } else {

		/* if it's a pawn-takes-pawn situation, check for en passant as well */

		if ((possible_captures[capturing_piece] & tb->legal_squares[captured_piece])
		    | ((tb->piece_type[captured_piece] == PAWN)
		       && (((tb->piece_color[capturing_piece] == WHITE)
			    ? ((possible_captures[capturing_piece] & 0x0000ff0000000000LL) >> 8)
			    : ((possible_captures[capturing_piece] & 0x0000000000ff0000LL) << 8))
			   & tb->legal_squares[captured_piece]))) {

		    int candidate_futuremove = NO_FUTUREMOVE;
		    char candidate_movestr[MOVESTR_CHARS];

		    /* start by dishing out a non-promotion futurecapture */

		    char * my_movestr
			= movestr[tb->piece_color[capturing_piece]]
			[num_futuremoves[tb->piece_color[capturing_piece]]];

		    sprintf(my_movestr, "%cx%c",
			    piece_char[tb->piece_type[capturing_piece]],
			    piece_char[tb->piece_type[captured_piece]]);

		    futurecaptures[capturing_piece][captured_piece]
			= num_futuremoves[tb->piece_color[capturing_piece]] ++;

		    /* Keep going only if it's a pawn capture that results in promotion */

		    if (! (possible_captures[capturing_piece] & tb->legal_squares[captured_piece]
			   & ((tb->piece_color[capturing_piece] == WHITE)
			      ? 0xff00000000000000LL : 0x00000000000000ffLL))) {
			continue;
		    }

		    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

			candidate_futuremove = NO_FUTUREMOVE;

			sprintf(candidate_movestr, "Px%c=%c",
				piece_char[tb->piece_type[captured_piece]],
				piece_char[promoted_pieces[promotion]]);

			/* Be conservative about handing out bit positions in the futurevector.
			 * Look through the other pieces that have been assigned bit positions and
			 * see if we can find one with an identical movestr that can never capture
			 * onto the squares that our piece can capture onto and reuse its bit
			 * positions.
			 *
			 * This code could be a lot more aggressively conservative, but for now I
			 * settle for handling the common simple case of pawns more than two files
			 * apart never being able to capture the same piece.  I only look at
			 * futuremoves for the current captured_piece, and only so far as the
			 * current capturing_piece.  That's why the nesting order of the two
			 * captured_piece and capturing_piece loops is important above.  First we
			 * look for a candidate futuremove, then we try to bust it by looking for
			 * overlaps.
			 */

			for (piece = 0; piece < capturing_piece; piece ++) {
			    if (tb->piece_color[piece] != tb->piece_color[capturing_piece]) continue;
			    if (promotion_captures[piece][captured_piece][promotion] != NO_FUTUREMOVE) {
				if ((! (possible_captures[capturing_piece] & possible_captures[piece]))
				    && (! strcmp(candidate_movestr, movestr[tb->piece_color[piece]][promotion_captures[piece][captured_piece][promotion]]))) {
				    candidate_futuremove = promotion_captures[piece][captured_piece][promotion];
				}
			    }
			}

			if (candidate_futuremove != NO_FUTUREMOVE) {
			    for (piece = 0; piece < capturing_piece; piece ++) {
				if (tb->piece_color[piece] != tb->piece_color[capturing_piece]) continue;
				if (! (possible_captures[capturing_piece] & possible_captures[piece])) continue;
				if (promotion_captures[piece][captured_piece][promotion] != NO_FUTUREMOVE) {
				    if (promotion_captures[piece][captured_piece][promotion] == candidate_futuremove) {
					candidate_futuremove = NO_FUTUREMOVE;
					break;
				    }
				}
			    }
			}

			if (candidate_futuremove == NO_FUTUREMOVE) {
			    candidate_futuremove = num_futuremoves[tb->piece_color[capturing_piece]] ++;
			    strcpy(movestr[tb->piece_color[capturing_piece]][candidate_futuremove], candidate_movestr);
			}

			promotion_captures[capturing_piece][captured_piece][promotion] = candidate_futuremove;

		    }
		}
	    }
	}
    }

    /* We also want to consider all promotions.  We don't wrap this into the pawn code that follows
     * because we want to count all promotions together, not a set for each destination square.
     * This is a special case of a more general problem that this code doesn't address yet.  We want
     * to minimize the assigned numbers to keep the futuremove bit vector small, so we want to reuse
     * those numbers if we're sure that two moves can't happen from different squares.  I.e, if a
     * king is restricted to the f1/h3 rectangle, then it can move to e1 from f1 and it can move to
     * h4 from h3, but there is no single position from which it can move to both e1 and h4.  So we
     * can use the same position in the bit vector for Ke1 and Kh4.  But we don't (yet).
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
	    promotions[piece][promotion] = NO_FUTUREMOVE;
	}
	if (tb->piece_type[piece] == PAWN) {
	    for (sq = (tb->piece_color[piece] == WHITE ? 48 : 8);
		 sq <= (tb->piece_color[piece] == WHITE ? 55 : 15); sq++) {
		if (tb->legal_squares[piece] & BITVECTOR(sq)) {

		    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
			promotions[piece][promotion] = num_futuremoves[tb->piece_color[piece]];
			sprintf(movestr[tb->piece_color[piece]][promotions[piece][promotion]],
				"P=%c", piece_char[promoted_pieces[promotion]]);
			num_futuremoves[tb->piece_color[piece]] ++;
		    }

		    break;
		}
	    }
	}
    }

    /* And now all piece moves outside their restriction.  We record a futuremove for each possible
     * destination square that the piece can reach outside its move restriction, unless we've
     * determined that there are no "normal" futurebases, in which case we flag the pruning right
     * here and now.
     */

    futurebase_cnt = 0;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	if (futurebases[fbnum]->futurebase_type == FUTUREBASE_NORMAL) futurebase_cnt ++;
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	for (sq = 0; sq < 64; sq ++) futuremoves[piece][sq] = NO_FUTUREMOVE;

	for (sq = 0; sq < 64; sq ++) {

	    /* Consider as _starting_ squares only those within the piece's movement restriction */

	    if (! (tb->legal_squares[piece] & BITVECTOR(sq))) continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			 movementptr->square != -1; movementptr++) {

			/* If we hit a frozen piece, movement has to stop.  We don't consider
			 * captures here; they were handled above.
			 */

			if (movementptr->vector & tb->frozen_pieces_vector) break;

			/* Don't assign futuremoves to king moves onto illegal squares (those that
			 * would place the king in check from a frozen piece)
			 */

			if ((piece == tb->white_king)
			    && (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
			if ((piece == tb->black_king)
			    && (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

			/* If the piece is moving outside its semilegal squares, it's a futuremove.
			 * If it's moving from a legal square to a semilegal square, it's also a
			 * futuremove... except for a special case.  Obviously the other piece in
			 * its semilegal group can't be on either the square it's moving from or the
			 * square it's moving to (no other piece can be).  If all remaining legal
			 * squares available to that other piece are also legal squares for this
			 * piece, then we can always successfully flip the two pieces and this isn't
			 * a futuremove.  The converse is that there must be at least one legal
			 * square available to the other piece that isn't a legal square for this
			 * piece; in other words, this piece must have another semilegal square that
			 * isn't legal.
			 */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))

			    || (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& ( tb->semilegal_squares[piece] & ~(tb->legal_squares[piece])
				     & ~BITVECTOR(movementptr->square) & ~BITVECTOR(sq) ))) {

			    if (futuremoves[piece][movementptr->square] == NO_FUTUREMOVE) {

				sprintf(local_movestr, "%c%c%c", piece_char[tb->piece_type[piece]],
					'a' + COL(movementptr->square), '1' + ROW(movementptr->square));

				if (futurebase_cnt > 0) {
				    futuremoves[piece][movementptr->square]
					= num_futuremoves[tb->piece_color[piece]];
				    strcpy(movestr[tb->piece_color[piece]][num_futuremoves[tb->piece_color[piece]]],
					   local_movestr);
				    num_futuremoves[tb->piece_color[piece]] ++;
				} else {
				    switch (match_pruning_statement(tb, tb->piece_color[piece],
								    local_movestr)) {
				    case RESTRICTION_DISCARD:
					futuremoves[piece][movementptr->square] = DISCARD_FUTUREMOVE;
					break;
				    case RESTRICTION_CONCEDE:
					futuremoves[piece][movementptr->square] = CONCEDE_FUTUREMOVE;
					break;
				    }
				}
			    }
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[sq][tb->piece_color[piece]];
		     movementptr->square != -1; movementptr++) {

		    /* If we hit a frozen piece, movement has to stop.  We don't consider captures
		     * here; they were handled above.
		     */

		    if (movementptr->vector & tb->frozen_pieces_vector) break;

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			/* might want to put the promotion code here */

		    } else {

			/* If the pawn is moving outside its restricted squares, it's a futuremove,
			 * unless the pawn is blocked, in which case the pawn will never be able to
			 * move outside its restriction (except via capture).
			 */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))

			    || (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& ( tb->semilegal_squares[piece] & ~(tb->legal_squares[piece])
				     & ~BITVECTOR(movementptr->square) & ~BITVECTOR(sq) ))) {

			    if (tb->blocking_piece[piece] == -1) {

				if (futuremoves[piece][movementptr->square] == NO_FUTUREMOVE) {
				    futuremoves[piece][movementptr->square]
					= num_futuremoves[tb->piece_color[piece]];
				    sprintf(movestr[tb->piece_color[piece]][num_futuremoves[tb->piece_color[piece]]],
					    "%c%c%c", piece_char[tb->piece_type[piece]],
					    'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				    num_futuremoves[tb->piece_color[piece]] ++;
				}
			    }
			}
		    }
		}
	    }
	}
    }

    info("%d possible WHITE futuremoves\n", num_futuremoves[WHITE]);
    info("%d possible BLACK futuremoves\n", num_futuremoves[BLACK]);

    if (num_futuremoves[WHITE] > sizeof(futurevector_t)*8) {
	fatal("Too many futuremoves - %d!  (only %d bits futurevector_t)\n",
	      num_futuremoves[WHITE], sizeof(futurevector_t)*8);
	terminate();
    }
    if (num_futuremoves[BLACK] > sizeof(futurevector_t)*8) {
	fatal("Too many futuremoves - %d!  (only %d bits futurevector_t)\n",
	      num_futuremoves[BLACK], sizeof(futurevector_t)*8);
	terminate();
    }

    if (using_proptables) {
	if (num_futuremoves[WHITE] > PROPTABLE_FORMAT_FUTUREVECTOR_BITS) {
	    fatal("Too many futuremoves - %d!  (only %d futurevector bits in proptable format)\n",
		  num_futuremoves[WHITE], PROPTABLE_FORMAT_FUTUREVECTOR_BITS);
	    terminate();
	}
	if (num_futuremoves[BLACK] > PROPTABLE_FORMAT_FUTUREVECTOR_BITS) {
	    fatal("Too many futuremoves - %d!  (only %d futurevector bits in proptable format)\n",
		  num_futuremoves[BLACK], PROPTABLE_FORMAT_FUTUREVECTOR_BITS);
	    terminate();
	}
    }
}

void print_futuremoves(void)
{
    unsigned int i;

    info("%d unpruned WHITE futuremoves\n", num_futuremoves[WHITE]);
    info("%d unpruned BLACK futuremoves\n", num_futuremoves[BLACK]);

    for (i=0; i < num_futuremoves[WHITE]; i ++) {
	info("WHITE Futuremove %i: %s\n", i, movestr[WHITE][i]);
    }
    for (i=0; i < num_futuremoves[BLACK]; i ++) {
	info("BLACK Futuremove %i: %s\n", i, movestr[BLACK][i]);
    }
}

/* This is where we parse pruning statements.  Fill in the pruned_futuremoves bit vector with bits
 * set for the various pruned moves.  We call this routine after assign_numbers_to_futuremoves(),
 * which also prints strings into the movestr array, and now we use those strings to match against
 * pruning statements.  To make this routine easier, assign_pruning_statement() can be called with a
 * '-1' futuremove, in which case it will do nothing.
 *
 * XXX something else I'd like to do here is to flag all of the pruning statements to make
 * sure we've used each one, and complain if any are left unused.
 */

boolean compute_pruned_futuremoves(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int color;
    unsigned int fm;

    /* Check pruning statements for consistency, and record stalemate pruning if specified */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");
	int color = find_name_in_array((char *) prune_color, colors);
	int type = find_name_in_array((char *) prune_type, restriction_types);

	if (! (type & tb->prune_enable[color])) {
	    fatal("Prune statements don't match tablebase prune-enables\n");
	}

	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_type != NULL) xmlFree(prune_type);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    if (fatal_errors != 0) return 0;

    for (color = WHITE; color <= BLACK; color ++) {
	for (fm = 0; fm < num_futuremoves[color]; fm ++) {
	    assign_pruning_statement(tb, color, fm);
	}
    }

    unpruned_futuremoves[WHITE] = ~pruned_futuremoves[WHITE];
    unpruned_futuremoves[BLACK] = ~pruned_futuremoves[BLACK];

    return (fatal_errors == 0);
}


/* check_pruning()
 *
 * We run this function after we've assigned numbers to the futuremoves and then matched pruning
 * statements against them, but before we initialize the tablebase.
 *
 * Check the futurebases to see if there are any for a given futuremove.  If not, check to make sure
 * the futuremove is pruned.  Otherwise, signal an error and exit right now.  Just because this test
 * is passed doesn't mean a particular futuremove is handled in a particular position (that's why we
 * use the bit vector), but if the test fails, well, then we know (almost) for sure that we'd get to
 * the end of program with unhandled futurebases, so we can save ourselves a long computation by
 * making this basic check now.
 *
 * If no futurebases exist for a given futuremove and it is correctly pruned, then flag it for
 * optimization, since there is no need to track its futurebase back propagation.
 *
 * There is an off chance that piece restrictions will prevent a futuremove from taking place, but
 * this code will conclude nevertheless that it is possible and demand either a prune statement or a
 * futurebase.  In this rare case, introducing an extraneous prune statement or two should solve the
 * problem.
 */

boolean check_pruning(tablebase_t *tb) {

    int fbnum;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int futurebase_cnt;

    /* for each possible captured_piece (i.e, everything but the two kings) check for capture
     * futurebases
     */

    for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	futurebase_cnt = 0;

	/* I've made this a bit more liberal now, because if we're dealing with move restrictions,
	 * then we might have a missing piece in the futurebase line up with one of our pieces that
	 * is identical to captured_piece in the sense that it's the same color and type, but not
	 * identical in the sense of next_identical_piece.
	 */

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if (tb->piece_type[captured_piece] == PAWN) {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_pawn] == tb->piece_color[captured_piece])
		    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
	    } else {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_non_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_non_pawn] == tb->piece_color[captured_piece])
		    && (futurebases[fbnum]->missing_pawn == -1)) futurebase_cnt ++;
	    }
	}

	/* If no such futurebase exists, then for every other piece, see if the piece restrictions
	 * would permit it to capture the original piece in question.  If so, there must be a prune
	 * statement, or it's an error.
	 */

	if (futurebase_cnt == 0) {

	    for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

		if (futurecaptures[capturing_piece][captured_piece] >= 0) {

		    if (! (pruned_futuremoves[tb->piece_color[capturing_piece]]
			   & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]))) {
			fatal("No futurebase or pruning for %s move %s\n",
			      colors[tb->piece_color[capturing_piece]],
			      movestr[tb->piece_color[capturing_piece]][futurecaptures[capturing_piece][captured_piece]]);
			return 0;
		    } else if (discarded_futuremoves[tb->piece_color[capturing_piece]]
			       & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece])) {
			optimized_futuremoves[tb->piece_color[capturing_piece]]
			    |= FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]);
			futurecaptures[capturing_piece][captured_piece] = DISCARD_FUTUREMOVE;
		    } else if (conceded_futuremoves[tb->piece_color[capturing_piece]]
			       & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece])) {
			optimized_futuremoves[tb->piece_color[capturing_piece]]
			    |= FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]);
			futurecaptures[capturing_piece][captured_piece] = CONCEDE_FUTUREMOVE;
		    } else {
			fatal("Internal error: pruned move is neither conceded nor discarded?!?\n");
		    }
		}
	    }
	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	int promotion;

	if (tb->piece_type[pawn] != PAWN) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	    if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->legal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->legal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

		int promoted_piece_handled = 0;

		if (promotion_captures[pawn][captured_piece][promotion] < 0) continue;

		for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
		    if ((futurebases[fbnum]->extra_piece != -1)
			&& (futurebases[fbnum]->piece_color[futurebases[fbnum]->extra_piece]
			    == (futurebases[fbnum]->invert_colors ? 1 - tb->piece_color[pawn] : tb->piece_color[pawn]))
			&& (futurebases[fbnum]->missing_non_pawn != -1)
			&& (tb->piece_color[futurebases[fbnum]->missing_non_pawn]
			    == tb->piece_color[captured_piece])
			&& (tb->piece_type[futurebases[fbnum]->missing_non_pawn]
			    == tb->piece_type[captured_piece])
			&& (futurebases[fbnum]->missing_pawn != -1)
			&& (tb->piece_color[futurebases[fbnum]->missing_pawn] == tb->piece_color[pawn])
			&& (futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece] == promoted_pieces[promotion])) {

			promoted_piece_handled = 1;
		    }
		}

		/* If no such futurebase exists, then there must be a prune statement, or it's an
		 * error.
		 */

		if (promoted_piece_handled) continue;

		if (! (pruned_futuremoves[tb->piece_color[pawn]]
		       & FUTUREVECTOR(promotion_captures[pawn][captured_piece][promotion]))) {
		    fatal("No futurebase or pruning for %s move %s\n",
			  colors[tb->piece_color[pawn]],
			  movestr[tb->piece_color[pawn]][promotion_captures[pawn][captured_piece][promotion]]);
		    return 0;
		} else if (discarded_futuremoves[tb->piece_color[pawn]]
			   & FUTUREVECTOR(promotion_captures[pawn][captured_piece][promotion])) {
		    optimized_futuremoves[tb->piece_color[pawn]] |= FUTUREVECTOR(promotion_captures[pawn][captured_piece][promotion]);
		    promotion_captures[pawn][captured_piece][promotion] = DISCARD_FUTUREMOVE;
		} else if (conceded_futuremoves[tb->piece_color[pawn]]
			   & FUTUREVECTOR(promotion_captures[pawn][captured_piece][promotion])) {
		    optimized_futuremoves[tb->piece_color[pawn]] |= FUTUREVECTOR(promotion_captures[pawn][captured_piece][promotion]);
		    promotion_captures[pawn][captured_piece][promotion] = CONCEDE_FUTUREMOVE;
		} else {
		    fatal("Internal error: pruned move is neither conceded nor discarded?!?\n");
		}

	    }
	}

	/* straight promotion futurebases */

	for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

	    int promoted_piece_handled = 0;

	    if (promotions[pawn][promotion] < 0) continue;

	    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
		if ((futurebases[fbnum]->extra_piece != -1)
		    && (futurebases[fbnum]->missing_non_pawn == -1)
		    && (futurebases[fbnum]->missing_pawn != -1)
		    && (futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece] == promoted_pieces[promotion])) {

		    promoted_piece_handled = 1;
		}
	    }


	    if (promoted_piece_handled) continue;

	    if (! (pruned_futuremoves[tb->piece_color[pawn]] & FUTUREVECTOR(promotions[pawn][promotion]))) {
		fatal("No futurebase or pruning for %s move %s\n",
		      colors[tb->piece_color[pawn]],
		      movestr[tb->piece_color[pawn]][promotions[pawn][promotion]]);
		return 0;
	    } else if (discarded_futuremoves[tb->piece_color[pawn]] & FUTUREVECTOR(promotions[pawn][promotion])) {
		optimized_futuremoves[tb->piece_color[pawn]] |= FUTUREVECTOR(promotions[pawn][promotion]);
		promotions[pawn][promotion] = DISCARD_FUTUREMOVE;
	    } else if (conceded_futuremoves[tb->piece_color[pawn]] & FUTUREVECTOR(promotions[pawn][promotion])) {
		optimized_futuremoves[tb->piece_color[pawn]] |= FUTUREVECTOR(promotions[pawn][promotion]);
		promotions[pawn][promotion] = CONCEDE_FUTUREMOVE;
	    } else {
		fatal("Internal error: pruned move is neither conceded nor discarded?!?\n");
	    }
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    futurebase_cnt = 0;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	if ((futurebases[fbnum]->extra_piece == -1)
	    && (futurebases[fbnum]->missing_pawn == -1)
	    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
    }

    /* I'd like to construct a mask of all allowable squares for each color and type of piece, and
     * verify that the futurebases or pruning actually account for all possible restricted
     * movements.  This would let me catch early things like forgetting to specify a g4 tablebase
     * for a pawn frozen on g2.  For now, we only check for missing pruning if there are no "normal"
     * futurebases at all.
     */

    if (futurebase_cnt == 0) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (sq = 0; sq < 64; sq ++) {
		if (futuremoves[piece][sq] >= 0) {

		    if (! (pruned_futuremoves[tb->piece_color[piece]] & FUTUREVECTOR(futuremoves[piece][sq]))) {
			fatal("No futurebase or pruning for %s move %s\n",
			      colors[tb->piece_color[piece]],
			      movestr[tb->piece_color[piece]][futuremoves[piece][sq]]);
			return 0;
		    }
		}
	    }
	}
    }

    return 1;
}


/* optimize_futuremoves()
 *
 * Once we've assigned futuremove numbers, then gone and checked pruning, some of those futuremoves
 * might now be completely pruned.  If so, flag them for pruning during initialization (by changing
 * their numbers to -2 or -3) and collapse the remaining futuremoves down into a smaller set.
 */

void remove_futuremove(futurevector_t *fvp, int fm)
{
    *fvp = ((*fvp) & (FUTUREVECTOR(fm)-1)) | (((*fvp) & ~(FUTUREVECTOR(fm+1)-1)) >> 1);
}

void optimize_futuremoves(tablebase_t *tb)
{
    int color, fm, fm2, piece, piece2, sq, promotion;

    for (color = WHITE; color <= BLACK; color ++) {

	for (fm = 0; fm < (int) num_futuremoves[color]; fm++) {

	    if (optimized_futuremoves[color] & FUTUREVECTOR(fm)) {

		for (piece = 0; piece < tb->num_pieces; piece ++) {

		    if (tb->piece_color[piece] == color) {

			for (piece2 = 0; piece2 < tb->num_pieces; piece2 ++) {
			    if (futurecaptures[piece][piece2] > fm) {
				futurecaptures[piece][piece2] --;
			    }
			    if (tb->piece_type[piece] == PAWN) {
				for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
				    if (promotion_captures[piece][piece2][promotion] > fm) {
					promotion_captures[piece][piece2][promotion] --;
				    }
				}
			    }
			}

			for (sq = 0; sq < 64; sq ++) {
			    if (futuremoves[piece][sq] > fm) {
				futuremoves[piece][sq] --;
			    }
			}

			if (tb->piece_type[piece] == PAWN) {
			    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {
				if (promotions[piece][promotion] > fm) {
				    promotions[piece][promotion] --;
				}
			    }
			}
		    }
		}

		remove_futuremove(&(pruned_futuremoves[color]), fm);
		remove_futuremove(&(conceded_futuremoves[color]), fm);
		remove_futuremove(&(discarded_futuremoves[color]), fm);
		remove_futuremove(&(optimized_futuremoves[color]), fm);

		info("Pruned %s futuremove %s\n", colors[color], movestr[color][fm]);

		for (fm2 = fm + 1; fm2 < (int) num_futuremoves[color]; fm2++) {
		    strcpy(movestr[color][fm2-1], movestr[color][fm2]);
		}

		num_futuremoves[color] --;
		fm --;
	    }
	}
    }
}

/***** INTRA-TABLE MOVE PROPAGATION *****/

/* We've got a move that needs to be propagated, so we back out one half-move to all of the
 * positions that could have gotten us here and update their counters in various obscure ways.
 */

void propagate_one_minimove_within_table(tablebase_t *tb, index_t future_index, local_position_t *current_position)
{
    index_t current_index;
    int dtm = get_entry_DTM(future_index);

    current_index = local_position_to_index(tb, current_position);

    if (current_index == INVALID_INDEX) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup position in intratable propagation!\n");
#endif
#ifdef DEBUG_MOVE
	if (future_index == DEBUG_MOVE) {
	    printf("propagate_one_minimove_within_table:  current_index=INVALID"
		   "; future_index=%" PRIindex "; dtm=%d\n",
		   future_index, dtm);
	}
#endif
	return;
    }

#ifdef DEBUG_MOVE
    if ((current_index == DEBUG_MOVE) || (future_index == DEBUG_MOVE))
	printf("propagate_one_minimove_within_table:  current_index=%"
	       PRIindex "; future_index=%" PRIindex "; dtm=%d\n",
	       current_index, future_index, dtm);
#endif

    /* Parent position is the FUTURE position.  We now back-propagate to
     * the current position, which is the PAST position.
     *
     * If the player to move in the FUTURE position wins, then we add one to that
     * player's win count in the PAST position.  On other other hand, if the player not
     * to move in the FUTURE position wins, then the player to move in the PAST position
     * has a winning move (the one we're considering).
     */

    if (dtm > 0) {
	commit_update(current_index, -dtm, 1, NO_FUTUREMOVE);
    } else if (dtm < 0) {
	commit_update(current_index, -dtm+1, 1, NO_FUTUREMOVE);
    } else if (get_entry_movecnt(future_index) == MOVECNT_PTM_WINS_UNPROPED) {
	commit_update(current_index, -2, 1, NO_FUTUREMOVE);
    } else if (get_entry_movecnt(future_index) == MOVECNT_PNTM_WINS_UNPROPED) {
	commit_update(current_index, 2, 1, NO_FUTUREMOVE);
    } else {
	fatal("Intra-table back prop doesn't match dtm or movecnt\n");
    }
}

void propagate_one_move_within_table(tablebase_t *tb, index_t future_index, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_one_minimove_within_table(tb, future_index, position);

    if (position->en_passant_square == ILLEGAL_POSITION) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I've taken care to update board_vector in the routine that calls here specifically so
	     * we can check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    position->en_passant_square = ILLEGAL_POSITION;
	}
    }
}

/* back_propagate_index_within_table()
 *
 * Once the final status of an index has been determined, this function back propagates all moves
 * (within the tablebase) from the corresponding position.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int reflection)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    /* This can fail if the reflection isn't valid for this index */

    if (! index_to_local_position(tb, index, reflection, &position)) return;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	info("back_propagate_index_within_table; index=%d\n", index);
#endif

    flip_side_to_move_local(&position);

    /* If there are any en passant capturable pawns in the position, then the last move had to
     * have been a pawn move.  In fact, in this case, we already know exactly what the last move
     * had to have been.
     */

    if (position.en_passant_square != ILLEGAL_POSITION) {

	int en_passant_pawn = -1;

	for (piece = 0; piece < tb->num_pieces; piece++) {

	    if (tb->piece_color[piece] != position.side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    if (((tb->piece_color[piece] == WHITE)
		 && (position.piece_position[piece] - 8 == position.en_passant_square))
		|| ((tb->piece_color[piece] == BLACK)
		    && (position.piece_position[piece] + 8 == position.en_passant_square))) {
		if (en_passant_pawn != -1) fatal("Two en passant pawns in back prop?!\n");
		en_passant_pawn = piece;
	    }
	}
	if (en_passant_pawn == -1) {
	    fatal("No en passant pawn in back prop!?\n");
	} else {

	    position.en_passant_square = ILLEGAL_POSITION;

	    /* I go to the trouble to update board_vector here so we can check en passant
	     * legality in propagate_one_move_within_table().
	     */

	    position.board_vector &= ~BITVECTOR(position.piece_position[en_passant_pawn]);

	    if (tb->piece_color[en_passant_pawn] == WHITE)
		position.piece_position[en_passant_pawn] -= 16;
	    else
		position.piece_position[en_passant_pawn] += 16;

	    position.board_vector |= BITVECTOR(position.piece_position[en_passant_pawn]);

	    /* We never back out into a restricted position.  Since we've already decided that this
	     * is the only legal back-move from this point, well...
	     */

	    if (! (tb->semilegal_squares[en_passant_pawn]
		   & BITVECTOR(position.piece_position[en_passant_pawn]))) {
		return;
	    }

	    propagate_one_move_within_table(tb, index, &position);
	}

	return;
    }

    /* foreach (mobile piece of player NOT TO PLAY) { */

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We've moving BACKWARDS in the game, so we want the pieces of the player who is NOT TO
	 * PLAY here - this is the LAST move we're considering, not the next move.
	 */

	if (tb->piece_color[piece] != position.side_to_move)
	    continue;

	origin_square = position.piece_position[piece];

	position.board_vector &= ~BITVECTOR(origin_square);

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		/* What about captures?  Well, first of all, there are no captures here!  We're
		 * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		 * Captures are handled by back-propagation from futurebases, not here in the
		 * movement code.  The piece moving had to come from somewhere, and that somewhere
		 * will now be an empty square, so once we've hit another piece along a movement
		 * vector, there's absolutely no need to consider anything further.
		 */

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS
		     * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     */

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    position.piece_position[piece] = movementptr->square;

		    position.board_vector |= BITVECTOR(movementptr->square);

		    propagate_one_move_within_table(tb, index, &position);

		    position.board_vector &= ~BITVECTOR(movementptr->square);
		}
	    }

	} else {

	    /* Usual special case for pawns */

	    for (movementptr = normal_pawn_movements_bkwd[origin_square][tb->piece_color[piece]];
		 (movementptr->vector & position.board_vector) == 0;
		 movementptr++) {

		/* We never back out into a restricted position (obviously) */

		if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		/* Do we have a backwards pawn move here?
		 *
		 * Back stepping a half move here involves several things: flipping the
		 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		 * the piece (backwards), and considering a bunch of additional positions
		 * identical to the base position except that a single one of the pawns on the
		 * fourth or fifth ranks was capturable en passant.
		 *
		 * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		 * created it.  We handle that as a special case above, so we shouldn't have to
		 * worry about clearing en passant pawns here - there should be none.  Checking
		 * additional en passant positions is taken care of in
		 * propagate_one_move_within_table()
		 *
		 * But we start with an extra check to make sure this isn't a double pawn move, in
		 * which case it would result in an en passant position, not the non-en passant
		 * position we are in now (en passant got taken care of in the special case
		 * above)...  unless we are using the "no-en-passant" index type, in which case we
		 * don't consider en passant at all, and so have to handle the double move here.
		 */

		if (((movementptr->square - origin_square) == 16)
		    || ((movementptr->square - origin_square) == -16)) {
		    if (tb->index_type != NO_EN_PASSANT_INDEX) continue;
		}

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		position.piece_position[piece] = movementptr->square;

		position.board_vector |= BITVECTOR(movementptr->square);

		propagate_one_move_within_table(tb, index, &position);

		position.board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

	position.piece_position[piece] = origin_square;
	position.board_vector |= BITVECTOR(origin_square);
    }
}

/* initialize_tablebase()
 *
 * This is another critical function; don't be deceived by the tame word 'initialize'.
 *
 * We determine that a position is won for the player not to move (PNTM) if all possible moves (of
 * the player to move) lead to a won game for PNTM.  We count down this total during back
 * propagation, so it stands to reason that we need an accurate count to start with.  Thus the
 * importance of this function.
 *
 * We don't count moves into check at all.
 *
 * Basically, there are two types of moves we need to consider in each position:
 *
 * 1. non-capture, non-promotion, non-restricted moves
 *
 * We just add these up and then count them down during intra-table propagation, depending on the
 * integrity of the program's algorithm to make sure that every move counted forward gets considered
 * as a move backward.
 *
 * 2. everything else (futuremoves)
 *
 * These always lead to a different tablebase (a futurebase).  The only way we handle them is
 * through inter-table back propagation.  We keep a seperate count of futuremoves because, unlike
 * intratable moves, we might miss some of these moves if we don't have a complete set of
 * futurebases.  So we count futuremoves by themselves (as well as part of the standard count), and
 * count them down normally during a single sweep through our futurebases.  If that takes care of
 * everything fine.  Otherwise, during our first pass through the current tablebase, we'll find that
 * some of the futuremoves remain unaccounted for.  If they occur with the "good guys" as PTM, we
 * just double-check that the restriction is OK, subtract the remaining futuremoves out from the
 * standard count, and keep going.  But if the "bad guys" are PTM, then the position has to be
 * assumed won for PTM.
 *
 */

int PTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    struct movement *movementptr;

    /* The concept of check doesn't exist in suicide - kings are normal pieces */

    if (tb->variant == VARIANT_SUICIDE) return 0;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is NOT to move... */

	if (tb->piece_color[piece] == position->side_to_move) continue;

	/* We might have removed the piece from the position... */

	if (position->piece_position[piece] == ILLEGAL_POSITION) continue;

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][position->piece_position[piece]][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[position->piece_position[piece]][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

	    }
	}
    }

    return 0;
}

int global_PTM_in_check(global_position_t *position)
{
    int piece_type;
    int piece_color = 1 - position->side_to_move;
    int square;
    int dir;
    struct movement *movementptr;

    if (position->variant == VARIANT_SUICIDE) return 0;

    for (square = 0; square < 64; square ++) {

	/* We only want to consider pieces of the side which is NOT to move... */

	for (piece_type = 0; piece_type < NUM_PIECES; piece_type ++) {
	    if (position->board[square] == global_pieces[piece_color][piece_type]) break;
	}
	if (piece_type == NUM_PIECES) continue;

	if (piece_type != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[piece_type]; dir++) {

		for (movementptr = movements[piece_type][square][dir];
		     ((movementptr->square != -1) && (position->board[movementptr->square] == 0));
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE) && (position->board[movementptr->square] == 'K'))
		    return 1;
		if ((position->side_to_move == BLACK) && (position->board[movementptr->square] == 'k'))
		    return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[square][piece_color];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE) && (position->board[movementptr->square] == 'K'))
		    return 1;
		if ((position->side_to_move == BLACK) && (position->board[movementptr->square] == 'k'))
		    return 1;

	    }
	}
    }

    return 0;
}

int global_PNTM_in_check(global_position_t *position)
{
    int piece_type;
    int piece_color = position->side_to_move;
    int square;
    int dir;
    struct movement *movementptr;

    if (position->variant == VARIANT_SUICIDE) return 0;

    for (square = 0; square < 64; square ++) {

	/* We only want to consider pieces of the side which is to move... */

	for (piece_type = 0; piece_type < NUM_PIECES; piece_type ++) {
	    if (position->board[square] == global_pieces[piece_color][piece_type]) break;
	}
	if (piece_type == NUM_PIECES) continue;

	if (piece_type != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[piece_type]; dir++) {

		for (movementptr = movements[piece_type][square][dir];
		     ((movementptr->square != -1) && (position->board[movementptr->square] == 0));
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE) && (position->board[movementptr->square] == 'k'))
		    return 1;
		if ((position->side_to_move == BLACK) && (position->board[movementptr->square] == 'K'))
		    return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[square][piece_color];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE) && (position->board[movementptr->square] == 'k'))
		    return 1;
		if ((position->side_to_move == BLACK) && (position->board[movementptr->square] == 'K'))
		    return 1;

	    }
	}
    }

    return 0;
}

int PNTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    if (tb->variant == VARIANT_SUICIDE) return 0;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is to move... */

	if (tb->piece_color[piece] != position->side_to_move) continue;

	origin_square = position->piece_position[piece];

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[origin_square][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

	    }
	}
    }

    return 0;
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;
    int i;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	fprintf(stderr, "Initializing %d\n", index);
#endif

    if (! index_to_local_position(tb, index, REFLECTION_NONE, &position)) {

	initialize_entry_as_illegal(tb, index);
	return 0;

    } else {

	/* Now we need to count moves.  FORWARD moves. */
	unsigned int movecnt = 0;
	unsigned int capturecnt = 0;
	unsigned int futuremovecnt = 0;
	futurevector_t futurevector = 0;
	futurevector_t capture_futurevector = 0;

	/* En passant:
	 *
	 * We're just counting moves here.  In particular, we don't compute the indices of the
	 * resulting positions.  If we did, we'd have to worry about clearing en passant status
	 * from any of fourth or fifth rank pawns, but we don't have to worry about it.
	 *
	 * We do have to count one or two possible extra en passant pawn captures, though...
	 */


	for (piece = 0; piece < tb->num_pieces; piece++) {

	    /* We only want to consider pieces of the side which is to move... */

	    if (tb->piece_color[piece] != position.side_to_move) continue;

	    origin_square = position.piece_position[piece];
	    position.board_vector &= ~BITVECTOR(origin_square);

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
			 (movementptr->vector & position.board_vector) == 0;
			 movementptr++) {

			/* Completely discard king moves into check by frozen pieces */

			if ((piece == tb->white_king)
			    && (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
			if ((piece == tb->black_king)
			    && (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

			/* Move the piece, so we can test the new position for check */

			position.piece_position[piece] = movementptr->square;

			position.board_vector |= BITVECTOR(movementptr->square);

			/* If we're NOT moving into check AND the piece is moving outside its legal
			 * squares AND we can't permute the pieces into a position where everything
			 * is legal, we regard this as a futuremove (since it will require back prop
			 * from futurebases).  We could just check if local_position_to_index()
			 * returns a valid index, but checking the legal_squares bitvector first
			 * makes this a little faster.
			 */

			if (! PTM_in_check(tb, &position)) {

			    if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& (local_position_to_index(tb, &position) == INVALID_INDEX)) {

				if (futuremoves[piece][movementptr->square] == DISCARD_FUTUREMOVE) {
				    /* it's a discard - decrement movecnt so net change is zero */
				    movecnt --;
				} else if (futuremoves[piece][movementptr->square] == CONCEDE_FUTUREMOVE) {
				    /* it's a concede - PTM wins */
				    initialize_entry_with_DTM(tb, index, 2);
				    return 0;
				} else if (futuremoves[piece][movementptr->square] == RESIGN_FUTUREMOVE) {
				    /* it's a resign - PTM loses */
				    initialize_entry_with_DTM(tb, index, -2);
				    return 0;
				} else if (futuremoves[piece][movementptr->square] < 0) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("No futuremove: %s %c%c%c\n", global_position_to_FEN(&global),
					  piece_char[tb->piece_type[piece]],
					  'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				} else if (futurevector
					   & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				    fatal("Duplicate futuremove!\n");
				} else {
				    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
				    futuremovecnt ++;
				}
			    }

			    movecnt ++;
			}

			position.board_vector &= ~BITVECTOR(movementptr->square);

		    }

		    /* Now check to see if the movement ended because we hit against another piece
		     * of the opposite color.  If so, add another move for the capture.  As before,
		     * ignore moves into check.
		     *
		     * Actually, we check to see that we DIDN'T hit a piece of our OWN color.  The
		     * difference is that this way we don't register a capture if we hit the end of
		     * the list of movements in a given direction.
		     *
		     * We also check to see if the capture was against the enemy king! in which case
		     * this position is a PNTM-mated.
		     */

		    /* Completely discard king moves into check by frozen pieces */

		    if ((piece == tb->white_king)
			&& (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
		    if ((piece == tb->black_king)
			&& (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

		    if ((movementptr->vector & position.PTM_vector) == 0) {

			for (i = 0; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if ((i == tb->black_king) || (i == tb->white_king)) {
				    initialize_entry_with_PNTM_mated(tb, index);
				    return 0;
				}

				position.piece_position[i] = ILLEGAL_POSITION;
				position.piece_position[piece] = movementptr->square;

				if (! PTM_in_check(tb, &position)) {

				    if (futurecaptures[piece][i] == DISCARD_FUTUREMOVE) {
					/* discard prune - do nothing */
				    } else if (futurecaptures[piece][i] == CONCEDE_FUTUREMOVE) {
					/* concede prune */
					initialize_entry_with_DTM(tb, index, 2);
					return 0;
				    } else if (futurecaptures[piece][i] == RESIGN_FUTUREMOVE) {
					/* resign prune (or an actual suicide loss if capturing last piece) */
					initialize_entry_with_DTM(tb, index, -2);
					return 0;
				    } else if (futurecaptures[piece][i] < 0) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    } else if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    } else {
					capture_futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futuremovecnt ++;
					capturecnt ++;
					movecnt ++;
				    }
				}

				position.piece_position[i] = movementptr->square;

				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fatal("Couldn't match capture!\n");
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[origin_square][tb->piece_color[piece]];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* Move the piece.  The in-check test below require this. */

		    position.piece_position[piece] = movementptr->square;
		    position.board_vector |= BITVECTOR(movementptr->square);

		    /* What about pawn promotions here?  Well, we're looking to see if the moving
		     * side is in check after the pawn move, and the only way the pawn could affect
		     * this is by blocking the check.  It still blocks no matter what it promotes
		     * into, so we don't have to distinguish between promotion and non-promotion
		     * moves here.
		     */

		    if (! PTM_in_check(tb, &position)) {

			/* If the piece is a pawn and we're moving to the last rank, then this has
			 * to be a promotion move, in fact, promotion_possibilities moves.  (queen,
			 * knight, maybe rook and bishop, king for suicide).  As such, they will
			 * require back propagation from futurebases and must therefore be flagged
			 * as futuremoves.
			 */

			if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			    int promotion;

			    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

				if (promotions[piece][promotion] == DISCARD_FUTUREMOVE) {
				    /* discard prune - do nothing */
				} else if (promotions[piece][promotion] == CONCEDE_FUTUREMOVE) {
				    /* concede prune */
				    initialize_entry_with_DTM(tb, index, 2);
				    return 0;
				} else if (promotions[piece][promotion] == RESIGN_FUTUREMOVE) {
				    /* resign prune */
				    initialize_entry_with_DTM(tb, index, -2);
				    return 0;
				} else if (promotions[piece][promotion] < 0) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("No futuremove: %s %c=%c\n", global_position_to_FEN(&global),
					  piece_char[tb->piece_type[piece]], piece_char[promoted_pieces[promotion]]);
				} else if (futurevector & FUTUREVECTOR(promotions[piece][promotion])) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("Duplicate futuremove: %s %s\n", global_position_to_FEN(&global),
					  movestr[tb->piece_color[piece]][promotions[piece][promotion]]);
				} else {
				    futurevector |= FUTUREVECTOR(promotions[piece][promotion]);
				    futuremovecnt ++;
				    movecnt ++;
				}
			    }

			} else {

			    /* If a piece is moving outside its legal squares AND we can't permute
			     * the pieces into a position where everything is legal, we regard this
			     * as a futuremove (since it will require back prop from futurebases).
			     */

			    if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& (local_position_to_index(tb, &position) == INVALID_INDEX)) {

				if (futuremoves[piece][movementptr->square] == DISCARD_FUTUREMOVE) {
				    /* discard prune */
				    movecnt --;
				} else if (futuremoves[piece][movementptr->square] == CONCEDE_FUTUREMOVE) {
				    /* concede prune */
				    initialize_entry_with_DTM(tb, index, 2);
				    return 0;
				} else if (futuremoves[piece][movementptr->square] == RESIGN_FUTUREMOVE) {
				    /* resign prune */
				    initialize_entry_with_DTM(tb, index, -2);
				    return 0;
				} else if (futuremoves[piece][movementptr->square] < 0) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("No futuremove: %s %c%c%c\n", global_position_to_FEN(&global),
					  piece_char[tb->piece_type[piece]],
					  'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				} else if (futurevector
					   & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				    fatal("Duplicate futuremove!\n");
				} else {
				    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
				    futuremovecnt ++;
				}
			    }

			    movecnt ++;
			}
		    }

		    position.board_vector &= ~BITVECTOR(movementptr->square);

		}


		/* Pawn captures.
		 *
		 * In this part of the code, we're just counting forward moves, and all captures
		 * are futurebase moves, so the only difference to us whether this is a
		 * promotion move or not is how many futuremoves get recorded.
		 */

		for (movementptr = capture_pawn_movements[origin_square][tb->piece_color[piece]];
		     movementptr->square != -1;
		     movementptr++) {

		    /* If we're capturing to the last rank, then this has to be a promotion move, in
		     * fact, promotion_possibilities moves.
		     */

		    int is_promotion_capture =
			((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0));

		    /* A special check for en passant captures.  */

		    if (movementptr->square == position.en_passant_square) {

			for (i = 0; i < tb->num_pieces; i ++) {
			    if ((i == tb->white_king) || (i == tb->black_king)) continue;
			    if (movementptr->square + (tb->piece_color[piece] == WHITE ? -8 : 8)
				== position.piece_position[i]) {

				position.piece_position[piece] = position.en_passant_square;
				position.board_vector |= BITVECTOR(position.en_passant_square);
				position.board_vector &= ~BITVECTOR(position.piece_position[i]);
				position.piece_position[i] = ILLEGAL_POSITION;

				if (! PTM_in_check(tb, &position)) {
				    if (futurecaptures[piece][i] == DISCARD_FUTUREMOVE) {
					/* discard prune - do nothing */
				    } else if (futurecaptures[piece][i] == CONCEDE_FUTUREMOVE) {
					/* concede prune */
					initialize_entry_with_DTM(tb, index, 2);
					return 0;
				    } else if (futurecaptures[piece][i] == RESIGN_FUTUREMOVE) {
					/* resign prune (or an actual suicide loss if capturing last piece) */
					initialize_entry_with_DTM(tb, index, -2);
					return 0;
				    } else if (futurecaptures[piece][i] < 0) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    } else if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    } else {
					capture_futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futuremovecnt ++;
					capturecnt ++;
					movecnt ++;
				    }
				}

				position.piece_position[i] = position.en_passant_square
				    + (tb->piece_color[piece] == WHITE ? -8 : 8);
				position.board_vector |= BITVECTOR(position.piece_position[i]);
				position.board_vector &= ~BITVECTOR(position.en_passant_square);

				break;
			    }
			}
			continue;
		    }

		    if (((movementptr->vector & position.board_vector) == 0)
			|| ((movementptr->vector & position.PTM_vector) != 0)) continue;

		    for (i = 0; i < tb->num_pieces; i ++) {
			if (movementptr->square == position.piece_position[i]) {
			    if ((i == tb->black_king) || (i == tb->white_king)) {
				initialize_entry_with_PNTM_mated(tb, index);
				return 0;
			    }

			    position.piece_position[i] = ILLEGAL_POSITION;
			    position.piece_position[piece] = movementptr->square;

			    if (! PTM_in_check(tb, &position)) {
				if (! is_promotion_capture) {
				    if (futurecaptures[piece][i] == DISCARD_FUTUREMOVE) {
					/* discard prune - do nothing */
				    } else if (futurecaptures[piece][i] == CONCEDE_FUTUREMOVE) {
					/* concede prune */
					initialize_entry_with_DTM(tb, index, 2);
					return 0;
				    } else if (futurecaptures[piece][i] == RESIGN_FUTUREMOVE) {
					/* resign prune (or an actual suicide loss if capturing last piece) */
					initialize_entry_with_DTM(tb, index, -2);
					return 0;
				    } else if (futurecaptures[piece][i] < 0) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    } else if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    } else {
					capture_futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
					futuremovecnt ++;
					capturecnt ++;
					movecnt ++;
				    }
				} else {
				    int promotion;

				    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

					if (promotion_captures[piece][i][promotion] == DISCARD_FUTUREMOVE) {
					    /* discard prune - do nothing */
					} else if (promotion_captures[piece][i][promotion] == CONCEDE_FUTUREMOVE) {
					    /* concede prune */
					    initialize_entry_with_DTM(tb, index, 2);
					    return 0;
					} else if (promotion_captures[piece][i][promotion] == RESIGN_FUTUREMOVE) {
					    /* resign prune (or an actual suicide loss if capturing last piece) */
					    initialize_entry_with_DTM(tb, index, -2);
					    return 0;
					} else if (promotion_captures[piece][i][promotion] < 0) {
					    global_position_t global;
					    index_to_global_position(tb, index, &global);
					    fatal("No futuremove: %s %cx%c=%c\n", global_position_to_FEN(&global),
						  piece_char[tb->piece_type[piece]],
						  piece_char[tb->piece_type[i]],
						  piece_char[promoted_pieces[promotion]]);
					} else if (futurevector & FUTUREVECTOR(promotion_captures[piece][i][promotion])) {
					    fatal("Duplicate futuremove!\n");
					} else {
					    capture_futurevector |= FUTUREVECTOR(promotion_captures[piece][i][promotion]);
					    futurevector |= FUTUREVECTOR(promotion_captures[piece][i][promotion]);
					    futuremovecnt ++;
					    capturecnt ++;
					    movecnt ++;
					}
				    }
				}
			    }

			    position.piece_position[i] = movementptr->square;
			    break;
			}
		    }

		    if (i == tb->num_pieces) {
			fatal("Couldn't match pawn capture!\n");
		    }


		}

	    }

	    position.board_vector |= BITVECTOR(origin_square);
	    position.piece_position[piece] = origin_square;

	}

	/* Finally, if every possible moves leads us into check, we determine if we're in check,
	 * being the difference between this being checkmate or stalemate.  In suicide analysis, a
	 * stalemate is a win for the stalemated player (international rules).
	 */

	if (movecnt == 0) {

	    if (tb->variant == VARIANT_SUICIDE) {
		initialize_entry_with_PNTM_mated(tb, index);
	    } else if (PTM_in_check(tb, &position)) {
		initialize_entry_with_PTM_mated(tb, index);
	    } else {
		initialize_entry_with_stalemate(tb, index);
	    }
	    return 0;

	} else {

	    /* total_moves += movecnt; */
	    (void) __sync_add(&total_moves, movecnt);

	    /* total_futuremoves += futuremovecnt; */
	    (void) __sync_add(&total_futuremoves, futuremovecnt);

	    /* In suicide, captures are forced, so if any captures are possible they are our only
	     * moves.  Of course, if we can capture the opponent's last piece, then we win!
	     */

	    if ((tb->variant == VARIANT_SUICIDE) && (capturecnt != 0)) {
		movecnt = capturecnt;
		futurevector = capture_futurevector;
	    }

	    set_entry_capture_possible_flag(index, capturecnt != 0);

	    /* Symmetry and multiplicity.  If we're using a symmetric index, then there might be more
	     * than one actual board position that corresponds to a given index value.  The number
	     * of non-identical board positions for a given index is called its multiplicity.  So
	     * here we multiply the movecnt by the multiplicity of the position to get the total
	     * number of moves out of all possible positions that correspond to this index.
	     *
	     * Actually, when computing position.multiplicity, we ignore horizontal and vertical
	     * symmetry because they always result in doubled (or quadrupled) board positions.
	     * Diagonal symmetry is more difficult to handle because the pieces along the diagonal
	     * don't move when you reflect the board.  So we need to use position.multiplicity to
	     * distinguish between the two kings being on the a1/h8 diagonal (multiplicity 1), and
	     * one of them being off the diagnoal (multiplicity 2).
	     */

	    initialize_entry_with_movecnt(tb, index, movecnt * position.multiplicity);

#ifdef DEBUG_MOVE
	    if (index == DEBUG_MOVE) {
		/* other fields were printed by DEBUG_MOVE statement in initialize_entry() */
		info("   futurevector " FUTUREVECTOR_HEX_FORMAT "\n", futurevector);
	    }
#endif

	    return futurevector;
	}
    }
}

/* Tablebase initialization is the first important place where we can use threads to speed things up
 * on a multi-processor machine, though my experience is that actual gains are highly architecture
 * specific.  We break the tablebase up into sections, and assign each section to its own thread.
 * Since initialization only touches single entries in the tablebase (no propagation at this point),
 * thread synchronization is trivial.
 */

typedef struct {
    index_t start_index;
    index_t end_index;
} initialization_control_t;

void * initialize_tablebase_section(void * ptr)
{
    initialization_control_t *control = (initialization_control_t *) ptr;
    index_t index;

    for (index=control->start_index; index <= control->end_index; index++) {

	long long bit_offset = ((long long)index * current_tb->futurevector_bits);

	set_unsigned_int_field(current_tb->futurevectors, bit_offset, current_tb->futurevector_bits,
			       initialize_tablebase_entry(current_tb, index));
    }

    return NULL;
}

#ifndef USE_THREADS

void initialize_tablebase(void)
{
    initialization_control_t control = {0, current_tb->max_index};

    initialize_tablebase_section(&control);
}

#else

void initialize_tablebase(void)
{
    initialization_control_t *controls;
    pthread_t *threads;
    int thread;

    /* XXX check for malloc failure */
    controls = (initialization_control_t *) malloc(sizeof(initialization_control_t) * num_threads);
    threads = (pthread_t *) malloc(sizeof(pthread_t) * num_threads);

    for (thread = 0; thread < num_threads; thread ++) {
	controls[thread].start_index = ((current_tb->max_index+1)*thread)/num_threads;
	if (thread != num_threads-1) {
	    controls[thread].end_index = ((current_tb->max_index+1)*(thread+1))/num_threads - 1;
	} else {
	    controls[thread].end_index = current_tb->max_index;
	}
	pthread_create(&threads[thread], NULL, &initialize_tablebase_section, &controls[thread]);
    }

    for (thread = 0; thread < num_threads; thread ++) {
	pthread_join(threads[thread], NULL);
    }

    free(threads);
    free(controls);
}

#endif

/* Intra-table propagation is (almost) trivial.  Keep making passes over the tablebase first until
 * we've processed everything from the futurebases, then until no more progress can be made.  We
 * don't even have to make every pass, just the ones that have mates in the entries table (and we
 * track that as we finalize the mates).  Once we're past all the mates that came in from the
 * futurebases (that's what max_tracked_dtm and min_tracked_dtm show), the only way we can have new
 * mates is by following a line that's completely within this tablebase, so we keep going until one
 * of the passes didn't finalize any positions.
 *
 * We have to be a little bit careful when we're using proptables, since we can have stuff queued up
 * in the current proptable that hasn't be reflected in the positive_passes_needed[] and
 * negative_passes_needed[] arrays, so if we're using proptables, then we ALWAYS run the next pass
 * after a pass that finalized some positions.
 */

void propagate_all_moves_within_tablebase(tablebase_t *tb)
{
    int dtm = 1;
    int positions_finalized_on_last_pass = 0;

    /* DTM 1 positions are illegal (PNTM is in check), so back prop from these positions is not
     * needed or desired because we don't count moves into check as part of movecnt.
     */

    positive_passes_needed[1] = 0;

    if (do_restart) {
	if (last_dtm_before_restart > 0) dtm = -last_dtm_before_restart;
	else dtm = -last_dtm_before_restart + 1;

	/* we don't know, exactly, but the existance of a proptable suggests at least one */
	positions_finalized_on_last_pass = 1;
    }

    /* If we're tracking DTM (i.e, if a DTM field exists in the entries format), then run at least
     * until we've looked at all the DTM values that came in from the futurebases.
     */

    if (ENTRIES_FORMAT_DTM_OFFSET != -1) {

	while ((dtm <= max_tracked_dtm) || (-dtm >= min_tracked_dtm)) {

	    /* PTM wins */
	    if (((dtm <= max_tracked_dtm) && positive_passes_needed[dtm])
		|| (positions_finalized_on_last_pass > 0))
		positions_finalized_on_last_pass = propagation_pass(dtm);
	    else
		positions_finalized_on_last_pass = 0;

	    if (dtm <= max_tracked_dtm) positive_passes_needed[dtm] = 0;

	    /* PNTM wins */
	    if (((-dtm >= min_tracked_dtm) && negative_passes_needed[dtm])
		|| (positions_finalized_on_last_pass > 0))
		positions_finalized_on_last_pass = propagation_pass(-dtm);
	    else
		positions_finalized_on_last_pass = 0;

	    if (-dtm >= min_tracked_dtm) negative_passes_needed[dtm] = 0;

	    dtm ++;
	}

    } else {

	positions_finalized_on_last_pass = 1;

    }

    /* Now keep running until there's nothing left to process */

    while (1) {

	/* PTM wins */
	if (positions_finalized_on_last_pass > 0)
	    positions_finalized_on_last_pass = propagation_pass(dtm);
	else break;

	/* PNTM wins */
	if (positions_finalized_on_last_pass > 0)
	    positions_finalized_on_last_pass = propagation_pass(-dtm);
	else break;

	dtm ++;
    }

}

/* The 'filename' argument passed in here can either be a filename or a URL.  We don't distinguish
 * between them except by looking at their prefix (though it would be easy to add an extra flag
 * argument to do so), so hopefully nobody will try to create tablebases starting with 'ftp:'.  Much
 * of the error checking on 'filename' is done by the caller, since we'd like that error checking to
 * occur prior to a time consuming generation run, rather than when we're ready to write the
 * finished product out.
 */

void write_tablebase_to_file(tablebase_t *tb, char *filename)
{
    xmlDocPtr doc;
    index_t index;
    void *file = NULL;
    xmlNodePtr tablebase;
    xmlChar *buf;
    int size;
    int padded_size;
    char str[16];
    char entrybuf[MAX_FORMAT_BYTES];
    void *entry = entrybuf;

#ifdef HAVE_LIBFTP
    if (strncmp(filename, "ftp:", 4) == 0) {
	void *ptr = ftp_openurl(filename, "w");
	if (ptr != NULL) {
	    file = zlib_open(ptr, ftp_read, ftp_write, ftp_seek, ftp_close, "w");
	}
    }
#endif

    if (file == NULL) {
	int fd;
	fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666);
	if (fd != -1) {
	    file = zlib_open((void *)((size_t) fd), read_ptr, write_ptr, lseek_ptr, close_ptr, "w");
	}
    }

    if (file == NULL) {
	fatal("Can't open output tablebase '%s'\n", filename);
	terminate();
    }

    info("Writing '%s'\n", filename);

    doc = finalize_XML_header(tb);

    /* We want at least one zero byte after the XML header, because that's how we figure out where
     * it ends when we read it back in, and I also want to align the tablebase on a four-byte
     * boundary for the hell of it.  (size+5)&(~3) achieves these goals.  I then modify the XML
     * header with the updated string that gives the offset to the tablebase, and make sure that its
     * size hasn't changed.
     */

    xmlDocDumpMemory(doc, &buf, &size);
    padded_size = (size+5)&(~3);

    sprintf(str, "0x%04x", padded_size);

    tablebase = xmlDocGetRootElement(doc);
    xmlSetProp(tablebase, BAD_CAST "offset", BAD_CAST str);

    xmlDocDumpMemory(doc, &buf, &size);

    if (padded_size != ((size+5)&(~3))) {
	fatal("sizes don't match in write_tablebase_to_file\n");
	terminate();
    }

    if (zlib_write(file, (char *) buf, padded_size) != padded_size) {
	fatal("Tablebase write failed\n");
	terminate();
    }

    xmlFree(buf);

    for (index = 0; index <= tb->max_index; index ++) {

#ifdef DEBUG_MOVE
	if (index == DEBUG_MOVE) {
	    fprintf(stderr, "Writing %d: DTM %d; movecnt %d\n", index,
		    get_entry_DTM(index), get_entry_movecnt(index));
	}
#endif

	/* Right now, there's only three possible fields in the tablebase format itself (as opposed
	 * to the intermediate entries and proptable formats) - dtm, basic, and flag.
	 */

	if (tb->format.dtm_bits > 0) {
	    set_int_field(entry,
			  tb->format.dtm_offset + ((index << tb->format.bits) % 8),
			  tb->format.dtm_bits,
			  get_entry_DTM(index));
	}

	if (tb->format.basic_offset != -1) {
	    int basic;

	    /* "3" is reserved to flag an illegal position, but we don't do that now, because we
	     * don't distinguish illegal positions from draws - see initialize_entry_as_illegal()
	     */

	    if (does_PTM_win(index)) {
		basic = 1;
	    } else if (does_PNTM_win(index)) {
		basic = 2;
	    } else {
		basic = 0;
	    }
	    set_unsigned_int_field(entry,
				   tb->format.basic_offset + ((index << tb->format.bits) % 8), 3,
				   basic);
	}

	switch (tb->format.flag_type) {
	case FORMAT_FLAG_WHITE_WINS:
	    set_bit_field(entry,
			  tb->format.flag_offset + ((index << tb->format.bits) % 8),
			  (index_to_side_to_move(tb, index) == WHITE)
			  ? does_PTM_win(index) : does_PNTM_win(index));
	    break;
	case FORMAT_FLAG_WHITE_DRAWS:
	    set_bit_field(entry,
			  tb->format.flag_offset + ((index << tb->format.bits) % 8),
			  (index_to_side_to_move(tb, index) == WHITE)
			  ? !does_PNTM_win(index) : !does_PTM_win(index));
	    break;
	}

	/* If the next index will be aligned on a byte boundary, write out what we've buffered */

	if ((((index + 1) << tb->format.bits) % 8) == 0) {
	    if (zlib_write(file, (char *) entry, tb->format.bytes) != tb->format.bytes) {
		fatal("Tablebase write failed\n");
		terminate();
	    }
	}
    }

    /* If the last index plus one wasn't on a byte boundary, write out what we've buffered */
    
    if (((index << tb->format.bits) % 8) != 0) {
	if (zlib_write(file, (char *) entry, tb->format.bytes) != tb->format.bytes) {
	    fatal("Tablebase write failed\n");
	    terminate();
	}
    }

    if (zlib_close(file) != 0) {
	fatal("Tablebase write failed\n");
	terminate();
    }
}

/* The "master routine" for tablebase generation.
 *
 * Many of these subroutines have already printed error messages of their own if they return
 * an error indication, which is why we just silently return in many cases.
 */

boolean generate_tablebase_from_control_file(char *control_filename, char *output_filename) {

    tablebase_t *tb;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    long long futurevector_bytes;
    /* int output_filename_needs_xmlFree = 0; */

#if defined(RLIMIT_MEMLOCK) && LOCK_MEMORY
    struct rlimit rlimit;
#endif

    tb = parse_XML_control_file(control_filename);
    if (tb == NULL) return 0;

    /* Need this no matter what.  I want to replace it with a global static tablebase for everything. */
    current_tb = tb;

    /* Figure out where we want to write the finished product. */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//output", context);
    if ((result->nodesetval->nodeNr == 0) && (output_filename == NULL)) {
	fatal("Output filename must be specified either on command line or with <output> tag\n");
	return 0;
    }
    if (result->nodesetval->nodeNr > 0) {
	if (output_filename != NULL) {
	    warning("Output filename specified on command line overrides <output> tag\n");
	} else {
	    /* XXX little memory leak here, but fixing it would clutter this routine */
	    if ((output_filename = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "filename")) != NULL) {
		/* output_filename_needs_xmlFree = 1; */
	    } else if ((output_filename = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url")) != NULL) {
		/* output_filename_needs_xmlFree = 1; */
	    }
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    if (output_filename == NULL) {
	fatal("No output filename or URL specified\n");
	return 0;
    }

    if (strncmp(output_filename, "http:", 5) == 0) {
	fatal("http URLs currently unsupported for tablebase I/O\n");
	return 0;
    }

#ifndef HAVE_LIBFTP
    if (strncmp(output_filename, "ftp:", 4) == 0) {
	fatal("Compiled without ftplib - ftp URLs unavailable\n");
	return 0;
    }
#endif

    if (using_proptables && num_threads > 1) {
	/* This is a limitation in TPIE */
	fatal("Can't use proptables with multiple threads (currently)\n");
	return 0;
    }

    if (!using_proptables) {
	tb->entries = malloc(LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3));
	if (tb->entries == NULL) {
	    fatal("Can't malloc %dMB for tablebase entries: %s\n",
		  LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3)/(1024*1024),
		  strerror(errno));
	    return 0;
	} else {
	    int kilobytes = LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3)/1024;
	    if (kilobytes < 1024) {
		info("Malloced %dKB for tablebase entries\n", kilobytes);
	    } else {
		info("Malloced %dMB for tablebase entries\n", kilobytes/1024);
	    }
	}
	/* Don't really need this, since they will all get initialized anyway */
	/* XXX actually do this need right now, because initialization isn't complete */
	memset(tb->entries, 0, LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3));
    }

#ifdef HAVE_LIBTPIE
    if (using_proptables) {
	if (! initialize_proptable(proptable_MBs)) return 0;
    }
#endif

    if (! preload_all_futurebases(tb)) return 0;
    assign_numbers_to_futuremoves(tb);
    if (! compute_pruned_futuremoves(tb)) return 0;
    if (! check_pruning(tb)) return 0;
    optimize_futuremoves(tb);
    print_futuremoves();

    if (! check_1000_indices(tb)) return 0;
    if (! check_1000_positions(tb)) return 0;

    /* This actually initializes the statistics arrays the first time it's called, and it
     * initializes for 100 passes, so these first few passes below here don't need any extra checks
     * to see if they would overflow the arrays.
     */
    expand_per_pass_statistics();

    /* Part of preloading the futurebases was to compute the smallest and largest DTMs in them, so
     * we now know what the sizes of these two arrays have to be.
     */
    positive_passes_needed = (uint8_t *) calloc(max_tracked_dtm + 1, sizeof(uint8_t));
    negative_passes_needed = (uint8_t *) calloc(-min_tracked_dtm + 1, sizeof(uint8_t));

    if ((positive_passes_needed == NULL) || (negative_passes_needed == NULL)) {
	fatal("Can't calloc positive/negative_passes_needed\n");
	return 0;
    }

    if (!using_proptables) {

	/* No proptables.  Allocate a futurevectors array, initialize the tablebase, back propagate
	 * the futurebases (noting which futuremoves have been handled in the futurevectors array),
	 * and run through the futurevectors array checking for unhandled futuremoves.
	 */

	/* tb->futurevectors = (futurevector_t *) calloc(tb->max_index + 1, sizeof(futurevector_t)); */
        if (num_futuremoves[WHITE] > num_futuremoves[BLACK])
	    tb->futurevector_bits = num_futuremoves[WHITE];
	else
	    tb->futurevector_bits = num_futuremoves[BLACK];

	futurevector_bytes = (((long long)(tb->max_index + 1) * tb->futurevector_bits) + 7) >> 3;
	tb->futurevectors = (char *) malloc(futurevector_bytes);
	if (tb->futurevectors == NULL) {
	    fatal("Can't malloc %dMB for tablebase futurevectors: %s\n", futurevector_bytes/(1024*1024),
		  strerror(errno));
	    return 0;
	} else {
	    int kilobytes = futurevector_bytes/1024;
	    if (kilobytes < 1024) {
		info("Malloced %dKB for tablebase futurevectors\n", kilobytes);
	    } else {
		info("Malloced %dMB for tablebase futurevectors\n", kilobytes/1024);
	    }
	}
	/* Don't really need this, since they will all get initialized anyway */
	memset(tb->futurevectors, 0, futurevector_bytes);

	/* Due to the heavily random access pattern of memory during back propagation, this
	 * application performs horribly if required to swap.  Attempt to lock all of its pages into
	 * memory, and die with a fatal error if we couldn't.  It seems better to die here, so we
	 * can detect this condition and rerun with either simpler tablebases (if there are pawns
	 * that can be factored) or using proptables.
	 *
	 * I'm finding that this system call is dangerous on Linux.  If you haven't set a resource
	 * limit, it can hang the machine if you try to lock more memory than the system physically
	 * possesses.  So I check first to make sure that a limit has been set before attempting the
	 * lock.
	 *
	 * The #ifdef keeps this from even being attempted on a Windows system.
	 */

#if defined(RLIMIT_MEMLOCK) && LOCK_MEMORY

	if (getrlimit(RLIMIT_MEMLOCK, &rlimit) == -1) {
	    warning("Can't getrlimit RLIMIT_MEMLOCK: %s\n", strerror(errno));
	} else if (rlimit.rlim_cur != 0) {
	    if ((mlockall(MCL_CURRENT) == -1) && (errno != EPERM)) {
		fatal("Can't mlockall memory: %s\n", strerror(errno));
		return 0;
	    }
	}

#endif

	pass_type[total_passes] = "initialization";

	info("Initializing tablebase\n");
	initialize_tablebase();

	finalize_pass_statistics();
	total_passes ++;

	info("Total legal positions: %lld\n", total_legal_positions);
	info("Total moves: %lld\n", total_moves);

	pass_type[total_passes] = "futurebase backprop";

	if (! back_propagate_all_futurebases(tb)) return 0;

	finalize_pass_statistics();
	total_passes ++;

	pass_type[total_passes] = "futuremove check";

	info("Checking futuremoves...\n");
	/* propagation_pass(0); */
	if (! have_all_futuremoves_been_handled(tb)) return 0;
	info("All futuremoves handled under move restrictions\n");

	finalize_pass_statistics();
	total_passes ++;

	free(tb->futurevectors);
	tb->futurevectors=NULL;

    } else {

	/* Using proptables.  No futurevectors array.  We back propagate the futurebases into the
	 * proptable, then in a single pass initialize the entries array and commit the proptable
	 * into it, checking each position move as we go to make sure its futuremoves are handled.
	 */

	initialize_current_entries_file();

	if (! do_restart) {
	    pass_type[total_passes] = "futurebase backprop";

	    if (! back_propagate_all_futurebases(tb)) return 0;

	    finalize_pass_statistics();
	    total_passes ++;
	}

	/* XXX should be able to handle restart just after a futurebase backprop */

	if (! do_restart) {
	    info("Initializing tablebase...\n");
	    pass_type[total_passes] = "initialization";
	    propagation_pass(0);

	    info("Total legal positions: %lld\n", total_legal_positions);
	    info("Total moves: %lld\n", total_moves);

	    info("All futuremoves handled under move restrictions\n");
	}

    }

    unload_all_futurebases();

    info("Intra-table propagating\n");
    propagate_all_moves_within_tablebase(tb);

    write_tablebase_to_file(tb, output_filename);

    return 1;
}

/***** PROBING NALIMOV TABLEBASES *****/

#ifdef USE_NALIMOV

int EGTBProbe(int wtm, unsigned char board[64], int sqEnP, int *score);

int IInitializeTb(char *pszPath);

int FTbSetCacheSize(void    *pv, unsigned long   cbSize );

#define EGTB_CACHE_DEFAULT (1024*1024)

void *EGTB_cache;

char *nalimov_path = (char *) ".";

void init_nalimov_code(void)
{
    int nalimov_num;

    nalimov_num = IInitializeTb(nalimov_path);
    printf("%d piece Nalimov tablebases found\n", nalimov_num);
    EGTB_cache = malloc(EGTB_CACHE_DEFAULT);
    if (EGTB_cache == NULL) {
	fprintf(stderr, "Can't malloc EGTB cache\n");
    } else {
	FTbSetCacheSize(EGTB_cache, EGTB_CACHE_DEFAULT);
    }
}

char * nalimov_to_english(int score)
{
    static char buffer[256];

    if (score > 0) {
	sprintf(buffer, "mate in %d", ((65536-4)/2)-score+1);
    } else if (score < 0) {
	sprintf(buffer, "mated in %d", ((65536-4)/2)+score);
    } else {
	sprintf(buffer, "draw");
    }

    return buffer;
}

void verify_tablebase_against_nalimov(tablebase_t *tb)
{
    index_t index;
    global_position_t global;
    local_position_t local;
    int score;

    info("Verifying tablebase against Nalimov\n");

    for (index = 0; index <= tb->max_index; index++) {
	if (index_to_global_position(tb, index, &global)) {

	    index_to_local_position(tb, index, REFLECTION_NONE, &local);

	    if (PNTM_in_check(tb, &local)) {

		/* I've learned the hard way not to probe a Nalimov tablebase for an illegal position... */

	    } else if ((global.en_passant_square != ILLEGAL_POSITION)
		       && ((global.board[global.en_passant_square - 9] != 'P')
			   || (global.en_passant_square == 40)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square - 7] != 'P')
			   || (global.en_passant_square == 47)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square + 7] != 'p')
			   || (global.en_passant_square == 16)
			   || (global.side_to_move == WHITE))
		       && ((global.board[global.en_passant_square + 9] != 'p')
			   || (global.en_passant_square == 23)
			   || (global.side_to_move == WHITE))) {

		/* Nor does Nalimov like it if the en passant pawn can't actually be captured by
		 * another pawn.
		 */

	    } else if (EGTBProbe(global.side_to_move == WHITE, global.board,
				 global.en_passant_square == ILLEGAL_POSITION ? -1 : global.en_passant_square, &score) == 1) {

		if (tb->format.dtm_bits > 0) {

		    int dtm = get_raw_DTM(tb, index);

		    if (dtm > 0) {
			if ((dtm-1) != ((65536-4)/2)-score+1) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mate in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, dtm-1);
			}
		    } else if (dtm < 0) {
			if ((-dtm-1) != ((65536-4)/2)+score) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mated in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, -dtm-1);
			}
		    } else if (dtm == 0) {
			if (score != 0) {
			    printf("%s (%d): Nalimov says %s (%d), but we say draw\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), ((65536-4)/2)+score);
			}
		    }
		}

		if (tb->format.basic_offset != -1) {

		    int basic = get_basic(tb, index);
		    static const char * basic_meaning[3] = {"draw", "PTM wins", "PNTM wins"};

		    if (global.side_to_move == BLACK) score *= -1;

		    if ((basic != 2) && (score < 0)) {
			fprintf(stderr, "%s (%d): Nalimov says PNTM wins, but we say %s\n",
				global_position_to_FEN(&global), index, basic_meaning[basic]);
		    } else if ((basic != 1) && (score > 0)) {
			fprintf(stderr, "%s (%d): Nalimov says PTM wins, but we say %s\n",
				global_position_to_FEN(&global), index, basic_meaning[basic]);
		    } else if ((basic != 0) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say %s\n",
				global_position_to_FEN(&global), index, basic_meaning[basic]);
		    }

		}

		if (tb->format.flag_type != FORMAT_FLAG_NONE) {

		    boolean flag = get_flag(tb, index);

		    if (global.side_to_move == BLACK) score *= -1;

		    if (flag && (score < 0)) {
			fprintf(stderr, "%s (%d): Nalimov says black wins, but we say white wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if (flag && (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say white wins\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (score > 0)) {
			fprintf(stderr, "%s (%d): Nalimov says white wins, but we say black wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (tb->format.flag_type == FORMAT_FLAG_WHITE_DRAWS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say black wins\n",
				global_position_to_FEN(&global), index);
		    }
		}
	    } else {
		fprintf(stderr, "%s (%d): Nalimov says illegal, but we don't\n",
			global_position_to_FEN(&global), index);
	    }
	}
    }
}

#endif /* USE_NALIMOV */


/* Search an array of tablebases for a global position.  Array should be terminated with a NULL ptr.
 */

boolean search_tablebases_for_global_position(tablebase_t **tbs, global_position_t *global_position,
					      tablebase_t **tbptr, index_t *indexptr)
{
    index_t index;

    for (; *tbs != NULL; tbs++) {
	index = global_position_to_index(*tbs, global_position);
	if (index != INVALID_INDEX) {
	    *tbptr = *tbs;
	    *indexptr = index;
	    return 1;
	}
    }

    return 0;
}

void print_score(tablebase_t *tb, index_t index, const char *ptm, const char *pntm, int pntm_offset)
{
    if (tb->format.dtm_bits > 0) {

	int dtm = get_raw_DTM(tb, index);

	if (dtm == 0) {
	    printf("Draw\n");
	} else if (dtm == 1) {
	    printf("Illegal position\n");
	} else if (dtm > 1) {
	    printf("%s wins in %d.5\n", ptm, dtm-1);
	} else if (dtm < 0) {
	    printf("%s wins in %d\n", pntm, pntm_offset-dtm-1);
	}

    } else if (tb->format.basic_offset != -1) {

	int basic = get_basic(tb, index);

	if (basic == 1) {
	    printf("%s wins\n", ptm);
	} else if (basic == 2) {
	    printf("%s wins\n", pntm);
	} else {
	    printf("Draw\n");
	}

    } else if (tb->format.flag_type != FORMAT_FLAG_NONE) {
	boolean flag = get_flag(tb, index);

	if (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS) {
	    if (flag) printf("White wins\n");
	    else printf("Black wins or draws\n");
	} else {
	    if (flag) printf("White wins or draws\n");
	    else printf("Black wins\n");
	}

    } else {
	printf("NO SCORE AVAILABLE\n");
    }
}

int print_move_list(tablebase_t **tbs, tablebase_t *tb, global_position_t *global_position_ptr,
		    const char *ptm, const char *pntm,
		    int print_non_captures, int print_captures)
{
    global_position_t global_position, saved_global_position;
    tablebase_t *tb2;
    index_t index2;
    int dir, square;
    int piece_color;
    int piece_type;
    int promotion;
    struct movement * movementptr;
    int moves_printed = 0;

    global_position = *global_position_ptr;
    saved_global_position = global_position;

    piece_color = global_position.side_to_move;

    for (square = 0; square < 64; square ++) {

	global_position = saved_global_position;

	flip_side_to_move_global(&global_position);

	if (global_position.board[square] == 0) continue;

	/* We only want to consider pieces of the side which is to move... */

	for (piece_type = 0; piece_type < NUM_PIECES; piece_type ++) {
	    if (global_position.board[square] == global_pieces[piece_color][piece_type]) break;
	}

	if (piece_type == NUM_PIECES) continue;

	global_position.board[square] = 0;

	if (piece_type != PAWN) {

	    global_position.en_passant_square = ILLEGAL_POSITION;

	    for (dir = 0; dir < number_of_movement_directions[piece_type]; dir++) {

		for (movementptr = movements[piece_type][square][dir];
		     (movementptr->square != -1) && (global_position.board[movementptr->square] == 0);
		     movementptr++) {

		    global_position.board[movementptr->square]
			= global_pieces[piece_color][piece_type];

		    if (! global_PNTM_in_check(&global_position) && print_non_captures) {
			if (search_tablebases_for_global_position(tbs, &global_position,
								  &tb2, &index2)){

			    printf("   %c%s%s    ", piece_char[piece_type],
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			    print_score(tb2, index2, pntm, ptm, 1);
			} else {
			    printf("   %c%s%s    NO DATA\n", piece_char[piece_type],
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			}
			moves_printed ++;
		    }

		    global_position.board[movementptr->square] = 0;

		}

		/* Now we consider possible captures */

		if (movementptr->square == -1) continue;

		if (((piece_color == WHITE)
		     && (global_position.board[movementptr->square] >= 'a')
		     && (global_position.board[movementptr->square] <= 'z'))
		    || ((piece_color == BLACK)
			&& (global_position.board[movementptr->square] >= 'A')
			&& (global_position.board[movementptr->square] <= 'Z'))) {

		    char captured_piece = global_position.board[movementptr->square];

		    if ((global_position.variant != VARIANT_SUICIDE)
			&& ((captured_piece == 'K') || (captured_piece == 'k'))) {

			/* printf("MATE\n"); */

		    } else {

			place_piece_in_global_position(&global_position, movementptr->square,
						       piece_color, piece_type);

			if (! global_PNTM_in_check(&global_position) && print_captures) {
			    if (search_tablebases_for_global_position(tbs, &global_position,
								      &tb2, &index2)) {

				printf ("   %c%sx%s   ", piece_char[piece_type],
					algebraic_notation[square],
					algebraic_notation[movementptr->square]);
				print_score(tb2, index2, pntm, ptm, 1);
			    } else if ((tb->variant == VARIANT_SUICIDE)
				       && (tb->num_pieces_by_color[1 - piece_color] == 1)) {
				printf("   %c%sx%s   %s WINS\n", piece_char[piece_type],
				       algebraic_notation[square],
				       algebraic_notation[movementptr->square],
				       colors[1 - piece_color]);
			    } else {
				printf("   %c%sx%s   NO DATA\n", piece_char[piece_type],
				       algebraic_notation[square],
				       algebraic_notation[movementptr->square]);
			    }
			    moves_printed ++;
			}

		    }

		    global_position.board[movementptr->square] = captured_piece;
		}

		/* end of capture search */
	    }

	    global_position.board[square] = global_pieces[piece_color][piece_type];
	    global_position.en_passant_square = saved_global_position.en_passant_square;

	} else {

	    /* PAWNs */

	    for (movementptr = normal_pawn_movements[square][piece_color];
		 movementptr->square != -1;
		 movementptr++) {

		/* break, not continue, because pawns can't jump over pieces */
		if (global_position.board[movementptr->square] != 0) break;

		if ((ROW(movementptr->square) != 0) && (ROW(movementptr->square) != 7)) {

		    global_position.board[movementptr->square] = global_pieces[piece_color][PAWN];

		    if (! global_PNTM_in_check(&global_position) && print_non_captures) {
			if (search_tablebases_for_global_position(tbs, &global_position,
								  &tb2, &index2)){

			    printf("   P%s%s    ",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			    print_score(tb, index2, pntm, ptm, 1);
			} else {
			    printf("   P%s%s    NO DATA\n",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			}
			moves_printed ++;
		    }

		    global_position.board[movementptr->square] = 0;

		} else {

		    /* non-capture promotion */

		    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

			place_piece_in_global_position(&global_position, movementptr->square,
						       piece_color, promoted_pieces[promotion]);


			if (! global_PNTM_in_check(&global_position) && print_non_captures) {
			    if (search_tablebases_for_global_position(tbs, &global_position,
								      &tb2, &index2)){
				printf ("   P%s%s=%c  ",
					algebraic_notation[square],
					algebraic_notation[movementptr->square],
					piece_char[promoted_pieces[promotion]]);
				print_score(tb2, index2, pntm, ptm, 1);
			    } else {
				printf("   P%s%s=%c  NO DATA\n",
				       algebraic_notation[square],
				       algebraic_notation[movementptr->square],
				       piece_char[promoted_pieces[promotion]]);
			    }
			    moves_printed ++;
			}
		    }

		    global_position.board[movementptr->square] = 0;
		}
	    }

	    /* capture pawn moves */

	    for (movementptr = capture_pawn_movements[square][piece_color];
		 movementptr->square != -1;
		 movementptr++) {

		if (movementptr->square == global_position.en_passant_square) {

		    /* en passant capture */

		    place_piece_in_global_position(&global_position, movementptr->square,
						   piece_color, PAWN);

		    if (piece_color == WHITE) {
			global_position.board[global_position.en_passant_square - 8] = 0;
		    } else {
			global_position.board[global_position.en_passant_square + 8] = 0;
		    }

		    if (! global_PNTM_in_check(&global_position) && print_captures) {
			if (search_tablebases_for_global_position(tbs, &global_position,
								  &tb2, &index2)) {

			    printf ("   P%sx%s   ",
				    algebraic_notation[square],
				    algebraic_notation[movementptr->square]);
			    print_score(tb2, index2, pntm, ptm, 1);
			} else if ((tb->variant == VARIANT_SUICIDE)
				   && (tb->num_pieces_by_color[1 - piece_color] == 1)) {
			    printf("   P%sx%s   %s WINS\n",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square],
				   colors[1 - piece_color]);
			} else {
			    printf("   P%sx%s   NO DATA\n",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			}
			moves_printed ++;
		    }

		    if (piece_color == WHITE) {
			global_position.board[global_position.en_passant_square - 8] = 'p';
		    } else {
			global_position.board[global_position.en_passant_square + 8] = 'P';
		    }

		    continue;
		}

		if (global_position.board[movementptr->square] == 0) continue;

		if (((piece_color == WHITE)
		     && (global_position.board[movementptr->square] >= 'A')
		     && (global_position.board[movementptr->square] <= 'Z'))
		    || ((piece_color == BLACK)
			&& (global_position.board[movementptr->square] >= 'a')
			&& (global_position.board[movementptr->square] <= 'z'))) {
		    continue;
		}

		if ((global_position.variant != VARIANT_SUICIDE)
		    && ((global_position.board[movementptr->square] == 'K')
			|| (global_position.board[movementptr->square] == 'k'))) {

		    /* printf("MATE\n"); */
		    continue;

		}

		if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

		    /* promotion capture */

		    char captured_piece = global_position.board[movementptr->square];

		    for (promotion = 0; promotion < promotion_possibilities; promotion ++) {

			place_piece_in_global_position(&global_position, movementptr->square,
						       piece_color, promoted_pieces[promotion]);

			if (! global_PNTM_in_check(&global_position) && print_captures) {
			    if (search_tablebases_for_global_position(tbs, &global_position,
								      &tb2, &index2)) {

				printf ("   P%sx%s=%c ",
					algebraic_notation[square],
					algebraic_notation[movementptr->square],
					piece_char[promoted_pieces[promotion]]);
				print_score(tb2, index2, pntm, ptm, 1);
			    } else if ((tb->variant == VARIANT_SUICIDE)
				       && (tb->num_pieces_by_color[1 - piece_color] == 1)) {
				printf("   P%sx%s=%c %s WINS\n",
				       algebraic_notation[square],
				       algebraic_notation[movementptr->square],
				       piece_char[promoted_pieces[promotion]],
				       colors[1 - piece_color]);
			    } else {
				printf("   P%sx%s=%c NO DATA\n",
				       algebraic_notation[square],
				       algebraic_notation[movementptr->square],
				       piece_char[promoted_pieces[promotion]]);
			    }
			    moves_printed ++;
			}
		    }

		    global_position.board[movementptr->square] = captured_piece;

		    continue;

		} else {

		    char captured_piece = global_position.board[movementptr->square];

		    global_position.board[square] = 0;
		    place_piece_in_global_position(&global_position, movementptr->square,
						   piece_color, PAWN);

		    if (! global_PNTM_in_check(&global_position) && print_captures) {
			if (search_tablebases_for_global_position(tbs, &global_position,
								  &tb2, &index2)) {

			    printf ("   P%sx%s   ",
				    algebraic_notation[square],
				    algebraic_notation[movementptr->square]);
			    print_score(tb2, index2, pntm, ptm, 1);
			} else if ((tb->variant == VARIANT_SUICIDE)
				   && (tb->num_pieces_by_color[1 - piece_color] == 1)) {
			    printf("   P%sx%s   %s WINS\n",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square],
				   colors[1 - piece_color]);
			} else {
			    printf("   P%sx%s   NO DATA\n",
				   algebraic_notation[square],
				   algebraic_notation[movementptr->square]);
			}
			moves_printed ++;
		    }

		    global_position.board[movementptr->square] = captured_piece;
		}
	    }
	    /* end of capture search */

	}
    }

    return moves_printed;
}

void probe_tablebases(tablebase_t **tbs) {
    global_position_t global_position;
    boolean global_position_valid = 0;
    boolean probing_single_tablebase;
    tablebase_t *tb = NULL;
    int i;

    if (tbs[0] == NULL) {
	fatal("No valid tablebases to probe!\n");
	terminate();
    }

    probing_single_tablebase = (tbs[1] == NULL);
    if (probing_single_tablebase) tb = tbs[0];

    for (i=1; tbs[i] != NULL; i ++) {
	if (tbs[i]->variant != tbs[0]->variant) {
	    fatal("All probed tablebases must use same variant!\n");
	    terminate();
	}
    }

#ifdef HAVE_LIBREADLINE
    read_history(".hoffman_history");
#endif

    while (1) {
#ifdef HAVE_LIBREADLINE
	char *buffer;
#else
	char buffer[256];
#endif
	index_t index = 0;
#ifdef USE_NALIMOV
	int score;
#endif

#ifdef HAVE_LIBREADLINE
	buffer = readline(global_position_valid ? "FEN or move? " : "FEN? ");
	if (buffer == NULL) break;
	if (*buffer == '\0') continue;
	add_history(buffer);
#else
	printf(global_position_valid ? "FEN or move? " : "FEN? ");
	if (fgets(buffer, sizeof(buffer), stdin) == NULL) break;
#endif

	/* the single period command - prints current position */
	if (!strcmp(buffer, ".")) {
	    int i;
	    for (i = 0; i < 64; i++) {
		char c = global_position.board[i % 8 + 8*(7-i/8)];
		if (i % 8 == 0)
		    printf("%c |",'8'-i/8);
		printf(" %s%c\e[0m", c >= 'a' ? "\e[7m" : "", c ? c : '.');
		if (i % 8 == 7)
		    printf("\n");
	    }
	    printf("  +----------------\n");
	    printf("    a b c d e f g h\n");
	    printf("%s to move\n", colors[global_position.side_to_move]);
	    continue;
	}

	if (!(global_position_valid && parse_move_in_global_position(buffer, &global_position))
	    && !parse_FEN_to_global_position(buffer, &global_position)
	    && (!probing_single_tablebase || (index = strtol(buffer, NULL, 10)) == 0)) {
	    printf(global_position_valid ? "Bad FEN or move\n\n" : "Bad FEN\n\n");
	    continue;
	}

	global_position.variant = tbs[0]->variant;
	global_position_valid = 1;

	if (index == 0) {
	    search_tablebases_for_global_position(tbs, &global_position, &tb, &index);
	} else {
	    index_to_global_position(tb, index, &global_position);
	}

	if ((tb != NULL) && (index != 0)) {

	    const char *ptm, *pntm;

	    /* 'index' is the index of the current position; 'index2' will be the index
	     * of the various next positions that we'll consider
	     */

	    printf("FEN %s\n", global_position_to_FEN(&global_position));
	    printf("Index %d (%s)\n", index, tb->filename);

	    if (global_position.side_to_move == WHITE) {
		ptm = "White";
		pntm = "Black";
	    } else {
		ptm = "Black";
		pntm = "White";
	    }

	    print_score(tb, index, ptm, pntm, 0);

#ifdef USE_NALIMOV
	    if ((global_position.variant == VARIANT_NORMAL)
		&& EGTBProbe(global_position.side_to_move == WHITE, global_position.board, -1, &score) == 1) {
		printf("\nNalimov score: ");
		if (score > 0) {
		    printf("%s wins in %d.5\n", ptm, ((65536-4)/2)-score+1);
		} else if (score < 0) {
		    printf("%s wins in %d\n", pntm, ((65536-4)/2)+score);
		} else {
		    printf("DRAW\n");
		}
	    }
#endif

	    /* In suicide, capture moves are forced, so if any exist they are the only moves. */

	    if (global_position.variant != VARIANT_SUICIDE) {
		print_move_list(tbs, tb, &global_position, ptm, pntm, 1, 1);
	    } else {
		if (print_move_list(tbs, tb, &global_position, ptm, pntm, 0, 1) == 0) {
		    print_move_list(tbs, tb, &global_position, ptm, pntm, 1, 0);
		}
	    }
	}
    }

#ifdef HAVE_LIBREADLINE
    write_history(".hoffman_history");
#endif

    printf("\n");
}

void usage(char *program_name)
{
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: %s -g [GENERATING-OPTIONS] XML-CONTROL-FILE   (generate)\n", program_name);
    fprintf(stderr, "   or: %s -p TABLEBASE                               (probe)\n", program_name);
    fprintf(stderr, "   or: %s -i TABLEBASE                               (info)\n", program_name);
#ifdef USE_NALIMOV
    fprintf(stderr, "   or: %s -v [-n NALIMOV-PATH] TABLEBASE             (verify)\n", program_name);
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Possible GENERATING-OPTIONS are:\n");
    fprintf(stderr, "   -o OUTPUT-FILENAME    set output filename (overrides control file)\n");
    fprintf(stderr, "   -P PROPTABLE-SIZE     enable proptables and sets size in MBs\n");
#ifdef USE_THREADS
    fprintf(stderr, "   -t NUM-THREADS        sets number of threads to use (default 1)\n");
#endif
    fprintf(stderr, "   -q                    quiet mode; suppress informational messages\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "Other options:\n");
#ifdef USE_NALIMOV
    fprintf(stderr, "   -n NALIMOV-PATH       sets path to find Nalimov tablebases\n");
#endif
    fprintf(stderr, "   -h                    display this help message and exit\n");
}

int main(int argc, char *argv[])
{
    /* Make sure this tablebase array is one bigger than we need, so it can be NULL terminated */
    tablebase_t **tbs;
    int argi;
    int i;
    int c;
    int generating=0;
    int probing=0;
    int verify=0;
    int dump_info=0;
    char *output_filename = NULL;
    extern char *optarg;
    extern int optind;
    char *options_string_ptr = options_string;
    struct sigaction action;

    /* Set signal handlers */

    memset(&action, 0, sizeof(action));
    action.sa_flags = SA_SIGINFO;
    action.sa_sigaction = sigaction_user_interrupt;
    if (sigaction(SIGINT, &action, NULL) == -1) {
	warning("Can't install SIGINTR handler: %s\n", strerror(errno));
    }

    action.sa_sigaction = sigaction_internal_error;
    if (sigaction(SIGSEGV, &action, NULL) == -1) {
	warning("Can't install SIGSEGV handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGILL, &action, NULL) == -1) {
	warning("Can't install SIGILL handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGFPE, &action, NULL) == -1) {
	warning("Can't install SIGFPE handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGBUS, &action, NULL) == -1) {
	warning("Can't install SIGBUS handler: %s\n", strerror(errno));
    }

    /* Note program start time */

    gettimeofday(&program_start_time, NULL);

    /* Print a greating banner with program version number. */

    fprintf(stderr, "Hoffman $Revision: 1.606 $ $Locker: baccala $\n");

    /* Figure how we were called.  This is just to record in the XML output for reference purposes. */

    for (i=0; i<argc; i++) {
	strncpy(options_string_ptr, argv[i], options_string + sizeof(options_string) - options_string_ptr);
	options_string_ptr += strlen(argv[i]);
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
	*options_string_ptr = ' ';
	options_string_ptr ++;
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
    }
    options_string[sizeof(options_string) - 1] = '\0';

    init_movements();
    verify_movements();

#ifdef DEBUG_MOVE
#define DEBUG_FLAG "d:"
#else
#define DEBUG_FLAG ""
#endif

    while (1) {
	c = getopt(argc, argv, "hiqgpvo:n:P:t:" DEBUG_FLAG);

	if (c == -1) break;

	switch (c) {

#ifdef DEBUG_MOVE
	case 'd':
	    /* XXX might want strtoll or something here */
	    if (strtol(optarg, NULL, 0) > 0) {
		debug_move = strtol(optarg, NULL, 0);
	    } else if (strtol(optarg, NULL, 0) < 0) {
		debug_futuremove = -strtol(optarg, NULL, 0);
	    } else {
		fatal("can't parse debugging index %s\n", optarg);
	    }
	    break;
#endif
	case 'i':
	    dump_info = 1;
	    break;
	case 'g':
	    generating = 1;
	    break;
	case 'p':
	    probing = 1;
	    break;
	case 'v':
	    verify = 1;
	    break;
	case 'h':
	    usage(argv[0]);
	    terminate();
	    break;
	case 'q':
	    verbose = 0;
	    break;
#ifdef USE_NALIMOV
	case 'n':
	    nalimov_path = optarg;
	    break;
#endif
	case 'o':
	    output_filename = optarg;
	    break;
	case 'P':
#ifdef HAVE_LIBTPIE
	    /* set size of proptable in megabytes */
	    proptable_MBs = strtol(optarg, NULL, 0);
	    using_proptables = 1;
#else
	    fatal("Not compiled with proptable support\n");
#endif
	    break;
#ifdef USE_THREADS
	case 't':
	    num_threads = strtol(optarg, NULL, 0);
	    break;
#endif
	}
    }

    if (generating && probing) {
	fatal("Only one of the generating (-g) and probing (-p) options can be specified\n");
	usage(argv[0]);
	terminate();
    }

    if (!generating && !probing && !verify && !dump_info) {
#if USE_NALIMOV
	fatal("At least one of -g, -p, -i, or -v must be specified\n");
#else
	fatal("At least one of -g, -p, or -i must be specified\n");
#endif
	usage(argv[0]);
	terminate();
    }

    if (!generating && (output_filename != NULL)) {
	fatal("An output filename can not be specified when probing or verifying\n");
	usage(argv[0]);
	terminate();
    }

#if !USE_NALIMOV
    if (verify) {
	fatal("Can't verify - program compiled without Nalimov support\n");
	usage(argv[0]);
	terminate();
    }
#endif

    /* Generating */

    if (generating) {
	generate_tablebase_from_control_file(argv[optind], output_filename);
	terminate();
    }

    /* Probing / Verifying */

#ifdef USE_NALIMOV
    init_nalimov_code();
#endif

    i = 0;
    /* calloc (unlike malloc) zeros memory */
    tbs = (tablebase_t **) calloc(argc - optind + 1, sizeof(tablebase_t *));

    for (argi=optind; argi<argc; argi++) {
	info("Loading '%s'\n", argv[argi]);
	tbs[i] = preload_futurebase_from_file(argv[argi]);
	open_futurebase(tbs[i]);
	if (dump_info) xmlDocDump(stdout, tbs[i]->xml);
	if (tbs[i] == NULL) {
	    fatal("Error loading '%s'\n", argv[argi]);
	} else {
#ifdef USE_NALIMOV
	    if (verify) verify_tablebase_against_nalimov(tbs[i]);
#endif
	    i++;
	}
    }

    if (!probing) terminate();

    probe_tablebases(tbs);
    terminate();
}

}
