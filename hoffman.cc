/* -*- mode: C; fill-column: 100; eval: (c-set-style "stroustrup"); -*-
 *
 * HOFFMAN - a chess endgame tablebase builder
 *
 * by Brent Baccala
 *
 * August, 2006
 *
 * no rights reserved; you may freely copy, modify, or distribute HOFFMAN
 *
 * written in C for speed
 *
 * This program is formated for a (minimum) 100 character wide display.
 *
 * INTRODUCTION
 *
 * This program calculates chess tablebases, which are large files containing all possible
 * configurations of chess pieces in an endgame and the best play to either win or draw.  Unlike a
 * conventional chess engine, which uses a heuristic evaluation function, a retrograde engine is
 * almost completely non-heuristic.  When it labels a position as a win, it is because it has
 * considered all possibles lines, be they 10, 20, or 100 moves long, and determined that the win is
 * forced, even with best play by the opposing side.  Some chess-like games, such as the Japanese
 * game Shogi, are not suitable for retrograde analysis because pieces never leave the game
 * (captured pieces in Shogi can be put back into play by the capturing player).  Yet for chess, the
 * frequent reduction of games to positions where only a handful of pieces remain has created an
 * entire subfield of endgame analysis.
 *
 * Systematic analysis of chess endgames dates at least to the ninth century.  Pioneering work in
 * computer retrograde analysis was done in the 1980s by Ken Thompson, the same of UNIX fame, and
 * S.J. Edwards, but the most popular tablebases today are those generated by a program written by
 * E.V. Nalimov.  Suffice it to say that while Nalimov's program has completely solved all chess
 * endgames with six or fewer pieces remaining, and while Nalimov tablebases are widely available on
 * the Internet, the Nalimov approach of solving an endgame completely results in very slow run
 * times and exceptionally large tablebases.  The K+P+P vs K+P endgame, for example, due to the
 * possibility of all pawns queening, requires the K+Q+Q vs K+Q endgame to be solved before it can
 * be calculated.
 *
 * Hoffman takes a somewhat different approach, one pioneered by the Eiko Bleicher's Freezer, now a
 * commercial program. When faced with something like K+P+P vs K+P, rather than calculate all
 * possible resulting positions, it may ignore the possibility of more than two pawns queening at
 * the same time, thus computing nothing more complex than K+Q+P vs K+Q.  While incomplete, such a
 * tablebase is nevertheless useful.  For the player with two pawns, if the tablebase finds a
 * winning line subject to the queening restrictions, then that line is still playable for a win,
 * even though a faster winning line may exist.  From the opposing point of view, if the tablebase
 * treats any position where the third pawn queens as a forced win, then the player can be confident
 * that any drawing line can not be improved upon by the superior side.  From a computational
 * perspective, we have reduced the complexity requirements to a point where the calculation can be
 * performed in a reasonable amount of time.  While still too slow for over-the-board use, we now
 * have a useful tool for the analysis of more complex endgames, useful for either static analysis,
 * or for the slow time controls of correspondence games.
 *
 * Hoffman improves upon Freezer with a more sophisticated method of chaining one endgame analysis
 * into another, allowing more realistic modeling of queening combinations and exchanges.  For
 * example, in a bishop vs knight endgame (with pawns), if we can (if we wish) analyze first the
 * king and pawn endgame resulting after a trade of the minors, then use this information to analyze
 * a similar set of king vs knight and king vs bishop endgames, and finally combine all this
 * information together to analyze the bishop vs knight endgame.  While the current version of
 * Freezer can only regard the capture of the knight or bishop as a forced win for one side or the
 * other, Hoffman can look through the exchange to determine the result more accurately.
 *
 * Hoffman thus attempts to combine the best of Nalimov and Freezer.  Unlike Freezer, the program is
 * powerful enough to solve any endgame completely (given enough computing resources), exactly
 * reproducing any Nalimov tablebase.  Unlike Nalimov, the program is capable of pruning pawn moves,
 * queening combinations, movement options and exchanges, giving it Freezer's ability to solve
 * complex endgames in a reasonable amount of time.  The exact tradeoff between the two extremes is
 * made using a XML-based configuration that can seem daunting at first, but ultimately offers the
 * user the ability to extensively tailor the program's operation.  Combined with a human being's
 * common sense and chess judgement, it is my hope that this flexibility with ultimately make the
 * program more useful for endgame retrograde analysis than either Nalimov or Freezer.
 *
 * For those not up on Americana, the program is named after Trevor Hoffman, an All Star baseball
 * pitcher who specializes in "closing" games.  It was written specifically for The World vs. Arno
 * Nickel game.
 *
 *
 * Usage: hoffman -g -o <output-tablebase> <xml-control-file>     (generate mode)
 *        hoffman -v <tablebase> ...                              (verification mode)
 *        hoffman -p <tablebase> ...                              (probe mode)
 */

#define _LARGEFILE64_SOURCE	/* because some of our files will require 64-bit offsets */

#define _XOPEN_SOURCE 600	/* for posix_memalign() and posix_fadvise() */

#define _GNU_SOURCE		/* to get O_DIRECT */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>	/* for write(), lseek(), gethostname() */
#include <time.h>	/* for putting timestamps on the output tablebases */
#include <fcntl.h>	/* for O_RDONLY */
#include <netdb.h>	/* for gethostbyname() */

#include <sys/time.h>     /* for reporting resource utilization */
#include <sys/resource.h>

#include <sys/mman.h>	/* for mmap() */

#include <errno.h>	/* for EINPROGRESS */

/* The program uses POSIX asynchronous I/O extensively.  Right now (November 2006), there are
 * basically two different Linux implementations available for this.  The native interface in the
 * 2.6 kernel series looks great on paper, but still seems to block at critical places.  GLIBC does
 * asynchronous I/O using threads, which works better right now but incurs the overhead of context
 * switches between the threads.  I've got both versions installed on my system and pick which one I
 * want to use by selecting the appropriate header file here and the appropriate library
 * (-lposix-aio for the native interface; -lrt for the GLIBC threads version) in the Makefile.  The
 * two selections have to match up; if they don't things will compile without warnings but fail with
 * various mysterious errors at runtime.
 */

#include </usr/local/include/aio.h>
/* #include </usr/include/aio.h> */

/* The GNU readline library, used for prompting the user during the probe code.  By defining
 * READLINE_LIBRARY, the library is set up to read include files from a directory specified on the
 * compiler's command line, rather than a system-wide /usr/include/readline.  I use it this way
 * simply because I don't have the readline include files installed system-wide on my machine.
 */

#define READLINE_LIBRARY
#include "readline.h"
#include "history.h"

/* The GNOME XML library.  To use it, I need "-I /usr/include/libxml2" (compiler) and "-lxml2"
 * (linker).
 */

#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xmlsave.h>

/* The ZLIB compression library */

#include <zlib.h>

/* According the GCC documentation, "long long" ints are supported by the C99 standard as well as
 * the GCC compiler.  In any event, since chess boards have 64 squares, being able to use 64 bit
 * integers makes a bunch of stuff a lot easier.  Might have to be careful with this if porting.
 */

typedef unsigned long long int uint64;
typedef unsigned int uint32;
typedef unsigned char uint8;
typedef short boolean;

typedef uint32 index_t;


/***** GLOBAL CONSTANTS *****/

/* Maximum number of pieces; used to simplify various arrays
 *
 * Since this includes frozen as well as mobile pieces, "16" may seem absurd, but it's probably
 * about right.  4 fully mobile pieces are easily doable in memory.  5 mobiles can often be done in
 * memory if you use either symmetry or a machine with lots of RAM.  6 mobiles requires sweeping
 * passes across a file on disk.  7 or more mobiles are only doable with severe restrictions on the
 * movements of the pieces.
 */

#define MAX_PIECES 16

/* Number of possibilities for pawn promotions.  "2" means queen and knight, but that can cause some
 * problems, as I've learned the hard (and embarrassing) way.
 */

#define PROMOTION_POSSIBILITIES 4

/* seven possible pieces: KQRBNP; 64 possible squares, up to 8 directions per piece, up to 7
 * movements in one direction
 */

#define NUM_PIECES 6
#define NUM_SQUARES 64
#define NUM_DIR 8
#define NUM_MOVEMENTS 7

/* Variables for gathering statistics */

uint64 total_legal_positions = 0;
uint64 total_PNTM_mated_positions = 0;
uint64 total_stalemate_positions = 0;
uint64 total_moves = 0;
uint64 total_futuremoves = 0;
uint64 total_backproped_moves = 0;
uint64 player_wins[2];
int max_dtm = 0;
int min_dtm = 0;

struct timeval program_start_time;
struct timeval program_end_time;

#define MAX_PASSES 100

int total_passes = 0;
struct timeval pass_start_times[MAX_PASSES];
struct timeval pass_end_times[MAX_PASSES];
char * pass_type[MAX_PASSES];
int pass_target_dtms[MAX_PASSES];
int positions_finalized[MAX_PASSES];
uint64 backproped_moves[MAX_PASSES];

int entries_write_stalls = 0;
int entries_read_stalls = 0;
int proptable_read_stalls = 0;
int proptable_writes = 0;

struct timeval entries_write_stall_time = {0, 0};
struct timeval entries_read_stall_time = {0, 0};
struct timeval proptable_read_stall_time = {0, 0};
struct timeval proptable_write_time = {0, 0};
struct timeval proptable_preload_time = {0, 0};


/***** DATA STRUCTURES *****/

/* 'futurevectors' are bit vector used to track which futuremoves have been handled in a particular
 * position.  They are of type futurevector_t, and the primary operations used to construct them are
 * FUTUREVECTOR(move) to get a futurevector with a bit set in move's position, and
 * FUTUREVECTORS(move,n) to get a futurevector with n bits set starting with move.
 */

typedef uint64 futurevector_t;
#define FUTUREVECTOR(move) (1ULL << (move))
#define FUTUREVECTORS(move, n) (((1ULL << (n)) - 1) << (move))

/* These arrays hold the bit locations in the futurevector of various futuremoves. */

int num_futuremoves = 0;
int futurecaptures[MAX_PIECES][MAX_PIECES];
int promotions[MAX_PIECES];
int futuremoves[MAX_PIECES][64];

/* XXX hardwired 100 futuremove max here */
char movestr[100][16];

futurevector_t pruned_futuremoves = 0;
futurevector_t conceded_futuremoves = 0;
futurevector_t discarded_futuremoves = 0;

/* position - the data structures that represents a board position
 *
 * There are two kinds of positions: local and global.  Locals are faster but are tied to a specific
 * tablebase.  Globals are more general and are used for probing.
 *
 * Both types use a 64-bit board_vector with one bit for each board position, in addition to a flag
 * to indicate which side is to move and the en passant capture square (or -1 if no en passant
 * capture is possible).  We use board_vector to easily check if possible moves are legal by looking
 * for pieces that block our moving piece.  This is done during futurebase propagation, during
 * intratable propagation, and during initialization.  It could be used to check if en passant
 * positions are legal (are the two squares behind the pawn blocked or not), but that is problematic
 * now because the board_vector isn't correct at the point where we need to make that check.
 *
 * Local positions use numbers (0-63) indicating the positions of the pieces, and also have a quick
 * way to check captures using a PTM_vector (pieces of the Player to Move).  You have to look into
 * the tablebase structure to figure out what piece corresponds to each number.  PTM_vector is only
 * used during tablebase initialization and in the probe code.
 *
 * It makes sense to include these vectors in the position structures because it's easiest to
 * compute them in the routines that convert indices to positions, but if you alter the position,
 * then they get out of sync, and its tempting to just leave them that way because you rarely need
 * them to be right at that point.  This really came back to haunt me when implementing en passant.
 *
 * "Multiplicity" is used in conjunction with symmetric indices, and indicates the actual number of
 * board positions that corresponds to this one.
 *
 * Global positions contain an 8x8 unsigned char array with ASCII characters representing each
 * piece.
 *
 * Sometimes I allow the board and PTM vectors to get out of sync with the position (for speed).
 * This can be a problem, so it has to be done really carefully.
 *
 * We don't worry about moving a piece that's pinned on our king, for example.  The resulting
 * position will already have been flagged illegal in the table.
 *
 */

/* Where are the kings located in the piece list? */

#define WHITE_KING 0
#define BLACK_KING 1

typedef struct {
    struct tablebase *tb;
    uint64 board_vector;
    uint64 PTM_vector;
    short side_to_move;
    short en_passant_square;
    short multiplicity;
    short piece_position[MAX_PIECES];
    uint8 reflection;
    uint8 permuted_piece[MAX_PIECES];
} local_position_t;

/* This is a global position, that doesn't depend on a particular tablebase.  It's slower to
 * manipulate, but is suitable for probing tablebases.  Each char in the array is either 0 for an
 * empty square, and one of the FEN characters for a chess piece.
 */

typedef struct {
    unsigned char board[64];
    short side_to_move;
    short en_passant_square;
} global_position_t;


/* bitvector gets initialized in init_movements() */

uint64 bitvector[64];
uint64 allones_bitvector = 0xffffffffffffffffLL;

/* pawn can't be on the first or last eight squares of the board */
#define LEGAL_PAWN_BITVECTOR 0x00ffffffffffff00LL

/* I'm not sure which one of these will be faster... */

/* #define BITVECTOR(square) bitvector[square] */
#define BITVECTOR(square) (1ULL << (square))

/* tablebase - the data structure used to hold tablebases
 *
 * WHITE and BLACK are also used for the side_to_move variable in the position type above
 */

#define KING 0
#define QUEEN 1
#define ROOK 2
#define BISHOP 3
#define KNIGHT 4
#define PAWN 5

char * piece_name[NUM_PIECES+1] = {"KING", "QUEEN", "ROOK", "BISHOP", "KNIGHT", "PAWN", NULL};
char piece_char[NUM_PIECES+1] = {'K', 'Q', 'R', 'B', 'N', 'P', 0};

char * colors[3] = {"WHITE", "BLACK", NULL};

/* We make a tacit assumption later (during promotion back propagation, when we compute the
 * futuremove number) that these numbers (QUEEN to KNIGHT) range from 1 to 4, and that they appear
 * in this array in numerical order.
 */

int promoted_pieces[] = {QUEEN, ROOK, BISHOP, KNIGHT, 0};

unsigned char global_pieces[2][NUM_PIECES] = {{'K', 'Q', 'R', 'B', 'N', 'P'},
					      {'k', 'q', 'r', 'b', 'n', 'p'}};

#define WHITE 0
#define BLACK 1


/* A 'struct format' gives the layout of a dynamic structure (one whose bit layout is specified at
 * run time).  See the section "DYNAMIC STRUCTURES" for more details on how this bugger works.
 */

struct format {
    uint8 bits;
    uint8 bytes;
    uint32 dtm_mask;
    uint8 dtm_offset;
    uint8 dtm_bits;
    uint32 movecnt_mask;
    uint8 movecnt_offset;
    uint8 movecnt_bits;
    uint8 in_check_flag_offset;
    uint32 index_mask;
    uint8 index_offset;
    uint8 index_bits;
    uint64 futurevector_mask;
    uint8 futurevector_offset;
    uint8 futurevector_bits;
    uint8 flag_offset;
    int flag_type;
};

char * format_fields[] = {"dtm", "movecnt", "in-check-flag", "index", "futurevector", "flag", NULL};

#define FORMAT_FIELD_DTM 0
#define FORMAT_FIELD_MOVECNT 1
#define FORMAT_FIELD_IN_CHECK_FLAG 2
#define FORMAT_FIELD_INDEX 3
#define FORMAT_FIELD_FUTUREVECTOR 4
#define FORMAT_FIELD_FLAG 5

char * format_flag_types[] = {"", "white-wins", "white-draws", NULL};

#define FORMAT_FLAG_NONE 0
#define FORMAT_FLAG_WHITE_WINS 1
#define FORMAT_FLAG_WHITE_DRAWS 2

#define MAX_FORMAT_BYTES 16

/* This is the format that we use for in-memory tablebase arrays.  The default is equivalent to:
 *
 * <format>
 *    <dtm bits="8" offset="0"/>
 *    <movecnt bits="7" offset="8"/>
 *    <in-check-flag bits="1" offset="15"/>
 * </format>
 */

struct format entries_format = {4,2, 0xff,0,8, 0x7f,8,7, 15};

/* This is the "one-byte-dtm" format */

struct format one_byte_dtm_format = {3,1, 0xff,0,8};

/* And this is the sixteen byte format we use by default for proptable entries */

struct format proptable_format = {7,16, 0xffff,32,16, 0xff,56,8, 0,
				  0xffffffff,0,32, 0xffffffffffffffffLL,64,64};



typedef void entry_t;


/* tablebase_t
 *
 * The 'xml' in the tablebase is authoritative; much of the other info is extracted from it
 * for efficiency.
 *
 * To make this work for either white or black positions, let's adopt the notation PTM (Player to
 * move) and PNTM (Player not to move)
 *
 * 'movecnt' is is the number of moves FORWARD from this position that haven't been analyzed yet,
 * with the high bit (128) set if PTM is in check.
 *
 * 'dtm' (Distance to Mate) is the number of moves required to force a mate.  It is positive
 * for a PTM mate and negative for a PNTM mate.
 *
 * Now PTM can mate with even a single move out of a position, so a postive dtm means PTM mates.
 * PNTM can only mate if PTM has no possible move that leads to mate, so a negative dtm coupled with
 * a 0 or 128 movecnt means PNTM mates.
 *
 * So, if we backtrace from a single PTM WINS, then this position becomes PTM WINS.  If we backtrace
 * from PNTM WINS, we decrement movecnt and adjust dtm to the lowest value (the slowest mate).  If
 * movecnt reaches 0 or 128, then the position becomes PNTM WINS.  When we're all done backtracing
 * possible wins, anything left with a non-zero movecnt, or a zero dtm, is a DRAW.
 *
 * We also need a mate-in count and a stalemate (conversion) count.
 *
 */

#define RESTRICTION_NONE 0
#define RESTRICTION_DISCARD 1
#define RESTRICTION_CONCEDE 2

char * restriction_types[4] = {"NONE", "DISCARD", "CONCEDE", NULL};

#define FORMAT_FOURBYTE 0
#define FORMAT_ONE_BYTE_DTM 1

char * formats[] = {"fourbyte", "one-byte-dtm", NULL};

#define NAIVE_INDEX 0
#define NAIVE2_INDEX 1
#define SIMPLE_INDEX 2
#define XOR_INDEX 3
#define COMPACT_INDEX 4

char * index_types[] = {"naive", "naive2", "simple", "xor", "compact"};

typedef struct tablebase {
    index_t max_index;
    index_t modulus;
    int index_type;
    int symmetry;
    int total_legal_piece_positions[MAX_PIECES];
    int simple_piece_positions[MAX_PIECES][64];
    int simple_piece_indices[MAX_PIECES][64];
    int last_identical_piece[MAX_PIECES];
    int next_identical_piece[MAX_PIECES];

    uint8 compact_white_king_positions[64*64];
    uint8 compact_black_king_positions[64*64];
    int compact_king_indices[64][64];
    int total_legal_compact_king_positions;

    struct format format;

    /* for futurebases only */
    gzFile file;
    long offset;
    int max_dtm;
    int min_dtm;
    int invert_colors;
    int extra_piece;
    int missing_pawn;
    int missing_non_pawn;

    xmlDocPtr xml;

    /* Pieces can restricted according to which squares they are allowed to move on.
     *
     * Legal squares are just that.
     *
     * "Semilegal" squares are squares that might be legal for a given piece, but we can't be sure
     * until we've considered other pieces in the position as well.  This becomes a factor when
     * we've got multiple identical pieces with overlapping, non-identical move restrictions.
     * Consider, for example, a tablebase with two rooks: one unrestricted, the other restricted to
     * its back rank.  Let's say we're moving a rook off the back rank.  If the other rook is on the
     * back rank, then the move is legal.  If the other rook is somewhere else, then the move would
     * be illegal.  So we make the entire board "semilegal" for both rooks, process the move
     * normally, and only when it's time to convert the entire position to an index in the tablebase
     * do we actually decide if the position is fully legal.
     */

    int num_pieces;
    int move_restrictions[2];		/* one for each color */
    short piece_type[MAX_PIECES];
    short piece_color[MAX_PIECES];
    uint64 semilegal_squares[MAX_PIECES];

    int entries_fd;
    entry_t *entries;
    futurevector_t *futurevectors;
} tablebase_t;

/* Propagation table
 *
 * This is used to optimize back propagation for large tablebases where the entire entries array
 * can't fit in memory.  Back propagation is done by first building proptable entries and sorting
 * them into a proptable.  The sorted proptable is then merged into the entries array.
 *
 * Currently, proptable entries are 16 bytes (128 bits) - a 32 bit index, 32 more bits of
 * housekeeping, and a 64 bit futurevector.  This is significant because many Pentium architectures
 * use 64 byte cache lines.
 *
 * I'm changing this to make the propentries variable using a 'struct format'.  That's why they're
 * void.
 */

typedef void proptable_entry_t;

proptable_entry_t *proptable = NULL;

proptable_entry_t *proptable1 = NULL;
proptable_entry_t *proptable2 = NULL;
int zeros_fd = -1;

tablebase_t *proptable_tb = NULL;

/* 0 indicates that we're not use proptables */
int num_propentries = 0;

/* PROPTABLE_BITS for 16 byte entries:
 *
 * 8 = 256 entries = 4KB (testing)
 * 16 = 64K entries (what I've been using)
 * 20 = 1M entries = 16MB
 * 24 = 16M entries = 256MB
 */

#define MAX_ZEROOFFSET 25

#define SEPERATE_PROPTABLE_FILES 0

#define FINITE_FIELD_INVERSION 1

#define USE_DUAL_PROPTABLES 1

#define CHECK_KING_LEGALITY_EARLY 1


/* DEBUG_MOVE can be used to print more verbose debugging information about what the program is
 * doing to process a single move.
 */

/* #define DEBUG_MOVE 2487633 */


/***** UTILITY FUNCTIONS *****/

/* Matches a string against a NULL-terminated array of strings using case insensitive match.
 * Returns index in array of matching string, or -1 if there was no match.
 */

int find_name_in_array(char * name, char * array[])
{
    int i=0;

    if (name == NULL) return -1;

    while (*array != NULL) {
	if (!strcasecmp(name, *array)) return i;
	array ++;
	i ++;
    }

    return -1;
}

/* do_write() is like the system call write(), but keeps repeating until the write is complete */

int do_write(int fd, void *ptr, int length)
{
    while (length > 0) {
	int writ = write(fd, ptr, length);
	if (writ == -1) {
	    perror("do_write");
	    return -1;
	}
	ptr += writ;
	length -= writ;
    }
    return 0;
}

#define ROW(square) ((square) / 8)
#define COL(square) ((square) % 8)

inline int rowcol2square(int row, int col)
{
    return (col + row*8);
}

/* diagonal_reflection() flips along the a1/h8 diagonal by simply interchanging the row and column */

int diagonal_reflection(int square)
{
    return rowcol2square(COL(square), ROW(square));
}

int horizontal_reflection(int square)
{
    return rowcol2square(ROW(square), 7-COL(square));
}

int vertical_reflection(int square)
{
    return rowcol2square(7-ROW(square), COL(square));
}

void subtract_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec -= src->tv_sec;
    if (dest->tv_usec > src->tv_usec) {
	dest->tv_usec -= src->tv_usec;
    } else {
	dest->tv_usec = 1000000 + dest->tv_usec - src->tv_usec;
	dest->tv_sec --;
    }
}

void add_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec += src->tv_sec;
    dest->tv_usec += src->tv_usec;
    if (dest->tv_usec >= 1000000) {
	dest->tv_usec -= 1000000;
	dest->tv_sec ++;
    }
}

void sprint_timeval(char *strbuf, struct timeval *timevalp)
{
    if (timevalp->tv_sec < 60) {
	sprintf(strbuf, "%ld.%03lds", timevalp->tv_sec, timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 3600) {
	sprintf(strbuf, "%ldm%02ld.%03lds", timevalp->tv_sec/60, timevalp->tv_sec%60,
		timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 24*3600) {
	sprintf(strbuf, "%ldh%02ldm%02ld.%03lds", timevalp->tv_sec/3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    } else {
	sprintf(strbuf, "%ldd%02ldh%02ldm%02ld.%03lds",
		timevalp->tv_sec/(24*3600), (timevalp->tv_sec/3600)%3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    }
}

void fprint_system_time(void)
{
    struct rusage rusage;
    char strbuf[256];

    getrusage(RUSAGE_SELF, &rusage);
    sprint_timeval(strbuf, &rusage.ru_stime);
    fprintf(stderr, "System time: %s\n", strbuf);
}


/***** DYNAMIC STRUCTURES *****/

/* Hoffman uses "dynamic structures" extensively, for its entries and proptable arrays.  A dynamic
 * structure is one whose bit layout is specified at run time by the XML control file.  Since we
 * can't use standard C structures (they require bit layouts to be set at compile time), we've got
 * to do all of this nonsense.
 *
 * Does it slow down the program?  You bet.  But for larger tablebases, which are disk bound and not
 * CPU bound, this actually speeds things up by giving us the flexibility of setting structure
 * layouts based on the needs of individual tablebases, and not having to use generic structures
 * big enough to accommodate every possibility.
 */

inline int get_signed_field(uint32 *ptr, uint32 mask, int offset)
{
    int val;

    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    val = (*ptr >> offset) & mask;

    /* sign extend */
    if (val > (mask >> 1)) val |= (~ (mask >> 1));

    return val;
}

inline void set_signed_field(uint32 *ptr, uint32 mask, int offset, int val)
{
    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    if ((val > 0) && (val > (mask >> 1))) {
	fprintf(stderr, "value too large in set_signed_field\n");  /* BREAKPOINT */
    }
    if ((val < 0) && (val < ~(mask >> 1))) {
	fprintf(stderr, "value too small in set_signed_field\n");  /* BREAKPOINT */
    }
    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}

inline unsigned int get_unsigned_field(uint32 *ptr, uint32 mask, int offset)
{
    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    return (*ptr >> offset) & mask;
}

inline void set_unsigned_field(uint32 *ptr, uint32 mask, int offset, unsigned int val)
{
    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    if (val > mask) {
	fprintf(stderr, "value too large in set_unsigned_field\n");  /* BREAKPOINT */
    }
    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}

inline uint64 get_unsigned64bit_field(void *fieldptr, uint64 mask, int offset)
{
    uint64 *ptr = (uint64 *)fieldptr;

    while (offset >= 64) {
	offset -= 64;
	ptr ++;
    }

    return (*ptr >> offset) & mask;
}

inline void set_unsigned64bit_field(void *fieldptr, uint64 mask, int offset, uint64 val)
{
    uint64 *ptr = (uint64 *)fieldptr;

    while (offset >= 64) {
	offset -= 64;
	ptr ++;
    }

    if (val > mask) {
	fprintf(stderr, "value too large in set_unsigned_field\n");  /* BREAKPOINT */
    }
    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}


/***** INDICES *****/

/* Basically there are two functions here - one converts an index to a local position, the other
 * converts a local position to an index - but they exist in several different versions, depending
 * on the type of index we're using for a particular tablebase.  These functions are used
 * extensively during all types of back propagation.
 *
 * local_position_to_index() also updates the position's board_vector (which doesn't have to be
 * valid going in), but not the PTM_vector.  It does this to check for illegal en passant positions.
 * It returns either an index into the table, or -1 if the position is illegal.
 *
 * Actually, it doesn't update the board vector anymore because we work on a copy of the position.
 *
 * index_to_local_position(), given an index, fill in a board position.  Obviously has to correspond
 * to local_position_to_index() and it's a big bug if it doesn't.  The boolean that gets returned is
 * TRUE if the operation succeeded and FALSE if the index was illegal.
 *
 * Several issues crop up for all index types.
 *
 * What exactly is an illegal position?  Well, for starters, one that index_to_local_position()
 * reports as illegal, because that's the function that initialize_tablebase() uses to figure which
 * positions are flagged illegal, as well as which positions to consider during back prop, and the
 * program screams if you try to back prop into an illegal position.  So the two functions have to
 * agree on illegality.  But there's also a subtle interaction between the legality tests here and
 * the move counting code in initialize_tablebase().  If we count a move, and it's not considered a
 * futuremove, then it'd better lead to a legal position, because we'll never backprop from an
 * illegal one, and that would imbalance the forward and reverse move counting.  For speed purposes,
 * the move counting code currently does not actually check positions to see if they are illegal.
 * So we can't, for example, flag positions with adjacent kings as illegal without updating that
 * code.
 *
 * En passant.  This is another case where subtle concepts of "legality" show up.  When we back
 * propagate a local position from either a futurebase or intratable, we generate en passant
 * positions simply by running through the pawns on the fourth and fifth ranks.  We look then to see
 * if there was a piece behind the "en passant" pawn (that would have prevented it from moving), but
 * (unlike Nalimov) we don't check if there is an enemy pawn that actually could have captured.
 * Again, the code has to match up between the two places, or we would try to back propagate to a
 * position that had been labeled illegal during initialization by index_to_local_position().
 *
 * Identical pieces.  Identical positions need to generate identical indices.  If we have two
 * identical pieces, then transposing them in a position can't affect the outcome of
 * local_position_to_index().  Right now, I deal with this by making a copy of the local position
 * and sorting identical pieces into ascending position numbers.
 *
 * So how about a static 64-bit vector with bits set for pieces frozen on a single square?
 * Everytime we call index_to_local_position, copy from the static vector into the position
 * structure.  Then we compute the positions of the mobile pieces and plug their bits into the
 * structure's vector at the right places.  Might implement this some day.
 */

boolean check_king_legality(int kingA, int kingB) {
    if ((ROW(kingA) < ROW(kingB) - 1) || (ROW(kingA) > ROW(kingB) + 1)) return 1;
    if ((COL(kingA) < COL(kingB) - 1) || (COL(kingA) > COL(kingB) + 1)) return 1;
    return 0;
}

unsigned char byte_transform[256];

unsigned char multiply_in_GF2_8(unsigned char a, unsigned char b)
{
    unsigned char result = 0;

    while (a != 0) {
	if ((a&1) == 1) result ^= b;
	a >>= 1;
	if ((b&0x80) == 0x80) {
	    b ^= 0x80;
	    b <<= 1;
	    b ^= 0x1b;
	} else {
	    b <<= 1;
	}
    }
    return result;
}

unsigned char byte_transform_64[64];
unsigned char byte_transform_64b[64];
unsigned char byte_transform_64c[64];

unsigned char multiply_in_GF2_6(unsigned char a, unsigned char b, unsigned char irreducible_polynomial)
{
    unsigned char result = 0;

    while (a != 0) {
	if ((a&1) == 1) result ^= b;
	a >>= 1;
	b <<= 1;
	if ((b&0x40) == 0x40) {
	    b ^= irreducible_polynomial;
	}
    }
    return result;
}

void initialize_byte_transform(void)
{
    unsigned char a;
    unsigned char b;

    byte_transform[0] = 0;

    for (a=1; a!=0; a++) {
	for (b=1; b!=0; b++) {
	    if (multiply_in_GF2_8(a,b) == 1) {
		byte_transform[a] = b;
		break;
	    }
	}
	if (b == 0) {
	    fprintf(stderr, "Couldn't invert in initialize_byte_transform\n");
	}
	/* fprintf(stderr, "0x%02x -> 0x%02x\n", a, b); */
    }

    byte_transform_64[0] = 0;
    byte_transform_64b[0] = 0;
    byte_transform_64c[0] = 0;

    /* use first three irreducible polynomials from Marsh's table for GF(2^6) */

    for (a=1; a<=63; a++) {
	for (b=1; b<=63; b++) {
	    if (multiply_in_GF2_6(a,b, 0103) == 1) {
		byte_transform_64[a] = b;
	    }
	    if (multiply_in_GF2_6(a,b, 0111) == 1) {
		byte_transform_64b[a] = b;
	    }
	    if (multiply_in_GF2_6(a,b, 0127) == 1) {
		byte_transform_64c[a] = b;
	    }
	}
    }
}

#define encode_index(INDEX)                                                                     \
   asm("                                                                                        \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                shr $3, %%eax;                                                                  \
                and $7, %%ecx;                                                                  \
                shl $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                          " : "+a" (INDEX) : "b" (byte_transform) : "cx", "cc")

#define decode_index(INDEX)                                                                     \
   asm("                                                                                        \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                mov %%eax, %%ecx;                                                               \
                and $0x0000ffff, %%eax;                                                         \
                shl $3, %%eax;                                                                  \
                shr $16, %%ecx;                                                                 \
                xor %%ecx, %%eax;                                                               \
                                                                                                \
                xlatb;                                                                          \
                xchg %%ah, %%al;                                                                \
                xlatb;                                                                          \
                                                                                                \
                          " : "+a" (INDEX) : "b" (byte_transform) : "cx", "cc")

/* Later in the program, I'll use these indices as the keys in an address calculation insertion
 * sort.  This kind of sort performs well if the keys are evenly distributed, and performs horribly
 * if the keys are clumped together.  Since checkmates occur in groups of similar positions,
 * something has to be done.  "Something" is inversion of the indices in a finite field,
 * specifically a modulo ring with a prime modulus.  The modulus is specified in the XML
 * configuration, and I don't check to make sure it's prime - there are other programs available
 * that do that.
 *
 * Originally, I used the HalfExtendedEuclidian algorithm from Manuel Bronstein's book "Symbolic
 * Integration I":
 *
 * Given a Euclidean domain D and a,b in D, return s,g in D such that g = gcd(a,b) and sa=g (mod b)
 *
 * But I had so much trouble implementing it that I wrote out the following explanation and then
 * coded it myself.
 *
 * Consider an array of number x[n].  To compute gcd(a,b), we set up x[0]=a and x[1]=b, then
 * repeatedly compute x[n+1] = x[n-1] % x[n].  So
 *
 *      x[n-1] = q[n] * x[n] + x[n+1],
 *
 * because x[n+1] is the remainder, and q[n] is the quotient of the n'th division.
 *
 *      x[n+1] = x[n-1] - q[n] * x[n],
 *
 * so all common factors of x[n] and x[n-1] are preserved in x[n+1] (if it is non-zero).
 * Eventually, x[n+1] will be zero, and x[n] will then be gcd(a,b).
 *
 * Now, each x[n] can be written in terms of a and b: x[n] = a[n] * a + b[n] * b.  Since
 *
 *      x[n+1]                  = x[n-1]                    - q[n] * x[n]
 *
 *      a[n+1] * a + b[n+1] * b = (a[n-1] * a + b[n-1] * b) - q[n] * (a[n] * a + b[n] * b)
 *
 *                              = (a[n-1] * a + b[n-1] * b) - q[n] * a[n] * a - q[n] * b[n] * b
 *
 *                              = (a[n-1] - q[n] * a[n]) * a + (b[n-1] - q[n] * b[n]) * b
 *
 *      a[n+1] = a[n-1] - q[n] * a[n]      and      b[n+1] = b[n-1] - q[n] * b[n]
 *
 * We started with x[0]=a and x[1]=b, so a[0]=1, b[0]=0, a[1]=0, and b[1]=1
 *
 * When we finally compute x[n] = gcd(a,b), we can decompose this into a[n] * a + b[n] * b,
 * and if a was the prime modulus of our finite field, then x[n] = gcd(a,b) = 1, so:
 *
 *        1 = a[n] * a + b[n] * b
 *
 *        1 = b[n] * b  (mod a)
 *
 * i.e, b[n] is the multiplicative inverse of b (mod a).
 *
 * Even a hand-coded assembly version of this algorithm was too slow, so on the advice of
 * Prof. Christof Paar I switched to using a binary extended GCD algorithm.  This is based on
 * computing a GCD by repeatedly subtracting the smaller number from the larger one.  A
 * consideration of the equation c = a - b shows that a common multiple of any two of the numbers
 * must be a common multiple of the third.  Therefore, subtracting preserves common multiples in the
 * result and does not introduce any new common multiples.  Because we are working with a binary
 * architecture, detecting multiples of two is easy, so we can eliminate them by right shifting.
 * Since subtracting two odd numbers gives an even number, we can right shift by at least one bit
 * per iteration.  Combining the two operations of subtraction and right shifting, we get a GCD
 * algorithm (14.61 in Menezes' Handbook of Applied Cryptography) that requires more iterations, but
 * still completes in a reasonable time and avoids the expensive multiplications and divisions.
 *
 * As above, we need to track the b[n] part of x[n] = a[n] * a + b[n] * b until we reach a GCD of 1.
 * Subtracting (x[n+1] = x[n] - x[n-1]) is easy:
 *
 *                a[n+1] = a[n] - a[n-1]    and    b[n+1] = b[n] - b[n-1]
 *
 * Right shifting (division by 2) is only a little more difficult.  Let's first note that if x[n] is
 * even (the only case in which we'd be right shifting) and a is odd (it's a prime modulus, after
 * all), then either a[n] is even or a[n] and b[n] must both be odd.  So if b[n] is even, then a[n]
 * is also even and we can right shift everything: x[n]/2 = a[n]/2 * a + b[n]/2 * b, while if
 * b[n] is odd, we can add and subtract a * b to obtain:
 *
 *             x[n] = (a[n] + b) * a + (b[n] - a) * b
 *
 *             x[n]/2 = (a[n] + b)/2 * a + (b[n] - a)/2 * b
 *
 * Remember that a[n] gets discarded; b[n] is all we care about computing.
 *
 * So our operations are:
 *
 *    subtract (x > y)    x = x - y             b[x] = (b[x] - b[y]) mod m
 *
 *    subtract (y > x)    y = y - x             b[y] = (b[y] - b[x]) mod m
 *
 *    right shift x (b[x] even)     x = x / 2                  b[x] = b[x] / 2
 *
 *    right shift x (b[x] odd)      x = x / 2                  b[x] = ((b[x] - m) / 2) mod m
 *
 *                                                         or  b[x] = ((b[x] + m) / 2) mod m
 *
 * m    -> EAX
 * x    -> EBX
 * y    -> ECX
 * (m+1)/2 -> EDX
 * b[x] -> ESI
 * b[y] -> EDI
 *
 * This is a GNU compiler, so we use AT&T assembler syntax - the destination comes second.
 */

#define ASM_invert_in_finite_field(INDEX, MODULUS)						\
   asm("                                                                                        \
                /* Input                                                                    */  \
                /*                                                                          */  \
                /* EAX - modulus                                                            */  \
                /* ECX - index                                                              */  \
                                                                                                \
                mov %%eax, %%ebx;                                                               \
                mov $0, %%esi;                                                                  \
                mov $1, %%edi;                                                                  \
                                                                                                \
                mov %%eax, %%edx;                                                               \
                add $1, %%edx;                                                                  \
                shr %%edx;                                                                      \
                                                                                                \
                /* while ((y&1) == 0)                                                       */  \
                                                                                                \
           1:   test $1, %%ecx;                                                                 \
                jne 2f;                                                                         \
                                                                                                \
                /*     y >>= 1;                                                             */  \
                shr %%ecx;                                                                      \
                                                                                                \
                /*     if ((by&1) == 0) {                                                   */  \
                /*        by >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        by = ((by + m)/2) mod m;                                          */  \
                /*        by = (((by-1 + m+1)/2) mod m;                                     */  \
                /*        by = ((by-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%edi;                                                                      \
                jnc 1b;                                                                         \
                add %%edx, %%edi;                                                               \
                cmp %%eax, %%edi;                                                               \
                jc  1b;                                                                         \
                sub %%eax, %%edi;                                                               \
                jmp 1b;                                                                         \
                                                                                                \
           2:   /* Is x = y ?  Is x > y ?                                                   */  \
                cmp %%ecx, %%ebx;                                                               \
                jz  6f;                                                                         \
                jc  4f;                                                                         \
                                                                                                \
                /* Yes, x > y                                                               */  \
                /* Set x = x - y                                                            */  \
                sub %%ecx, %%ebx;                                                               \
                                                                                                \
                /* Set b[x] = (b[x] - b[y]) mod m                                           */  \
                sub %%edi, %%esi;                                                               \
                jnc 3f;                                                                         \
                add %%eax, %%esi;                                                               \
                                                                                                \
                /* while ((x&1) == 0)                                                       */  \
                                                                                                \
           3:   test $1, %%ebx;                                                                 \
                jne 2b;                                                                         \
                                                                                                \
                /*     x >>= 1;                                                             */  \
                shr %%ebx;                                                                      \
                                                                                                \
                /*     if ((bx&1) == 0) {                                                   */  \
                /*        bx >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        bx = ((bx + m)/2) mod m;                                          */  \
                /*        bx = (((bx-1 + m+1)/2) mod m;                                     */  \
                /*        bx = ((bx-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%esi;                                                                      \
                jnc 3b;                                                                         \
                add %%edx, %%esi;                                                               \
                cmp %%eax, %%esi;                                                               \
                jc  3b;                                                                         \
                sub %%eax, %%esi;                                                               \
                jmp 3b;                                                                         \
                                                                                                \
                /* y > x                                                                    */  \
                /* Set y = y - x                                                            */  \
           4:   sub %%ebx, %%ecx;                                                               \
                                                                                                \
                /* Set b[y] = (b[y] - b[x]) mod m                                           */  \
                sub %%esi, %%edi;                                                               \
                jnc 1b;                                                                         \
                add %%eax, %%edi;                                                               \
                                                                                                \
                jmp 1b;                                                                         \
                                                                                                \
           6:   mov %%edi, %%ecx;                                                               \
                                                                                                \
                          " : "+c" (INDEX) : "a" (MODULUS) : "bx", "dx", "di", "si", "cc")

uint32 invert_in_finite_field(uint32 b, uint32 m)
{
#if 0
    uint32 x = m;
    uint32 y = b;
    uint32 bx = 0;
    uint32 by = 1;

    int test = b;
    ASM_invert_in_finite_field(test, m);

    while ((y&1) == 0) {
	y >>= 1;
	if ((by&1) == 0) {
	    by >>= 1;
	} else {
	    by = ((by + m)/2)%m;
	}
    }

    while (x != y) {
	if (x > y) {
	    x = x - y;

	    if (bx > by) bx = (bx - by)%m;
	    else bx = (m + bx - by)%m;

	    while ((x&1) == 0) {
		x >>= 1;
		if ((bx&1) == 0) {
		    bx >>= 1;
		} else {
		    bx = ((bx + m)/2)%m;
		}
	    }
	} else {
	    y = y - x;

	    if (by > bx) by = (by - bx)%m;
	    else by = (m + by - bx)%m;

	    while ((y&1) == 0) {
		y >>= 1;
		if ((by&1) == 0) {
		    by >>= 1;
		} else {
		    by = ((by + m)/2)%m;
		}
	    }
	}
    }
    if (x != 1) fprintf(stderr, "x != 1 in invert_finite_field v2\n");

    if (by != test) {
	fprintf(stderr, "%d: assembly inversion (%d) didn't match C code (%d)\n", b, test, by);
    }

    return by;
#else
    ASM_invert_in_finite_field(b, m);
    return b;
#endif
}

#if 0
int invert_in_finite_field(int b, int modulus)
{
#if 1
    /* We start with n=1 */

    int xn_1 = modulus;  /* x_n-1 = x[0] = a */
    int xn = b;          /* x_n = x[1] = b */
    int bn_1 = 0;        /* b_n-1 = b[0] = 0 */
    int bn = 1;          /* b_n = b[1] = 1 */
    int bnn;

#if 0
    int test = b;
    ASM_invert_in_finite_field(test, modulus);
#else
    int test = invert_in_finite_field_v2(b, modulus);
#endif

    while (xn != 0) {

	int q = xn_1/xn;
	int r = xn_1%xn;

	bnn=bn_1-q*bn;   /* b[n+1] = b[n-1] - q_n * b[n] */

	bn_1=bn;         /* b[n-1] = b[n] */
	bn=bnn;          /* b[n] = b[n+1] */

	xn_1=xn;         /* x[n-1] = x[n] */
	xn=r;            /* x[n] = x[n+1] */
    }

    /* Since xn = x[n] is zero, that means x[n-1] is the gcd (1), and b[n-1] is our inverse.
     *
     * We may, however, have to adjust it to be within the range of our modulo field
     */

    bn_1 = bn_1 % modulus;
    if (bn_1 < 0) bn_1 += modulus;

    if (bn_1 != test) {
	fprintf(stderr, "%d: assembly inversion (%d) didn't match C code (%d)\n", b, test, bn_1);
    }

    if (xn_1 != 1) {
	fprintf(stderr, "GCD not 1 in invert_in_finite_field; was modulus prime?!\n");
    }
    if (bn_1 == 0) {
	fprintf(stderr, "inverse 0 in invert_in_finite_field; was modulus prime?!\n");
    }
    return bn_1;
#else
    ASM_invert_in_finite_field(b, modulus);
    return b;
#endif
}
#endif

int eight_way_white_king_position_to_index(local_position_t *pos)
{
    int white_king = pos->piece_position[WHITE_KING];
    static int index[4][4] = {{ 6, -1, -1, -1},
			      { 0,  7, -1, -1},
			      { 1,  3,  6, -1},
			      { 2,  4,  5,  7}};

    return index[COL(white_king)][ROW(white_king)];
}

int eight_way_white_king_index_to_position(int index)
{
    if (index <= 2) return index + 1;
    else if (index <= 4) return index + 7;
    else if (index == 5) return 19;
    else if (index == 6) return 0;
    else return 9;
}

int eight_way_black_king_position_to_index(local_position_t *pos)
{
    int white_king = pos->piece_position[WHITE_KING];
    int black_king = pos->piece_position[BLACK_KING];

    if ((ROW(white_king) == COL(white_king)) && (ROW(white_king) >= 2)) {
	return diagonal_reflection(black_king);
    } else {
	return black_king;
    }
}

/* "Naive" index.  Just assigns a number from 0 to 63 to each square on the board and
 * multiplies them together for the various pieces.  Simple and fast.
 */

index_t local_position_to_naive_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;

    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->semilegal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index |= COL(pos->en_passant_square) << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else if ((piece == WHITE_KING) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == WHITE_KING) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else {
	    index |= pos->piece_position[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	}
	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);

    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean naive_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square;

	if ((tb->symmetry == 2) && (piece == WHITE_KING)) {
	    square = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == WHITE_KING)) {
	    square = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else {
	    square = index & 63;
	    index >>= 6;
	}

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which positions are legal and which are
	 * not.
	 */

	if (!(tb->semilegal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Naive2" index.  Assigns a number from 0 to 63 to each square on the board and multiplies them
 * together for the various pieces.  Differs from "naive" in its handling of multiple identical
 * pieces, which it stores as a base and an offset, thus saving a single bit.  Currently, only
 * pairs of identical pieces are correctly handled.
 */

index_t local_position_to_naive2_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;
    uint8 vals[MAX_PIECES];

    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->semilegal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = COL(pos->en_passant_square);
	} else {
	    vals[piece] = pos->piece_position[piece];
	}
	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);
    }

    /* What's all this?
     *
     * The idea is to encode two identical pieces using one less bit than needed for encoding them
     * separately, because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (tb->next_identical_piece[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_identical_piece[piece]])
		 && (vals[piece] + 32 < vals[tb->next_identical_piece[piece]]))
		|| ((vals[tb->next_identical_piece[piece]] < vals[piece])
		    && (vals[tb->next_identical_piece[piece]] + 32 >= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_identical_piece[piece]];
		vals[tb->next_identical_piece[piece]] = val;
	    }
	}

	if ((piece == WHITE_KING) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == WHITE_KING) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if (tb->last_identical_piece[piece] == -1) {
	    index |= vals[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else {
	    if (vals[piece] > vals[tb->last_identical_piece[piece]]) {
		index |= (vals[piece] - vals[tb->last_identical_piece[piece]] - 1) << shift_count;
	    } else {
		index |= (64 + vals[piece] - vals[tb->last_identical_piece[piece]] - 1) << shift_count;
	    }
	    shift_count += 5; /* the whole point of "naive2" */
	}
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

    return index;
}

boolean naive2_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8 vals[MAX_PIECES];

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	if ((tb->symmetry == 2) && (piece == WHITE_KING)) {
	    vals[piece] = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == WHITE_KING)) {
	    vals[piece] = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else if (tb->last_identical_piece[piece] == -1) {
	    vals[piece] = index & 63;
	    index >>= 6;
	} else {
	    vals[piece] = (vals[tb->last_identical_piece[piece]] + (index & 31) + 1) % 64;
	    index >>= 5;

	    if (vals[piece] < vals[tb->last_identical_piece[piece]]) {
		unsigned char val;

		/* One of the important tasks of any index_to_local_position() function is to return
		 * false on all but one of the indices that correspond to identical positions.
		 * Here, that can only happen when the two identical pieces are exactly 32 squares
		 * apart, which can be encoded using either piece first.  In this case, we toss out
		 * the index with the larger of the two squares encoded as the base value, and make
		 * sure that the "<" and the ">=" match up just right in the previous function.
		 */

		if (vals[tb->last_identical_piece[piece]] - vals[piece] == 32) return 0;

		val = vals[piece];
		vals[piece] = vals[tb->last_identical_piece[piece]];
		vals[tb->last_identical_piece[piece]] = val;
	    }
	}

    }

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square = vals[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which positions are legal and which are
	 * not.
	 */

	if (!(tb->semilegal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "XOR" index.  Assigns a number from 0 to 63 to each square on the board and xor's them together
 * for the various pieces.  Ensures that moving a single piece will result in large strides in the
 * index.
 */

index_t local_position_to_xor_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;
    int val = 0;
    int val1 = 0;
    int val2 = 0;
    int val3 = 0;

    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
    /* for (piece = tb->num_pieces - 1; piece >= 0; piece--) { */

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->semilegal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    val = COL(pos->en_passant_square);
	} else {
	    val = pos->piece_position[piece];
	}
	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);

#if 0
	index |= (val^val1^val2) << shift_count;
	val2 = val1;
	val1 = byte_transform_64[val];
#else
#if 1
	if (piece == tb->num_pieces - 1) {
	    index |= (val^val3) << shift_count;
	} else if (piece == tb->num_pieces - 2) {
	    index |= (val^val2) << shift_count;
	} else if (piece == tb->num_pieces - 3) {
	    index |= (val^val1) << shift_count;
	} else {
	    index |= val << shift_count;
	}
#else
	if (piece == 0) {
	    index |= (val^val3) << shift_count;
	} else if (piece == 1) {
	    index |= (val^val2) << shift_count;
	} else if (piece == 2) {
	    index |= (val^val1) << shift_count;
	} else {
	    index |= val << shift_count;
	}
#endif
	val1 ^= byte_transform_64[val];
	val2 ^= byte_transform_64b[val];
	val3 ^= byte_transform_64c[val];
#endif

	shift_count += 6;  /* because 2^6=64 */
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean xor_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    int val1 = 0;
    int val2 = 0;
    int val3 = 0;
    int square;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {
    /* for (piece = tb->num_pieces - 1; piece >= 0; piece--) { */

#if 0
	square = (index & 63) ^ val1 ^ val2;
	val2 = val1;
	val1 = byte_transform_64[square];
#else
#if 1
	if (piece == tb->num_pieces - 1) {
	    square = (index & 63) ^ val3;
	} else if (piece == tb->num_pieces - 2) {
	    square = (index & 63) ^ val2;
	} else if (piece == tb->num_pieces - 3) {
	    square = (index & 63) ^ val1;
	} else {
	    square = (index & 63);
	}
#else
	if (piece == 0) {
	    square = (index & 63) ^ val3;
	} else if (piece == 1) {
	    square = (index & 63) ^ val2;
	} else if (piece == 2) {
	    square = (index & 63) ^ val1;
	} else {
	    square = (index & 63);
	}
#endif
	val1 ^= byte_transform_64[square];
	val2 ^= byte_transform_64b[square];
	val3 ^= byte_transform_64c[square];
#endif

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which positions are legal and which are
	 * not.
	 */

	if (!(tb->semilegal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
	index >>= 6;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Simple" index.  Like naive, but only assigns numbers to squares that are legal for a particular
 * piece.  Slower to compute than naive, but more compact for tablebases with lots of movement
 * restrictions on the pieces.
 */

index_t local_position_to_simple_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;

    index = 0;
    pos->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	index *= tb->total_legal_piece_positions[piece];

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->semilegal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index += tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    index += tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}

	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

    /* We've still got code that assumes flipping the index's LSB flip side-to-move */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean simple_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = tb->simple_piece_positions[piece][index % tb->total_legal_piece_positions[piece]];
	index /= tb->total_legal_piece_positions[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* This should never happen. */

	if (!(tb->semilegal_squares[piece] & BITVECTOR(square))) {
	    fprintf(stderr, "Illegal piece position in simple_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }

    if (index != 0) {
	fprintf (stderr, "index != 0 at end of simple_index_to_local_position!\n");  /* BREAKPOINT */
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "compact" index
 *
 */

index_t local_position_to_compact_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;
    uint8 vals[MAX_PIECES];

    index = 0;
    pos->board_vector = 0;

    for (piece = 2; piece < tb->num_pieces; piece ++) {

	if ((pos->piece_position[piece] < 0) || (pos->piece_position[piece] > 63)
	    || !(tb->semilegal_squares[piece] & BITVECTOR(pos->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
#if 0
	    fprintf(stderr, "Bad piece position in local_position_to_index()\n");
#endif
	    return -1;
	}

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    vals[piece] = tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}

	if (pos->board_vector & BITVECTOR(pos->piece_position[piece])) return -1;
	pos->board_vector |= BITVECTOR(pos->piece_position[piece]);
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (pos->en_passant_square != -1) {
	if (pos->board_vector & BITVECTOR(pos->en_passant_square)) return -1;
	if (pos->side_to_move == WHITE) {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square + 8)) return -1;
	} else {
	    if (pos->board_vector & BITVECTOR(pos->en_passant_square - 8)) return -1;
	}
    }

    /* Compute the index.
     *
     * We encode two identical pieces using one less bit than needed for encoding them separately,
     * because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    index = tb->compact_king_indices[pos->piece_position[WHITE_KING]][pos->piece_position[BLACK_KING]];

    for (piece = 2; piece < tb->num_pieces; piece ++) {

	if (tb->next_identical_piece[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_identical_piece[piece]])
		 && (vals[piece] + tb->total_legal_piece_positions[piece]/2
		     < vals[tb->next_identical_piece[piece]]))
		|| ((vals[tb->next_identical_piece[piece]] < vals[piece])
		    && (vals[tb->next_identical_piece[piece]] + tb->total_legal_piece_positions[piece]/2
			>= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_identical_piece[piece]];
		vals[tb->next_identical_piece[piece]] = val;
	    }
	}

	if (tb->last_identical_piece[piece] == -1) {
	    index *= tb->total_legal_piece_positions[piece];
	    index += vals[piece];
	} else {
	    index *= tb->total_legal_piece_positions[piece] / 2;

	    if (vals[piece] > vals[tb->last_identical_piece[piece]]) {
		index += (vals[piece] - vals[tb->last_identical_piece[piece]] - 1);
	    } else {
		index += (tb->total_legal_piece_positions[piece] + vals[piece] - vals[tb->last_identical_piece[piece]] - 1);
	    }
	}
    }

    /* We've still got code that assumes flipping the index's LSB flip side-to-move.
     *
     * Actually, we don't anymore, but I want to put it back because it's more efficient.
     */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

#if 0
    /* Possibly a quicker check for position legality that all that en passant stuff */
    /* The problem is that the entries array might not be valid */

    if (tb->entries[index].movecnt == ILLEGAL_POSITION) return -1;
#endif

    return index;
}

boolean compact_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8 vals[MAX_PIECES];

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    for (piece = tb->num_pieces - 1; piece >= 2; piece --) {

	if (tb->last_identical_piece[piece] == -1) {
	    vals[piece] = index % tb->total_legal_piece_positions[piece];
	    index /= tb->total_legal_piece_positions[piece];
	} else {
	    vals[piece] = index % (tb->total_legal_piece_positions[piece]/2);
	    index /= tb->total_legal_piece_positions[piece]/2;
	}
    }

    for (piece = tb->num_pieces - 1; piece >= 2; piece --) {

	int square;

	if (tb->last_identical_piece[piece] != -1) {

	    vals[piece] += vals[tb->last_identical_piece[piece]] + 1;
	    vals[piece] %= tb->total_legal_piece_positions[piece];

	    /* One of the important tasks of any index_to_local_position() function is to return
	     * false on all but one of the indices that correspond to identical positions.  Here,
	     * that can only happen when the two identical pieces are exactly half their total legal
	     * piece positions squares apart, which can be encoded using either piece first.  In
	     * this case, we toss out the index with the larger of the two squares encoded as the
	     * base value, and make sure that the "<" and the ">=" match up just right in the
	     * previous function.
	     */

	    if (vals[tb->last_identical_piece[piece]] - vals[piece]
		== tb->total_legal_piece_positions[piece]/2) return 0;

	    if (vals[piece] < vals[tb->last_identical_piece[piece]]) {
		uint8 val = vals[piece];
		vals[piece] = vals[tb->last_identical_piece[piece]];
		vals[tb->last_identical_piece[piece]] = val;
	    }
	}

	square = tb->simple_piece_positions[piece][vals[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* This should never happen. */

	if (!(tb->semilegal_squares[piece] & BITVECTOR(square))) {
	    fprintf(stderr, "Illegal piece position in simple_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    p->piece_position[WHITE_KING] = tb->compact_white_king_positions[index];
    p->piece_position[BLACK_KING] = tb->compact_black_king_positions[index];
    if (p->board_vector & BITVECTOR(p->piece_position[WHITE_KING])) return 0;
    if (p->board_vector & BITVECTOR(p->piece_position[BLACK_KING])) return 0;
    p->board_vector |= BITVECTOR(p->piece_position[WHITE_KING]);
    p->board_vector |= BITVECTOR(p->piece_position[BLACK_KING]);
    if (p->side_to_move == WHITE)
	p->PTM_vector |= BITVECTOR(p->piece_position[WHITE_KING]);
    else
	p->PTM_vector |= BITVECTOR(p->piece_position[BLACK_KING]);
    index /= tb->total_legal_compact_king_positions;

    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }

    if (index != 0) {
	fprintf (stderr, "index != 0 at end of compact_index_to_local_position!\n");  /* BREAKPOINT */
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* Normalization - normalize_position() and denormalize_position()
 *
 * Not all positions are created equal.  For example, interchanging two identical pieces doesn't
 * change the position at all, so a position with rook #1 on e4 and rook #2 on g6 is the same as one
 * with rook #1 on g6 and rook #2 on e4.  When converting to an index, we deal with this by sorting
 * identical pieces so the piece on the lowest numbered square always appears first in the position.
 *
 * But this creates problems when trying to move a piece.  Consider for example, the two rooks.  If
 * we now being moving rook #1 along the e file, it moves to e5, then e6, then e7.  Now, at e7, it
 * has become the rook on the higher numbered square, so the pieces have just "flipped" in the
 * position structure!  Additionally, if we have symmetry involved, then which piece is on the
 * higher numbered square can depend on the reflections required to get the kings to their
 * restricted areas.
 *
 * And we can't simply hide all of this in the guts of the position-to-index functions, because we
 * track futuremoves.  Figuring out "which one" of an identical pair of pieces got captured is
 * critical to figuring out which bit in the futuremoves vector corresponds to this move.
 *
 * So, we deal with this using "normalization".  We call normalize_position() to apply all the
 * reflection and sorting needed to get the position to a point where it can be directly converted
 * to an index.  We record these transformations using the 'reflection' variable and an array of
 * permutations in the position structure, so we can put everything back with
 * denormalize_position().
 *
 * Oh, and we can look into the permutation array to figure out which piece has been swapped where,
 * so we can figure out futuremove bit vectors accordingly.  So the way we move a rook, like in the
 * example above, is to move it e5, normalize, back prop, denormalize, then move it to e6,
 * normalize, back prop, denormalize, move it to e7, etc.
 *
 * We also recompute the board vector in both functions, because the reflections can change it
 * around.
 */

void normalize_position(tablebase_t *tb, local_position_t *position)
{
    int piece, piece2;

    /* Reflect the pieces around to get the white king where we want him for symmetry.
     *
     * 2-way symmetry: white king always on left side of board
     *
     * 4-way symmetry: white king always in lower left quarter of board
     *
     * 8-way symmetry: white king always in a1-a4-d4 triangle, and if white king is on a1-d4
     * diagonal, then black king is on or below a1-h8 diagonal
     */

    position->reflection = 0;

    if (tb->symmetry >= 2) {
	if (COL(position->piece_position[WHITE_KING]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = horizontal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 4;
	}
    }

    if (tb->symmetry >= 4) {
	if (ROW(position->piece_position[WHITE_KING]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = vertical_reflection(position->en_passant_square);
	    }
	    position->reflection |= 2;
	}
    }

    if (tb->symmetry == 8) {
	if (ROW(position->piece_position[WHITE_KING]) > COL(position->piece_position[WHITE_KING])) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = diagonal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 1;
	}
#if 1
	if (ROW(position->piece_position[WHITE_KING]) == COL(position->piece_position[WHITE_KING])) {
	    if (ROW(position->piece_position[BLACK_KING]) > COL(position->piece_position[BLACK_KING])) {
		for (piece = 0; piece < tb->num_pieces; piece ++) {
		    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
		}
		position->reflection |= 1;
	    }
	}
#endif
    }

    /* Sort any identical pieces so that the lowest square number always comes first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (position->piece_position[piece2]
		   < position->piece_position[tb->last_identical_piece[piece2]])) {
	    int square = position->piece_position[piece2];
	    int permuted_piece = position->permuted_piece[piece2];

	    position->piece_position[piece2] = position->piece_position[tb->last_identical_piece[piece2]];
	    position->piece_position[tb->last_identical_piece[piece2]] = square;

	    position->permuted_piece[piece2] = position->permuted_piece[tb->last_identical_piece[piece2]];
	    position->permuted_piece[tb->last_identical_piece[piece2]] = permuted_piece;

	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }
}

void denormalize_position(tablebase_t *tb, local_position_t *position)
{
    int piece;

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (position->permuted_piece[piece] != piece) {
	    int square = position->piece_position[piece];

	    position->piece_position[piece] = position->piece_position[position->permuted_piece[piece]];
	    position->piece_position[position->permuted_piece[piece]] = square;

	    position->permuted_piece[position->permuted_piece[piece]] = position->permuted_piece[piece];
	    position->permuted_piece[piece] = piece;
	}

	if ((position->reflection & 1) == 1) {
	    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	}
	if ((position->reflection & 2) == 2) {
	    position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	}
	if ((position->reflection & 4) == 4) {
	    position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	}
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }

    if (position->en_passant_square != -1) {
	if ((position->reflection & 1) == 1) {
	    position->en_passant_square = diagonal_reflection(position->en_passant_square);
	}
	if ((position->reflection & 2) == 2) {
	    position->en_passant_square = vertical_reflection(position->en_passant_square);
	}
	if ((position->reflection & 4) == 4) {
	    position->en_passant_square = horizontal_reflection(position->en_passant_square);
	}
    }

    position->reflection = 0;
}

index_t normalized_position_to_index(tablebase_t *tb, local_position_t *position)
{
    index_t index;

#if CHECK_KING_LEGALITY_EARLY
    if (! check_king_legality(position->piece_position[WHITE_KING], position->piece_position[BLACK_KING]))
	return -1;
#endif

    switch (tb->index_type) {
    case NAIVE_INDEX:
	index = local_position_to_naive_index(tb, position);
	break;
    case NAIVE2_INDEX:
	index = local_position_to_naive2_index(tb, position);
	break;
    case XOR_INDEX:
	index = local_position_to_xor_index(tb, position);
	break;
    case SIMPLE_INDEX:
	index = local_position_to_simple_index(tb, position);
	break;
    case COMPACT_INDEX:
	index = local_position_to_compact_index(tb, position);
	break;
    default:
	fprintf(stderr, "Unknown index type in local_position_to_index()\n");  /* BREAKPOINT */
	return -1;
    }

    if ((index != -1) && (index != 0) && (tb->modulus != 0)) {
#if FINITE_FIELD_INVERSION
	index = invert_in_finite_field(index, tb->modulus);
#else
	encode_index(index);
#endif
    }

    /* Multiplicity - number of non-identical positions that this index corresponds to.  We want to
     * update the original position structure that got passed in.
     */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[WHITE_KING]) != COL(position->piece_position[WHITE_KING]))
	    || (ROW(position->piece_position[BLACK_KING]) != COL(position->piece_position[BLACK_KING])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    return index;
}

index_t local_position_to_index(tablebase_t *tb, local_position_t *original)
{
    index_t index;

    /* We don't want to change around the original position, during these next transformations, so
     * we use a copy of it.  We do, however, update the multiplicity in the original structure.
     */

    local_position_t copy = *original;

    normalize_position(tb, &copy);

    index = normalized_position_to_index(tb, &copy);

    original->multiplicity = copy.multiplicity;

    return index;
}

boolean index_to_local_position(tablebase_t *tb, index_t index, int symmetry, local_position_t *position)
{
    int ret;
    int piece, piece2;

    if ((index != 0) && (tb->modulus != 0)) {
#if FINITE_FIELD_INVERSION
	index = invert_in_finite_field(index, tb->modulus);
#else
	decode_index(index);
#endif
    }

    switch (tb->index_type) {
    case NAIVE_INDEX:
	ret = naive_index_to_local_position(tb, index, position);
	break;
    case NAIVE2_INDEX:
	ret = naive2_index_to_local_position(tb, index, position);
	break;
    case XOR_INDEX:
	ret = xor_index_to_local_position(tb, index, position);
	break;
    case SIMPLE_INDEX:
	ret = simple_index_to_local_position(tb, index, position);
	break;
    case COMPACT_INDEX:
	ret = compact_index_to_local_position(tb, index, position);
	break;
    default:
	fprintf(stderr, "Unknown index type in index_to_local_position()\n");  /* BREAKPOINT */
	return 0;
    }

    if (!ret) return 0;

#if CHECK_KING_LEGALITY_EARLY
    if (! check_king_legality(position->piece_position[WHITE_KING], position->piece_position[BLACK_KING]))
	return 0;
#endif

    if ((tb->symmetry == 8)
	&& (ROW(position->piece_position[WHITE_KING]) == COL(position->piece_position[WHITE_KING]))
	&& (ROW(position->piece_position[BLACK_KING]) > COL(position->piece_position[BLACK_KING])))
	return 0;

    /* Multiplicity - number of non-identical positions that this index corresponds to */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[WHITE_KING]) != COL(position->piece_position[WHITE_KING]))
	    || (ROW(position->piece_position[BLACK_KING]) != COL(position->piece_position[BLACK_KING])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    if ((symmetry & 1) == 1) {
	if (position->multiplicity == 1) return 0;

	/* diagonal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = diagonal_reflection(position->en_passant_square);
    }

    if ((symmetry & 2) == 2) {
	/* vertical reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = vertical_reflection(position->en_passant_square);
    }

    if ((symmetry & 4) == 4) {
	/* horizontal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = horizontal_reflection(position->en_passant_square);
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->permuted_piece[piece] = piece;
    }
    position->reflection = 0;

    /* Sort any identical pieces so that the lowest square number always comes first.
     *
     * The various index-to-position routines returned sorted piece arrays, but the various symmetry
     * reflections might have upset this.  Some places, particularly the translate_... routines in
     * futurebase back propagation, depend on the pieces being sorted.
     *
     * Note that we DON'T changed the permuted_piece array here.  That's because permuted_piece is
     * used to track the changes that happen after index-to-position and before position-to-index,
     * NOT the changes that happen internally in index-to-position.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (position->piece_position[piece2]
		   < position->piece_position[tb->last_identical_piece[piece2]])) {
	    int square = position->piece_position[piece2];

	    position->piece_position[piece2] = position->piece_position[tb->last_identical_piece[piece2]];
	    position->piece_position[tb->last_identical_piece[piece2]] = square;

	    piece2 = tb->last_identical_piece[piece2];
	}
    }

#if 0
    /* Maybe should do this here, instead of in the various reflection code above. */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }
#endif

    return 1;
}

/* check_1000_positions(); check_1000_indices() - used just to double check the code above.
 *
 * I don't use check_1000_positions() anymore because it barks if there are identical pieces in a
 * position that come back sorted after being run through a position->index->position conversion.
 */

void check_1000_positions(tablebase_t *tb)
{
    local_position_t position1;
    local_position_t position2;
    index_t index;
    int positions;
    int piece;

    for (positions=0; positions < 1000; positions ++) {

	memset(&position1, 0, sizeof(position1));

	position1.side_to_move = rand() % 2;
	position1.en_passant_square = -1;

    retry:
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    do {
		position1.piece_position[piece] = rand() % 64;
	    } while (! (BITVECTOR(position1.piece_position[piece]) & tb->semilegal_squares[piece]));
	}

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if ((tb->last_identical_piece[piece] != -1) &&
		(position1.piece_position[piece] <=
		 position1.piece_position[tb->last_identical_piece[piece]])) goto retry;
	}

	index = local_position_to_index(tb, &position1);

	if (index != -1) {

	    /* PTM_vector wasn't set in position1, so don't check them now */

	    if (!index_to_local_position(tb, index, 0, &position2)
		|| (position2.PTM_vector = 0, position2.board_vector = 0,
		    memcmp(&position1, &position2, sizeof(position1)))) {
		fprintf(stderr, "Mismatch in check_1000_positions()\n");  /* BREAKPOINT */
	    }
	}
    }
}

void check_1000_indices(tablebase_t *tb)
{
    local_position_t position;
    index_t index;
    index_t index2;
    int positions;

    for (positions=0; positions < 1000; positions ++) {

	index = rand() % (tb->max_index + 1);

	if (index_to_local_position(tb, index, 0, &position)) {
	    index2 = local_position_to_index(tb, &position);
	    if (index != index2) {
		fprintf(stderr, "Mismatch in check_1000_indices()\n");  /* BREAKPOINT */
	    }
	}
    }
}

/***** XML TABLEBASE INTERACTION *****/

/* Parses XML, creates a tablebase structure corresponding to it, and returns it.
 *
 * I use a DTD and validate the XML input, so there's very little error checking here.  The idea is
 * that the validation provides most of the error checks.
 */

/* parse_format()
 *
 * Parse an XML format specification (for a dynamic structure) into a format structure.  A simple
 * XML format looks something like:
 *
 *   <format>
 *      <dtm bits="8"/>
 *   </format>
 *
 * Essentially, this specifies the layout of a C structure at run-time, and we have to jump through
 * all kinds of obscure nonsense to get dynamic structures.  Basically, we end up doing everything
 * with shifts and masks rather than normal structure operations.
 *
 * The XML format can be specified with either explicit or implicit offsets.  Explicit offsets are
 * just that: <dtm bits="8" offset="8"/> specifies an 8-bit field at an 8-bit offset into the
 * structure.  Implicit offsets assign the offset values counting up from zero (like the first
 * example above).  The two can not be mixed in the same format spec.
 *
 * The total size of a format is silently rounded up to a power-of-two byte boundary.  This is done
 * to make sure that the resulting structures can't straddle buffer boundaries.
 */

boolean parse_format(xmlNodePtr formatNode, struct format *format)
{
    xmlNodePtr child;
    int auto_offset = 0;
    int total_bits = 0;
    int power_of_two;

    memset(format, 0, sizeof(struct format));

    for (child = formatNode->children; child != NULL; child = child->next) {
	if (child->type == XML_ELEMENT_NODE) {
	    char * bitstr = (char *) xmlGetProp(child, BAD_CAST "bits");
	    char * offsetstr = (char *) xmlGetProp(child, BAD_CAST "offset");
	    int bits = (bitstr != NULL) ? atoi(bitstr) : 0;
	    int offset = (offsetstr != NULL) ? atoi(offsetstr) : -1;
	    int format_field = find_name_in_array((char *) child->name, format_fields);

	    if (format_field == -1) {
		fprintf(stderr, "Unknown field in format: %s\n", (char *) child->name);
		return 0;
	    }
	    if ((bits == 0)
		&& (format_field != FORMAT_FIELD_IN_CHECK_FLAG) && (format_field != FORMAT_FIELD_FLAG)) {
		fprintf(stderr, "Non-zero 'bits' value must be specified in format field '%s'\n",
			(char *) child->name);
		return 0;
	    }
	    if ((bitstr != NULL) && (bits != 1)
		&& ((format_field == FORMAT_FIELD_IN_CHECK_FLAG) || (format_field == FORMAT_FIELD_FLAG))) {
		fprintf(stderr, "Format fields 'flag' and 'in-check-flag' only accept bits=\"1\"\n");
		return 0;
	    }
	    if ((format_field == FORMAT_FIELD_IN_CHECK_FLAG) || (format_field == FORMAT_FIELD_FLAG)) {
		bits = 1;
	    }

	    if ((offset == -1) && (auto_offset == -1)) {
		fprintf(stderr, "Can't mix explicit and implicit offsets in format\n");
		return 0;
	    }

	    if (offset == -1) {
		offset = auto_offset;
		auto_offset += bits;
	    } else {
		auto_offset = -1;
	    }

	    if ((format_field != FORMAT_FIELD_FUTUREVECTOR) && (offset/32 != (offset+bits-1) / 32)) {
		fprintf(stderr, "Most format fields can't straddle a 32-bit boundary\n");
		return 0;
	    }

	    if (offset/64 != (offset+bits-1) / 64) {
		fprintf(stderr, "Format fields can't straddle a 64-bit boundary\n");
		return 0;
	    }

	    if (offset + bits > total_bits) total_bits = offset + bits;

	    switch (format_field) {
	    case FORMAT_FIELD_DTM:
		format->dtm_bits = bits;
		format->dtm_offset = offset;
		format->dtm_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_MOVECNT:
		format->movecnt_bits = bits;
		format->movecnt_offset = offset;
		format->movecnt_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_IN_CHECK_FLAG:
		format->in_check_flag_offset = offset;
		break;
	    case FORMAT_FIELD_INDEX:
		format->index_bits = bits;
		format->index_offset = offset;
		format->index_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_FUTUREVECTOR:
		format->futurevector_bits = bits;
		format->futurevector_offset = offset;
		format->futurevector_mask = (1LL << bits) - 1;
		break;
	    case FORMAT_FIELD_FLAG:
		format->flag_offset = offset;
		format->flag_type = find_name_in_array((char *) xmlGetProp(child, BAD_CAST "type"),
						       format_flag_types);
		if (format->flag_type == -1) {
		    fprintf(stderr, "'type' is a required property in format field 'flag'\n");
		    return 0;
		}
		break;
	    default:
		fprintf(stderr, "Unknown field in format\n");
		return 0;
	    }
	}
    }

    /* Round up total number of bytes to a power-of-two boundary.  This should probably be a little
     * less dependant on the assumption that MAX_FORMAT_BYTES is no more than 16.
     */

    for (power_of_two = 0; (1 << power_of_two) < total_bits; power_of_two ++);

    if ((1 << power_of_two) != total_bits) {
	fprintf(stderr, "Total bits in format must be a power of two\n");
	return 0;
    }

    format->bits = power_of_two;

    if (total_bits <= 8) {
	format->bytes = 1;
    } else {
	format->bytes = total_bits/8;
    }

    if (format->bytes > MAX_FORMAT_BYTES) {
	fprintf(stderr, "Maximum number of bytes in format exceeded\n");
	return 0;
    }

    return 1;
}

tablebase_t * parse_XML_into_tablebase(xmlDocPtr doc)
{
    tablebase_t *tb;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    xmlNodePtr tablebase;
    xmlNodePtr index_node;
    xmlChar * format;
    xmlChar * index;
    xmlChar * modulus;
    int piece, piece2, square, white_king_square, black_king_square;

    tb = malloc(sizeof(tablebase_t));
    if (tb == NULL) {
	fprintf(stderr, "Can't malloc tablebase\n");
	return NULL;
    }
    memset(tb, 0, sizeof(tablebase_t));

    tb->xml = doc;

    /* Fetch tablebase from XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//tablebase", context);
    tablebase = result->nodesetval->nodeTab[0];
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Some statistics we'll use if this is a futurebase */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//max-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	tb->max_dtm = atoi((char *) xmlNodeGetContent(result->nodesetval->nodeTab[0]));
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//min-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	tb->min_dtm = atoi((char *) xmlNodeGetContent(result->nodesetval->nodeTab[0]));
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Fetch the pieces from the XML */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//piece", context);
    if (xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fprintf(stderr, "No pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr < 2) {
	fprintf(stderr, "Too few pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr > MAX_PIECES) {
	fprintf(stderr, "Too many pieces!\n");
	return NULL;
    } else {

	tb->num_pieces = result->nodesetval->nodeNr;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    xmlChar * color;
	    xmlChar * type;
	    xmlChar * location;
	    color = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "color");
	    type = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "type");
	    location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");
	    tb->piece_color[piece] = find_name_in_array((char *) color, colors);
	    tb->piece_type[piece] = find_name_in_array((char *) type, piece_name);

	    if (location == NULL) {
		if (tb->piece_type[piece] == PAWN) {
		    tb->semilegal_squares[piece] = LEGAL_PAWN_BITVECTOR;
		} else {
		    tb->semilegal_squares[piece] = allones_bitvector;
		}
	    } else {
		int j = 0;
		tb->semilegal_squares[piece] = 0;
		while ((location[j] >= 'a') && (location[j] <= 'h')
		       && (location[j+1] >= '1') && (location[j+1] <= '8')) {
		    tb->semilegal_squares[piece]
			|= BITVECTOR(rowcol2square(location[j+1] - '1', location[j] - 'a'));
		    j += 2;
		    while (location[j] == ' ') j ++;
		}
		if (location[j] != '\0') {
		    fprintf(stderr, "Illegal piece location (%s)\n", location);
		    return NULL;
		}
	    }

	    if ((tb->piece_color[piece] == -1) || (tb->piece_type[piece] == -1)) {
		fprintf(stderr, "Illegal piece color (%s) or type (%s)\n", color, type);
		return NULL;
	    }

	    /* Now we need to figure out if there are any other pieces identical to this one,
	     * because if so, exchanging the two pieces would not change the position, and that has
	     * to be taken into account in the index code.  Move restrictions on the pieces
	     * complicate this, unless they are either identical or completely non-overlapping.
	     */

	    tb->last_identical_piece[piece] = -1;
	    tb->next_identical_piece[piece] = -1;

	    for (piece2 = piece - 1; piece2 >= 0; piece2 --) {
		if ((tb->piece_color[piece2] == tb->piece_color[piece])
		    && (tb->piece_type[piece2] == tb->piece_type[piece])) {
		    if (tb->semilegal_squares[piece2] == tb->semilegal_squares[piece]) {
			tb->last_identical_piece[piece] = piece2;
			tb->next_identical_piece[piece2] = piece;
			break;
		    } else if (tb->semilegal_squares[piece2] & tb->semilegal_squares[piece]) {
			fprintf(stderr, "Identical pieces with overlapping non-identical move restrictions not allowed\n");
			return NULL;
		    }
		}
	    }

	    if (color != NULL) xmlFree(color);
	    if (type != NULL) xmlFree(type);
	    if (location != NULL) xmlFree(location);
	}
    }

    if ((tb->piece_color[WHITE_KING] != WHITE) || (tb->piece_type[WHITE_KING] != KING)
	|| (tb->piece_color[BLACK_KING] != BLACK) || (tb->piece_type[BLACK_KING] != KING)) {
	fprintf(stderr, "Kings aren't where they need to be in piece list!\n");
	return NULL;
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* get the format */

    format = xmlGetProp(tablebase, BAD_CAST "format");
    if (format != NULL) {
	switch (find_name_in_array((char *) format, formats)) {
	case FORMAT_ONE_BYTE_DTM:
	    tb->format = one_byte_dtm_format;
	    break;
	default:
	    fprintf(stderr, "Unknown tablebase format '%s'\n", format);
	    return NULL;
	}
    } else {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//format", context);
	if (result->nodesetval->nodeNr == 1) {
	    if (! parse_format(result->nodesetval->nodeTab[0], &tb->format)) return NULL;
	} else {
	    xmlNewProp(tablebase, BAD_CAST "format", BAD_CAST "one-byte-dtm");
	    tb->format = one_byte_dtm_format;
	    fprintf(stderr, "Format not expressly specified; assuming ONE-BYTE-DTM\n");
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }

    /* Fetch the index type */

    index = xmlGetProp(tablebase, BAD_CAST "index");
    index_node = tablebase;  /* XXX here for backwards compatibility */
    if (index == NULL) {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//index", context);
	if (result->nodesetval->nodeNr == 1) {
	    index_node = result->nodesetval->nodeTab[0];
	    index = xmlGetProp(index_node, BAD_CAST "type");
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }
    if (index == NULL) {
	tb->index_type = NAIVE_INDEX;
	xmlNewProp(tablebase, BAD_CAST "index", BAD_CAST "naive");
	fprintf(stderr, "Index type not expressly specified; assuming NAIVE\n");
    } else {
	tb->index_type = find_name_in_array((char *) index, index_types);
	if (tb->index_type == -1) {
	    fprintf(stderr, "Unknown tablebase index type '%s'\n", index);
	    return NULL;
	}
    }

    /* Extract index symmetry (if it was specified) */

    if (xmlGetProp(index_node, BAD_CAST "symmetry") != NULL) {
	tb->symmetry = atoi((char *) xmlGetProp(index_node, BAD_CAST "symmetry"));
	if ((tb->symmetry != 1) && (tb->symmetry != 2) && (tb->symmetry != 4) && (tb->symmetry != 8)) {
	    fprintf(stderr, "Bad index symmetry %d\n", tb->symmetry);
	    return NULL;
	}
    } else {
	tb->symmetry = 1;
    }

    /* Check piece specification to make sure it matches symmetry
     *
     * XXX Some piece restrictions should be allowed for, so long as the restrictions themselves are
     * symmetric.  For example, a rook restricted to a single row is consistent with 2-way symmetry.
     */

    if ((tb->symmetry == 8) && ((tb->index_type == NAIVE_INDEX) || (tb->index_type == NAIVE2_INDEX))) {
	fprintf(stderr, "8-way symmetry incompatible with naive/naive2 index types\n");
	return NULL;
    }

    if ((tb->symmetry > 1) && (tb->index_type == XOR_INDEX)) {
	fprintf(stderr, "Symmetry doesn't work with xor index type\n");
	return NULL;
    }

    if (tb->symmetry >= 4) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (tb->piece_type[piece] == PAWN) {
		fprintf(stderr, "Pawns not allowed with 4/8-way symmetric indices\n");
		return NULL;
	    }
	}
    }

    if (tb->symmetry > 1) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (((tb->piece_type[piece] != PAWN) && (tb->semilegal_squares[piece] != allones_bitvector))
		|| ((tb->piece_type[piece] == PAWN) && (tb->semilegal_squares[piece] != LEGAL_PAWN_BITVECTOR))) {
		fprintf(stderr, "Piece restrictions not allowed with symmetric indices\n");
		return NULL;
	    }
#if 0
	    if (tb->next_identical_piece[piece] != -1) {
		fprintf(stderr, "Can't handle identical pieces with symmetric indices (yet)\n");
		return NULL;
	    }
#endif
	}
    }

    /* Compute tb->max_index (but see next section of code where it might be modified) */

    switch (tb->index_type) {
    case NAIVE_INDEX:

	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index = (2<<(6*tb->num_pieces)) - 1;
	    break;
	case 2:
	    tb->max_index = (2<<(6*tb->num_pieces - 1)) - 1;
	    break;
	case 4:
	    tb->max_index = (2<<(6*tb->num_pieces - 2)) - 1;
	    break;
	}
	break;

    case NAIVE2_INDEX:

	tb->max_index = 2;

	/* do the white king "by hand" */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index <<= 6;
	    break;
	case 2:
	    tb->max_index <<= 5;
	    break;
	case 4:
	    tb->max_index <<= 4;
	    break;
	}

	/* now do everything else */
	for (piece = 1; piece < tb->num_pieces; piece ++) {

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fprintf(stderr, "Can't have more than two identical pieces with 'naive2' index (yet)\n");
		return NULL;
	    }

	    if (tb->last_identical_piece[piece] == -1) tb->max_index <<= 6;
	    else tb->max_index <<=5;
	}
	tb->max_index --;

	break;

    case XOR_INDEX:

	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	tb->max_index = (2<<(6*tb->num_pieces)) - 1;
	break;

    case SIMPLE_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (square = 0; square < 64; square ++) {
		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == WHITE_KING) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == WHITE_KING) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == WHITE_KING) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->simple_piece_indices[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    tb->max_index *= tb->total_legal_piece_positions[piece];
	}

	tb->max_index --;
	break;

    case COMPACT_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		/* if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue; */
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;
#if CHECK_KING_LEGALITY_EARLY
		if (! check_king_legality(white_king_square, black_king_square)) continue;
#endif
		tb->compact_white_king_positions[tb->total_legal_compact_king_positions] = white_king_square;
		tb->compact_black_king_positions[tb->total_legal_compact_king_positions] = black_king_square;
		tb->compact_king_indices[white_king_square][black_king_square] = tb->total_legal_compact_king_positions;
		tb->total_legal_compact_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_compact_king_positions;

	for (piece = 2; piece < tb->num_pieces; piece ++) {

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fprintf(stderr, "Can't have more than two identical pieces with 'compact' index (yet)\n");
		return NULL;
	    }

	    for (square = 0; square < 64; square ++) {
		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == WHITE_KING) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == WHITE_KING) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == WHITE_KING) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->simple_piece_indices[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    if (tb->last_identical_piece[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;
    }

    /* See if an index modulus was specified for inversion in a finite field */

    modulus = xmlGetProp(tablebase, BAD_CAST "modulus");
    if (modulus != NULL) {
	tb->modulus = strtoll((const char *) modulus, NULL, 0);
	if (tb->modulus <= tb->max_index) {
	    fprintf(stderr, "modulus %d less than max_index %d\n", tb->modulus, tb->max_index);
	    return NULL;
	}
#if FINITE_FIELD_INVERSION
	/* XXX took this out for encode/decode index */
	tb->max_index = tb->modulus - 1;
#endif
    }

    /* Fetch the move restrictions */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//move-restriction", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	int i;
	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * color_str;
	    xmlChar * type_str;
	    int color;
	    int type;

	    color_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "color");
	    type_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "type");

	    color = find_name_in_array((char *) color_str, colors);
	    type = find_name_in_array((char *) type_str, restriction_types);
	    if ((color == -1) || (type == -1)) {
		fprintf(stderr, "Illegal move restriction\n");
		return NULL;
	    } else {
		if ((tb->move_restrictions[color] > 0) && (tb->move_restrictions[color] != type)) {
		    fprintf(stderr, "Incompatible move restrictions\n");
		    return NULL;
		} else {
		    tb->move_restrictions[color] = type;
		}
	    }
	}
    }

    xmlXPathFreeContext(context);

    return tb;
}

/* Parses an XML control file.
 */

tablebase_t * parse_XML_control_file(char *filename)
{
    xmlParserCtxtPtr ctxt; /* the parser context */
    xmlDocPtr doc;
    tablebase_t *tb;

    /* create a parser context */
    ctxt = xmlNewParserCtxt();
    if (ctxt == NULL) {
        fprintf(stderr, "Failed to allocate parser context\n");
	return NULL;
    }
    /* parse the file, activating the DTD validation option */
    doc = xmlCtxtReadFile(ctxt, filename, NULL, XML_PARSE_DTDVALID);

    /* check if parsing suceeded */
    if (doc == NULL) {
	fprintf(stderr, "'%s' failed XML read\n", filename);
	return NULL;
    } else {
	/* check if validation suceeded */
        if (ctxt->valid == 0) {
	    fprintf(stderr, "WARNING: '%s' failed XML validatation\n", filename);
	}
    }
    /* free up the parser context */
    xmlFreeParserCtxt(ctxt);

    tb = parse_XML_into_tablebase(doc);
    if (tb == NULL) return NULL;

    /* We don't free the XML doc because the tablebase struct contains a pointer to it */

    return tb;
}

/* preload_futurebase_from_file() reads a tablebase's XML header and parses it, leaving the file
 * open and ready to begin reading the first entry with fetch_next_DTM_from_disk().
 */

tablebase_t * preload_futurebase_from_file(char *filename)
{
    gzFile file;
    int xml_size;
    char fileptr[16384];	/* XXX hardwired max size of XML */
    xmlDocPtr doc;
    tablebase_t *tb = NULL;
    xmlNodePtr tablebase;
    xmlChar * offsetstr;

    file = gzopen(filename, "r");

    if (file == NULL) {

	fprintf(stderr, "Can't gzopen file '%s'\n", filename);

    } else {

	for (xml_size = 0; (fileptr[xml_size] = gzgetc(file)) != '\0'; xml_size ++) ;

	doc = xmlReadMemory(fileptr, xml_size, NULL, NULL, 0);

	tb = parse_XML_into_tablebase(doc);

	tb->file = file;

	tablebase = xmlDocGetRootElement(doc);

	offsetstr = xmlGetProp(tablebase, BAD_CAST "offset");
	tb->offset = strtol((const char *) offsetstr, NULL, 0);

	gzseek(file, tb->offset, SEEK_SET);
    }

    return tb;
}

void unload_futurebase(tablebase_t *tb)
{
    if (tb->xml != NULL) xmlFreeDoc(tb->xml);
    tb->xml = NULL;
    if (tb->file != NULL) gzclose(tb->file);
    tb->file = NULL;
}

/* Given a tablebase, change its XML structure to reflect the fact that the tablebase has now
 * actually been built.  Adds a dummy "offset" property to the root element which will be adjusted
 * later to reflect the actual byte offset of the tablebase entries, and a "generated-by" block
 * indicating the program, time, and host that generated the data.
 */

xmlDocPtr finalize_XML_header(tablebase_t *tb, char *options)
{
    xmlNodePtr tablebase, node;
    char hostname[256];
    struct hostent *he;
    struct rusage rusage;
    char strbuf[256];
    int passnum;

    tablebase = xmlDocGetRootElement(tb->xml);

    xmlNewProp(tablebase, BAD_CAST "offset", BAD_CAST "0x1000");

    xmlNodeAddContent(tablebase, BAD_CAST "   ");
    node = xmlNewChild(tablebase, NULL, BAD_CAST "tablebase-statistics", NULL);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%d", tb->max_index + 1);
    xmlNewChild(node, NULL, BAD_CAST "indices", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_legal_positions);
    xmlNewChild(node, NULL, BAD_CAST "legal-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_PNTM_mated_positions);
    xmlNewChild(node, NULL, BAD_CAST "PNTM-mated-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_stalemate_positions);
    xmlNewChild(node, NULL, BAD_CAST "stalemate-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", player_wins[0]);
    xmlNewChild(node, NULL, BAD_CAST "white-wins-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", player_wins[1]);
    xmlNewChild(node, NULL, BAD_CAST "black-wins-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_moves);
    xmlNewChild(node, NULL, BAD_CAST "forward-moves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_futuremoves);
    xmlNewChild(node, NULL, BAD_CAST "futuremoves", BAD_CAST strbuf);
#if 0
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_backproped_moves);
    xmlNewChild(node, NULL, BAD_CAST "backproped-moves", BAD_CAST strbuf);
#endif
#if 0
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_passes);
    xmlNewChild(node, NULL, BAD_CAST "passes", BAD_CAST strbuf);
#endif
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%d", max_dtm);
    xmlNewChild(node, NULL, BAD_CAST "max-dtm", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%d", min_dtm);
    xmlNewChild(node, NULL, BAD_CAST "min-dtm", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n   ");

    xmlNodeAddContent(tablebase, BAD_CAST "\n   ");

    node = xmlNewChild(tablebase, NULL, BAD_CAST "generation-statistics", NULL);

    gethostname(hostname, sizeof(hostname));
    he = gethostbyname(hostname);

    getrusage(RUSAGE_SELF, &rusage);

    gettimeofday(&program_end_time, NULL);

    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewChild(node, NULL, BAD_CAST "host", BAD_CAST he->h_name);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewChild(node, NULL, BAD_CAST "program", BAD_CAST "Hoffman $Revision: 1.267 $ $Locker: baccala $");
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewChild(node, NULL, BAD_CAST "args", BAD_CAST options);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&program_start_time.tv_sec));
    xmlNewChild(node, NULL, BAD_CAST "start-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&program_end_time.tv_sec));
    xmlNewChild(node, NULL, BAD_CAST "completion-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprint_timeval(strbuf, &rusage.ru_utime);
    xmlNewChild(node, NULL, BAD_CAST "user-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprint_timeval(strbuf, &rusage.ru_stime);
    xmlNewChild(node, NULL, BAD_CAST "system-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    /* Note that we modified program_end_time here to compute the real time used by the program */
    subtract_timeval(&program_end_time, &program_start_time);
    sprint_timeval(strbuf, &program_end_time);
    xmlNewChild(node, NULL, BAD_CAST "real-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%ld", rusage.ru_majflt);
    xmlNewChild(node, NULL, BAD_CAST "page-faults", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%ld", rusage.ru_minflt);
    xmlNewChild(node, NULL, BAD_CAST "page-reclaims", BAD_CAST strbuf);

    if (num_propentries > 0) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", entries_write_stalls);
	xmlNewChild(node, NULL, BAD_CAST "entries-write-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", entries_read_stalls);
	xmlNewChild(node, NULL, BAD_CAST "entries-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", proptable_read_stalls);
	xmlNewChild(node, NULL, BAD_CAST "proptable-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", proptable_writes);
	xmlNewChild(node, NULL, BAD_CAST "proptable-writes", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &entries_write_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "entries-write-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &entries_read_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "entries-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_read_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_write_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-write-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_preload_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-preload-time", BAD_CAST strbuf);
    }

    for (passnum = 0; passnum < total_passes; passnum ++) {
	xmlNodePtr passNode;

	xmlNodeAddContent(node, BAD_CAST "\n      ");
	passNode = xmlNewChild(node, NULL, BAD_CAST "pass", NULL);

	xmlNewProp(passNode, BAD_CAST "type", BAD_CAST pass_type[passnum]);

	subtract_timeval(&pass_end_times[passnum], &pass_start_times[passnum]);
	sprint_timeval(strbuf, &pass_end_times[passnum]);
	xmlNewProp(passNode, BAD_CAST "real-time", BAD_CAST strbuf);

	if (! strcmp(pass_type[passnum], "intratable")) {
	    sprintf(strbuf, "%d", pass_target_dtms[passnum]);
	    xmlNewProp(passNode, BAD_CAST "dtm", BAD_CAST strbuf);
	    sprintf(strbuf, "%d", positions_finalized[passnum]);
	    xmlNewProp(passNode, BAD_CAST "positions-finalized", BAD_CAST strbuf);
	    sprintf(strbuf, "%lld", backproped_moves[passnum]);
	    xmlNewProp(passNode, BAD_CAST "moves-generated", BAD_CAST strbuf);
	}
    }

    xmlNodeAddContent(node, BAD_CAST "\n   ");

    xmlNodeAddContent(tablebase, BAD_CAST "\n");

    return tb->xml;
}


/***** INDICES AND POSITIONS *****/

/* This function could be made a bit faster, but this simpler version is hopefully safer. */

int index_to_side_to_move(tablebase_t *tb, index_t index)
{
    local_position_t position;

    if (! index_to_local_position(tb, index, 0, &position)) return -1;
    else return position.side_to_move;
}

inline void flip_side_to_move_local(local_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

inline void flip_side_to_move_global(global_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

/* invert_colors_of_global_position - just what its name implies
 *
 * We used to use this when propagating from a futurebase, but now it's only use is in the probe
 * code.  It translates a position for a tablebase built for the opposite colors, say a K+R vs K
 * endgame that we now want to probe where the rook is black, not white.  If there are pawns in the
 * game, this function has to reflect the board around a horizontal centerline.
 */

void invert_colors_of_global_position(global_position_t *global)
{
    int squareA;

    for (squareA=0; squareA < NUM_SQUARES/2; squareA++) {
	unsigned char pieceA;
	unsigned char pieceB;
	int squareB = rowcol2square(7-ROW(squareA),COL(squareA));

	pieceA = global->board[squareA];
	pieceB = global->board[squareB];

	if ((pieceA >= 'A') && (pieceA <= 'Z')) {
	    pieceA += 'a' - 'A';
	} else if ((pieceA >= 'a') && (pieceA <= 'z')) {
	    pieceA += 'A' - 'a';
	}

	if ((pieceB >= 'A') && (pieceB <= 'Z')) {
	    pieceB += 'a' - 'A';
	} else if ((pieceB >= 'a') && (pieceB <= 'z')) {
	    pieceB += 'A' - 'a';
	}
	
	global->board[squareA] = pieceB;
	global->board[squareB] = pieceA;
    }

    if (global->side_to_move == WHITE) {
	global->side_to_move = BLACK;
	if (global->en_passant_square != -1) global->en_passant_square -= 3*8;
    } else {
	global->side_to_move = WHITE;
	if (global->en_passant_square != -1) global->en_passant_square += 3*8;
    }
}

/* translate_foreign_index_to_local_position() - one of our key, key functions, used extensively
 * during futurebase back propagation.  It takes an index into a foreign tablebase and converts it
 * to a position in the local tablebase (the tablebase we're processing).  Of course, the pieces
 * might not match up between the two tablebases, but there are only a finite number of possible
 * differences:
 *
 * 1. There can be an "extra" piece in the foreign tablebase that doesn't appear in the
 * local tablebase.
 *
 * 2. There can be up to two "missing" pieces in the local tablebase that don't appear in
 * the foreign tablebase.
 *
 * 3. There can be one piece (the "restricted" piece) that matches up, but is on a square flagged
 * illegal for it in the local tablebase.
 *
 * If there are additional differences not covered in this list (more than one extra piece, for
 * example), or if the index isn't legal in the foreign tablebase, the function returns -1.
 * Otherwise, the return value is a 32 bit integer split into four eight bit fields:
 *
 * bits 0-7:   local tb piece number of missing piece #1
 * bits 8-15:  local tb piece number of restricted piece
 * bits 16-23: foreign tb piece number of extra piece
 * bits 24-31: local tb piece number of missing piece #2
 *
 * If any of the fields are unused (because there is no corresponding piece), it's value is 0x80.
 * If there are two missing pieces and only one of them is a pawn, the pawn will always be returned
 * as missing piece #1.  If there are multiple identical missing pieces, the last one will always be
 * returned as the missing piece(s).
 *
 * The function does not depend on the indexing scheme used by the foreign tablebase.  Instead, it
 * uses index_to_local_position() on the foreign tablebase.
 *
 * The only thing I don't like about this function right now is that it returns -1 if there is more
 * than one restricted piece, and we certainly could have liberal tablebases with lots of restricted
 * pieces that we want to back-prop from.
 */

#define NONE 0x80

int translate_foreign_position_to_local_position(tablebase_t *tb1, local_position_t *foreign,
						 tablebase_t *tb2, local_position_t *local,
						 int invert_colors)
{
    int foreign_piece;
    int piece;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    short pieces_processed_bitvector = 0;

    memset(local, 0, sizeof(local_position_t));

    for (piece = 0; piece < tb2->num_pieces; piece ++) {
	local->piece_position[piece] = -1;
	local->permuted_piece[piece] = piece;
    }

    local->en_passant_square = foreign->en_passant_square;
    local->side_to_move = foreign->side_to_move;

    if (invert_colors) flip_side_to_move_local(local);

    for (foreign_piece = 0; foreign_piece < tb1->num_pieces; foreign_piece ++) {

	int sq = foreign->piece_position[foreign_piece];

	if (invert_colors) sq = rowcol2square(7 - ROW(sq), COL(sq));

	for (piece = 0; piece < tb2->num_pieces; piece ++) {

	    if ((tb1->piece_type[foreign_piece] == tb2->piece_type[piece])
		&& (invert_colors
		    ? (tb1->piece_color[foreign_piece] != tb2->piece_color[piece])
		    : (tb1->piece_color[foreign_piece] == tb2->piece_color[piece]))
		&& !(pieces_processed_bitvector & (1 << piece))) {

		local->piece_position[piece] = sq;
		local->board_vector |= BITVECTOR(sq);
		if (tb2->piece_color[piece] == local->side_to_move)
		    local->PTM_vector |= BITVECTOR(sq);

		pieces_processed_bitvector |= (1 << piece);

		break;
	    }
	}

	if (piece == tb2->num_pieces) {
	    if (extra_piece != NONE) {
		fprintf(stderr, "More than one extra piece in translation\n");
		return -1;
	    }
	    extra_piece = foreign_piece;
	}
    }


    /* Make sure all the pieces but one have been accounted for.  We count a piece as "free" if
     * either it hasn't been processed at all, or if it was processed but was outside its move
     * restriction.
     */

    for (piece = 0; piece < tb2->num_pieces; piece ++) {
	if (!(pieces_processed_bitvector & (1 << piece))) {
	    if (missing_piece1 == NONE) {
		missing_piece1 = piece;
	    } else if (missing_piece2 == NONE) {
		if (tb2->piece_type[piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = piece;
		} else {
		    missing_piece2 = piece;
		}
	    } else {
		fprintf(stderr, "More than one missing piece in translation\n");
		return -1;
	    }
	} else if (!(tb2->semilegal_squares[piece] & BITVECTOR(local->piece_position[piece]))) {
	    if (restricted_piece == NONE) restricted_piece = piece;
	    else {
		/* This can happen if the futurebase is more liberal */
		/* fprintf(stderr, "More than one restricted piece in translation\n"); */
		return -1;
	    }
	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);

}

int translate_foreign_index_to_local_position(tablebase_t *tb1, index_t index1, int symmetry,
					      tablebase_t *tb2, local_position_t *local, int invert_colors)
{
    local_position_t foreign_position;

    if (! index_to_local_position(tb1, index1, symmetry, &foreign_position)) return -1;

    return translate_foreign_position_to_local_position(tb1, &foreign_position, tb2, local, invert_colors);
}

/* This function works just like previous one.  So much so that I've considered wrapping them
 * together, but since this one is already written, I'll just leave it alone for now.
 *
 * It's only use now is by the probing code (see next function).
 */

index_t global_position_to_local_position(tablebase_t *tb, global_position_t *global, local_position_t *local)
{
    int piece;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    int square;
    short pieces_processed_bitvector = 0;

    memset(local, 0, sizeof(local_position_t));

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	local->piece_position[piece] = -1;
	local->permuted_piece[piece] = piece;
    }

    local->en_passant_square = global->en_passant_square;
    local->side_to_move = global->side_to_move;

    for (square = 0; square < NUM_SQUARES; square ++) {
	if ((global->board[square] != 0) && (global->board[square] != ' ')) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		if ((global->board[square] == global_pieces[tb->piece_color[piece]][tb->piece_type[piece]])
		    && !(pieces_processed_bitvector & (1 << piece))) {

		    local->piece_position[piece] = square;
		    local->board_vector |= BITVECTOR(square);
		    if (tb->piece_color[piece] == local->side_to_move)
			local->PTM_vector |= BITVECTOR(square);

		    pieces_processed_bitvector |= (1 << piece);

		    break;
		}
	    }
	    if (piece == tb->num_pieces) {
		if (extra_piece != NONE) {
		    /* This can happen if we're probing a whole bunch of radically different tablebases. */
		    /* fprintf(stderr, "More than one extra piece in translation\n"); */
		    return -1;
		}
		/* XXX I'd like to change this (for consistency) to be the piece index in the
		 * futurebase, but since there is still an intermediate global position, that will
		 * have to wait.
		 */
		extra_piece = square;
	    }
	}
    }


    /* Make sure all the pieces but one have been accounted for.  We count a piece as "free" if
     * either it hasn't been processed at all, or if it was processed but was outside its move
     * restriction.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (!(pieces_processed_bitvector & (1 << piece))) {
	    if (missing_piece1 == NONE) {
		missing_piece1 = piece;
	    } else if (missing_piece2 == NONE) {
		if (tb->piece_type[piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = piece;
		} else {
		    missing_piece2 = piece;
		}
	    } else {
		/* This can happen if we're probing a whole bunch of radically different tablebases. */
		/* fprintf(stderr, "More than one missing piece in translation\n"); */
		return -1;
	    }
	} else if (!(tb->semilegal_squares[piece] & BITVECTOR(local->piece_position[piece]))) {
	    if (restricted_piece == NONE) restricted_piece = piece;
	    else {
		/* This can happen if we're probing a whole bunch of radically different tablebases. */
		/* fprintf(stderr, "More than one restricted piece in translation\n"); */
		return -1;
	    }
	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);
}

index_t global_position_to_index(tablebase_t *tb, global_position_t *global)
{
    local_position_t local;

    if (global_position_to_local_position(tb, global, &local) != 0x80808080) return -1;

    return local_position_to_index(tb, &local);
}

/* index_to_global_position()
 *
 * Used during Nalimov tablebase verification (by running through all indices in a tablebase), as
 * well as during probe code to consider possible captures and promotions because they may lead out
 * of the current tablebase.
 *
 * Massively simplified from an earlier implementation because I want to contain the details of
 * indexing to the local position routines.  Probably a little bit slower now, but not too much.
 *
 * Seems never to be used on a tablebase under construction; only on a finished one.
 */

boolean index_to_global_position(tablebase_t *tb, index_t index, global_position_t *global)
{
    local_position_t local;
    int piece;

    memset(global, 0, sizeof(global_position_t));

    if (! index_to_local_position(tb, index, 0, &local)) return 0;

    global->side_to_move = local.side_to_move;
    global->en_passant_square = local.en_passant_square;

    for (piece = 0; piece < tb->num_pieces; piece++) {
	global->board[local.piece_position[piece]]
	    = global_pieces[tb->piece_color[piece]][tb->piece_type[piece]];
    }

    return 1;
}


/***** PARSING FEN TO/FROM POSITION STRUCTURES *****/

boolean place_piece_in_local_position(tablebase_t *tb, local_position_t *pos, int square, int color, int type)
{
    int piece;

    if (pos->board_vector & BITVECTOR(square)) return 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == type) && (tb->piece_color[piece] == color)) {
	    pos->piece_position[piece] = square;
	    pos->board_vector |= BITVECTOR(square);
	    if (color == pos->side_to_move) pos->PTM_vector |= BITVECTOR(square);
	    return 1;
	}
    }

    return 0;
}

boolean place_piece_in_global_position(global_position_t *position, int square, int color, int type)
{
    position->board[square] = global_pieces[color][type];
    return 1;
}

boolean parse_FEN_to_local_position(char *FEN_string, tablebase_t *tb, local_position_t *pos)
{
    int row, col;
    int piece;

    memset(pos, 0, sizeof(local_position_t));
    pos->en_passant_square = -1;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	pos->piece_position[piece] = -1;
	pos->permuted_piece[piece] = piece;
    }

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

boolean parse_FEN_to_global_position(char *FEN_string, global_position_t *pos)
{
    int row, col;

    memset(pos, 0, sizeof(global_position_t));
    pos->en_passant_square = -1;

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

/* Note that the buffer in this function is static... */

char * global_position_to_FEN(global_position_t *position)
{
    static char buffer[256];
    char *ptr = buffer;
    int empty_squares;
    int row, col;

    for (row=7; row>=0; row--) {
	empty_squares=0;
	for (col=0; col<=7; col++) {
	    if ((position->board[rowcol2square(row, col)] == ' ') || (position->board[rowcol2square(row,col)] == 0)) {
		empty_squares++;
	    } else {
		if (empty_squares > 0) {
		    *(ptr++) = '0' + empty_squares;
		    empty_squares = 0;
		}
		*(ptr++) = position->board[rowcol2square(row,col)];
	    }
	}
	if (empty_squares > 0) {
	    *(ptr++) = '0' + empty_squares;
	}
	if (row > 0) *(ptr++) = '/';
    }

    *(ptr++) = ' ';

    *(ptr++) = (position->side_to_move == WHITE) ? 'w' : 'b';

    /* no castling rights */

    *(ptr++) = ' ';
    *(ptr++) = '-';
    *(ptr++) = ' ';

    if (position->en_passant_square == -1) {
	*(ptr++) = '-';
    } else {
	*(ptr++) = 'a' + COL(position->en_passant_square);
	*(ptr++) = '1' + ROW(position->en_passant_square);
    }

    *(ptr++) = '\0';

    return buffer;
}

char * index_to_FEN(tablebase_t *tb, index_t index)
{
    global_position_t global;
    index_to_global_position(tb, index, &global);
    return global_position_to_FEN(&global);
}

/* This routine looks at "movestr" to try and figure out if it is a valid move from this global
 * position.  If so, it changes the global position to reflect the move and returns true.
 * Otherwise, it leaves the global position alone and returns false.
 */

boolean parse_move_in_global_position(char *movestr, global_position_t *global)
{
    int origin_square, destination_square;
    int is_capture = 0;
    unsigned char promotion_piece = '\0';

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	origin_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == 'x') {
	is_capture = 1;
	movestr ++;
    }

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	destination_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == '=') {
	movestr ++;
	promotion_piece = movestr[0];
    }

    if (!(global->board[origin_square] >= 'A' && global->board[origin_square] <= 'Z')
	&& global->side_to_move == WHITE)
	return 0;

    if (!(global->board[origin_square] >= 'a' && global->board[origin_square] <= 'z')
	&& global->side_to_move == BLACK)
	return 0;

    if (global->board[destination_square] >= 'A' && !is_capture) return 0;

    if (!(global->board[destination_square] >= 'A' && global->board[destination_square] <= 'Z')
	&& is_capture && global->side_to_move == BLACK)
	return 0;

    if (!(global->board[destination_square] >= 'a' && global->board[destination_square] <= 'z')
	&& is_capture && global->side_to_move == WHITE)
	return 0;

    global->board[destination_square] = promotion_piece ? promotion_piece : global->board[origin_square];
    global->board[origin_square] = 0;
    if (global->side_to_move == WHITE)
	global->side_to_move = BLACK;
    else
	global->side_to_move = WHITE;

    global->en_passant_square = -1;

    if ((global->board[destination_square] == 'P') && (origin_square == destination_square - 16)) {
	global->en_passant_square = destination_square - 8;
    }
    if ((global->board[destination_square] == 'p') && (origin_square == destination_square + 16)) {
	global->en_passant_square = destination_square + 8;
    }

    return 1;
}


/* ENTRY RING BUFFERS
 *
 * In order to avoid copying file buffers in the kernel, which would really hurt our performance, we
 * turn off kernel buffering on the entries and proptable files by passing O_DIRECT to open().  This
 * makes disk read/write DMA operations go directly to user space buffers (which must now be page
 * aligned) and avoids any copying in the kernel.  It also means that we must now do our own
 * buffering, making extensive use of POSIX asynchronous I/O operations.  For the entries file,
 * which we update in memory and so must write back to disk, I use a ring buffering scheme.
 *
 * Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed) uses four colors to
 * illustrate the concept.  I'll use five - blue (input started but not yet complete), green (input
 * complete), yellow (currently processing), red (output started but not yet complete), and purple
 * (output done; input not yet started).  In our case, the buffers turn from blue to green and from
 * red to purple by themselves and we can detect the color difference between blue and green and
 * between red and purple by looking to see if their asynchronous read or write operation completed.
 * So we need two pointers, one to the single yellow buffer, and one to the first red or purple
 * buffer.  If the red/purple pointer catches up to the yellow pointer, then it means that there are
 * no read or purple buffers at the moment.
 *
 * The only functions "exported" from this section are the singly called init_entry_buffers(),
 * fetch_entry(), and store_entry().
 *
 * I'm aiming right now for a target buffer size of 128 KB, since that's my kernel's maximum
 * internal request size.  So, 128 KB / 4 byte entries = 32 K entries = 1<<15
 */

#define LEFTSHIFT(val,bits) (((bits) > 0) ? ((val) << (bits)) : ((val) >> (-(bits))))

#define NUM_ENTRY_BUFFERS 4
#define ENTRY_BUFFER_ENTRIES (1<<12)
#define ENTRY_BUFFER_BYTES LEFTSHIFT(ENTRY_BUFFER_ENTRIES, entries_format.bits - 3)

struct entry_buffer {
    entry_t *buffer;
    index_t start;
    struct aiocb aiocb;
};

struct entry_buffer entry_buffers[NUM_ENTRY_BUFFERS];

int yellow_entry_buffer = 0;
int first_purple_red_entry_buffer = 0;

/* Arrange to read buffernum (i.e, turn it blue).  'buffer' must be allocated (and page aligned),
 * and 'start' must indicate the index number (not the byte number) at which we want to start our
 * read, always of ENTRY_BUFFER_BYTES bytes.
 */

void turn_entry_buffer_blue(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= LEFTSHIFT(entry_buffers[buffernum].start, entries_format.bits - 3);

    if (aio_read(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_read for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_green(int buffernum)
{
    const struct aiocb * aiocbs[1];
    int retval;

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer read to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_read_stall_time, &tv2);
	entries_read_stalls ++;
    }

    retval = aio_return(&entry_buffers[buffernum].aiocb);

    if (retval == 0) {
	/* zero byte read - this is OK the first time through */
	memset(entry_buffers[buffernum].buffer, 0, ENTRY_BUFFER_BYTES);
    } else if ((retval != ENTRY_BUFFER_BYTES)
	       && (retval != LEFTSHIFT(proptable_tb->max_index % ENTRY_BUFFER_ENTRIES,
				       entries_format.bits - 3)))  {
	fprintf(stderr, "entry buffer aio_read didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

/* Arrange to write buffernum (i.e, turn it red).  Again, 'buffer' must be allocated and 'start'
 * must indicate the index number at which we want to start our write.
 */

void turn_entry_buffer_red(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= LEFTSHIFT(entry_buffers[buffernum].start, entries_format.bits - 3);

    if (aio_write(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_write for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_purple(int buffernum)
{
    const struct aiocb * aiocbs[1];

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer write to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_write_stall_time, &tv2);
	entries_write_stalls ++;
    }

    if (aio_return(&entry_buffers[buffernum].aiocb) != ENTRY_BUFFER_BYTES) {
	fprintf(stderr, "entry buffer aio_write didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

void init_entry_buffers(tablebase_t *tb)
{
    int alignment = fpathconf(tb->entries_fd, _PC_REC_XFER_ALIGN);
    int buffernum;

    for (buffernum = 0; buffernum < NUM_ENTRY_BUFFERS; buffernum ++) {
	if (posix_memalign((void **) &entry_buffers[buffernum], alignment, ENTRY_BUFFER_BYTES) != 0) {
	    fprintf(stderr, "Can't posix_memalign entries buffer\n");
	    exit(EXIT_FAILURE);
	}
	entry_buffers[buffernum].start = buffernum * ENTRY_BUFFER_ENTRIES;
	turn_entry_buffer_blue(tb->entries_fd, buffernum);
    }

    wait_for_entry_buffer_green(0);
}

entry_t * fetch_entry_pointer(tablebase_t *tb, index_t index)
{
    if (tb->entries != NULL) {

	/* entries array exists in memory - so just return a pointer into it */
	return (void *)(tb->entries) + LEFTSHIFT(index, entries_format.bits - 3);

    } else if (tb->file != NULL) {

	/* it's a preloaded tablebase - we're reading from a compressed file */

	/* XXX I can't see any reason why this shouldn't be integrated into the next code case. */

	static char entry[MAX_FORMAT_BYTES];
	static tablebase_t *cached_tb = NULL;
	static index_t cached_index = 0;
	int retval;

	if ((cached_tb == tb) && (cached_index == index)) return entry;

	gzseek(tb->file, tb->offset + LEFTSHIFT(index, tb->format.bits - 3), SEEK_SET);
	retval = gzread(tb->file, entry, tb->format.bytes);
	if (retval == EOF) {
	    fprintf(stderr, "fetch_entry_pointer() hit EOF reading from disk\n");
	}

	cached_tb = tb;
	cached_index = index;
	return entry;

    } else if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	/* The index we're looking for isn't in the yellow buffer.  Play Twister. */

	int next_entry_buffer = yellow_entry_buffer + 1;
	if (next_entry_buffer >= NUM_ENTRY_BUFFERS) next_entry_buffer = 0;

	/* Have we caught up with our first purple/red buffer?  Wait until the write has finished
	 * and start the read.
	 */

	if (next_entry_buffer == first_purple_red_entry_buffer) {

	    wait_for_entry_buffer_purple(first_purple_red_entry_buffer);

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* Now, next_entry_buffer is at least blue.  Wait for it to turn green. */

	wait_for_entry_buffer_green(next_entry_buffer);

	/* Check to see if any of the trailing red buffers have turned purple.  If so, turn them
	 * blue.  We do this towards the end here, because if we had to block waiting for
	 * next_entry_buffer to become green, some of the reds might have turned purple.
	 */

	while ((first_purple_red_entry_buffer != yellow_entry_buffer)
	       && (aio_error(&entry_buffers[first_purple_red_entry_buffer].aiocb) != EINPROGRESS)) {

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* queue a write operation for yellow_entry_buffer (i.e, turn it red) */

	turn_entry_buffer_red(tb->entries_fd, yellow_entry_buffer);

	/* Move on to the next buffer to be processed.  We waited for it to be green, remember? */

	yellow_entry_buffer = next_entry_buffer;
    }

    /* Now, as silly as this sounds, we might have done all of that and still not have a valid
     * buffer if the calling routine isn't going through the index numbers in order.  Complain, and
     * wait for a special read to finish on the buffer.  We don't bother with a write because we
     * just flipped buffers above, so our yellow buffer was green a split second ago.
     */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	fprintf(stderr, "fetch_entry_pointer(): special read; needed %d had %d\n",
		index, entry_buffers[yellow_entry_buffer].start);  /* BREAKPOINT */

	entry_buffers[yellow_entry_buffer].start = (index / ENTRY_BUFFER_ENTRIES) * ENTRY_BUFFER_ENTRIES;

	turn_entry_buffer_blue(tb->entries_fd, yellow_entry_buffer);

	wait_for_entry_buffer_green(yellow_entry_buffer);
    }

    /* If we STILL don't have a valid buffer, well, give up, I guess. */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {
	fprintf(stderr, "Can't fetch in fetch_entry_pointer\n");
    }

    return (void *) (entry_buffers[yellow_entry_buffer].buffer)
	+ LEFTSHIFT(index - entry_buffers[yellow_entry_buffer].start, entries_format.bits - 3);
}


/* MORE TABLEBASE OPERATIONS - those that probe and manipulate individual position entries
 *
 * "Designed to multi-thread"
 *
 * Keep atomic operations confined to single functions.  Design functions so that functions calling
 * them don't need to know the details of table format, either.
 *
 * These "add one" functions (atomically) add one to the count in question, subtract one from the
 * total move count, and flag the position as 'ready for propagation' (maybe this is just a move
 * count of zero) if the total move count goes to zero.
 *
 * PTM = Player to Move
 * PNTM = Player not to Move
 *
 */

inline int get_entry_raw_DTM(tablebase_t *tb, index_t index)
{
    return get_signed_field(fetch_entry_pointer(tb, index),
			    entries_format.dtm_mask,
			    entries_format.dtm_offset + ((index << entries_format.bits) % 8));
}

inline void set_entry_raw_DTM(tablebase_t *tb, index_t index, int dtm)
{
    set_signed_field(fetch_entry_pointer(tb, index),
		     entries_format.dtm_mask,
		     entries_format.dtm_offset + ((index << entries_format.bits) % 8),
		     dtm);
}

inline int get_entry_movecnt(tablebase_t *tb, index_t index)
{
    return get_unsigned_field(fetch_entry_pointer(tb, index),
			      entries_format.movecnt_mask,
			      entries_format.movecnt_offset + ((index << entries_format.bits) % 8));
}

inline void set_entry_movecnt(tablebase_t *tb, index_t index, int movecnt)
{
    set_unsigned_field(fetch_entry_pointer(tb, index),
		       entries_format.movecnt_mask,
		       entries_format.movecnt_offset + ((index << entries_format.bits) % 8),
		       movecnt);
}

inline int get_entry_in_check_flag(tablebase_t *tb, index_t index)
{
    return get_unsigned_field(fetch_entry_pointer(tb, index),
			      1,
			      entries_format.in_check_flag_offset + ((index << entries_format.bits) % 8));
}

inline void set_entry_in_check_flag(tablebase_t *tb, index_t index, int in_check_flag)
{
    set_unsigned_field(fetch_entry_pointer(tb, index),
		       1,
		       entries_format.in_check_flag_offset + ((index << entries_format.bits) % 8),
		       in_check_flag);
}

inline int get_entry_flag(tablebase_t *tb, index_t index)
{
    return get_unsigned_field(fetch_entry_pointer(tb, index),
			      1,
			      entries_format.flag_offset + ((index << entries_format.bits) % 8));
}

inline short does_PTM_win(tablebase_t *tb, index_t index)
{
    return (get_entry_raw_DTM(tb, index) > 0);
}

inline short does_PNTM_win(tablebase_t *tb, index_t index)
{
    return (get_entry_movecnt(tb, index) == 0) && (get_entry_raw_DTM(tb, index) < 0);
}

/* Get the result in a format suitable for a one-byte DTM tablebase
 *
 * 0 = draw
 * 1 = PNTM in check (illegal position)
 * N = mate in N-1
 * -1 = PTM checkmated
 * -N = PNTM will have a mate in N-1 after this move
 *
 * The difference between get_DTM (here) and get_raw_DTM (above) is that if the DTM value is less
 * than zero (PNTM wins), but movecnt is still greater than zero, then there are still moves that
 * might let PTM slip off the hook, so in that case we indicate draw.
 */

int get_entry_DTM(tablebase_t *tb, index_t index)
{
    return (does_PTM_win(tb, index) || does_PNTM_win(tb, index)) ? get_entry_raw_DTM(tb, index) : 0;
}

inline boolean is_position_valid(tablebase_t *tb, index_t index)
{
    return (get_entry_DTM(tb,index) != 1);
}

/* Four possible ways we can initialize a tablebase entry for a position:
 *  - it's illegal
 *  - PNTM's mated
 *  - stalemate
 *  - any other position, with 'movecnt' possible moves out the position
 */

void initialize_entry(tablebase_t *tb, index_t index, int movecnt, int dtm, int in_check_flag)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE) {
	fprintf(stderr, "initialize index %d %s movecnt %d; dtm %d; in-check %d\n",
		index, index_to_FEN(tb, index), movecnt, dtm, in_check_flag);
    }
#endif

    set_entry_movecnt(tb, index, movecnt);
    set_entry_raw_DTM(tb, index, dtm);
    set_entry_in_check_flag(tb, index, in_check_flag);
}

void initialize_entry_as_illegal(tablebase_t *tb, index_t index)
{
    /* XXX need to look more closely at this (again) */
    initialize_entry(tb, index, 0, 0, 0);
    /* initialize_entry(tb, entry, 0, 1); */
}

void initialize_entry_with_PTM_mated(tablebase_t *tb, index_t index)
{
    initialize_entry(tb, index, 0, -1, 0);
    total_legal_positions ++;
    /* total_PNTM_mated_positions ++; */
}

void initialize_entry_with_PNTM_mated(tablebase_t *tb, index_t index)
{
    initialize_entry(tb, index, 0, 1, 0);
    /* total_legal_positions ++; */
    total_PNTM_mated_positions ++;
}

void initialize_entry_with_stalemate(tablebase_t *tb, index_t index)
{
    /* use movecnt 127 as stalemate for now */
    /* XXX this should at least be (movecnt_mask - 1) */
    initialize_entry(tb, index, 127, 0, 0);
    total_legal_positions ++;
    total_stalemate_positions ++;
}

void initialize_entry_with_movecnt(tablebase_t *tb, index_t index, int movecnt, int in_check)
{
    initialize_entry(tb, index, movecnt, 0, in_check);
    total_legal_positions ++;
}

inline void PTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("PTM_wins; index=%d; dtm=%d\n", index, dtm);
#endif

    if (dtm < 0) {
	fprintf(stderr, "Negative distance to mate in PTM_wins!?\n"); /* BREAKPOINT */
    } else if ((dtm < get_entry_raw_DTM(tb, index)) || (get_entry_raw_DTM(tb, index) <= 0)) {
	set_entry_raw_DTM(tb, index, dtm);
    }
}

inline void add_one_to_PNTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("add_one_to_PNTM_wins; index=%d; dtm=%d; table dtm=%d\n", index, dtm, get_entry_raw_DTM(tb, index));
#endif

    if (dtm > 0) {
	fprintf(stderr, "Positive distance to mate in PNTM_wins!?\n"); /* BREAKPOINT */
    } else {
	set_entry_movecnt(tb, index, get_entry_movecnt(tb, index) - 1);
	if ((dtm < get_entry_raw_DTM(tb, index)) && (get_entry_raw_DTM(tb, index) <= 0)) {
	    /* Since this is PNTM wins, PTM will make the move leading to the slowest mate. */
	    set_entry_raw_DTM(tb, index, dtm);
	}

	if ((get_entry_movecnt(tb, index) == 0) && (!get_entry_in_check_flag(tb, index))
	    && (get_entry_raw_DTM(tb, index) == -1)) {

	    /* In this case, the only moves at PTM's disposal move him into check (DTM is now one,
	     * so it would drop to zero on next move).  So we need to distinguish here between being
	     * in check (it's checkmate) and not being in check (stalemate).  This is stalemate...
	     */

	    total_stalemate_positions ++;

	    set_entry_raw_DTM(tb, index, 0);
	}
    }
}


/***** MOVEMENT VECTORS *****/

/* The idea here is to calculate piece movements, and to do it FAST.
 *
 * We build a table of "movements" organized into "directions".  Each direction is just that - the
 * direction that a piece (like a queen) moves.  When we want to check for what movements are
 * possible in a given direction, we run through the direction until we "hit" another pieces - until
 * the bit in the vector matches something already in the position vector.  At the end of the
 * direction, an all-ones vector will "hit" the end of the board and end the direction.  I know,
 * kinda confusing.  It's because it's designed to be fast; we have to do this a lot.
 */

struct movement {
    uint64 vector;
    short square;
};

/* we add one to NUM_MOVEMENTS to leave space at the end for the all-ones bitmask that signals the
 * end of the list
 */

struct movement movements[NUM_PIECES][NUM_SQUARES][NUM_DIR][NUM_MOVEMENTS+1];

/* Pawns are, of course, special.  We have seperate vectors for different types of pawn movements.
 * Each array is indexed first by square number, then by side (WHITE or BLACK - this doesn't exist
 * for other pieces), then by the number of possibilities (at most two normal movements, at most two
 * captures, and one more for the all-ones bitvector to terminate)
 *
 * All of these are FORWARD motions.
 */

struct movement normal_pawn_movements[NUM_SQUARES][2][3];
struct movement capture_pawn_movements[NUM_SQUARES][2][3];

struct movement normal_pawn_movements_bkwd[NUM_SQUARES][2][3];
struct movement capture_pawn_movements_bkwd[NUM_SQUARES][2][3];

/* How many different directions can each piece move in?  Knights have 8 directions because they
 * can't be blocked in any of them.  Pawns are handled separately.
 */

int number_of_movement_directions[NUM_PIECES] = {8,8,4,4,8,0};
int maximum_movements_in_one_direction[NUM_PIECES] = {1,7,7,7,1,0};

enum {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR, KNIGHTmove}
movementdir[5][8] = {
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* King */
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* Queen */
    {RIGHT, LEFT, UP, DOWN},						/* Rook */
    {DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},				/* Bishop */
    {KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove},	/* Knights are special... */
};



char algebraic_notation[64][3];

void init_movements()
{
    int square, piece, dir, mvmt, color;

    for (square=0; square < NUM_SQUARES; square++) {
	bitvector[square] = 1ULL << square;
	algebraic_notation[square][0] = 'a' + square%8;
	algebraic_notation[square][1] = '1' + square/8;
	algebraic_notation[square][2] = '\0';
    }

    for (piece=KING; piece <= KNIGHT; piece++) {

	for (square=0; square < NUM_SQUARES; square++) {

	    for (dir=0; dir < number_of_movement_directions[piece]; dir++) {

		int current_square = square;

		for (mvmt=0; mvmt < maximum_movements_in_one_direction[piece]; mvmt ++) {

#define RIGHT_MOVEMENT_POSSIBLE ((current_square%8)<7)
#define RIGHT2_MOVEMENT_POSSIBLE ((current_square%8)<6)
#define LEFT_MOVEMENT_POSSIBLE ((current_square%8)>0)
#define LEFT2_MOVEMENT_POSSIBLE ((current_square%8)>1)
#define UP_MOVEMENT_POSSIBLE (current_square<56)
#define UP2_MOVEMENT_POSSIBLE (current_square<48)
#define DOWN_MOVEMENT_POSSIBLE (current_square>7)
#define DOWN2_MOVEMENT_POSSIBLE (current_square>15)

		    switch (movementdir[piece][dir]) {
		    case RIGHT:
			if (RIGHT_MOVEMENT_POSSIBLE) {
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case LEFT:
			if (LEFT_MOVEMENT_POSSIBLE) {
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case UP:
			if (UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DOWN:
			if (DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UL:
			if (LEFT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UR:
			if (RIGHT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DL:
			if (LEFT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DR:
			if (RIGHT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case KNIGHTmove:
			current_square=square;
			switch (dir) {
			case 0:
			    if (RIGHT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 1:
			    if (RIGHT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 2:
			    if (LEFT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 3:
			    if (LEFT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 4:
			    if (RIGHT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 5:
			    if (RIGHT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 6:
			    if (LEFT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 7:
			    if (LEFT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			}
			break;

		    }
		}

		/* Always put an allones_bitvector at the end of the movement vector
		 * to make sure we stop!
		 */

		movements[piece][square][dir][mvmt].square = -1;
		movements[piece][square][dir][mvmt].vector = allones_bitvector;

	    }
	}
    }

    /* Now for the pawns... */

    for (square=0; square < NUM_SQUARES; square ++) {

	for (color = WHITE; color <= BLACK; color ++) {

	    int forwards_pawn_move = ((color == WHITE) ? 8 : -8);
	    int backwards_pawn_move = ((color == WHITE) ? -8 : 8);

	    /* Forward pawn movements
	     *
	     * An ordinary pawn move... unless its a white pawn on the second rank, or a black
	     * pawn on the seventh.  In these two cases, there is a possible double move as
	     * well.
	     */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		normal_pawn_movements[square][color][mvmt].square = square + forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + forwards_pawn_move);

		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 1)) || ((color == BLACK) && (ROW(square) == 6))) {

		normal_pawn_movements[square][color][mvmt].square = square + 2*forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + 2*forwards_pawn_move);

		mvmt ++;

	    }

	    normal_pawn_movements[square][color][mvmt].square = -1;
	    normal_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn movements */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + backwards_pawn_move);
		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 3)) || ((color == BLACK) && (ROW(square) == 4))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + 2*backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + 2*backwards_pawn_move);
		mvmt ++;
	    }

	    normal_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    normal_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	    /* Forward pawn captures. */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		if (COL(square) > 0) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move - 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move + 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements[square][color][mvmt].square = -1;
	    capture_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn captures */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		if (COL(square) > 0) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move - 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move + 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    capture_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	}

    }

}

/* This routine is pretty fast, so I just call it once every time the program runs.  It has to be
 * used after any changes to the code above to verify that those complex movement vectors are
 * correct, or at least consistent.  We're using this in a game situation.  We can't afford bugs in
 * this code.
 */

void verify_movements()
{
    int piece;
    int squareA, squareB;
    int dir;
    int color;
    struct movement * movementptr;
    int pawn_option;

    /* For everything except pawns, if it can move from A to B, then it better be able to move from
     * B to A...
     */

    for (piece=KING; piece <= KNIGHT; piece ++) {

	for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

	    for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		int movement_possible = 0;
		int reverse_movement_possible = 0;

		/* check for possible self-movement, if A and B are the same square */

		if (squareA == squareB) {
		    for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {
			for (movementptr = movements[piece][squareA][dir];
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fprintf(stderr, "Self movement possible!? %s %d %d\n",
				    piece_name[piece], squareA, movementptr->square);
			}
		    }
		    continue;
		}

		/* check for possible A to B move */

		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareA][dir];
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fprintf(stderr, "Bad movement square: %s %d %d %d\n",
				    piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fprintf(stderr, "-1 movement lacks allones_bitvector: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fprintf(stderr, "Bad movement square: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fprintf(stderr, "bitvector does not match destination square: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fprintf(stderr, "multiple idential destinations from same origin: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fprintf(stderr, "allones_bitvector on a legal movement: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    }
		}


		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareB][dir];
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;
		}


		if (movement_possible && !reverse_movement_possible) {
		    fprintf(stderr, "reverse movement impossible: %s %d %d\n",
			    piece_name[piece], squareA, squareB);
		}

	    }
	}
    }

    /* Pawns are special */

    piece = PAWN;

    for (pawn_option = 0; pawn_option < 4; pawn_option ++) {

	struct movement * fwd_movement;
	struct movement * rev_movement;

	for (color = WHITE; color <= BLACK; color ++) {

	    /* fprintf(stderr, "Pawn option %d; color %s\n", pawn_option, colors[color]); */

	    for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

		for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		    int movement_possible = 0;
		    int reverse_movement_possible = 0;

		    switch (pawn_option) {
		    case 0:
			fwd_movement = normal_pawn_movements[squareA][color];
			rev_movement = normal_pawn_movements_bkwd[squareB][color];
			break;
		    case 1:
			fwd_movement = normal_pawn_movements_bkwd[squareA][color];
			rev_movement = normal_pawn_movements[squareB][color];
			break;
		    case 2:
			fwd_movement = capture_pawn_movements[squareA][color];
			rev_movement = capture_pawn_movements_bkwd[squareB][color];
			break;
		    case 3:
			fwd_movement = capture_pawn_movements_bkwd[squareA][color];
			rev_movement = capture_pawn_movements[squareB][color];
			break;
		    }

		    /* check for self-movement */

		    if (squareA == squareB) {
			for (movementptr = fwd_movement;
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fprintf(stderr, "Self movement possible!? PAWN %d %d\n",
				    squareA, movementptr->square);
			}
		    }

		    /* check for possible A to B move */

		    for (movementptr = fwd_movement;
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fprintf(stderr, "Bad movement square: %s %d %d %d\n",
				    piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fprintf(stderr, "-1 movement lacks allones_bitvector: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fprintf(stderr, "Bad movement square: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fprintf(stderr, "bitvector does not match destination square: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fprintf(stderr, "multiple idential destinations from same origin: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fprintf(stderr, "allones_bitvector on a legal movement: %s %d %d\n",
				    piece_name[piece], squareA, squareB);
			}
		    }


		    /* check for possible B to A reverse move */

		    for (movementptr = rev_movement;
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;

		    if (movement_possible && !reverse_movement_possible) {
			fprintf(stderr, "reverse movement impossible: %s %d %d\n",
				piece_name[piece], squareA, squareB);
		    }
		}
	    }
	}
    }
}


/***** PROPAGATION TABLE *****/

/* When propagating a change from one position to another, we go through this table to do it.  By
 * maintaining this table sorted, we avoid the random accesses that would be required to propagate
 * directly from one position to another.  It only makes sense to use a propagation table if the
 * tablebase can't fit in memory.  If the tablebase does fit in memory, we set num_propentries to
 * zero and bypass almost this entire section of code.
 *
 * We insert into the propagation table using an "address calculation insertion sort".  Knuth
 * described it by analogy to shelving books.  You're sorting the books as you place them onto the
 * shelf; that makes it an "insertion sort" (as opposed to something like an exchange sort, where
 * you place them first and then sort by swapping).  You look at the author's last name to try and
 * "guess" where it should go on the shelf - "Alfors" all the way to the left; "Munkres" about in
 * the middle; "van der Waerden" towards the right.  That's the "address calculation" part.
 *
 * We do this with indices, dividing them by a scaling factor to get an offset into the propagation
 * table (in memory).  This type of sort works well if the indices are well spread out, and not so
 * well in they are clumped together.  That's why we invert indices in a finite field - to spread
 * out the mating positions that naturally clump together into groups of similar positions.  Once we
 * start having to move things around too much to do an insertion, we write the current proptable
 * out to disk, zero out the memory, and start again fresh.
 *
 * Once we've got a bunch of proptables written to disk, we then need to read them back in.  We do
 * this "semi-sequentially" - each individual table is read sequentially, even though we need to
 * jump our reads around between them.  We run the entries from each table through a sort tree to
 * produce a single stream of sorted proptable entries, which are then committed into the tablebase.
 *
 * To optimize all of this, we simultaneously read one set of proptables and write another set while
 * making a single pass through the tablebase.
 */

int proptable_entries = 0;
int proptable_merges = 0;

#define PROPTABLE_ELEM(n)  ((void *)proptable + proptable_format.bytes * (n))

index_t get_propentry_index(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned_field(ptr, proptable_format.index_mask, proptable_format.index_offset);
}

void set_propentry_index(proptable_entry_t *propentry, index_t index)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned_field(ptr, proptable_format.index_mask, proptable_format.index_offset, index);
}

futurevector_t get_propentry_futurevector(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned64bit_field(ptr, proptable_format.futurevector_mask, proptable_format.futurevector_offset);
}

void set_propentry_futurevector(proptable_entry_t *propentry, futurevector_t futurevector)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned64bit_field(ptr, proptable_format.futurevector_mask, proptable_format.futurevector_offset, futurevector);
}

int get_propentry_dtm(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_signed_field(ptr, proptable_format.dtm_mask, proptable_format.dtm_offset);
}

void set_propentry_dtm(proptable_entry_t *propentry, int distance)
{
    uint32 *ptr = (uint32 *) propentry;
    set_signed_field(ptr, proptable_format.dtm_mask, proptable_format.dtm_offset, distance);
}

int get_propentry_movecnt(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned_field(ptr, proptable_format.movecnt_mask, proptable_format.movecnt_offset);
}

void set_propentry_movecnt(proptable_entry_t *propentry, int movecnt)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned_field(ptr, proptable_format.movecnt_mask, proptable_format.movecnt_offset, movecnt);
}

void insert_at_propentry(int propentry, proptable_entry_t * pentry)
{
#ifdef DEBUG_MOVE
    if (get_propentry_index(pentry) == DEBUG_MOVE)
	fprintf(stderr, "insert_at_propentry; index=%d; propentry=%d\n",
		get_propentry_index(pentry), propentry);
#endif

    memcpy(PROPTABLE_ELEM(propentry), pentry, proptable_format.bytes);

    proptable_entries ++;

#ifdef DEBUG_MOVE
    if (get_propentry_index(pentry) == DEBUG_MOVE)
	fprintf(stderr, "Propentry: %llx %llx\n", *((uint64 *) pentry), *(((uint64 *) pentry) + 1));
#endif
}

void merge_at_propentry(int propentry, proptable_entry_t *src)
{
    uint32 *dest = (uint32 *) PROPTABLE_ELEM(propentry);
    int dest_dtm = get_propentry_dtm(dest);
    int src_dtm = get_propentry_dtm(src);

    proptable_merges ++;

#ifdef DEBUG_MOVE
    if (get_propentry_index(PROPTABLE_ELEM(propentry)) == DEBUG_MOVE)
	fprintf(stderr, "merge_at_propentry; index=%d; propentry=%d; src_dtm=%d\n",
		get_propentry_index(PROPTABLE_ELEM(propentry)), propentry, src_dtm);
#endif

    if (src_dtm > 0) {
	/* DTM > 0 - this move lets PTM mate from this position.  Update the proptable entry if
	 * either we don't have any PTM mates yet (table's dtm <= 0), or if this new mate is faster
	 * than the old one.
	 */
	if ((dest_dtm <= 0) || (src_dtm < dest_dtm)) {
	    set_propentry_dtm(dest, src_dtm);
	}
    } else if (src_dtm < 0) {
	/* DTM < 0 - this move lets PNTM mate from this position.  Update the proptable entry only
	 * if we don't have any PTM mates (table's dtm <= 0) and this PNTM mate is slower than the
	 * old one.
	 */
	if ((dest_dtm <= 0) && (src_dtm < dest_dtm)) {
	    set_propentry_dtm(dest, src_dtm);
	}
    }

    set_propentry_movecnt(dest, get_propentry_movecnt(dest) + get_propentry_movecnt(src));

    if (get_propentry_futurevector(dest) & get_propentry_futurevector(src)) {
	global_position_t global;
	index_to_global_position(proptable_tb, get_propentry_index(PROPTABLE_ELEM(propentry)), &global);
	/* This might happen just because of symmetry issues */
#if 0
	fprintf(stderr, "Futuremoves multiply handled: %s\n", global_position_to_FEN(&global));
#endif
    }

    set_propentry_futurevector(dest, get_propentry_futurevector(dest) | get_propentry_futurevector(src));
}

void commit_proptable_entry(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    index_t index = get_propentry_index(propentry);
    int dtm = get_propentry_dtm(ptr);
    int movecnt = get_propentry_movecnt(ptr);
    futurevector_t futurevector = get_propentry_futurevector(ptr);
    int i;

    /* Skip everything if the position isn't valid.  In particular, we don't track futuremove
     * propagation for illegal positions.
     */

    if (get_entry_raw_DTM(proptable_tb, index) == 1) return;

    /* Somewhat of a special case here.  First of all, futurevector is non-zero only on the first
     * back-propagation pass, when we back prop from the futurebases.  Also, if we're not using
     * proptables (so num_propentries is zero), then I use a seperate array for the futurevectors,
     * which got filled in when we initialized the tablebase.  In that case, we now check off the
     * futurevectors in that array as we back prop.  If we are using proptables, then this gets done
     * during the initialization pass and we don't use the seperate array.
     */

    if ((num_propentries == 0) && (futurevector != 0)) {

	if ((futurevector & proptable_tb->futurevectors[index]) != futurevector) {
	    /* This could happen simply if the futuremove has already been considered */
	    /* XXX In particular, I need to turn this off right now for symmetric tablebases */
#if 0
	    global_position_t global;
	    index_to_global_position(proptable_tb, index, &global);
	    fprintf(stderr, "Futuremove discrepancy: %s\n", global_position_to_FEN(&global));
#endif
	    return;
	}

	proptable_tb->futurevectors[index] ^= futurevector;
    }

    if (dtm > 0) {
	PTM_wins(proptable_tb, index, dtm);
    } else if (dtm < 0) {
	for (i=0; i<movecnt; i++) {
	    add_one_to_PNTM_wins(proptable_tb, index, dtm);
	}
    }
}


int num_proptables = 0;
int proptable_output_fd = -1;

struct aiocb proptable_output_aiocb;
int proptable_write_in_progress = 0;

/* proptable_full() - dump out to disk and empty table
 *
 * If we're using dual proptables, then we switch to the empty table and start background async
 * operations to dump the full one out to disk, and then zero it out.
 */

void finalize_proptable_write(void)
{
    const struct aiocb * aiocbs[1];
    int ret;

    if (!proptable_write_in_progress) return;

    aiocbs[0] = &proptable_output_aiocb;
    aio_suspend(aiocbs, 1, NULL);

    ret = aio_return(&proptable_output_aiocb);

    if (ret != num_propentries * proptable_format.bytes) {
	fprintf(stderr, "proptable aio_write returned %d, not PROPTABLE_BYTES\n", ret);
	kill(getpid(), SIGSTOP);
    }

    /* Whichever proptable is in use, we just finished writing the other one, so zero it out.
     * If we don't USE_DUAL_PROPTABLES, then proptable1 and proptable2 have the same value.
     */

    if (proptable == proptable1) memset(proptable2, 0, num_propentries * proptable_format.bytes);
    else memset(proptable1, 0, num_propentries * proptable_format.bytes);

    proptable_write_in_progress = 0;
}

void proptable_full(void)
{
    char outfilename[256];
    struct timeval tv1, tv2;

    if (proptable_entries == 0) return;

#if SEPERATE_PROPTABLE_FILES
    sprintf(outfilename, "propfile%04d_out", num_proptables);
#else
    sprintf(outfilename, "propfile_out");
#endif

    if (proptable_output_fd == -1) {
	proptable_output_fd = open(outfilename, O_WRONLY | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
    }
    if (proptable_output_fd == -1) {
	fprintf(stderr, "Can't open '%s' for writing propfile\n", outfilename);
	return;
    }

    /* XXX redo this by recording this data into an array and generating the XML when we're done */
#if 0
    xmlNodeAddContent(proptable_tb->current_pass_stats, BAD_CAST "\n      ");
    node = xmlNewChild(proptable_tb->current_pass_stats, NULL, BAD_CAST "proptable", NULL);
    sprintf(strbuf, "%d", proptable_entries);
    xmlNewProp(node, BAD_CAST "entries", BAD_CAST strbuf);
    sprintf(strbuf, "%d", proptable_merges);
    xmlNewProp(node, BAD_CAST "merges", BAD_CAST strbuf);
    sprintf(strbuf, "%d%%", (100*proptable_entries)/num_propentries);
    xmlNewProp(node, BAD_CAST "occupancy", BAD_CAST strbuf);
#endif

    fprintf(stderr, "Writing proptable block %d with %d entries (%d%% occupancy)\n",
	    num_proptables, proptable_entries, (100*proptable_entries)/num_propentries);

    /* If we USE_DUAL_PROPTABLES, and there was a write already running, make sure it's done. */
    finalize_proptable_write();

    gettimeofday(&tv1, NULL);

    /* Hitting a disk full condition is by no means out of the question here!
     *
     * And I haven't really dealt with that yet, so XXX.
     *
     * We do fire off an asynchronous write if we're using dual proptables.  That makes the most
     * sense if the output proptables are on their own disk; otherwise, it might more more sense to
     * break the write down into a series of smaller ones that we can scatter with the reads.
     */

    /* do_write(proptable_output_fd, proptable, num_propentries * sizeof(proptable_entry_t)); */

    memset(&proptable_output_aiocb, 0, sizeof(struct aiocb));
    proptable_output_aiocb.aio_fildes = proptable_output_fd;
    proptable_output_aiocb.aio_buf = proptable;
    proptable_output_aiocb.aio_nbytes = num_propentries * proptable_format.bytes;
#if SEPERATE_PROPTABLE_FILES
    proptable_output_aiocb.aio_offset = 0;
#else
    proptable_output_aiocb.aio_offset = num_proptables * num_propentries * proptable_format.bytes;
#endif
    proptable_output_aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;

    if (aio_write(& proptable_output_aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_write for proptable\n");
	kill(getpid(), SIGSTOP);
    }

    proptable_write_in_progress = 1;

#if USE_DUAL_PROPTABLES
    if (proptable == proptable1) proptable = proptable2;
    else proptable = proptable1;
#else
    finalize_proptable_write();
#endif

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_write_time, &tv2);
    proptable_writes ++;

    num_proptables ++;
    proptable_entries = 0;
    proptable_merges = 0;

#if SEPERATE_PROPTABLE_FILES
    close(proptable_output_fd);
    proptable_output_fd = -1;
#endif
}

/* proptable_finalize()
 *
 * Start a new set of proptables and commit the old set into the entries array.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int symmetry);

/* fetch_next_propentry()
 *
 * proptable_buffer[propbuf(tablenum, buffernum)]
 *         a malloc'ed buffer of PROPTABLE_BUFFER_SIZE bytes
 * proptable_buffer_index[tablenum]
 *         the local (relative to buffer) entry number of the NEXT entry in the buffer to be read
 * proptable_input_fds[tablenum]
 *         file descriptor of this proptable
 * proptable_current_buffernum[tablenum]
 *         current buffernum (from 0 to BUFFERS_PER_PROPTABLE) for this table
 */

int *proptable_input_fds;
proptable_entry_t **proptable_buffer;
struct aiocb *proptable_aiocb;
int *proptable_buffer_index;
int *proptable_current_buffernum;

/* Proptable buffering settings.
 *
 * Based on a paper I read about disk throughput using Linux asynchronous I/O, 256 KB seems to be a
 * good target buffer size to shoot for.  Also, there's currently nothing in the code to deal with
 * the case where the buffers are so large relative to the proptable that the first set of AIO reads
 * more than completely consumes the proptable.  Since the smallest proptable we can specify (the -P
 * option) is 1 MB, and I'm currently using 4 BUFFERS_PER_PROPTABLE, 256 KB is also the largest
 * buffer size we can use with our smallest proptable size and not break the code.  Since
 * proptable_entry_t is currently hardwired at 16 bytes, 1<<14 (16 K) entries per buffer gives 256
 * KB buffers.
 *
 * Adjusting these numbers is actually quite tricky.  Make the buffers too small or too few, and
 * you'll be stalling because you've emptied your pipeline.  Make the buffers too big or too many,
 * and you'll stall because your pipeline is full of big, slow reads that you don't need yet.
 * Probably want to look at adjusting these things dynamically at some point; perhaps keep the
 * buffer size constant and adjust on the fly the number of buffers in the rings.
 *
 * I _assume_ that these numbers read full disk blocks on disk block multiples (otherwise the direct
 * I/O stuff will scream and fail).  I've also found out from the linux-kernel mailing list that
 * /sys/block/DEV/queue/max_sectors_kb gives the maximum size (in KB) of the kernel internal
 * requests.  My disk shows 128 KB there, so I've bumped 256 KB down to 128 KB.  (1<<13 entries)
 */

#define PROPTABLE_BUFFER_ENTRIES (1<<13)
#define PROPTABLE_BUFFER_BYTES (PROPTABLE_BUFFER_ENTRIES * proptable_format.bytes)
#define BUFFERS_PER_PROPTABLE 4

#define propbuf(tablenum, buffernum) (((tablenum) * BUFFERS_PER_PROPTABLE) + buffernum)

#define current_propbuf(tablenum) propbuf(tablenum, proptable_current_buffernum[tablenum])

void fetch_next_propentry(int tablenum, proptable_entry_t *dest)
{
    const struct aiocb * aiocbs[1];
    uint32 offset;
    int ret;

    do {

	/* First, look for additional entries in the in-memory buffer.  Entries with zero
	 * index are empty slots and are skipped.
	 */

	while (proptable_buffer_index[tablenum] < PROPTABLE_BUFFER_ENTRIES) {

	    if (get_propentry_index(proptable_buffer[current_propbuf(tablenum)]
				    + proptable_format.bytes * (proptable_buffer_index[tablenum])) != 0) {
		memcpy(dest,
		       proptable_buffer[current_propbuf(tablenum)]
		       + proptable_format.bytes * (proptable_buffer_index[tablenum]),
		       proptable_format.bytes);

		proptable_buffer_index[tablenum] ++;
		return;
	    }

	    proptable_buffer_index[tablenum] ++;
	}

	/* Finished with this buffer.  Issue a read request for what its next contents should be
	 * (unless we've reached EOF).
	 */

	/* I'm reading Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed).
	 * He uses three colors to illustrate the operation of these things - red (read not yet
	 * complete), green (read complete), and yellow (currently processing).  In our case, the
	 * buffers turn from red to green themselves and we can detect their color (by looking to
	 * see if their asynchronous read operation completed).  So we only need a single pointer,
	 * to the single yellow buffer.
	 */

	offset = proptable_aiocb[current_propbuf(tablenum)].aio_offset
	    + PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE;
	if (offset % (num_propentries * proptable_format.bytes)
	    < PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE) offset = 0;

	memset(&proptable_aiocb[current_propbuf(tablenum)], 0, sizeof(struct aiocb));
	proptable_aiocb[current_propbuf(tablenum)].aio_fildes = proptable_input_fds[tablenum];
	proptable_aiocb[current_propbuf(tablenum)].aio_buf = proptable_buffer[current_propbuf(tablenum)];
	proptable_aiocb[current_propbuf(tablenum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	proptable_aiocb[current_propbuf(tablenum)].aio_sigevent.sigev_notify = SIGEV_NONE;
	proptable_aiocb[current_propbuf(tablenum)].aio_offset = offset;

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    if (aio_read(& proptable_aiocb[current_propbuf(tablenum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }

	}

	/* On to the next buffer. */

	proptable_current_buffernum[tablenum] ++;
	proptable_current_buffernum[tablenum] %= BUFFERS_PER_PROPTABLE;

	/* Wait for it to finish its disk read, if necessary */

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    ret = aio_error(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret == EINPROGRESS) {
		struct timeval tv1, tv2;
		gettimeofday(&tv1, NULL);

		/* fprintf(stderr, "Waiting for proptable buffer read to complete\n"); */
		aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
		aio_suspend(aiocbs, 1, NULL);

		gettimeofday(&tv2, NULL);
		subtract_timeval(&tv2, &tv1);
		add_timeval(&proptable_read_stall_time, &tv2);
		proptable_read_stalls ++;
	    } else if (ret != 0) {
		fprintf(stderr, "Error return %d from proptable aio_read\n", ret);
	    }

	    ret = aio_return(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret != PROPTABLE_BUFFER_BYTES) {
		fprintf(stderr, "proptable aio_read returned %d, not PROPTABLE_BUFFER_BYTES\n", ret);
		kill(getpid(), SIGSTOP);
	    }
	}

	/* Start at the beginning of the buffer, and keep looking */

	proptable_buffer_index[tablenum] = 0;

    } while (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0);

    /* No, we're really at the end! */

    /* XXX could be a problem if max_index + 1 won't fit in the index element */
    set_propentry_index(dest, proptable_tb->max_index + 1);
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index);
void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector);

int proptable_finalize(int target_dtm)
{
    int i;
    int tablenum, bufnum;
    int num_input_proptables;
    struct timeval tv1, tv2;

    void *sorting_network;
    int *proptable_num;
    int highbit;
    int network_node;

#if SEPERATE_PROPTABLE_FILES
    char infilename[256];
    char outfilename[256];
#else
    int proptable_input_fd;
#endif

#define SORTING_NETWORK_ELEM(n)  (sorting_network + proptable_format.bytes * (n))

    index_t index;
    int positions_finalized = 0;

    /* Flush out anything in the last proptable, and wait for its write to complete */
    proptable_full();
    finalize_proptable_write();

    num_input_proptables = num_proptables;

    if (proptable_output_fd != -1) {
	close(proptable_output_fd);
	proptable_output_fd = -1;
    }

    num_proptables = 0;

    for (highbit = 1; highbit <= num_input_proptables; highbit <<= 1);

    proptable_buffer = (proptable_entry_t **)
	malloc(BUFFERS_PER_PROPTABLE * num_input_proptables * proptable_format.bytes);
    proptable_aiocb = (struct aiocb *)
	calloc(BUFFERS_PER_PROPTABLE * num_input_proptables, sizeof(struct aiocb));
    proptable_buffer_index = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_current_buffernum = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_input_fds = (int *) calloc(num_input_proptables, sizeof(int));

    if ((proptable_buffer == NULL) || (proptable_input_fds == NULL)
	|| (proptable_buffer_index == NULL)) {
	fprintf(stderr, "Can't malloc proptable buffers in proptable_finalize()\n");
	return 0;
    }

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	rename("propfile_out", "propfile_in");
	proptable_input_fd = open("propfile_in", O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fd == -1) {
	    fprintf(stderr, "Can't open 'propfile_in' for reading propfile\n"); /* BREAKPOINT */
	    return 0;
	}
    }
#endif

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
#if SEPERATE_PROPTABLE_FILES
	sprintf(infilename, "propfile%04d_in", tablenum);
	sprintf(outfilename, "propfile%04d_out", tablenum);
	rename(outfilename, infilename);
	proptable_input_fds[tablenum] = open(infilename, O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fds[tablenum] == -1) {
	    fprintf(stderr, "Can't open '%s' for reading propfile\n", infilename);
	    return 0;
	}
#else
	proptable_input_fds[tablenum] = proptable_input_fd;
#endif
    }

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	int alignment = fpathconf(proptable_input_fds[tablenum], _PC_REC_XFER_ALIGN);

	for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	    if (posix_memalign((void **) &proptable_buffer[propbuf(tablenum, bufnum)],
			       alignment, PROPTABLE_BUFFER_BYTES) != 0) {
		fprintf(stderr, "Can't posix_memalign proptable buffer\n");
		return 0;
	    }
	}
    }

    /* I run this loop in the opposite direction from the last one because I want the reads
     * for the initial buffers for all the tables to be first in the queue.
     */

    for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_fildes = proptable_input_fds[tablenum];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_buf = proptable_buffer[propbuf(tablenum, bufnum)];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_sigevent.sigev_notify = SIGEV_NONE;
#if SEPERATE_PROPTABLE_FILES
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset = PROPTABLE_BUFFER_BYTES * bufnum;
#else
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset
		= tablenum * num_propentries * proptable_format.bytes + PROPTABLE_BUFFER_BYTES * bufnum;
#endif

	    if (aio_read(& proptable_aiocb[propbuf(tablenum, bufnum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }
	}
    }

    /* Wait for initial read to finish on each input proptable */

    gettimeofday(&tv1, NULL);

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	const struct aiocb * aiocbs[1];
	aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
	aio_suspend(aiocbs, 1, NULL);
    }

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_preload_time, &tv2);

    sorting_network = malloc(2*highbit * proptable_format.bytes);
    proptable_num = malloc(2*highbit * sizeof(int));

    if ((sorting_network == NULL) || (proptable_num == NULL)) {
	fprintf(stderr, "Can't malloc sorting network in proptable_finalize()\n");
	return 0;
    }

    /* Initialize the sorting network.
     *
     * First, fill in the upper half of the network with either the first entry from a proptable,
     * or an "infinite" entry for slots with no proptables.  Then, sort into the lower half
     * of the network.
     */

    for (i = 0; i < highbit; i ++) {
	if (i < num_input_proptables) {
	    fetch_next_propentry(i, SORTING_NETWORK_ELEM(highbit + i));
	    proptable_num[highbit + i] = i;
	} else {
	    /* XXX could be a problem if max_index + 1 won't fit in the index element */
	    set_propentry_index(SORTING_NETWORK_ELEM(highbit + i), proptable_tb->max_index + 1);
	    proptable_num[highbit + i] = -1;
	}
    }

    for (network_node = highbit-1; network_node > 0; network_node --) {
	if (get_propentry_index(SORTING_NETWORK_ELEM(2*network_node))
	    < get_propentry_index(SORTING_NETWORK_ELEM(2*network_node + 1))) {
	    memcpy(SORTING_NETWORK_ELEM(network_node),
		   SORTING_NETWORK_ELEM(2*network_node), proptable_format.bytes);
	    proptable_num[network_node] = proptable_num[2*network_node];
	} else {
	    memcpy(SORTING_NETWORK_ELEM(network_node),
		   SORTING_NETWORK_ELEM(2*network_node + 1), proptable_format.bytes);
	    proptable_num[network_node] = proptable_num[2*network_node+1];
	}
    }

    /* Now, process the data through the sorting network. */

    for (index = 0; index <= proptable_tb->max_index; index ++) {

	futurevector_t futurevector = 0;
	futurevector_t possible_futuremoves;

	if (get_propentry_index(SORTING_NETWORK_ELEM(1)) < index) {
	    fprintf(stderr, "Out-of-order entries in sorting network\n");   /* BREAKPOINT */
	}

	if (target_dtm == 0) {
	    possible_futuremoves = initialize_tablebase_entry(proptable_tb, index);
	}

	while (get_propentry_index(SORTING_NETWORK_ELEM(1)) == index ) {

#ifdef DEBUG_MOVE
	    if (index == DEBUG_MOVE)
		fprintf(stderr, "Commiting sorting element 1: %llx %llx\n",
			*((uint64 *) SORTING_NETWORK_ELEM(1)), *(((uint64 *) SORTING_NETWORK_ELEM(1)) + 1));
#endif

	    commit_proptable_entry(SORTING_NETWORK_ELEM(1));

	    if (get_propentry_futurevector(SORTING_NETWORK_ELEM(1)) & futurevector) {
		global_position_t global;
		index_to_global_position(proptable_tb, get_propentry_index(SORTING_NETWORK_ELEM(1)), &global);
		fprintf(stderr, "Futuremoves multiply handled: %s\n", global_position_to_FEN(&global));
	    }

	    futurevector |= get_propentry_futurevector(SORTING_NETWORK_ELEM(1));

	    fetch_next_propentry(proptable_num[1], SORTING_NETWORK_ELEM(highbit + proptable_num[1]));

	    network_node = highbit + proptable_num[1];

	    while (network_node > 1) {
		network_node >>= 1;
		if (get_propentry_index(SORTING_NETWORK_ELEM(2*network_node))
		    < get_propentry_index(SORTING_NETWORK_ELEM(2*network_node+1))) {
		    memcpy(SORTING_NETWORK_ELEM(network_node),
			   SORTING_NETWORK_ELEM(2*network_node), proptable_format.bytes);
		    proptable_num[network_node] = proptable_num[2*network_node];
		} else {
		    memcpy(SORTING_NETWORK_ELEM(network_node),
			   SORTING_NETWORK_ELEM(2*network_node + 1), proptable_format.bytes);
		    proptable_num[network_node] = proptable_num[2*network_node+1];
		}
	    }
	}

	/* Don't track futuremoves for illegal (DTM 1) positions */

	if ((target_dtm == 0) && (get_entry_DTM(proptable_tb, index) != 1)) {

	    if ((futurevector & possible_futuremoves) != futurevector) {
		global_position_t global;
		index_to_global_position(proptable_tb, index, &global);
		fprintf(stderr, "Futuremove discrepancy: %d %s\n", index, global_position_to_FEN(&global)); /* BREAKPOINT */
	    }

	    finalize_futuremove(proptable_tb, index, possible_futuremoves ^ futurevector);
	}

	/* Symmetry.
	 *
	 * The only case we really have to worry about here is diagonal symmetry, because in both
	 * horizontal and vertical symmetry all of the positions neatly double up, so anytime we'd
	 * have a move backprop into our symmetry restriction from outside it, a matching move will
	 * backprop from inside out.
	 *
	 * For diagnoal symmetry however, things aren't so neat, because squares along the diagonal
	 * map to themselves.  So positions where both kings are on the diagonal don't have a
	 * matching double, while the other positions do.  We deal with this here by backproping
	 * both the position itself and its matching pair (if one exists).  If one doesn't exist,
	 * then back_propagate_index_within_table() will quickly detect this case (when
	 * index_to_position returns false).  We also doubled the movecnt of "paired" positions
	 * during initialization, because moves will be backproped twice from doubled positions to
	 * doubled positions, not just assumed like the horizontal or vertical cases.
	 */

	if ((target_dtm != 0) && (get_entry_DTM(proptable_tb, index) == target_dtm)) {
	    back_propagate_index_within_table(proptable_tb, index, 0);
	    if (proptable_tb->symmetry == 8) {
		back_propagate_index_within_table(proptable_tb, index, 1);
	    }
	    positions_finalized ++;
	}

    }

    for (i = 0; i < num_input_proptables * BUFFERS_PER_PROPTABLE; i ++) {
	free(proptable_buffer[i]);
    }

    free(proptable_buffer_index);
    free(proptable_buffer);
    free(proptable_input_fds);

    free(sorting_network);
    free(proptable_num);

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	close(proptable_input_fd);
	unlink("propfile_in");
    }
#else
    for (i = 0; i < num_input_proptables; i ++) {
	close(proptable_input_fds[i]);
	sprintf(infilename, "propfile%04d_in", i);
	unlink(infilename);
    }
#endif

    /* Flush out anything in the last proptable, and wait for its write to complete */
    proptable_full();
    finalize_proptable_write();

    return positions_finalized;
}

/* target_dtm == 0 is special because the initialization / futurebase back prop pass
 *
 * Among other things, for pass 0 we've already set the start time when we began the futurebase back
 * prop.
 */

int propagation_pass(int target_dtm)
{
    index_t index;

    gettimeofday(&pass_start_times[total_passes], NULL);
    if (pass_type[total_passes] == NULL) pass_type[total_passes] = "intratable";
    pass_target_dtms[total_passes] = target_dtm;

    if (num_propentries != 0) {
	positions_finalized[total_passes] = proptable_finalize(target_dtm);
    } else {

	for (index = 0; index <= proptable_tb->max_index; index ++) {

	    /* Symmetry.
	     *
	     * The only case we really have to worry about here is diagonal symmetry, because in
	     * both horizontal and vertical symmetry all of the positions neatly double up, so
	     * anytime we'd have a move backprop into our symmetry restriction from outside it, a
	     * matching move will backprop from inside out.
	     *
	     * For diagnoal symmetry however, things aren't so neat, because squares along the
	     * diagonal map to themselves.  So positions where both kings are on the diagonal don't
	     * have a matching double, while the other positions do.  We deal with this here by
	     * backproping both the position itself and its matching pair (if one exists).  If one
	     * doesn't exist, then back_propagate_index_within_table() will quickly detect this case
	     * (when index_to_position returns false).  We also doubled the movecnt of "paired"
	     * positions during initialization, because moves will be backproped twice from doubled
	     * positions to doubled positions, not just assumed like the horizontal or vertical
	     * cases.
	     */

	    if ((target_dtm != 0) && (get_entry_DTM(proptable_tb, index) == target_dtm)) {
		back_propagate_index_within_table(proptable_tb, index, 0);
		if (proptable_tb->symmetry == 8) {
		    back_propagate_index_within_table(proptable_tb, index, 1);
		}
		positions_finalized[total_passes] ++;
	    }
	}

    }

    gettimeofday(&pass_end_times[total_passes], NULL);

    total_backproped_moves += backproped_moves[total_passes];

    if (positions_finalized[total_passes] > 0) {
	if (target_dtm > max_dtm) max_dtm = target_dtm;
	if (target_dtm < min_dtm) min_dtm = target_dtm;
    }

    fprintf(stderr, "Pass %3d complete; %d positions finalized\n", target_dtm, positions_finalized[total_passes]);

    total_passes ++;

    return positions_finalized[total_passes-1];
}

void insert_into_proptable(proptable_entry_t *pentry)
{
    int propentry;
    int zerooffset;
    index_t index = get_propentry_index(pentry);
    static int scaling_factor = 0;

    /* I had a bug here with the scaling_factor rounding down - that's why we increment by one */

    if (scaling_factor == 0) {
	scaling_factor = proptable_tb->max_index / num_propentries;
	scaling_factor ++;
	fprintf(stderr, "Scaling factor %d\n", scaling_factor);
    }

 retry:

    /* We need an index into the proptable that maintains the index sort order of the entries. */

    propentry = index / scaling_factor;

    if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	/* empty slot: insert at propentry */
	/* proptable[propentry] = entry; */
	insert_at_propentry(propentry, pentry);
	return;
    } else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	/* entry at slot with identical index: merge at propentry */
	/* proptable[propentry] += entry; */
	merge_at_propentry(propentry, pentry);
	return;
    } else if (get_propentry_index(PROPTABLE_ELEM(propentry)) > index) {
	/* entry at slot greater than index to be inserted */
	while ((get_propentry_index(PROPTABLE_ELEM(propentry)) > index) && (propentry > 0)) propentry --;
	if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	    /* empty slot at lower end of a block all gt than index: insert there */
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	    /* identical slot in a block: merge there */
	    /* proptable[propentry] += entry; */
	    merge_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) > index) {
	    /* we're at the beginning of the table and the first entry is gt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (get_propentry_index(PROPTABLE_ELEM(zerooffset)) == 0) {
		    /* proptable[1:zerooffset] = proptable[0:zerooffset-1]; */
		    memmove(proptable + proptable_format.bytes, proptable,
			    (zerooffset) * proptable_format.bytes);
		    /* proptable[0] = entry; */
		    insert_at_propentry(0, pentry);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* still in the block; propentry is lt index and propentry+1 is gt index: fall through */
	}
    } else {
	/* entry at slot less than index to be inserted */
	while ((get_propentry_index(PROPTABLE_ELEM(propentry)) != 0)
	       && (get_propentry_index(PROPTABLE_ELEM(propentry)) < index)
	       && (propentry < num_propentries - 1)) propentry ++;
	if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	    /* empty slot at upper end of a block all lt than index: insert there */
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	    /* identical slot in a block: merge there */
	    /* proptable[propentry] += entry; */
	    merge_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) < index) {
	    /* we're at the end of the table and the last entry is lt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (get_propentry_index(PROPTABLE_ELEM(num_propentries - 1 - zerooffset)) == 0) {
		    /* proptable[num_propentries-zerooffset-1 : num_propentrys-2]
		     *    = proptable[num_propentries-zerooffset : num_propentries-1];
		     */
		    memmove(proptable + (num_propentries - 1 - zerooffset) * proptable_format.bytes,
			    proptable + (num_propentries - zerooffset) * proptable_format.bytes,
			    (zerooffset) * proptable_format.bytes);
		    /* proptable[num_propentries-1] = entry; */
		    insert_at_propentry(num_propentries - 1, pentry);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* propentry is gt index and propentry-1 is lt index */
	    propentry --;
	}
    }

    /* We found a boundary within a block: propentry is lt index and propentry+1 is gt index */

    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
	if ((propentry + zerooffset < num_propentries - 1)
	    && (get_propentry_index(PROPTABLE_ELEM(propentry+zerooffset)) == 0)) {
	    /* proptable[propentry+2 : propentry+zerooffset]
	     *    = proptable[propentry+1 : propentry+zerooffset-1];
	     */
	    memmove(proptable + proptable_format.bytes * (propentry + 2),
		    proptable + proptable_format.bytes * (propentry + 1),
		    (zerooffset-1) * proptable_format.bytes);
	    /* proptable[propentry+1] = entry; */
	    insert_at_propentry(propentry+1, pentry);
	    return;
	}
	if ((propentry - zerooffset >= 0)
	    && (get_propentry_index(PROPTABLE_ELEM(propentry-zerooffset)) == 0)) {
	    /* proptable[propentry-zerooffset : propentry-1]
	     *    = proptable[propentry-zerooffset+1 : propentry];
	     */
	    memmove(proptable + proptable_format.bytes * (propentry - zerooffset),
		    proptable + proptable_format.bytes * (propentry - zerooffset + 1),
		    zerooffset * proptable_format.bytes);
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	}
    }

    /* zerooffset > MAX_ZEROOFFSET: ran of space - table is "full" */
    proptable_full();
    goto retry;
}

void insert_or_commit_propentry(proptable_entry_t *propentry)
{
    backproped_moves[total_passes] ++;

    if (num_propentries == 0) {
	commit_proptable_entry(propentry);
    } else {
	insert_into_proptable(propentry);
    }
}

void insert_or_commit_trivial_propentry(index_t index, short dtm, short movecnt,
					futurevector_t futurevector)
{
    char entry[MAX_FORMAT_BYTES];
    void *ptr = entry;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("insert_or_commit_trivial_proptable; index=%d; dtm=%d; movecnt=%d; futurevector=0x%llx\n",
	       index, dtm, movecnt, futurevector);
#endif

    memset(ptr, 0, proptable_format.bytes);

    set_unsigned_field(ptr, proptable_format.index_mask, proptable_format.index_offset, index);
    set_signed_field(ptr, proptable_format.dtm_mask, proptable_format.dtm_offset, dtm);
    set_unsigned_field(ptr, proptable_format.movecnt_mask, proptable_format.movecnt_offset, movecnt);
    set_unsigned64bit_field(ptr, proptable_format.futurevector_mask, proptable_format.futurevector_offset, futurevector);

#if 0
    /* Don't track futuremoves for illegal (DTM 1) positions */

    if ((proptable_tb->futurevectors != NULL) && (get_entry_DTM(proptable_tb, index) != 1)) {

	if ((futurevector & proptable_tb->futurevectors[index]) != futurevector) {
	    /* This could happen simply if the futuremove has already been considered */
	    /* XXX In particular, I need to turn this off right now for symmetric tablebases */
#if 0
	    global_position_t global;
	    index_to_global_position(proptable_tb, index, &global);
	    fprintf(stderr, "Futuremove discrepancy: %s\n", global_position_to_FEN(&global));
#endif
	    return;
	}

	proptable_tb->futurevectors[index] ^= futurevector;
    }
#endif

    insert_or_commit_propentry(ptr);
}


/***** FUTUREBASES *****/

/* Subroutines to backpropagate an individual index, or an individual local position (these are the
 * "mini" routines), or a set of local positions that differ only in the en passant square.
 *
 * The idea behind the en passant handling is this.  If we back propagate a position with the en
 * passant square set, then that's the only position we process.  If we back prop a position without
 * the en passant square set, then we process not only that position, but also any positions just
 * like it that have en passant set.  The idea being that we set en passant if we actually need it,
 * and we clear it if we don't need it, so if it's clear we need to process positions where it was
 * set, but we didn't use it.
 */

void propagate_index_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
				     short movecnt, int futuremove, index_t current_index)
{
    int dtm = get_entry_DTM(futurebase, future_index);

    if (futuremove == -1) {
	static int errors = 0;
	global_position_t global;

	index_to_global_position(tb, current_index, &global);
	fprintf(stderr, "Futuremove never assigned: %s %s\n",
		global_position_to_FEN(&global), movestr[futuremove]);

	if (errors++ == 10) exit(EXIT_FAILURE);
	return;
    }

    /* We insert even if dtm is zero because we have to track futuremoves */

    if (dtm > 0) {
	insert_or_commit_trivial_propentry(current_index, -dtm, movecnt, FUTUREVECTOR(futuremove));
    } else if (dtm < 0) {
	insert_or_commit_trivial_propentry(current_index, -dtm+1, movecnt, FUTUREVECTOR(futuremove));
    } else {
	insert_or_commit_trivial_propentry(current_index, 0, movecnt, FUTUREVECTOR(futuremove));
    }

#if 0
    /* This is pretty primitive, but we need to track the deepest mates during futurebase back prop
     * in order to know how deep we have to look during intra-table propagation.  We could improve
     * on this by only bumping dtm_limit if we called PTM_wins(), or if we called
     * add_one_to_PNTM_wins() and the move count went to zero.
     */

    if ((dtm > 0) && (*dtm_limit < dtm)) *dtm_limit = dtm;
    if ((dtm < 0) && (*dtm_limit < -dtm)) *dtm_limit = -dtm;
#endif
}

void propagate_minilocal_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_local_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

void propagate_mini_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = normalized_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* Back propagate promotion moves
 *
 * Passed a piece (a global position character) that the pawn is promoting into.  Searches
 * futurebase for positions with that piece on the last rank and back-props.
 */

void propagate_moves_from_promotion_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					       int invert_colors_of_futurebase,
					       int pawn)
{
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int true_pawn;
    int symmetry;
    int max_symmetry;

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    /* If we're back propagating from a futurebase with greater symmetry, then a single futurebase
     * index will correspond to several positions in the current tablebase.  We'll need to apply
     * some reflections to get those additional positions, so compute here how many of them we'll
     * need.  It's a fairly easy calculation, since our symmetry options are currently limited to
     * 1/2/4/8, so a simple ratio suffices, except if both tablebases have symmetry 8, in which case
     * the more complex effects of diagonal symmetry require a double conversion no matter what.
     */

    max_symmetry = futurebase->symmetry / tb->symmetry;
    if ((futurebase->symmetry == 8) && (tb->symmetry == 8)) max_symmetry = 2;

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (symmetry = 0; symmetry < max_symmetry; symmetry ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position (the pawn that
	     * promoted) and one piece extra (what it promoted into).  There can be no pieces on
	     * restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, symmetry, &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		missing_piece1 = conversion_result & 0xff;
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece == NONE) || missing_piece1 != pawn) {
		    fprintf(stderr, "Conversion error during promotion back-prop\n");  /* BREAKPOINT */
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != -1) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical pieces.
		 * Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.  If we've got
		 * a futurebase position with both queens on the back rank, then we have to consider the
		 * possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.  We can safely 'break' here due
		     * to identical pieces being sorted into ascending square number.  If we've
		     * backed up to an extra piece that isn't on the back rank, then there can't be
		     * any more identical pieces on the back rank.
		     */

		    if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
			break;

		    /* There has to be an empty square right behind where the pawn came from, and it
		     * has to be a legal (i.e, non-restricted) square for the pawn in our tablebase.
		     */

		    if (!(position.board_vector & BITVECTOR(promotion_sq - promotion_move))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move;

			/* Normalize the position, and back prop it. */

			normalize_position(tb, &position);

			true_pawn = position.permuted_piece[pawn];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								      promotions[true_pawn]
								      + futurebase->piece_type[extra_piece] - 1,
								      &position);

			/* We may be about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &=~ BITVECTOR(position.piece_position[pawn]);
		    }

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == tb->num_pieces) {
			    fprintf(stderr, "Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }
}

void propagate_moves_from_promotion_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
						       int invert_colors_of_futurebase,
						       int pawn)
{
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    int symmetry;
    int max_symmetry;
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int true_captured_piece;
    int true_pawn;

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    max_symmetry = futurebase->symmetry / tb->symmetry;
    if ((futurebase->symmetry == 8) && (tb->symmetry == 8)) max_symmetry = 2;

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (symmetry = 0; symmetry < max_symmetry; symmetry ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be two pieces missing from the local position (the pawn that
	     * promoted and the piece it captured) and one piece extra (what it promoted into).
	     * There can be no pieces on restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, symmetry, &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		missing_piece1 = conversion_result & 0xff;
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece == NONE) || (missing_piece1 != pawn) || (missing_piece2 == NONE)) {
		    fprintf(stderr, "Conversion error during promotion capture back-prop\n");  /* BREAKPOINT */
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != -1) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical
		 * pieces.  Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.
		 * If we've got a futurebase position with both queens on the back rank, then we
		 * have to consider the possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.  We can safely 'break' here due
		     * to identical pieces being sorted into ascending square number.  If we've
		     * backed up to an extra piece that isn't on the back rank, then there can't be
		     * any more identical pieces on the back rank.
		     */


		    if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
			break;

		    /* Put the piece that was captured onto the board on the promotion square. */

		    position.piece_position[missing_piece2] = promotion_sq;

		    /* Consider first a capture to the left (white's left).  There has to be an
		     * empty square where the pawn came from, and it has to be a legal (i.e,
		     * non-restricted) square for the pawn in our tablebase.
		     */

		    if ((COL(promotion_sq) != 0)
			&& !(position.board_vector & BITVECTOR(promotion_sq - promotion_move - 1))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move - 1))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move - 1;

			/* Back propagate the resulting position */

			normalize_position(tb, &position);

			true_captured_piece = position.permuted_piece[missing_piece2];
			true_pawn = position.permuted_piece[pawn];

			/* This function also back props any similar positions with one of the pawns
			 * from the side that didn't promote in an en passant state.
			 */

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								 futurecaptures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
								 &position);

			/* We're about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		    }

		    /* Now consider a capture to the right (white's right).  Again, there has to be
		     * an empty square where the pawn came from, and it has to be a legal (i.e,
		     * non-restricted) square for the pawn in our tablebase.
		     */

		    if ((COL(promotion_sq) != 7)
			&& !(position.board_vector & BITVECTOR(promotion_sq - promotion_move + 1))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move + 1))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move + 1;

			normalize_position(tb, &position);

			true_captured_piece = position.permuted_piece[missing_piece2];
			true_pawn = position.permuted_piece[pawn];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								 futurecaptures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
								 &position);

			/* We're about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		    }

		    /* Remove the piece from the promotion square, at least in board_vector.  We'll
		     * change its position next time around this do/while loop, if there's another
		     * possibility for the "extra" piece.
		     */

		    position.board_vector &= ~BITVECTOR(promotion_sq);

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == tb->num_pieces) {
			    fprintf(stderr, "Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }
}

/* Propagate moves from a futurebase that resulted from capturing one of the pieces in the current
 * tablebase.
 *
 * I'm thinking of changing that "invert_colors_of_futurebase" flag to be a subroutine that gets
 * passed in.  It could be a pointer to invert_colors_of_global_position to do what it does now.  Or
 * it could be a "reflect board around vertical axis" to move a d4 pawn to e4.  Also see my comments
 * on invert_colors_of_global position.
 */

void consider_possible_captures(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
				local_position_t *position,
				int capturing_piece, int captured_piece)
{
    int dir;
    struct movement *movementptr;
    int true_captured_piece;
    int true_capturing_piece;

    /* We only want to consider pieces of the side which captured... */

    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) return;

    /* Put the captured piece on the capturing piece's square (from the future position).  */

    position->piece_position[captured_piece] = position->piece_position[capturing_piece];

    /* When we finally convert the position to an index (in local_position_to_index()), we'll make a
     * copy of the position and normalize it by sorting the identical pieces so that they are in
     * ascending order.  But we have to at least be aware of this here, in order to figure out which
     * piece "actually" got captured (we're always called with captured_piece set to the last piece
     * number of any identical pieces), so we can figure out which futuremove number to use.
     */

    /* Now consider all possible backwards movements of the capturing piece. */

    if (tb->piece_type[capturing_piece] != PAWN) {

	/* If the square we put the captured piece on isn't legal for it, then don't consider this
	 * capturing piece in this future position any more.  This is after the "if" instead of
	 * before it because an en passant pawn capture is special, since then the capturing piece
	 * ends up on a different square from the captured piece.
	 */

	if (!(tb->semilegal_squares[captured_piece]
	      & BITVECTOR(position->piece_position[captured_piece]))) {
	    return;
	}

	for (dir = 0; dir < number_of_movement_directions[tb->piece_type[capturing_piece]]; dir++) {

	    /* Make sure we start each movement of the capturing piece from the capture square */

	    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

	    for (movementptr = movements[tb->piece_type[capturing_piece]][position->piece_position[capturing_piece]][dir];
		 (movementptr->vector & position->board_vector) == 0;
		 movementptr++) {

		/* We already checked that the captured piece was on a legal square
		 * for it.  Now check the capturing piece.
		 */

		if (! (tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

		/* Move the capturing piece, normalize the position, and back prop it.
		 *
		 * We have to figure out the "true" capturing and captured pieces, which might not
		 * be the pieces we started with (see comments on normalization).
		 *
		 * normalize_position() and denormalize_position() both update board_vector.  This
		 * is good for normalization because I want to check for en passant legality before
		 * I call local_position_to_index().  It just makes the code a little more robust at
		 * this point, because then there should be no reason for local_position_to_index()
		 * to return -1.  After denormalization though, we do want to clear the bit in
		 * board_vector for the capturing_piece, because we're about to move it somewhere
		 * else, and we don't want that for loop above us to get the idea that there's
		 * a piece on a square that's actually vacant.
		 */

		position->piece_position[capturing_piece] = movementptr->square;

		normalize_position(tb, position);

		true_capturing_piece = position->permuted_piece[capturing_piece];
		true_captured_piece = position->permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      position);

		denormalize_position(tb, position);
		position->board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

    } else {

	/* Yes, pawn captures are special */

	for (movementptr = capture_pawn_movements_bkwd[position->piece_position[capturing_piece]][tb->piece_color[capturing_piece]];
	     movementptr->square != -1;
	     movementptr++) {

	    /* Is there anything on the square the pawn had to capture from? */

	    if ((movementptr->vector & position->board_vector) != 0) continue;

	    /* Move back the capturing pawn and see if it came from a legal square for it. */

	    position->piece_position[capturing_piece] = movementptr->square;
	    if (! (tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

	    /* And if the captured piece is also on a legal square for it... */

	    if ((tb->semilegal_squares[captured_piece]
		 & BITVECTOR(position->piece_position[captured_piece]))) {

		normalize_position(tb, position);

		true_capturing_piece = position->permuted_piece[capturing_piece];
		true_captured_piece = position->permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      position);

		denormalize_position(tb, position);

		position->board_vector &= ~BITVECTOR(movementptr->square);

	    }

	    /* The en passant special case: if both the piece that captured and the piece that was
	     * captured are both pawns, and either a white pawn captured from the fifth rank, or a
	     * black pawn captured from the fourth, then there are two possible back prop positions
	     * - the obvious one we just handled, and the one where the captured pawn was in an en
	     * passant state.  We also make sure right away that the rank is clear where the pawn
	     * had to come from, and the rank is clear where the pawn had to go to, ensuring that an
	     * en passant move was even possible.
	     */

	    if ((tb->piece_type[captured_piece] == PAWN)
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]-8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]+8))) {

		if ((tb->piece_color[capturing_piece] == BLACK) && (ROW(movementptr->square) == 3)) {

		    /* A black pawn capturing a white one (en passant)
		     *
		     * The white pawn is actually a rank higher than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] += 8;

		    if ((tb->semilegal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			normalize_position(tb, position);

			true_capturing_piece = position->permuted_piece[capturing_piece];
			true_captured_piece = position->permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								      futurecaptures[true_capturing_piece][true_captured_piece],
								      position);

			denormalize_position(tb, position);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] -= 8;
		}

		if ((tb->piece_color[capturing_piece] == WHITE) && (ROW(movementptr->square) == 4)) {

		    /* A white pawn capturing a black one (en passant)
		     *
		     * The black pawn is actually a rank lower than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] -= 8;

		    if ((tb->semilegal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			normalize_position(tb, position);

			true_capturing_piece = position->permuted_piece[capturing_piece];
			true_captured_piece = position->permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								 futurecaptures[true_capturing_piece][true_captured_piece],
								 position);

			denormalize_position(tb, position);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] += 8;
		}
	    }

	}

    }

    /* Put the capturing piece back where it came from (on the capture square) so that we can use
     * this local position again (on another call to this function) to consider other potential
     * capturing pieces without having to copy or recreate the entire local position structure.
     */


    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

}

void propagate_moves_from_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					     int invert_colors_of_futurebase, int captured_piece)
{
    index_t future_index;
    local_position_t current_position;
    int piece;
    int symmetry;
    int max_symmetry;
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;

    max_symmetry = futurebase->symmetry / tb->symmetry;
    if ((futurebase->symmetry == 8) && (tb->symmetry == 8)) max_symmetry = 2;

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (symmetry = 0; symmetry < max_symmetry; symmetry ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position: the piece that
	     * was captured.  There could possibly be one piece on a restricted square, as well.  If
	     * so, then it must be the piece that moved in order to capture.
	     */

	    /* XXX If the futurebase is more liberal than the tablebase, then there will be
	     * positions with multiple restricted pieces that should be quietly ignored.
	     */

	    conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
									  symmetry,
									  tb, &current_position,
									  invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		missing_piece1 = conversion_result & 0xff;
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece != NONE) || (missing_piece1 != captured_piece) || (missing_piece2 != NONE)) {
		    fprintf(stderr, "Conversion error during capture back-prop\n");  /* BREAKPOINT */
		    continue;
		}

		/* Since the last move had to have been a capture move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (current_position.en_passant_square != -1) continue;

		/* Since the position resulted from a capture, we only want to consider future
		 * positions where the side to move is not the side that captured.
		 */

		if (current_position.side_to_move != tb->piece_color[captured_piece])
		    continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&current_position);

		if (restricted_piece == NONE) {

		    /* No pieces were on restricted squares.  Check them all. */

		    for (piece = 0; piece < tb->num_pieces; piece++) {

			consider_possible_captures(tb, futurebase, future_index, &current_position,
						   piece, captured_piece);
		    }

		} else {

		    /* One piece was on a restricted square.  It's the only possible capturing piece. */

		    consider_possible_captures(tb, futurebase, future_index, &current_position,
					       restricted_piece, captured_piece);

		}
	    }
	}
    }
}

/* A "normal" futurebase is one that's identical to our own in terms of the number and types
 * of pieces.  It differs only in the frozen positions of the pieces.
 *
 * XXX not sure how to handle symmetry changes here.  At the moment it's not an issue, since we
 * don't allow frozen pieces in symmetric tablebases.
 */

void propagate_moves_from_normal_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					    int invert_colors_of_futurebase)
{
    index_t future_index;
    local_position_t parent_position;
    local_position_t current_position; /* i.e, last position that moved to parent_position */
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int piece;
    int dir;
    struct movement *movementptr;
    int origin_square;

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* Translate the futurebase index into a local position.  We have exactly the same number
	 * and type of pieces here, but exactly one of them is on a restricted square (according to
	 * the current tablebase).  If more than one of them was on a restricted square, then
	 * there'd be no way we could get to this futurebase with a single move.  On the other hand,
	 * if none of them were on restricted squares, then this would be a position in the current
	 * tablebase.
	 */

	/* XXX If the futurebase is more liberal than the tablebase, then there will be positions
	 * with multiple restricted pieces that should be quietly ignored.
	 */

	conversion_result = translate_foreign_index_to_local_position(futurebase, future_index, 0,
								      tb, &current_position,
								      invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((missing_piece1 != NONE) || (extra_piece != NONE) || (restricted_piece == NONE)) {
		fprintf(stderr, "Conversion error during normal back-prop\n"); /* BREAKPOINT */
		continue;
	    }

	    piece = restricted_piece;

	    origin_square = current_position.piece_position[piece];

	    /* We've moving BACKWARDS in the game, so this has to be a piece of the player who is
	     * NOT TO PLAY here - this is the LAST move we're considering, not the next move.
	     */

	    if (tb->piece_color[piece] == current_position.side_to_move)
		continue;


	    /* If there are any en passant capturable pawns in the position, then the last move had
	     * to have been a pawn move.  In fact, in this case, we already know exactly what the
	     * last move had to have been.
	     */

	    if (current_position.en_passant_square != -1) {

		if (tb->piece_type[piece] != PAWN) continue;

		if (((tb->piece_color[piece] == WHITE)
		     && (current_position.piece_position[piece] != current_position.en_passant_square + 8))
		    || ((tb->piece_color[piece] == BLACK)
			&& (current_position.piece_position[piece] != current_position.en_passant_square - 8))) {

		    /* No reason to complain here.  Maybe some other pawn was the en passant pawn. */
		    continue;
		}

		flip_side_to_move_local(&current_position);
		current_position.en_passant_square = -1;

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);
		if (tb->piece_color[piece] == WHITE)
		    current_position.piece_position[piece] -= 16;
		else
		    current_position.piece_position[piece] += 16;

		current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		/* We never back out into a restricted position.  Since we've already decided
		 * that this is the only legal back-move from this point, well...
		 */

		if (! (tb->semilegal_squares[piece]
		       & BITVECTOR(current_position.piece_position[piece]))) {
		    continue;
		}

		propagate_local_position_from_futurebase(tb, futurebase, future_index,
							 futuremoves[piece][origin_square],
							 &current_position);

		continue;

	    }

	    /* Abuse of notation here.  We just want to keep a copy of current_position because we
	     * change it around a lot during the loops below.
	     */

	    parent_position = current_position;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    /* What about captures?  Well, first of all, there are no captures here!  We're
		     * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		     * Captures are handled by back-propagation from futurebases, not here in the
		     * movement code.  The piece moving had to come from somewhere, and that
		     * somewhere will now be an empty square, so once we've hit another piece along
		     * a movement vector, there's absolutely no need to consider anything further.
		     */

		    for (movementptr
			     = movements[tb->piece_type[piece]][parent_position.piece_position[piece]][dir];
			 (movementptr->vector & parent_position.board_vector) == 0;
			 movementptr++) {

			/* We never back out into a restricted position (obviously) */

			if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

			/* Back stepping a half move here involves several things: flipping the
			 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
			 * the piece (backwards), and considering a bunch of additional positions
			 * identical to the base position except that a single one of the pawns on the
			 * fourth or fifth ranks was capturable en passant.
			 *
			 * Of course, the only way we could have gotten an en passant pawn is if THIS
			 * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
			 * additional en passant positions is taken care of in
			 * propagate_one_move_within_table()
			 */

			flip_side_to_move_local(&current_position);

			/* I go to the trouble to update board_vector here so we can check en passant
			 * legality in propagate_one_move_within_table().
			 */

			current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

			current_position.piece_position[piece] = movementptr->square;

			current_position.board_vector |= BITVECTOR(movementptr->square);

			propagate_local_position_from_futurebase(tb, futurebase, future_index,
								 futuremoves[piece][origin_square],
								 &current_position);
		    }
		}

	    } else {

		/* Usual special case for pawns */

		for (movementptr = normal_pawn_movements_bkwd[parent_position.piece_position[piece]][tb->piece_color[piece]];
		     (movementptr->vector & parent_position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Do we have a backwards pawn move here?
		     *
		     * Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		     * created it.  We handle that as a special case above, so we shouldn't have to
		     * worry about clearing en passant pawns here - there should be none.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     *
		     * But we start with an extra check to make sure this isn't a double pawn move, it
		     * which case it would result in an en passant position, not the non-en passant
		     * position we are in now (en passant got taken care of in the special case above).
		     */

		    if (((movementptr->square - parent_position.piece_position[piece]) == 16)
			|| ((movementptr->square - parent_position.piece_position[piece]) == -16)) {
			continue;
		    }

		    current_position = parent_position;

		    flip_side_to_move_local(&current_position);

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

		    current_position.piece_position[piece] = movementptr->square;

		    current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		    propagate_local_position_from_futurebase(tb, futurebase, future_index,
							     futuremoves[piece][origin_square],
							     &current_position);

		}
	    }
	}
    }
}

/* compute_extra_and_missing_piece()
 *
 * See comments for translate_foreign_position_to_local_position(), since this function mimicks that
 * one, except that this function works on an entire tablebase, while the other one works on a
 * single position within the tablebase.
 */

boolean compute_extra_and_missing_pieces(tablebase_t *tb, tablebase_t *futurebase, char *filename)
{
    int piece;
    int future_piece;
    int piece_vector;
    int color;

    futurebase->extra_piece = -1;
    futurebase->missing_pawn = -1;
    futurebase->missing_non_pawn = -1;

    /* Check futurebase to make sure its move restriction(s) match our own */

    for (color = 0; color < 2; color ++) {
	if ((futurebase->move_restrictions[color] != RESTRICTION_NONE)
	    && (futurebase->move_restrictions[color]
		!= tb->move_restrictions[futurebase->invert_colors ? 1 - color : color])) {
	    fprintf(stderr, "'%s': Futurebase doesn't match move restrictions!\n", filename);
	    return 0;
	}
    }

    /* The futurebase can have different pieces than the current tablebase.  There can be a single
     * extra piece, as well as a missing pawn and/or a missing non-pawn.  Find them.
     */

    /* piece_vector - set a bit for every piece in current tablebase */
    piece_vector = (1 << tb->num_pieces) - 1;

    for (future_piece = 0; future_piece < futurebase->num_pieces; future_piece ++) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (! (piece_vector & (1 << piece))) continue;
	    if ((tb->piece_type[piece] == futurebase->piece_type[future_piece])
		&& ((!futurebase->invert_colors &&
		     (tb->piece_color[piece] == futurebase->piece_color[future_piece]))
		    || (futurebase->invert_colors &&
			(tb->piece_color[piece] != futurebase->piece_color[future_piece])))) {
		if ((tb->semilegal_squares[piece] & futurebase->semilegal_squares[future_piece])
		    != tb->semilegal_squares[piece]) {
		    /* This can be OK if we have piece and/or move restrictions in effect */
		    /* fprintf(stderr, "WARNING: matched a piece but futurebase is more restrictive\n"); */
		    piece_vector ^= (1 << piece);
		    break;
		} else {
		    piece_vector ^= (1 << piece);
		    break;
		}
	    }
	}
	if (piece == tb->num_pieces) {
	    if ((futurebase->extra_piece == -1) && (futurebase->piece_type[future_piece] != PAWN)) {
		futurebase->extra_piece = future_piece;
	    } else {
		fprintf(stderr, "'%s': Couldn't find future piece in tablebase\n", filename);
		return 0;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] != PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_non_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    if (piece_vector != 0) {
	fprintf(stderr, "'%s': Too many missing pieces in futurebase\n", filename);
	return 0;
    }

    return 1;
}

/* Back propagates from all the futurebases.
 *
 * Should be called after the tablebase has been initialized, but before intra-table propagation.
 *
 * Runs through the parsed XML control file, pulls out all the futurebases, and back-propagates each
 * one.
 *
 * Returns true, or false if something went wrong
 */

boolean back_propagate_all_futurebases(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;

    /* Fetch the futurebases from the XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//futurebase", context);
    if ((tb->num_pieces > 2) && xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fprintf(stderr, "No futurebases!\n");
    } else {
	int i;

	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * filename;
	    xmlChar * type;
	    xmlChar * colors_property;
	    tablebase_t * futurebase;
	    int piece;

	    filename = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "filename");

	    futurebase = preload_futurebase_from_file((char *) filename);

	    /* load_futurebase_from_file() already printed some kind of error message */
	    if (futurebase == NULL) return 0;

	    futurebase->invert_colors = 0;
	    colors_property = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "colors");
	    if (colors_property != NULL) {
		if (!strcasecmp((char *) colors_property, "invert")) futurebase->invert_colors = 1;
		xmlFree(colors_property);
	    }

	    if (! compute_extra_and_missing_pieces(tb, futurebase, (char *) filename)) return 0;

	    /* Various combinations of missing/extra pieces are legal for different futurebase
	     * types.
	     */

	    type = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "type");

	    if ((type != NULL) && !strcasecmp((char *) type, "capture")) {

		/* It's a capture futurebase.  Futurebase should have exactly one less piece than
		 * the current tablebase.
		 */

		if (futurebase->extra_piece != -1) {
		    fprintf(stderr, "'%s': Extra piece in capture futurebase\n", filename);
		    return 0;
		}

		if ((futurebase->missing_pawn != -1) && (futurebase->missing_non_pawn != -1)) {
		    fprintf(stderr, "'%s': Too many missing pieces in capture futurebase\n", filename);
		}

		if ((futurebase->missing_pawn == -1) && (futurebase->missing_non_pawn == -1)) {
		    fprintf(stderr, "'%s': No missing pieces in capture futurebase\n", filename);
		}

		piece = (futurebase->missing_pawn != -1)
		    ? futurebase->missing_pawn : futurebase->missing_non_pawn;

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_capture_futurebase(tb, futurebase, futurebase->invert_colors, piece);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "promotion")) {

		/* It's a promotion futurebase.  Futurebase should have exactly the same number of
		 * pieces as the current tablebase, and one of our pawns should have promoted into
		 * something else.  Determine what the pawn promoted into.
		 */

		if (futurebase->extra_piece == -1) {
		    fprintf(stderr, "'%s': No extra piece in promotion futurebase\n", filename);
		    return 0;
		}

		if (futurebase->missing_non_pawn != -1) {
		    fprintf(stderr, "'%s': Missing non-pawn in promotion futurebase\n", filename);
		}

		if (futurebase->missing_pawn == -1) {
		    fprintf(stderr, "'%s': No missing pawn in promotion futurebase\n", filename);
		}

		/* Ready to go. */

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_promotion_futurebase(tb, futurebase, futurebase->invert_colors,
							  futurebase->missing_pawn);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "promotion-capture")) {

		/* It's a promotion capture futurebase.  Futurebase should have exactly one less
		 * piece than the current tablebase, and one of our pawns should have promoted into
		 * something else.
		 */

		if (futurebase->extra_piece == -1) {
		    fprintf(stderr, "'%s': No extra piece in promotion capture futurebase\n", filename);
		    return 0;
		}

		if (futurebase->missing_non_pawn == -1) {
		    fprintf(stderr, "'%s': No missing non-pawn in promotion capture futurebase\n", filename);
		}

		if (futurebase->missing_pawn == -1) {
		    fprintf(stderr, "'%s': No missing pawn in promotion capture futurebase\n", filename);
		}


		/* Ready to go. */

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_promotion_capture_futurebase(tb, futurebase, futurebase->invert_colors,
								  futurebase->missing_pawn);

	    } else if ((type != NULL) && !strcasecmp((char *) type, "normal")) {

		if (futurebase->extra_piece != -1) {
		    fprintf(stderr, "'%s': Extra piece in normal futurebase\n", filename);
		    return 0;
		}

		if ((futurebase->missing_pawn != -1) || (futurebase->missing_non_pawn != -1)) {
		    fprintf(stderr, "'%s': Missing pieces in normal futurebase\n", filename);
		}

		fprintf(stderr, "Back propagating from '%s'\n", (char *) filename);

		propagate_moves_from_normal_futurebase(tb, futurebase, futurebase->invert_colors);

	    } else {

		fprintf(stderr, "'%s': Unknown back propagation type (%s)\n",
			(char *) filename, (char *) type);
		return 0;

	    }

	    unload_futurebase(futurebase);
	}
    }

    xmlXPathFreeContext(context);

    return 1;
}

/***** PRUNING *****/

/* If we don't want to fully analyze out the tree past the table we're now building, we prune some
 * possible futuremoves.  Of course, this will affect the accuracy of the table; the table is a
 * result of BOTH the position it was set up for AND the pruning decisions (and any pruning
 * decisions made on the futurebases used to calculate this one).
 *
 * We specify pruning in a simple way - by omitting future tables for moves we don't want to
 * consider.  This can be dangerous, so we require this feature to be specifically enabled.  Right
 * now, there are two possibilities we can specify in the XML control file; one to allow moves to be
 * DISCARDED; the other to allow victory to be CONCEDED to the side that makes the move.
 *
 * So, if we are white, and assuming that this is a table with a frozen white pawn on e3, we can
 * prune by simply ignoring Pe4 as a possible move.  If there is a black pawn on the g-file, and we
 * don't want to compute out what happens after it queens, we can prune by treating Pg1=X as a forced
 * win for black.
 *
 * We might want to "partially" prune a move like Pg1=X by looking a half-move into the future to
 * see if we can immediately take the new piece and simplify that way.  To do so, we would construct
 * a futurebase for the piece combination resulting after Pg1=X, probably leaving X frozen on g1,
 * make one pass through that futurebase (this is currently unimplemented) and flag everything else
 * a win for black.  This approach avoids having to step a half-move into the future during back
 * propagation.  The advantages of this are three-fold.  First, it simplifies the program, and
 * that's a big plus from a quality control standpoint.  Second, it avoids the random accesses that
 * would be required to probe into the tablebase, replacing them with a series of sequential sweeps,
 * and for a big tablebase that's probably a significant performance win.  Finally, it's a lot more
 * flexible.  We can make two, or three, or five sweeps through that tablebase, looking a few more
 * moves into the future for forced reductions.
 *
 * For example, let's say we're looking at a Q-and-P vs. Q-and-P endgame.  There are four completely
 * mobile pieces (2 Ks and 2 Qs), and this is easy.  But if one of the pawns queens, then we've got
 * a more complex game with five mobile pieces, and that's too complex.  But we don't want to
 * completely discard all possible enemy promotions, if we can immediately capture the new queen (or
 * the old one).  So we construct a special tablebase for a queen frozen on the queening square,
 * back prop a tablebase for a Q-and-P vs. Q endgame into it, make a pass or two through it, then
 * feed it into our current tablebase.
 *
 * And finally, we want to label in the file header that this pruning was done.  In particular, if
 * we use a pruned tablebase to compute another (earlier) pruned tablebase, we want to make sure the
 * pruning is consistent, i.e. "our" side has to stay the same.  This is guaranteed by explicitly
 * flagging in the XML header which sides can be pruned in which way (concede or discard).
 */

int all_futuremoves_handled = 1;
int max_complaints = 10;
futurevector_t unpruned_futuremoves;

void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector) {

    int futuremove;

    if (futurevector & unpruned_futuremoves) {
	global_position_t global;
	index_to_global_position(tb, index, &global);
	if (all_futuremoves_handled)
	    fprintf(stderr, "ERROR: Some futuremoves not handled under move restrictions!\n");
	fprintf(stderr, "%d %s", index, global_position_to_FEN(&global));
	for (futuremove = 0; futuremove < num_futuremoves; futuremove ++) {
	    if (futurevector & unpruned_futuremoves & FUTUREVECTOR(futuremove)) {
		fprintf(stderr, " %s", movestr[futuremove]);
	    }
	}
	fprintf(stderr, "\n");
	if ((-- max_complaints) == 0) exit(EXIT_FAILURE);
	all_futuremoves_handled = 0;		/* BREAKPOINT */
    }

    /* concede - we treat these unhandled futuremoves as forced wins for PTM */

    if (futurevector & conceded_futuremoves) {
	/* PTM_wins(tb, index, 1, 1); */
	/* We insert here with DTM=2 (mate in one), movecnt=1 (XXX), and no futuremove */
	/* XXX I bet we want to insert with position's multiplicity as movecnt */
	insert_or_commit_trivial_propentry(index, 2, 1, 0);
    }

    /* discard - we ignore these unhandled futuremoves by decrementing movecnt */

    if (futurevector & discarded_futuremoves) {
	for (futuremove = 0; futuremove < num_futuremoves; futuremove ++) {
	    if (futurevector & discarded_futuremoves & FUTUREVECTOR(futuremove)) {
		/* tb->entries[index].movecnt --; */
		/* XXX this isn't handled right - a draw is different from a discard */
		insert_or_commit_trivial_propentry(index, 0, 0, 0);
	    }
	}
    }
}

boolean have_all_futuremoves_been_handled(tablebase_t *tb) {

    index_t index;

    for (index = 0; index <= tb->max_index; index ++) {
	if (get_entry_DTM(tb, index) != 1) {
	    finalize_futuremove(tb, index, tb->futurevectors[index]);
	}
    }

    return all_futuremoves_handled;
}

/* assign_numbers_to_futuremoves()
 *
 * We could just dismiss any moves that aren't handled by our futurebases, but I've found this to be
 * a source of error, since moves tend to get overlooked this way.  We're also concerned with the
 * more sobering possibility of a single move getting processed twice.
 *
 * So we assign numbers, bit positions in a bit vector, actually, to each futuremove.  When we
 * initialize the tablebase, we set bits in the vector (each position has its own vector) for each
 * futuremove possible from that position.  As we back propagate futuremoves, we check the bit to
 * make sure it's still set, then clear it.  After we've back propagated all the futurebases, we run
 * through the entire tablebase, making sure that the only bits that remain set correspond to prune
 * statements.
 */

void assign_numbers_to_futuremoves(tablebase_t *tb) {

    uint64 frozen_vector = 0LL;
    int piece;
    int captured_piece;
    int capturing_piece;
    int sq;
    int dir;
    struct movement *movementptr;


    /* First, compute a bitvector for all the pieces that are frozen on single squares. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (sq = 0; sq < 64; sq ++) {
	    if (BITVECTOR(sq) == tb->semilegal_squares[piece]) {
		frozen_vector |= tb->semilegal_squares[piece];
		break;
	    }
	}
    }

    /* Next, consider all possible pairs of pieces that might capture, and assign a number (in the
     * futurecaptures array) to each pair.  We'll ultimately use this number as an index into a bit
     * vector to determine if this capture has been handled in any particular position.  However,
     * there's a common enough "special" case: the two pieces are frozen (or at least sufficiently
     * restricted) so that the capture can never occur.  Go to the trouble of checking for this.
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    futurecaptures[capturing_piece][captured_piece] = -1;

	    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) continue;

	    /* We run through the board either from end to start (if the capturing piece is white)
	     * or from start to end (if it's black) in order to make sure that pawn captures that
	     * result in promotions are considered before any other pawn captures, since promotion
	     * captures are treated as multiple moves, not just one.
	     */

	    for (sq = (tb->piece_color[capturing_piece] == WHITE ? 63 : 0);
		 tb->piece_color[capturing_piece] == WHITE ? (sq >= 0) : (sq <= 63);
		 tb->piece_color[capturing_piece] == WHITE ? sq-- : sq++) {

		if (tb->semilegal_squares[capturing_piece] & BITVECTOR(sq)) {
		    if (tb->piece_type[capturing_piece] != PAWN) {
			for (dir = 0; dir < number_of_movement_directions[tb->piece_type[capturing_piece]]; dir++) {
			    for (movementptr = movements[tb->piece_type[capturing_piece]][sq][dir];
				 movementptr->square != -1; movementptr++) {
				if (movementptr->vector & tb->semilegal_squares[captured_piece]) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
				/* If we hit a frozen piece, then this movement direction ends here */
				if (movementptr->vector & frozen_vector) break;
			    }
			}
		    } else {
			for (movementptr = capture_pawn_movements[sq][tb->piece_color[capturing_piece]];
			     movementptr->square != -1; movementptr++) {

			    if (movementptr->vector & tb->semilegal_squares[captured_piece]) {

				futurecaptures[capturing_piece][captured_piece] = num_futuremoves;

				/* a pawn capture that results in promotion - PROMOTION_POSSIBILTIES moves */

				if ((ROW(movementptr->square) == 0) || (ROW(movementptr->square) == 7)) {
				    num_futuremoves += PROMOTION_POSSIBILITIES;
				} else {
				    num_futuremoves ++;
				}
				goto next_pair_of_pieces;
			    }

			    /* if it's a pawn-takes-pawn situation, check for en passant as well */

			    if (tb->piece_type[captured_piece] == PAWN) {

				if ((tb->piece_type[capturing_piece] == WHITE) && (ROW(sq) == 4)
				    && (tb->semilegal_squares[captured_piece]
					& BITVECTOR(movementptr->square - 8))) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
				if ((tb->piece_type[capturing_piece] == BLACK) && (ROW(sq) == 3)
				    && (tb->semilegal_squares[captured_piece]
					& BITVECTOR(movementptr->square + 8))) {
				    futurecaptures[capturing_piece][captured_piece] = num_futuremoves;
				    num_futuremoves ++;
				    goto next_pair_of_pieces;
				}
			    }

			}
		    }
		}
	    }
	next_pair_of_pieces: ;
	}
    }

    /* We also want to consider all promotions.  We don't wrap this into the pawn code that follows
     * because we want to count all promotions together, not a set for each destination square.
     * This is a special case of a more general problem that this code doesn't address yet.  We want
     * to minimize the assigned numbers to keep the futuremove bit vector small, so we want to reuse
     * those numbers if we're sure that two moves can't happen from different squares.  I.e, if a
     * king is restricted to the f1/h3 rectangle, then it can move to e1 from f1 and it can move to
     * h4 from h3, but there is no single position from which it can move to both e1 and h4.  So we
     * can use the same position in the bit vector for Ke1 and Kh4.  But we don't (yet).
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	promotions[piece] = -1;
	if (tb->piece_type[piece] == PAWN) {
	    for (sq = (tb->piece_color[piece] == WHITE ? 48 : 8);
		 sq <= (tb->piece_color[piece] == WHITE ? 55 : 15); sq++) {
		if (tb->semilegal_squares[piece] & BITVECTOR(sq)) {
		    promotions[piece] = num_futuremoves;
		    num_futuremoves += PROMOTION_POSSIBILITIES;
		    break;
		}
	    }
	}
    }

    /* And now all piece moves outside their restriction.  We record a futuremove for each possible
     * destination square that the piece can reach outside its move restriction.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	for (sq = 0; sq < 64; sq ++) futuremoves[piece][sq] = -1;

	for (sq = 0; sq < 64; sq ++) {

	    if (! (tb->semilegal_squares[piece] & BITVECTOR(sq))) continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			 movementptr->square != -1; movementptr++) {

			/* If we hit a frozen piece, movement has to stop.  We don't consider
			 * captures here; they were handled above.
			 */

			if (movementptr->vector & frozen_vector) break;

			/* If the piece is moving outside its restricted squares, it's a futuremove */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square] = num_futuremoves;
				num_futuremoves ++;
			    }
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[sq][tb->piece_color[piece]];
		     movementptr->square != -1; movementptr++) {

		    /* If we hit a frozen piece, movement has to stop.  We don't consider captures
		     * here; they were handled above.
		     */

		    if (movementptr->vector & frozen_vector) break;

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			/* might want to put the promotion code here */

		    } else {

			/* If the pawn is moving outside its restricted squares, it's a futuremove */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square] = num_futuremoves;
				num_futuremoves ++;
			    }
			}
		    }
		}
	    }
	}
    }

    fprintf(stderr, "%d possible futuremoves\n", num_futuremoves);

    if (num_propentries == 0) {
	if (num_futuremoves > sizeof(futurevector_t)*8) {
	    fprintf(stderr, "Too many futuremoves - %d!  (only %d bits futurevector_t)\n",
		    num_futuremoves, sizeof(futurevector_t)*8);
	    exit(EXIT_FAILURE);
	}
    } else {
	if (num_futuremoves > proptable_format.futurevector_bits) {
	    fprintf(stderr, "Too many futuremoves - %d!  (only %d futurevector bits in proptable format)\n",
		    num_futuremoves, proptable_format.futurevector_bits);
	    exit(EXIT_FAILURE);
	}
    }
}

/* assign_pruning_statement() - a helper function for compute_pruned_futuremoves()
 *
 * searches the tablebase's XML pruning statements for one matching (more or less identically) the
 * specified color and string.  If there is a match, set the corresponding bit in the
 * pruned_futuremoves bit vector.  The function can be called more than once for a given bit.  For
 * example, the function might be called on the same bit for both "Pf6" and "Pany" (assuming there
 * is a white pawn frozen on f5).  If there are multiple prune statements that match a given bit, it
 * is currently undefined what happens, so we print an error message.
 */

void assign_pruning_statement(tablebase_t *tb, int color, char *pruning_statement, int futuremove)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int type;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_move = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "move");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");

	if (find_name_in_array((char *) prune_color, colors) != color) continue;

	type = find_name_in_array((char *) prune_type, restriction_types);

	if (!strcasecmp((char *) prune_move, pruning_statement)) break;
    }

    if (prune != result->nodesetval->nodeNr) {
	if (pruned_futuremoves & FUTUREVECTOR(futuremove)) {
	    fprintf(stderr, "WARNING: Multiple pruning statements ('%s') match a futuremove\n",
		    pruning_statement);
	}
	pruned_futuremoves |= FUTUREVECTOR(futuremove);
	if (type == RESTRICTION_CONCEDE) {
	    conceded_futuremoves |= FUTUREVECTOR(futuremove);
	}
	if (type == RESTRICTION_DISCARD) {
	    discarded_futuremoves |= FUTUREVECTOR(futuremove);
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);
}

/* This is where we parse pruning statements.  Fill in the pruned_futuremoves bit vector with bits
 * set for the various pruned moves.
 */

void compute_pruned_futuremoves(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int i;
    char movestr2[16];


    /* Check pruning statements for consistency */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");
	int color = find_name_in_array((char *) prune_color, colors);
	int type = find_name_in_array((char *) prune_type, restriction_types);

	if (type != tb->move_restrictions[color]) {
	    fprintf(stderr, "Pruning restrictions don't match tablebase restrictions\n");
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* for each possible captured_piece (i.e, everything but the two kings in piece numbers 0 and 1)
     * check for capture futurebases
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    if (futurecaptures[capturing_piece][captured_piece] != -1) {

		sprintf(movestr[futurecaptures[capturing_piece][captured_piece]], "%cx%c",
			piece_char[tb->piece_type[capturing_piece]],
			piece_char[tb->piece_type[captured_piece]]);

		assign_pruning_statement(tb, tb->piece_color[capturing_piece],
					 movestr[futurecaptures[capturing_piece][captured_piece]],
					 futurecaptures[capturing_piece][captured_piece]);
	    }
	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	if (tb->piece_type[pawn] != PAWN) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->semilegal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->semilegal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->semilegal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->semilegal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    if (futurecaptures[pawn][captured_piece] == -1) continue;

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		sprintf(movestr[futurecaptures[pawn][captured_piece] + i], "Px%c=%c",
			piece_char[tb->piece_type[captured_piece]],
			piece_char[promoted_pieces[i]]);

		assign_pruning_statement(tb, tb->piece_color[pawn],
					 movestr[futurecaptures[pawn][captured_piece] + i],
					 futurecaptures[pawn][captured_piece] + i);
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    sprintf(movestr[promotions[pawn] + i], "P=%c", piece_char[promoted_pieces[i]]);

	    assign_pruning_statement(tb, tb->piece_color[pawn], movestr[promotions[pawn] + i],
				     promotions[pawn] + i);
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (sq = 0; sq < 64; sq ++) {
	    if (futuremoves[piece][sq] != -1) {

		sprintf(movestr[futuremoves[piece][sq]], "%c%c%c", piece_char[tb->piece_type[piece]],
			'a' + COL(sq), '1' + ROW(sq));
		sprintf(movestr2, "%cany", piece_char[tb->piece_type[piece]]);

		assign_pruning_statement(tb, tb->piece_color[piece], movestr[futuremoves[piece][sq]],
					 futuremoves[piece][sq]);
		assign_pruning_statement(tb, tb->piece_color[piece], movestr2, futuremoves[piece][sq]);
	    }
	}
    }

    unpruned_futuremoves = ~pruned_futuremoves;
}


/* check_pruning()
 *
 * We run this function after we've assigned numbers to the futuremoves, but before we initialize
 * the tablebase.
 *
 * Check the futurebases to see if there are any for a given futuremove.  If not, check to make sure
 * the futuremove is pruned.  Otherwise, signal an error and exit right now.  Just because this test
 * is passed doesn't mean a particular futuremove is handled in a particular position (that's why we
 * use the bit vector), but if the test fails, well, then we know (almost) for sure that we'd get to
 * the end of program with unhandled futurebases, so we can save ourselves a long computation by
 * making this basic check now.
 *
 * There is an off chance that piece restrictions will prevent a futuremove from taking place, but
 * this code will conclude nevertheless that it is possible and demand either a prune statement or a
 * futurebase.  In this rare case, introducing an extraneous prune statement or two should solve the
 * problem.
 */

boolean check_pruning(tablebase_t *tb, int *max_dtm, int *min_dtm) {

    tablebase_t **futurebases;
    int num_futurebases;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int fbnum;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int futurebase_cnt;
    int i;


    /* First, preload all futurebases */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//futurebase", context);
    num_futurebases = result->nodesetval->nodeNr;
    futurebases = malloc(sizeof(tablebase_t *) * num_futurebases);
    if (futurebases == NULL) {
	fprintf(stderr, "Can't malloc futurebases array\n");
	return 0;
    }

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	xmlChar * filename;
	xmlChar * colors_property;

	filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "filename");
	futurebases[fbnum] = preload_futurebase_from_file((char *) filename);

	/* load_futurebase_from_file() already printed some kind of error message */
	if (futurebases[fbnum] == NULL) return 0;

	if (futurebases[fbnum]->symmetry < tb->symmetry) {
	    fprintf(stderr, "Futurebases can't be less symmetric than the tablebase under construction\n");
	    return 0;
	}

	if (futurebases[fbnum]->max_dtm > *max_dtm) *max_dtm = futurebases[fbnum]->max_dtm;
	if (futurebases[fbnum]->min_dtm < *min_dtm) *min_dtm = futurebases[fbnum]->min_dtm;

	futurebases[fbnum]->invert_colors = 0;
	colors_property = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "colors");
	if (colors_property != NULL) {
	    if (!strcasecmp((char *) colors_property, "invert")) futurebases[fbnum]->invert_colors = 1;
	    xmlFree(colors_property);
	}

	compute_extra_and_missing_pieces(tb, futurebases[fbnum], (char *)filename);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* for each possible captured_piece (i.e, everything but the two kings in piece numbers 0 and 1)
     * check for capture futurebases
     */

    for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	futurebase_cnt = 0;

	/* If we've going to consider a captured piece identical to this one, skip it.  Remember
	 * that compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to skip
	 * everything before it.
	 */
	if (tb->next_identical_piece[captured_piece] != -1) continue;

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if (tb->piece_type[captured_piece] == PAWN) {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
	    } else {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_non_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_pawn == -1)) futurebase_cnt ++;
	    }
	}

	/* If no such futurebase exists, then for every other piece, see if the piece restrictions
	 * would permit it to capture the original piece in question.  If so, there must be a prune
	 * statement, or it's an error.
	 */

	if (futurebase_cnt == 0) {

	    for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

		/* If we've going to consider a capturing piece identical to this one, skip it.
		 * Again, compute_extra_and_missing_pieces() uses the LAST identical piece, so we
		 * want to skip everything before it.
		 */
		if (tb->next_identical_piece[capturing_piece] != -1) continue;

		if (futurecaptures[capturing_piece][captured_piece] != -1) {

		    if (! (pruned_futuremoves & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]))) {
			fprintf(stderr, "No futurebase or pruning for %s move %s\n",
				colors[tb->piece_color[capturing_piece]],
				movestr[futurecaptures[capturing_piece][captured_piece]]);
			return 0;
		    }
		}
	    }

	} else if (futurebase_cnt > 1) {

	    /* Otherwise, a futurebase matched the capture.  Did more than one?  This is an error
	     * because then we might have two futurebases that would back prop into the same
	     * position with the same move.  Since we determine PNTM mates by counting down moves,
	     * this could result in the same move getting counted down twice.  We deal with this by
	     * making sure that only one futurebase of any given piece combo can exist.
	     *
	     * Once we get the bitvector working, we'll be able to make this check during
	     * move back propagation and won't need this code anymore.
	     */

	    fprintf(stderr, "Multiple futurebases for capturing %s's %s\n",
		    colors[tb->piece_color[captured_piece]],
		    piece_name[tb->piece_type[captured_piece]]);
	    return 0;

	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	int promoted_pieces_handled;

	if (tb->piece_type[pawn] != PAWN) continue;

	/* Again, compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to
	 * skip everything before it.
	 */

	if (tb->next_identical_piece[pawn] != -1) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 2; captured_piece < tb->num_pieces; captured_piece ++) {

	    /* If we've going to consider a captured piece identical to this one, skip it.  Again,
	     * compute_extra_and_missing_pieces() uses the LAST identical piece, so we want to skip
	     * everything before it.
	     */

	    if (tb->next_identical_piece[captured_piece] != -1) continue;

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->semilegal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->semilegal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->semilegal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->semilegal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    promoted_pieces_handled = 0;

	    if (futurecaptures[pawn][captured_piece] == -1) continue;

	    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
		if ((futurebases[fbnum]->extra_piece != -1)
		    && (futurebases[fbnum]->missing_non_pawn == captured_piece)
		    && (futurebases[fbnum]->missing_pawn == pawn)) {
		    if (promoted_pieces_handled
			& (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece])) {
			fprintf(stderr, "Multiple promotion capture futurebases for %s's Px%c=%c\n",
				colors[tb->piece_color[pawn]],
				piece_char[tb->piece_type[futurebases[fbnum]->missing_non_pawn]],
				piece_char[futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]]);
			return 0;
		    }
		    promoted_pieces_handled
			|= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);
		}
	    }

	    /* If no such futurebase exists, then for every other piece, see if the piece
	     * restrictions would permit it to capture the original piece in question.  If so, there
	     * must be a prune statement, or it's an error.
	     */

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		if (promoted_pieces_handled & (1 << promoted_pieces[i])) break;

		if (! (pruned_futuremoves & FUTUREVECTOR(futurecaptures[pawn][captured_piece] + i))) {
		    fprintf(stderr, "No futurebase or pruning for %s move %s\n",
			    colors[tb->piece_color[pawn]],
			    movestr[futurecaptures[pawn][captured_piece] + i]);
		    return 0;
		}
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	promoted_pieces_handled = 0;

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if ((futurebases[fbnum]->extra_piece != -1)
		&& (futurebases[fbnum]->missing_non_pawn == -1)
		&& (futurebases[fbnum]->missing_pawn == pawn)) {
		if (promoted_pieces_handled
		    & (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece])) {
		    fprintf(stderr, "Multiple promotion futurebases for %s's P=%c\n",
			    colors[tb->piece_color[pawn]],
			    piece_char[futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]]);
		    return 0;
		}
		promoted_pieces_handled
		    |= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);
	    }
	}

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    if (promoted_pieces_handled & (1 << promoted_pieces[i])) break;

	    if (! (pruned_futuremoves & FUTUREVECTOR(promotions[pawn] + i))) {

		fprintf(stderr, "No futurebase or pruning for %s move %s\n",
			colors[tb->piece_color[pawn]], movestr[promotions[pawn] + i]);
		return 0;
	    }
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    futurebase_cnt = 0;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	if ((futurebases[fbnum]->extra_piece == -1)
	    && (futurebases[fbnum]->missing_pawn == -1)
	    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
    }

    if (futurebase_cnt == 0) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (sq = 0; sq < 64; sq ++) {
		if (futuremoves[piece][sq] != -1) {

		    if (! (pruned_futuremoves & FUTUREVECTOR(futuremoves[piece][sq]))) {
			fprintf(stderr, "No futurebase or pruning for %s move %s\n",
				colors[tb->piece_color[piece]], movestr[futuremoves[piece][sq]]);
			return 0;
		    }
		}
	    }
	}
    } else if (futurebase_cnt > 1) {
	fprintf(stderr, "Multiple futurebases for restricted moves\n");
	return 0;
    }

    /* Unload the futurebases (for now; we'll need them again later) */

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	unload_futurebase(futurebases[fbnum]);
    }

    return 1;
}


/***** INTRA-TABLE MOVE PROPAGATION *****/

/* We've got a move that needs to be propagated, so we back out one half-move to all of the
 * positions that could have gotten us here and update their counters in various obscure ways.
 */

void propagate_one_minimove_within_table(tablebase_t *tb, index_t future_index, local_position_t *current_position)
{
    index_t current_index;
    int dtm = get_entry_DTM(tb, future_index);

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup position in intratable propagation!\n");
#endif
	return;
    }

#ifdef DEBUG_MOVE
    if (current_index == DEBUG_MOVE)
	printf("propagate_one_minimove_within_table:  current_index=%d; dtm=%d\n", current_index, dtm);
#endif

    /* Parent position is the FUTURE position.  We now back-propagate to
     * the current position, which is the PAST position.
     *
     * If the player to move in the FUTURE position wins, then we add one to that
     * player's win count in the PAST position.  On other other hand, if the player not
     * to move in the FUTURE position wins, then the player to move in the PAST position
     * has a winning move (the one we're considering).
     */

#if 0
    if (dtm > 0) {
	insert_or_commit_trivial_propentry(current_index, -dtm, current_position->multiplicity, 0);
    } else if ((dtm < 0) && (dtc < STALEMATE_COUNT)) {
	insert_or_commit_trivial_propentry(current_index, -dtm+1, current_position->multiplicity, 0);
    }
#else
    if (dtm > 0) {
	insert_or_commit_trivial_propentry(current_index, -dtm, 1, 0);
    } else if (dtm < 0) {
	insert_or_commit_trivial_propentry(current_index, -dtm+1, 1, 0);
    }
#endif
}

void propagate_one_move_within_table(tablebase_t *tb, index_t future_index, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_one_minimove_within_table(tb, future_index, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I've taken care to update board_vector in the routine that calls here specifically so
	     * we can check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* back_propagate_index_within_table()
 *
 * Once the final status of an index has been determined, this function back propagates all moves
 * (within the tablebase) from the corresponding position.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int symmetry)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    /* This can fail if the symmetry isn't valid for this index */

    if (! index_to_local_position(tb, index, symmetry, &position)) return;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	fprintf(stderr, "back_propagate_index_within_table; index=%d\n", index);
#endif

    /* Track "player wins" statistics.  We want to count each finalized position once, so we only
     * increment if 'symmetry' is zero.  Also, we don't want to count illegal (PNTM mated)
     * positions, so we don't increment anything if DTM is 1.
     */

    if (symmetry == 0) {
	if (get_entry_DTM(tb, index) > 1) {
	    player_wins[position.side_to_move] ++;
	} else if (get_entry_DTM(tb, index) < 0) {
	    player_wins[1 - position.side_to_move] ++;
	}
    }

    flip_side_to_move_local(&position);

    /* If there are any en passant capturable pawns in the position, then the last move had to
     * have been a pawn move.  In fact, in this case, we already know exactly what the last move
     * had to have been.
     */

    if (position.en_passant_square != -1) {

	int en_passant_pawn = -1;

	for (piece = 0; piece < tb->num_pieces; piece++) {

	    if (tb->piece_color[piece] != position.side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    if (((tb->piece_color[piece] == WHITE)
		 && (position.piece_position[piece] - 8 == position.en_passant_square))
		|| ((tb->piece_color[piece] == BLACK)
		    && (position.piece_position[piece] + 8 == position.en_passant_square))) {
		if (en_passant_pawn != -1) fprintf(stderr, "Two en passant pawns in back prop?!\n");
		en_passant_pawn = piece;
	    }
	}
	if (en_passant_pawn == -1) {
	    fprintf(stderr, "No en passant pawn in back prop!?\n");
	} else {

	    position.en_passant_square = -1;

	    /* I go to the trouble to update board_vector here so we can check en passant
	     * legality in propagate_one_move_within_table().
	     */

	    position.board_vector &= ~BITVECTOR(position.piece_position[en_passant_pawn]);

	    if (tb->piece_color[en_passant_pawn] == WHITE)
		position.piece_position[en_passant_pawn] -= 16;
	    else
		position.piece_position[en_passant_pawn] += 16;

	    position.board_vector |= BITVECTOR(position.piece_position[en_passant_pawn]);

	    /* We never back out into a restricted position.  Since we've already decided that this
	     * is the only legal back-move from this point, well...
	     */

	    if (! (tb->semilegal_squares[en_passant_pawn]
		   & BITVECTOR(position.piece_position[en_passant_pawn]))) {
		return;
	    }

	    propagate_one_move_within_table(tb, index, &position);
	}

	return;
    }

    /* foreach (mobile piece of player NOT TO PLAY) { */

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We've moving BACKWARDS in the game, so we want the pieces of the player who is NOT TO
	 * PLAY here - this is the LAST move we're considering, not the next move.
	 */

	if (tb->piece_color[piece] != position.side_to_move)
	    continue;

	origin_square = position.piece_position[piece];

	position.board_vector &= ~BITVECTOR(origin_square);

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		/* What about captures?  Well, first of all, there are no captures here!  We're
		 * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		 * Captures are handled by back-propagation from futurebases, not here in the
		 * movement code.  The piece moving had to come from somewhere, and that somewhere
		 * will now be an empty square, so once we've hit another piece along a movement
		 * vector, there's absolutely no need to consider anything further.
		 */

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS
		     * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     */

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    position.piece_position[piece] = movementptr->square;

		    position.board_vector |= BITVECTOR(movementptr->square);

		    propagate_one_move_within_table(tb, index, &position);

		    position.board_vector &= ~BITVECTOR(movementptr->square);
		}
	    }

	} else {

	    /* Usual special case for pawns */

	    for (movementptr = normal_pawn_movements_bkwd[origin_square][tb->piece_color[piece]];
		 (movementptr->vector & position.board_vector) == 0;
		 movementptr++) {

		/* We never back out into a restricted position (obviously) */

		if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		/* Do we have a backwards pawn move here?
		 *
		 * Back stepping a half move here involves several things: flipping the
		 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		 * the piece (backwards), and considering a bunch of additional positions
		 * identical to the base position except that a single one of the pawns on the
		 * fourth or fifth ranks was capturable en passant.
		 *
		 * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		 * created it.  We handle that as a special case above, so we shouldn't have to
		 * worry about clearing en passant pawns here - there should be none.  Checking
		 * additional en passant positions is taken care of in
		 * propagate_one_move_within_table()
		 *
		 * But we start with an extra check to make sure this isn't a double pawn move, it
		 * which case it would result in an en passant position, not the non-en passant
		 * position we are in now (en passant got taken care of in the special case above).
		 */

		if (((movementptr->square - origin_square) == 16)
		    || ((movementptr->square - origin_square) == -16)) {
		    continue;
		}

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		position.piece_position[piece] = movementptr->square;

		position.board_vector |= BITVECTOR(movementptr->square);

		propagate_one_move_within_table(tb, index, &position);

		position.board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

	position.piece_position[piece] = origin_square;
	position.board_vector |= BITVECTOR(origin_square);
    }
}

/* initialize_tablebase()
 *
 * This is another critical function; don't be deceived by the tame word 'initialize'.
 *
 * We determine that a position is won for the player not to move (PNTM) if all possible moves (of
 * the player to move) lead to a won game for PNTM.  We count down this total during back
 * propagation, so it stands to reason that we need an accurate count to start with.  Thus the
 * importance of this function.
 *
 * Basically, there are two types of moves we need to consider in each position:
 *
 * 1. non-capture, non-promotion, non-restricted moves
 *
 * We just add these up and then count them down during intra-table propagation, depending on the
 * integrity of the program's algorithm to make sure that every move counted forward gets considered
 * as a move backward.
 *
 * 2. everything else (futuremoves)
 *
 * These always lead to a different tablebase (a futurebase).  The only way we handle them is
 * through inter-table back propagation.  We keep a seperate count of futuremoves because, unlike
 * intratable moves, we might miss some of these moves if we don't have a complete set of
 * futurebases.  So we count futuremoves by themselves (as well as part of the standard count), and
 * count them down normally during a single sweep through our futurebases.  If that takes care of
 * everything fine.  Otherwise, during our first pass through the current tablebase, we'll find that
 * some of the futuremoves remain unaccounted for.  If they occur with the "good guys" as PTM, we
 * just double-check that the restriction is OK, subtract the remaining futuremoves out from the
 * standard count, and keep going.  But if the "bad guys" are PTM, then some more work is needed.
 * The position is marked won for PTM, unless we want to step forward another half move.  In this
 * case, we compute all possible next moves (or maybe just captures), and search for them in our
 * tablebases.  If any of them are marked drawn or won, we can safely back-propagate this.
 * Otherwise, the position has to be marked won for PTM, as before.
 *
 * There's a real serious speed penalty here, because this half-move-forward algorithm requires
 * random access lookups in the futurebases.  A possible way to address this would be to create an
 * intermediate tablebase for the half move following the capture/promotion.  This could be done by
 * building a tablebase with a queen (and another one with a knight) frozen on the queening square.
 * Any possible move of the queen or knight would result in a win for the moving side.  A similar
 * shortcut could be done for a capture, though the only real justification (from a performance
 * perspective) would be on promotions.
 *
 */

int PTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    struct movement *movementptr;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is NOT to move... */

	if (tb->piece_color[piece] == position->side_to_move) continue;

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][position->piece_position[piece]][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[position->piece_position[piece]][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

	    }
	}
    }

    return 0;
}

int PNTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    struct movement *movementptr;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is to move... */

	if (tb->piece_color[piece] != position->side_to_move) continue;

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][position->piece_position[piece]][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[position->piece_position[piece]][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[BLACK_KING])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[WHITE_KING])) return 1;

	    }
	}
    }

    return 0;
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index)
{
    local_position_t position;
    int piece;
    int dir;
    struct movement *movementptr;
    int i;

    if (! index_to_local_position(tb, index, 0, &position)) {

	initialize_entry_as_illegal(tb, index);
	return 0;

    } else {

	/* Now we need to count moves.  FORWARD moves. */
	int movecnt = 0;
	int futuremovecnt = 0;
	futurevector_t futurevector = 0;

	/* En passant:
	 *
	 * We're just counting moves here.  In particular, we don't compute the indices of the
	 * resulting positions.  If we did, we'd have to worry about clearing en passant status
	 * from any of fourth or fifth rank pawns, but we don't have to worry about it.
	 *
	 * We do have to count one or two possible extra en passant pawn captures, though...
	 */


	for (piece = 0; piece < tb->num_pieces; piece++) {

	    /* We only want to consider pieces of the side which is to move... */

	    if (tb->piece_color[piece] != position.side_to_move)
		continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][position.piece_position[piece]][dir];
			 (movementptr->vector & position.board_vector) == 0;
			 movementptr++) {

#if CHECK_KING_LEGALITY_EARLY
			if (piece == WHITE_KING) {
			    if (! check_king_legality(movementptr->square, position.piece_position[BLACK_KING])) continue;
			}
			if (piece == BLACK_KING) {
			    if (! check_king_legality(movementptr->square, position.piece_position[WHITE_KING])) continue;
			}
#endif

			/* If a piece is moving outside its restricted squares, we regard this
			 * as a futurebase (since it will require back prop from futurebases)
			 */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			    }
			    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
			    futuremovecnt ++;
			}

			movecnt ++;

		    }

		    /* Now check to see if the movement ended because we hit against another piece
		     * of the opposite color.  If so, add another move for the capture.
		     *
		     * Actually, we check to see that we DIDN'T hit a piece of our OWN color.  The
		     * difference is that this way we don't register a capture if we hit the end of
		     * the list of movements in a given direction.
		     *
		     * We also check to see if the capture was against the enemy king! in which case
		     * this position is a "mate in 0" (i.e, illegal)
		     */

#if CHECK_KING_LEGALITY_EARLY
		    if (piece == WHITE_KING) {
			if (! check_king_legality(movementptr->square, position.piece_position[BLACK_KING]))
			    continue;
		    }
		    if (piece == BLACK_KING) {
			if (! check_king_legality(movementptr->square, position.piece_position[WHITE_KING]))
			    continue;
		    }
#endif
		    if ((movementptr->vector & position.PTM_vector) == 0) {
			movecnt ++;
			for (i = 0; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if ((i == BLACK_KING) || (i == WHITE_KING)) {
				    initialize_entry_with_PNTM_mated(tb, index);
				    return 0;
				}
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match capture!\n"); /* BREAKPOINT */
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[position.piece_position[piece]][tb->piece_color[piece]];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* If the piece is a pawn and we're moving to the last rank, then this has
		     * to be a promotion move, in fact, PROMOTION_POSSIBILITIES moves.  (queen,
		     * knight, maybe rook and bishop).  As such, they will require back
		     * propagation from futurebases and must therefore be flagged as
		     * futuremoves.
		     */

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			if (futurevector & FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES)) {
			    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			}
			futurevector |= FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES);
			futuremovecnt += PROMOTION_POSSIBILITIES;

			movecnt += PROMOTION_POSSIBILITIES;

		    } else {

			/* If a piece is moving outside its restricted squares, we regard this
			 * as a futurebase (since it will require back prop from futurebases)
			 */

			if (!(tb->semilegal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
			    }
			    futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
			    futuremovecnt ++;
			}

			movecnt ++;

		    }

		}


		/* Pawn captures.
		 *
		 * In this part of the code, we're just counting forward moves, and all captures
		 * are futurebase moves, so the only difference to us whether this is a
		 * promotion move or not is how many futuremoves get recorded.
		 */

		for (movementptr = capture_pawn_movements[position.piece_position[piece]][tb->piece_color[piece]];
		     movementptr->square != -1;
		     movementptr++) {

		    /* A special check for en passant captures.  */

		    if (movementptr->square == position.en_passant_square) {
			movecnt ++;
			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square + (tb->piece_color[piece] == WHITE ? -8 : 8)
				== position.piece_position[i]) {
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			continue;
		    }

		    if (((movementptr->vector & position.board_vector) == 0)
			|| ((movementptr->vector & position.PTM_vector) != 0)) continue;

		    /* Same check as above for a mated situation */

		    if (position.side_to_move == WHITE) {
			if (movementptr->square == position.piece_position[BLACK_KING]) {
			    initialize_entry_with_PNTM_mated(tb, index);
			    return 0;
			}
		    } else {
			if (movementptr->square == position.piece_position[WHITE_KING]) {
			    initialize_entry_with_PNTM_mated(tb, index);
			    return 0;
			}
		    }

		    /* If the piece is a pawn and we're moving to the last rank, then this has
		     * to be a promotion move, in fact, PROMOTION_POSSIBILITIES moves.  (queen,
		     * knight, maybe rook and bishop).  As such, they will require back
		     * propagation from futurebases and must therefore be flagged as
		     * futuremoves.
		     */

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			movecnt += PROMOTION_POSSIBILITIES;

			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if (futurevector & FUTUREVECTORS(futurecaptures[piece][i],
								 PROMOTION_POSSIBILITIES)) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTORS(futurecaptures[piece][i],
							      PROMOTION_POSSIBILITIES);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match promotion capture!\n"); /* BREAKPOINT */
			}

		    } else {

			movecnt ++;

			for (i = 2; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
				    fprintf(stderr, "Duplicate futuremove!\n"); /* BREAKPOINT */
				}
				futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				futuremovecnt ++;
				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fprintf(stderr, "Couldn't match pawn capture!\n"); /* BREAKPOINT */
			}

		    }

		}

	    }

	}

	/* Finally, we want to determine is if we're in check.  This is significant because if
	 * and when we decide there are no valid moves out of this position, being in check is
	 * the difference between this being checkmate or stalemate.  We note being in check by
	 * setting the high order bit in the unsigned char movecnt.
	 */

	if (movecnt == 0) {
	    if (PTM_in_check(tb, &position)) {
		initialize_entry_with_PTM_mated(tb, index);
	    } else {
		initialize_entry_with_stalemate(tb, index);
	    }
	    return 0;
	} else {

	    total_moves += movecnt;
	    total_futuremoves += futuremovecnt;

	    /* What's this?  Well, diagonal symmetry is more difficult to handle than other types of
	     * symmetry because the piece along the diagonal don't actually move when you reflect
	     * the board.  So, here, we double the movecnt to account for the symmetry so long as
	     * the white king isn't on the a1/h8 diagonal.
	     *
	     * Other kinds of symmetry (horizontal and vertical) we can basically ignore at this
	     * point, but please explain why.
	     */

	    /* Symmetry and multiplicty.  If we're using a symmetric index, then there might be more
	     * than one actual board position that corresponds to a given index value.  The number
	     * of non-identical board positions for a given index is called its multiplicity.  So
	     * here we multiply the movecnt by the multiplicity of the position to get the total
	     * number of moves out of all possible positions that correspond to this index.
	     */

	    movecnt *= position.multiplicity;

	    initialize_entry_with_movecnt(tb, index, movecnt, PTM_in_check(tb, &position));

#ifdef DEBUG_MOVE
	    if (index == DEBUG_MOVE) {
		/* other fields were printed by DEBUG_MOVE statement in initialize_entry() */
		fprintf(stderr, "   futurevector 0x%llx\n", futurevector);
	    }
#endif

	    return futurevector;
	}
    }
}

void initialize_tablebase(tablebase_t *tb)
{
    index_t index;

    for (index=0; index <= tb->max_index; index++) {
	tb->futurevectors[index] = initialize_tablebase_entry(tb, index);
    }
}

/* Intra-table propagation is almost trivial.  Keep making passes over the tablebase first until
 * we've hit dtm_limit, which means we've processed everything from the futurebases, then until no
 * more progress is made on a given pass.
 */

void propagate_all_moves_within_tablebase(tablebase_t *tb, int lower_dtm_limit, int upper_dtm_limit)
{
    int dtm = 1;

    while ((dtm <= upper_dtm_limit) || (-dtm >= lower_dtm_limit)) {

	/* PTM wins */
	propagation_pass(dtm);

	/* PNTM wins */
	propagation_pass(-dtm);

	dtm ++;
    }

    while (1) {

	/* PTM wins */
	if (propagation_pass(dtm) == 0) break;

	/* PNTM wins */
	if (propagation_pass(-dtm) == 0) break;

	dtm ++;
    }

}

void write_tablebase_to_file(tablebase_t *tb, char *filename, char *options)
{
    xmlDocPtr doc;
    int fd;
    int index;
    FILE *file;
    xmlNodePtr tablebase;
    xmlChar *buf;
    int size;
    int padded_size;
    char str[16];
    char entrybuf[MAX_FORMAT_BYTES];
    void *entry = entrybuf;
    int dtm;
    int raw_dtm;

    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (fd == -1) {
	fprintf(stderr, "Can't open '%s' for writing tablebase\n", filename);
	return;
    }

    doc = finalize_XML_header(tb, options);

    /* We want at least one zero byte after the XML header, because that's how we figure out where
     * it ends when we read it back it, and I also want to align the tablebase on a four-byte
     * boundary for the hell of it.  (size+5)&(~3) achieves these goals.  I then modify the XML
     * header with the updated string that gives the offset to the tablebase, and make sure that its
     * size hasn't changed.
     */

    xmlDocDumpMemory(doc, &buf, &size);
    padded_size = (size+5)&(~3);

    sprintf(str, "0x%04x", padded_size);

    tablebase = xmlDocGetRootElement(doc);
    xmlSetProp(tablebase, BAD_CAST "offset", BAD_CAST str);

    xmlDocDumpMemory(doc, &buf, &size);

    if (padded_size != ((size+5)&(~3))) {
	fprintf(stderr, "sizes don't match in write_tablebase_to_file\n");
    }

    do_write(fd, buf, size);
    xmlFree(buf);
    close(fd);

    file = fopen(filename, "a");
    if (file == NULL) {
	fprintf(stderr, "Can't fopen output file\n");
    } else {
	while (ftell(file) < padded_size) {
	    fputc(0, file);
	}
	for (index = 0; index <= tb->max_index; index ++) {

	    dtm = get_entry_DTM(tb, index);
	    raw_dtm = get_entry_raw_DTM(tb, index);

	    if (tb->format.dtm_bits > 0) {
		/* If we're saving movecnt, then use the raw DTM, else "cook" it. */
		set_signed_field(entry, tb->format.dtm_mask,
				 tb->format.dtm_offset + ((index << tb->format.bits) % 8),
				 (tb->format.movecnt_bits > 0) ? raw_dtm : dtm);
	    }

	    if (tb->format.movecnt_bits > 0) {
		int movecnt = get_entry_movecnt(tb, index);
		set_unsigned_field(entry, tb->format.movecnt_mask,
				   tb->format.movecnt_offset + ((index << tb->format.bits) % 8),
				   movecnt);
	    }

	    switch (tb->format.flag_type) {
	    case FORMAT_FLAG_WHITE_WINS:
		set_unsigned_field(entry, 1,
				   tb->format.flag_offset + ((index << tb->format.bits) % 8),
				   ((index_to_side_to_move(tb, index) == WHITE ? dtm : -dtm) > 0) ? 1 : 0);
		break;
	    case FORMAT_FLAG_WHITE_DRAWS:
		set_unsigned_field(entry, 1,
				   tb->format.flag_offset + ((index << tb->format.bits) % 8),
				   ((index_to_side_to_move(tb, index) == WHITE ? dtm : -dtm) >= 0) ? 1 : 0);
		break;
	    }

	    if ((((index + 1) << tb->format.bits) % 8) == 0) {
		fwrite(entry, tb->format.bytes, 1, file);
	    }
	}
    }

    fclose(file);
}

/* The "master routine" for tablebase generation.
 *
 * Many of these subroutines have already printed error messages of their own if they return
 * an error indication, which is why we just silently return in many cases.
 */

boolean generate_tablebase_from_control_file(char *control_filename, char *output_filename, char *options) {

    tablebase_t *tb;
    int max_dtm = 0;
    int min_dtm = 0;
    int i;

    tb = parse_XML_control_file(control_filename);
    if (tb == NULL) return 0;

    if (num_propentries != 0) {
	tb->entries_fd = open("entries", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
	if (tb->entries_fd == -1) {
	    fprintf(stderr, "Can't open 'entries' for read-write\n");
	    return 0;
	}
	init_entry_buffers(tb);
    } else {
	tb->entries = (entry_t *) malloc(LEFTSHIFT(tb->max_index + 1, entries_format.bits - 3));
	if (tb->entries == NULL) {
	    fprintf(stderr, "Can't malloc tablebase entries\n");
	}
	memset(tb->entries, 0, LEFTSHIFT(tb->max_index + 1, entries_format.bits - 3));
    }

    if (num_propentries != 0) {
#if USE_DUAL_PROPTABLES
	/* This is here so we can use O_DIRECT when writing the proptable out to disk.  1024 is a guess. */
	if (posix_memalign((void **) &proptable1, 1024, num_propentries * proptable_format.bytes) != 0) {
	    fprintf(stderr, "Can't posix_memalign proptable\n");
	    return 0;
	}
	/* POSIX doesn't guarantee that the memory will be zeroed (but Linux seems to zero it) */
	memset(proptable1, 0, num_propentries * proptable_format.bytes);

	if (posix_memalign((void **) &proptable2, 1024, num_propentries * proptable_format.bytes) != 0) {
	    fprintf(stderr, "Can't posix_memalign proptable\n");
	    return 0;
	}
	memset(proptable2, 0, num_propentries * proptable_format.bytes);

	proptable = proptable1;

#if ZERO_PROPTABLES_USING_DISK
	zeros_fd = open("zeros", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE, 0666);
	if (zeros_fd == -1) {
	    fprintf(stderr, "Can't open 'zeros' for writing zero propfile\n");
	    return 0;
	}
	do_write(zeros_fd, proptable1, num_propentries * proptable_format.bytes);
#endif
#else
	/* This is here so we can use O_DIRECT when writing the proptable out to disk.  1024 is a guess. */
	if (posix_memalign((void **) &proptable, 1024, num_propentries * proptable_format.bytes) != 0) {
	    fprintf(stderr, "Can't posix_memalign proptable\n");
	    return 0;
	}
	/* POSIX doesn't guarantee that the memory will be zeroed (but Linux seems to zero it) */
	memset(proptable, 0, num_propentries * proptable_format.bytes);

	proptable1 = proptable;
	proptable2 = proptable;
#endif
    }
    /* Need this no matter what.  I want to replace it with a global static tablebase for everything. */
    proptable_tb = tb;

    assign_numbers_to_futuremoves(tb);
    compute_pruned_futuremoves(tb);
#if 0
    for (i=0; i < num_futuremoves; i ++) {
	fprintf(stderr, "Futuremove %i: %s\n", i, movestr[i]);
    }
#endif
    if (! check_pruning(tb, &max_dtm, &min_dtm)) return 0;

    check_1000_indices(tb);
    /* check_1000_positions(tb); */  /* This becomes a problem with symmetry, among other things */

    if (num_propentries == 0) {

	/* No proptables.  Allocate a futurevectors array, initialize the tablebase, back propagate
	 * the futurebases (noting which futuremoves have been handled in the futurevectors array),
	 * and run through the futurevectors array checking for unhandled futuremoves.
	 */

	tb->futurevectors = (futurevector_t *) calloc(tb->max_index + 1, sizeof(futurevector_t));
	if (tb->futurevectors == NULL) {
	    fprintf(stderr, "Can't malloc tablebase futurevectors\n");
	    return 0;
	}

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "initialization";

	fprintf(stderr, "Initializing tablebase\n");
	initialize_tablebase(tb);

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	fprintf(stderr, "Total legal positions: %lld\n", total_legal_positions);
	fprintf(stderr, "Total moves: %lld\n", total_moves);

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futurebase backprop";

	if (! back_propagate_all_futurebases(tb)) return 0;

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futuremove check";

	fprintf(stderr, "Checking futuremoves...\n");
	/* propagation_pass(0); */
	if (! have_all_futuremoves_been_handled(tb)) return 0;
	fprintf(stderr, "All futuremoves handled under move restrictions\n");

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	free(tb->futurevectors);
	tb->futurevectors=NULL;

    } else {

	/* Using proptables.  No futurevectors array.  We back propagate the futurebases into the
	 * proptable, then in a single pass initialize the entries array and commit the proptable
	 * into it, checking each position move as we go to make sure its futuremoves are handled.
	 */

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futurebase backprop";

	if (! back_propagate_all_futurebases(tb)) return 0;
	proptable_full();  /* flush moves out to disk */
	finalize_proptable_write();

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	fprintf(stderr, "Initializing tablebase...\n");
	pass_type[total_passes] = "initialization";
	propagation_pass(0);
	proptable_full();  /* flush moves out to disk */
	finalize_proptable_write();

	/* fprintf(stderr, "Total legal positions: %lld\n", total_legal_positions); */
	/* fprintf(stderr, "Total moves: %lld\n", total_moves); */
	/* fprint_system_time(); */

	fprintf(stderr, "All futuremoves handled under move restrictions\n");

    }

    /* We add one to dtm_limit here because, even if there are intra-table passes with no
     * progress made, we want to process at least one pass beyond the maximum mate-in value we
     * saw during futurebase back-prop.
     */

    fprintf(stderr, "Intra-table propagating\n");
    propagate_all_moves_within_tablebase(tb, min_dtm-1, max_dtm+1);

    write_tablebase_to_file(tb, output_filename, options);

    return 1;
}

/***** PROBING NALIMOV TABLEBASES *****/

#ifdef USE_NALIMOV

int EGTBProbe(int wtm, unsigned char board[64], int sqEnP, int *score);

int IInitializeTb(char *pszPath);

int FTbSetCacheSize(void    *pv, unsigned long   cbSize );

#define EGTB_CACHE_DEFAULT (1024*1024)

void *EGTB_cache;

char *nalimov_path = ".";

void init_nalimov_code(void)
{
    int nalimov_num;

    nalimov_num = IInitializeTb(nalimov_path);
    printf("%d piece Nalimov tablebases found\n", nalimov_num);
    EGTB_cache = malloc(EGTB_CACHE_DEFAULT);
    if (EGTB_cache == NULL) {
	fprintf(stderr, "Can't malloc EGTB cache\n");
    } else {
	FTbSetCacheSize(EGTB_cache, EGTB_CACHE_DEFAULT);
    }
}

char * nalimov_to_english(int score)
{
    static char buffer[256];

    if (score > 0) {
	sprintf(buffer, "mate in %d", ((65536-4)/2)-score+1);
    } else if (score < 0) {
	sprintf(buffer, "mated in %d", ((65536-4)/2)+score);
    } else {
	sprintf(buffer, "draw");
    }

    return buffer;
}

void verify_tablebase_against_nalimov(tablebase_t *tb)
{
    index_t index;
    global_position_t global;
    local_position_t local;
    int score;

    fprintf(stderr, "Verifying tablebase against Nalimov\n");

    entries_format = tb->format;

    for (index = 0; index <= tb->max_index; index++) {
	if (index_to_global_position(tb, index, &global)) {

	    index_to_local_position(tb, index, 0, &local);

	    if (PNTM_in_check(tb, &local)) {

		/* I've learned the hard way not to probe a Nalimov tablebase for an illegal position... */

	    } else if ((global.en_passant_square != -1)
		       && ((global.board[global.en_passant_square - 9] != 'P')
			   || (global.en_passant_square == 40)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square - 7] != 'P')
			   || (global.en_passant_square == 47)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square + 7] != 'p')
			   || (global.en_passant_square == 16)
			   || (global.side_to_move == WHITE))
		       && ((global.board[global.en_passant_square + 9] != 'p')
			   || (global.en_passant_square == 23)
			   || (global.side_to_move == WHITE))) {

		/* Nor does Nalimov like it if the en passant pawn can't actually be captured by
		 * another pawn.
		 */

	    } else if (EGTBProbe(global.side_to_move == WHITE, global.board, global.en_passant_square, &score) == 1) {

		if (tb->format.dtm_bits > 0) {

		    int dtm = get_entry_DTM(tb, index);

		    if (dtm > 1) {
			if ((dtm-1) != ((65536-4)/2)-score+1) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mate in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, dtm-1);
			}
		    } else if (dtm < 0) {
			if ((-dtm-1) != ((65536-4)/2)+score) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mated in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, -dtm-1);
			}
		    } else if (dtm == 0) {
			if (score != 0) {
			    printf("%s (%d): Nalimov says %s (%d), but we say draw\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), ((65536-4)/2)+score);
			}
		    }
		}

		if (tb->format.flag_type != FORMAT_FLAG_NONE) {
		    boolean flag = get_entry_flag(tb, index);

		    if (global.side_to_move == BLACK) score *= -1;

		    if (flag && (score < 0)) {
			fprintf(stderr, "%s (%d): Nalimov says black wins, but we say white wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if (flag && (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say white wins\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (score > 0)) {
			fprintf(stderr, "%s (%d): Nalimov says white wins, but we say black wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (tb->format.flag_type == FORMAT_FLAG_WHITE_DRAWS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say black wins\n",
				global_position_to_FEN(&global), index);
		    }
		}
	    } else {
		fprintf(stderr, "%s (%d): Nalimov says illegal, but we don't\n",
			global_position_to_FEN(&global), index);
	    }
	}
    }
}

#endif /* USE_NALIMOV */


/* Search an array of tablebases for a global position.  Array should be terminated with a NULL ptr.
 */

boolean search_tablebases_for_global_position(tablebase_t **tbs, global_position_t *global_position,
					      tablebase_t **tbptr, index_t *indexptr)
{
    index_t index;

    for (; *tbs != NULL; tbs++) {
	index = global_position_to_index(*tbs, global_position);
	if (index != -1) {
	    *tbptr = *tbs;
	    *indexptr = index;
	    return 1;
	}
    }

    return 0;
}

void print_score(tablebase_t *tb, index_t index, char *ptm, char *pntm)
{
    /* int dtm = fetch_DTM_from_disk(tb, index); */
    int dtm = get_entry_DTM(tb, index);

    if (dtm == 0) {
	printf("Draw\n");
    } else if (dtm == 1) {
	printf("Illegal position\n");
    } else if (dtm > 1) {
	printf("%s moves and wins in %d\n", ptm, dtm-1);
    } else if (dtm < 0) {
	printf("%s wins in %d\n", pntm, -dtm-1);
    }
}

int main(int argc, char *argv[])
{
    /* Make sure this tablebase array is one bigger than we need, so it can be NULL terminated */
    tablebase_t *tb, **tbs;
    global_position_t global_position;
    boolean global_position_valid = 0;
    int argi;
    int i;
    int c;
    int generating=0;
    int probing=0;
    int verify=0;
    char *output_filename = NULL;
    extern char *optarg;
    extern int optind;
    char options_string[256];
    char *options_string_ptr = options_string;

    /* Figure how we were called.  This is just to record in the XML output for reference purposes. */

    for (i=0; i<argc; i++) {
	strncpy(options_string_ptr, argv[i], options_string + sizeof(options_string) - options_string_ptr);
	options_string_ptr += strlen(argv[i]);
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
	*options_string_ptr = ' ';
	options_string_ptr ++;
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
    }
    options_string[sizeof(options_string) - 1] = '\0';

    gettimeofday(&program_start_time, NULL);

    init_movements();
    verify_movements();

    initialize_byte_transform();

    while (1) {
	c = getopt(argc, argv, "gpvo:n:P:");

	if (c == -1) break;

	switch (c) {

	case 'g':
	    generating = 1;
	    break;
	case 'p':
	    probing = 1;
	    break;
	case 'v':
	    verify = 1;
	    break;
	case 'n':
	    nalimov_path = optarg;
	    break;
	case 'o':
	    output_filename = optarg;
	    break;
	case 'P':
	    /* set size of proptable in megabytes */
	    num_propentries = strtol(optarg, NULL, 0) * 1024 * 1024 / proptable_format.bytes;
	    break;
	}
    }

    if (generating && probing) {
	fprintf(stderr, "Only one of the generating (-g) and probing (-p) options can be specified\n");
	exit(EXIT_FAILURE);
    }

    if (!generating && !probing && !verify) {
	fprintf(stderr, "At least one of generating (-g), probing (-p), or verify (-v) must be specified\n");
	exit(EXIT_FAILURE);
    }

    if (generating && (output_filename == NULL)) {
	fprintf(stderr, "An output filename must be specified to generate\n");
	exit(EXIT_FAILURE);
    }

    if (!generating && (output_filename != NULL)) {
	fprintf(stderr, "An output filename can not be specified when probing or verifying\n");
	exit(EXIT_FAILURE);
    }

    /* Generating */

    if (generating) {
	exit(generate_tablebase_from_control_file(argv[optind], output_filename, options_string)
	     ? EXIT_SUCCESS : EXIT_FAILURE);
    }

    /* Probing / Verifying */

#ifdef USE_NALIMOV
    init_nalimov_code();
#endif

    i = 0;
    /* calloc (unlike malloc) zeros memory */
    tbs = calloc(argc - optind + 1, sizeof(tablebase_t *));

    for (argi=optind; argi<argc; argi++) {
	fprintf(stderr, "Loading '%s'\n", argv[argi]);
	tbs[i] = preload_futurebase_from_file(argv[argi]);
	if (tbs[i] == NULL) {
	    fprintf(stderr, "Error loading '%s'\n", argv[argi]);
	} else {
#ifdef USE_NALIMOV
	    if (verify) verify_tablebase_against_nalimov(tbs[i]);
#endif
	    i++;
	}
    }

    if (!probing) exit(EXIT_SUCCESS);

    /* Probing only */

    read_history(".hoffman_history");

    while (1) {
	char *buffer;
	local_position_t pos;
	local_position_t nextpos;
	int piece, dir;
	struct movement * movementptr;
	global_position_t global_capture_position;
	int score;
	index_t index;

	buffer = readline(global_position_valid ? "FEN or move? " : "FEN? ");
	if (buffer == NULL) break;
	if (*buffer == '\0') continue;
	add_history(buffer);

	if (!(global_position_valid && parse_move_in_global_position(buffer, &global_position))
	    && !parse_FEN_to_global_position(buffer, &global_position)) {
	    printf(global_position_valid ? "Bad FEN or move\n\n" : "Bad FEN\n\n");
	    continue;
	}

	global_position_valid = 1;

	if (search_tablebases_for_global_position(tbs, &global_position, &tb, &index)) {

	    index_t index2;
	    char *ptm, *pntm;

	    /* 'index' is the index of the current position; 'index2' will be the index
	     * of the various next positions that we'll consider
	     */

	    printf("FEN %s\n", global_position_to_FEN(&global_position));
	    printf("Index %d\n", index);

	    if (global_position.side_to_move == WHITE) {
		ptm = "White";
		pntm = "Black";
	    } else {
		ptm = "Black";
		pntm = "White";
	    }

	    print_score(tb, index, ptm, pntm);

#ifdef USE_NALIMOV
		if (EGTBProbe(global_position.side_to_move == WHITE, global_position.board, -1, &score) == 1) {
		    printf("\nNalimov score: ");
		    if (score > 0) {
			printf("%s moves and wins in %d\n", ptm, ((65536-4)/2)-score+1);
		    } else if (score < 0) {
			printf("%s wins in %d\n", pntm, ((65536-4)/2)+score);
		    } else {
			printf("DRAW\n");
		    }
		}
#endif

	    /* Now we want to print a move list */

	    for (piece = 0; piece < tb->num_pieces; piece++) {

		/* We only want to consider pieces of the side which is to move... */

		if (tb->piece_color[piece] != global_position.side_to_move)
		    continue;

		if (tb->piece_type[piece] != PAWN) {

		    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

			if (! index_to_local_position(tb, index, 0, &pos))
			    index_to_local_position(tb, index, 1, &pos);

			nextpos = pos;

			flip_side_to_move_local(&nextpos);
			nextpos.en_passant_square = -1;

			for (movementptr = movements[tb->piece_type[piece]][pos.piece_position[piece]][dir];
			     (movementptr->vector & pos.board_vector) == 0;
			     movementptr++) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			}

			/* Now we consider possible captures */

			index_to_global_position(tb, index, &global_capture_position);

			if ((movementptr->vector & pos.PTM_vector) == 0) {

			    if ((movementptr->square == pos.piece_position[BLACK_KING])
				|| (movementptr->square == pos.piece_position[WHITE_KING])) {

				/* printf("MATE\n"); */

			    } else {
				tablebase_t *tb2;
				global_position_t reversed_position;

				global_capture_position.board[pos.piece_position[piece]] = 0;
				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       tb->piece_type[piece]);

				if (global_capture_position.side_to_move == WHITE)
				    global_capture_position.side_to_move = BLACK;
				else
				    global_capture_position.side_to_move = WHITE;

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s   ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s   NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square]);
				}
			    }
			}
			/* end of capture search */
		    }

		} else {

		    /* PAWNs */

		    if (! index_to_local_position(tb, index, 0, &pos))
			index_to_local_position(tb, index, 1, &pos);
		    nextpos = pos;
		    flip_side_to_move_local(&nextpos);

		    /* normal pawn moves */

		    for (movementptr = normal_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 (movementptr->vector & pos.board_vector) == 0;
			 movementptr++) {

			if ((ROW(movementptr->square) != 0) && (ROW(movementptr->square) != 7)) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			} else {

			    /* non-capture promotion */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %s%s=%c  ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %s%s=%c  NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }
			}
		    }

		    /* capture pawn moves */

		    for (movementptr = capture_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 movementptr->square != -1;
			 movementptr++) {

			if (movementptr->square == pos.en_passant_square) {

			    /* en passant capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    if (tb->piece_color[piece] == WHITE) {
				global_capture_position.board[pos.en_passant_square - 8] = 0;
			    } else {
				global_capture_position.board[pos.en_passant_square + 8] = 0;
			    }

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }

			    continue;
			}

			if ((movementptr->vector & pos.PTM_vector) != 0) continue;

			if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			    /* promotion capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s=%c ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s=%c NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }

			    continue;
			}

			if ((movementptr->square == pos.piece_position[BLACK_KING])
			    || (movementptr->square == pos.piece_position[WHITE_KING])) {

			    /* printf("MATE\n"); */

			} else {
			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }
			}
		    }
		    /* end of capture search */


		}

	    }
	}
    }
    write_history(".hoffman_history");
    printf("\n");

    exit(EXIT_SUCCESS);
}
