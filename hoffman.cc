/* -*- mode: C; fill-column: 100; c-basic-offset: 4; -*-
 *
 * HOFFMAN - a chess endgame tablebase builder
 *
 * by Brent Baccala
 *
 * August, 2006
 *
 * no rights reserved; you may freely copy, modify, or distribute HOFFMAN
 *
 * written in C for speed
 *
 * This program is formated for a (minimum) 100 character wide display.
 *
 * INTRODUCTION
 *
 * This program calculates chess tablebases, which are large files containing all possible
 * configurations of chess pieces in an endgame and the best play to either win or draw.  Unlike a
 * conventional chess engine, which uses a heuristic evaluation function, a retrograde engine is
 * almost completely non-heuristic.  When it labels a position as a win, it is because it has
 * considered all possibles lines, be they 10, 20, or 100 moves long, and determined that the win is
 * forced, even with best play by the opposing side.  Some chess-like games, such as the Japanese
 * game Shogi, are not suitable for retrograde analysis because pieces never leave the game
 * (captured pieces in Shogi can be put back into play by the capturing player).  Yet for chess, the
 * frequent reduction of games to positions where only a handful of pieces remain has created an
 * entire subfield of endgame analysis.
 *
 * Systematic analysis of chess endgames dates at least to the ninth century.  Pioneering work in
 * computer retrograde analysis was done in the 1980s by Ken Thompson, the same of UNIX fame, and
 * S.J. Edwards, but the most popular tablebases today are those generated by a program written by
 * E.V. Nalimov.  Suffice it to say that while Nalimov's program has completely solved all chess
 * endgames with six or fewer pieces remaining, and while Nalimov tablebases are widely available on
 * the Internet, the Nalimov approach of solving an endgame completely results in very slow run
 * times and exceptionally large tablebases.  The K+P+P vs K+P endgame, for example, due to the
 * possibility of all pawns queening, requires the K+Q+Q vs K+Q endgame to be solved before it can
 * be calculated.
 *
 * Hoffman takes a somewhat different approach, one pioneered by the Eiko Bleicher's Freezer, now a
 * commercial program. When faced with something like K+P+P vs K+P, rather than calculate all
 * possible resulting positions, it may ignore the possibility of more than two pawns queening at
 * the same time, thus computing nothing more complex than K+Q+P vs K+Q.  While incomplete, such a
 * tablebase is nevertheless useful.  For the player with two pawns, if the tablebase finds a
 * winning line subject to the queening restrictions, then that line is still playable for a win,
 * even though a faster winning line may exist.  From the opposing point of view, if the tablebase
 * treats any position where the third pawn queens as a forced win, then the player can be confident
 * that any drawing line can not be improved upon by the superior side.  From a computational
 * perspective, we have reduced the complexity requirements to a point where the calculation can be
 * performed in a reasonable amount of time.  While still too slow for over-the-board use, we now
 * have a useful tool for the analysis of more complex endgames, useful for either static analysis,
 * or for the slow time controls of correspondence games.
 *
 * Hoffman improves upon Freezer with a more sophisticated method of chaining one endgame analysis
 * into another, allowing more realistic modeling of queening combinations and exchanges.  For
 * example, in a bishop vs knight endgame (with pawns), if we can (if we wish) analyze first the
 * king and pawn endgame resulting after a trade of the minors, then use this information to analyze
 * a similar set of king vs knight and king vs bishop endgames, and finally combine all this
 * information together to analyze the bishop vs knight endgame.  While the current version of
 * Freezer can only regard the capture of the knight or bishop as a forced win for one side or the
 * other, Hoffman can look through the exchange to determine the result more accurately.
 *
 * Hoffman thus attempts to combine the best of Nalimov and Freezer.  Unlike Freezer, the program is
 * powerful enough to solve any endgame completely (given enough computing resources), exactly
 * reproducing any Nalimov tablebase.  Unlike Nalimov, the program is capable of pruning pawn moves,
 * queening combinations, movement options and exchanges, giving it Freezer's ability to solve
 * complex endgames in a reasonable amount of time.  The exact tradeoff between the two extremes is
 * made using a XML-based configuration that can seem daunting at first, but ultimately offers the
 * user the ability to extensively tailor the program's operation.  Combined with a human being's
 * common sense and chess judgement, it is my hope that this flexibility with ultimately make the
 * program more useful for endgame retrograde analysis than either Nalimov or Freezer.
 *
 * For those not up on Americana, the program is named after Trevor Hoffman, an All Star baseball
 * pitcher who specializes in "closing" games.  It was written specifically for The World vs. Arno
 * Nickel game.
 *
 *
 * Usage: hoffman -g -o <output-tablebase> <xml-control-file>     (generate mode)
 *        hoffman -v <tablebase> ...                              (verification mode)
 *        hoffman -p <tablebase> ...                              (probe mode)
 */

#define USE_PROPTABLES 0


#define _LARGEFILE64_SOURCE	/* because some of our files will require 64-bit offsets */

#define _XOPEN_SOURCE 600	/* for posix_memalign() and posix_fadvise() */

#define _GNU_SOURCE		/* to get O_DIRECT */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>	/* for write(), lseek(), gethostname() */
#include <time.h>	/* for putting timestamps on the output tablebases */
#include <fcntl.h>	/* for O_RDONLY */
#include <netdb.h>	/* for gethostbyname() */

#include <signal.h>	/* so user interrupts and internal errors are reported to the error URL */

#include <sys/time.h>     /* for reporting resource utilization */
#include <sys/resource.h>

#include <sys/mman.h>	/* for mmap() */

#include <errno.h>	/* for EINPROGRESS */

/* If we're using proptables, then the program uses POSIX asynchronous I/O extensively.  Right now
 * (November 2006), there are basically two different Linux implementations available for this.  The
 * native interface in the 2.6 kernel series looks great on paper, but still seems to block at
 * critical places.  GLIBC does asynchronous I/O using threads, which works better right now but
 * incurs the overhead of context switches between the threads.  I've got both versions installed on
 * my system and pick which one I want to use by selecting the appropriate header file here and the
 * appropriate library (-lposix-aio for the native interface; -lrt for the GLIBC threads version) in
 * the Makefile.  The two selections have to match up; if they don't things will compile without
 * warnings but fail with various mysterious errors at runtime.
 */

#if USE_PROPTABLES
#include </usr/local/include/aio.h>
/* #include </usr/include/aio.h> */
#endif

/* The GNU readline library, used for prompting the user during the probe code.  By defining
 * READLINE_LIBRARY, the library is set up to read include files from a directory specified on the
 * compiler's command line, rather than a system-wide /usr/include/readline.  I use it this way
 * simply because I don't have the readline include files installed system-wide on my machine.
 */

#define READLINE_LIBRARY
#include "readline.h"
#include "history.h"

/* The GNOME XML library.  To use it, I need "-I /usr/include/libxml2" (compiler) and "-lxml2"
 * (linker).
 */

#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xmlsave.h>

/* The ZLIB compression library */

#include <zlib.h>

/* The public face of libcurl */

FILE * url_fopen(char *url,const char *operation);

/* The public face of zlib */

FILE * zlib_fopen(FILE *file, char *operation);


/* Our DTD.  We compile it into the program because we want to validate our input against the
 * version of the DTD that the program was compiled with, not some newer version from the network.
 */

#include "tablebase_dtd.h"


/* According the GCC documentation, "long long" ints are supported by the C99 standard as well as
 * the GCC compiler.  In any event, since chess boards have 64 squares, being able to use 64 bit
 * integers makes a bunch of stuff a lot easier.  Might have to be careful with this if porting.
 */

typedef unsigned long long int uint64;
typedef unsigned int uint32;
typedef unsigned short uint16;
typedef unsigned char uint8;
typedef short boolean;

typedef uint32 index_t;


/***** GLOBAL CONSTANTS *****/

/* Maximum number of pieces; used to simplify various arrays
 *
 * Since this includes frozen as well as mobile pieces, "16" may seem absurd, but it's probably
 * about right.  4 fully mobile pieces are easily doable in memory.  5 mobiles can often be done in
 * memory if you use either symmetry or a machine with lots of RAM.  6 mobiles requires sweeping
 * passes across a file on disk.  7 or more mobiles are only doable with severe restrictions on the
 * movements of the pieces.
 */

#define MAX_PIECES 16

/* Number of possibilities for pawn promotions.  "2" means queen and knight, but that can cause some
 * problems, as I've learned the hard (and embarrassing) way.
 */

#define PROMOTION_POSSIBILITIES 4

/* seven possible pieces: KQRBNP; 64 possible squares, up to 8 directions per piece, up to 7
 * movements in one direction
 */

#define NUM_PIECES 6
#define NUM_SQUARES 64
#define NUM_DIR 8
#define NUM_MOVEMENTS 7

/* Variables for gathering statistics */

uint64 total_legal_positions = 0;
uint64 total_PNTM_mated_positions = 0;
uint64 total_stalemate_positions = 0;
uint64 total_moves = 0;
uint64 total_futuremoves = 0;
uint64 total_backproped_moves = 0;
uint64 player_wins[2];
int max_dtm = 0;
int min_dtm = 0;

struct timeval program_start_time;
struct timeval program_end_time;

#define MAX_PASSES 200

int total_passes = 0;
struct timeval pass_start_times[MAX_PASSES];
struct timeval pass_end_times[MAX_PASSES];
char * pass_type[MAX_PASSES];
int pass_target_dtms[MAX_PASSES];
int positions_finalized[MAX_PASSES];
uint64 backproped_moves[MAX_PASSES];

uint8 positive_passes_needed[MAX_PASSES];
uint8 negative_passes_needed[MAX_PASSES];

int entries_write_stalls = 0;
int entries_read_stalls = 0;
int proptable_read_stalls = 0;
int proptable_writes = 0;

struct timeval entries_write_stall_time = {0, 0};
struct timeval entries_read_stall_time = {0, 0};
struct timeval proptable_read_stall_time = {0, 0};
struct timeval proptable_write_time = {0, 0};
struct timeval proptable_preload_time = {0, 0};


/***** DATA STRUCTURES *****/

/* 'futurevectors' are bit vector used to track which futuremoves have been handled in a particular
 * position.  They are of type futurevector_t, and the primary operations used to construct them are
 * FUTUREVECTOR(move) to get a futurevector with a bit set in move's position, and
 * FUTUREVECTORS(move,n) to get a futurevector with n bits set starting with move.
 */

typedef uint16 futurevector_t;
#define FUTUREVECTOR(move) (1ULL << (move))
#define FUTUREVECTORS(move, n) (((1ULL << (n)) - 1) << (move))

/* These arrays hold the bit locations in the futurevector of various futuremoves. */

int num_futuremoves[2] = {0, 0};
int futurecaptures[MAX_PIECES][MAX_PIECES];
int promotion_captures[MAX_PIECES][MAX_PIECES];
int promotions[MAX_PIECES];
int futuremoves[MAX_PIECES][64];

/* XXX hardwired 100 futuremove max per color here */
#define MOVESTR_CHARS 16
char movestr[2][100][MOVESTR_CHARS];

futurevector_t pruned_white_futuremoves = 0;
futurevector_t pruned_black_futuremoves = 0;
futurevector_t conceded_white_futuremoves = 0;
futurevector_t conceded_black_futuremoves = 0;
futurevector_t discarded_white_futuremoves = 0;
futurevector_t discarded_black_futuremoves = 0;

/* position - the data structures that represents a board position
 *
 * There are two kinds of positions: local and global.  Locals are faster but are tied to a specific
 * tablebase.  Globals are more general and are used for probing.
 *
 * Both types use a 64-bit board_vector with one bit for each board position, in addition to a flag
 * to indicate which side is to move and the en passant capture square (or -1 if no en passant
 * capture is possible).  We use board_vector to easily check if possible moves are legal by looking
 * for pieces that block our moving piece.  This is done during futurebase propagation, during
 * intratable propagation, and during initialization.  It could be used to check if en passant
 * positions are legal (are the two squares behind the pawn blocked or not), but that is problematic
 * now because the board_vector isn't correct at the point where we need to make that check.
 *
 * Local positions use numbers (0-63) indicating the positions of the pieces, and also have a quick
 * way to check captures using a PTM_vector (pieces of the Player to Move).  You have to look into
 * the tablebase structure to figure out what piece corresponds to each number.  PTM_vector is only
 * used during tablebase initialization and in the probe code.
 *
 * It makes sense to include these vectors in the position structures because it's easiest to
 * compute them in the routines that convert indices to positions, but if you alter the position,
 * then they get out of sync, and its tempting to just leave them that way because you rarely need
 * them to be right at that point.  This really came back to haunt me when implementing en passant.
 *
 * "Multiplicity" is used in conjunction with symmetric indices, and indicates the actual number of
 * board positions that corresponds to this one.
 *
 * Global positions contain an 8x8 unsigned char array with ASCII characters representing each
 * piece.
 *
 * Sometimes I allow the board and PTM vectors to get out of sync with the position (for speed).
 * This can be a problem, so it has to be done really carefully.
 *
 * We don't worry about moving a piece that's pinned on our king, for example.  The resulting
 * position will already have been flagged illegal in the table.
 *
 */

typedef struct {
    struct tablebase *tb;
    uint64 board_vector;
    uint64 PTM_vector;
    short side_to_move;
    short en_passant_square;
    short multiplicity;
    short piece_position[MAX_PIECES];
    uint8 reflection;
    uint8 permuted_piece[MAX_PIECES];
} local_position_t;

/* This is a global position, that doesn't depend on a particular tablebase.  It's slower to
 * manipulate, but is suitable for probing tablebases.  Each char in the array is either 0 for an
 * empty square, and one of the FEN characters for a chess piece.
 */

typedef struct {
    unsigned char board[64];
    short side_to_move;
    short en_passant_square;
} global_position_t;


/* bitvector gets initialized in init_movements() */

uint64 bitvector[64];
uint64 allones_bitvector = 0xffffffffffffffffLL;

/* pawn can't be on the first or last eight squares of the board */
#define LEGAL_PAWN_BITVECTOR 0x00ffffffffffff00LL

/* I'm not sure which one of these will be faster... */

/* #define BITVECTOR(square) bitvector[square] */
#define BITVECTOR(square) (1ULL << (square))


#define REFLECTION_NONE 0
#define REFLECTION_HORIZONTAL 1
#define REFLECTION_VERTICAL 2
#define REFLECTION_DIAGONAL 4

/* tablebase - the data structure used to hold tablebases
 *
 * WHITE and BLACK are also used for the side_to_move variable in the position type above
 */

#define KING 0
#define QUEEN 1
#define ROOK 2
#define BISHOP 3
#define KNIGHT 4
#define PAWN 5

char * piece_name[NUM_PIECES+1] = {"KING", "QUEEN", "ROOK", "BISHOP", "KNIGHT", "PAWN", NULL};
char piece_char[NUM_PIECES+1] = {'K', 'Q', 'R', 'B', 'N', 'P', 0};

char * colors[3] = {"WHITE", "BLACK", NULL};

/* We make a tacit assumption later (during promotion back propagation, when we compute the
 * futuremove number) that these numbers (QUEEN to KNIGHT) range from 1 to 4, and that they appear
 * in this array in numerical order.
 */

int promoted_pieces[] = {QUEEN, ROOK, BISHOP, KNIGHT, 0};

unsigned char global_pieces[2][NUM_PIECES] = {{'K', 'Q', 'R', 'B', 'N', 'P'},
					      {'k', 'q', 'r', 'b', 'n', 'p'}};

#define WHITE 0
#define BLACK 1


/* A 'struct format' gives the layout of a dynamic structure (one whose bit layout is specified at
 * run time).  See the section "DYNAMIC STRUCTURES" for more details on how this bugger works.
 */

struct format {
    uint8 bits;
    uint8 bytes;
    uint32 dtm_mask;
    int dtm_offset;
    uint8 dtm_bits;
    uint32 movecnt_mask;
    int movecnt_offset;
    uint8 movecnt_bits;
    uint32 index_mask;
    int index_offset;
    uint8 index_bits;
    uint64 futurevector_mask;
    int futurevector_offset;
    uint8 futurevector_bits;
    int flag_offset;
    int flag_type;
    int PTM_wins_flag_offset;
};

char * format_fields[] = {"dtm", "movecnt", "index-field", "futurevector", "flag", "ptm-wins-flag", NULL};

#define FORMAT_FIELD_DTM 0
#define FORMAT_FIELD_MOVECNT 1
#define FORMAT_FIELD_INDEX 2
#define FORMAT_FIELD_FUTUREVECTOR 3
#define FORMAT_FIELD_FLAG 4
#define FORMAT_FIELD_PTM_WINS_FLAG 5

char * format_flag_types[] = {"", "white-wins", "white-draws", NULL};

#define FORMAT_FLAG_NONE 0
#define FORMAT_FLAG_WHITE_WINS 1
#define FORMAT_FLAG_WHITE_DRAWS 2

#define MAX_FORMAT_BYTES 16

/* This is the format that we use for in-memory tablebase arrays.  The default is equivalent to:
 *
 * <entries-format>
 *    <dtm bits="8" offset="0"/>
 *    <movecnt bits="8" offset="8"/>
 * </entries-format>
 */

#define USE_CONST_ENTRIES_FORMAT 1

#if !USE_CONST_ENTRIES_FORMAT

struct format entries_format = {4,2, 0xff,0,8, 0xff,8,8};

#define ENTRIES_FORMAT_BITS (entries_format.bits)
#define ENTRIES_FORMAT_BYTES (entries_format.bytes)
#define ENTRIES_FORMAT_DTM_MASK (entries_format.dtm_mask)
#define ENTRIES_FORMAT_DTM_OFFSET (entries_format.dtm_offset)
#define ENTRIES_FORMAT_DTM_BITS (entries_format.dtm_bits)
#define ENTRIES_FORMAT_MOVECNT_MASK (entries_format.movecnt_mask)
#define ENTRIES_FORMAT_MOVECNT_OFFSET (entries_format.movecnt_offset)
#define ENTRIES_FORMAT_MOVECNT_BITS (entries_format.movecnt_bits)
#define ENTRIES_FORMAT_FLAG_OFFSET (entries_format.flag_offset)

#else

#define ENTRIES_FORMAT_BITS 4
#define ENTRIES_FORMAT_BYTES 2
#define ENTRIES_FORMAT_DTM_MASK 0xff
#define ENTRIES_FORMAT_DTM_OFFSET 0
#define ENTRIES_FORMAT_DTM_BITS 8
#define ENTRIES_FORMAT_MOVECNT_MASK 0xff
#define ENTRIES_FORMAT_MOVECNT_OFFSET 8
#define ENTRIES_FORMAT_MOVECNT_BITS 8
#define ENTRIES_FORMAT_FLAG_OFFSET 0

#endif

/* This is the "one-byte-dtm" format */

struct format one_byte_dtm_format = {3,1, 0xff,0,8};

/* And this is the sixteen byte format we use by default for proptable entries.  Equivalent to:
 *
 * <proptable-format>
 *    <index bits="32" offset="0"/>
 *    <dtm bits="16" offset="32"/>
 *    <movecnt bits="8" offset="56"/>
 *    <futurevector bits="64" offset="64"/>
 * </proptable-format>
 */

#define USE_CONST_PROPTABLE_FORMAT 0

#if !USE_CONST_PROPTABLE_FORMAT

const struct format proptable_format = {7,16, 0xffff,32,16, 0xff,56,8,
					0xffffffff,0,32, 0xffffffffffffffffLL,64,64,
					-1,FORMAT_FLAG_NONE, -1};

#define PROPTABLE_FORMAT_BYTES (proptable_format.bytes)
#define PROPTABLE_FORMAT_INDEX_MASK (proptable_format.index_mask)
#define PROPTABLE_FORMAT_INDEX_OFFSET (proptable_format.index_offset)
#define PROPTABLE_FORMAT_FUTUREVECTOR_BITS (proptable_format.futurevector_bits)
#define PROPTABLE_FORMAT_FUTUREVECTOR_MASK (proptable_format.futurevector_mask)
#define PROPTABLE_FORMAT_FUTUREVECTOR_OFFSET (proptable_format.futurevector_offset)
#define PROPTABLE_FORMAT_DTM_BITS (proptable_format.dtm_bits)
#define PROPTABLE_FORMAT_DTM_MASK (proptable_format.dtm_mask)
#define PROPTABLE_FORMAT_DTM_OFFSET (proptable_format.dtm_offset)
#define PROPTABLE_FORMAT_MOVECNT_MASK (proptable_format.movecnt_mask)
#define PROPTABLE_FORMAT_MOVECNT_OFFSET (proptable_format.movecnt_offset)
#define PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET (proptable_format.PTM_wins_flag_offset)

#endif



typedef void entry_t;


/* tablebase_t
 *
 * The 'xml' in the tablebase is authoritative; much of the other info is extracted from it
 * for efficiency.
 *
 * To make this work for either white or black positions, let's adopt the notation PTM (Player to
 * move) and PNTM (Player not to move)
 *
 * 'movecnt' is is the number of moves FORWARD from this position that haven't been analyzed yet,
 * with the high bit (128) set if PTM is in check.
 *
 * 'dtm' (Distance to Mate) is the number of moves required to force a mate.  It is positive
 * for a PTM mate and negative for a PNTM mate.
 *
 * Now PTM can mate with even a single move out of a position, so a postive dtm means PTM mates.
 * PNTM can only mate if PTM has no possible move that leads to mate, so a negative dtm coupled with
 * a 0 or 128 movecnt means PNTM mates.
 *
 * So, if we backtrace from a single PTM WINS, then this position becomes PTM WINS.  If we backtrace
 * from PNTM WINS, we decrement movecnt and adjust dtm to the lowest value (the slowest mate).  If
 * movecnt reaches 0 or 128, then the position becomes PNTM WINS.  When we're all done backtracing
 * possible wins, anything left with a non-zero movecnt, or a zero dtm, is a DRAW.
 *
 * We also need a mate-in count and a stalemate (conversion) count.
 *
 */

#define RESTRICTION_NONE 0
#define RESTRICTION_DISCARD 1
#define RESTRICTION_CONCEDE 2

char * restriction_types[4] = {"NONE", "DISCARD", "CONCEDE", NULL};

#define FORMAT_FOURBYTE 0
#define FORMAT_ONE_BYTE_DTM 1

char * formats[] = {"fourbyte", "one-byte-dtm", NULL};

#define NAIVE_INDEX 0
#define NAIVE2_INDEX 1
#define SIMPLE_INDEX 2
#define COMPACT_INDEX 3
#define STANDARD_INDEX 4
#define NO_EN_PASSANT_INDEX 5

char * index_types[] = {"naive", "naive2", "simple", "compact", "standard", "no-en-passant"};

typedef struct tablebase {
    int index_type;
    int index_offset;
    index_t max_index;
    index_t modulus;
    int white_king;
    int black_king;

    int symmetry;
    int total_legal_piece_positions[MAX_PIECES];
    int simple_piece_positions[MAX_PIECES][64];
    int simple_piece_indices[MAX_PIECES][64];
    int last_paired_piece[MAX_PIECES];
    int next_paired_piece[MAX_PIECES];

    uint8 compact_white_king_positions[64*64];
    uint8 compact_black_king_positions[64*64];
    int compact_king_indices[64][64];
    int total_legal_compact_king_positions;

    struct format format;

    /* for futurebases only */
    FILE * file;
    index_t next_read_index;
    long offset;
    int max_dtm;
    int min_dtm;
    int invert_colors;
    int extra_piece;
    int missing_pawn;
    int missing_non_pawn;

    xmlDocPtr xml;

    /* Pieces can restricted according to which squares they are allowed to move on.
     *
     * Legal squares are just that.
     *
     * "Semilegal" squares are squares that might be legal for a given piece, but we can't be sure
     * until we've considered other pieces in the position as well.  This becomes a factor when
     * we've got multiple identical pieces with overlapping, non-identical move restrictions.
     * Consider, for example, a tablebase with two rooks: one unrestricted, the other restricted to
     * its back rank.  Let's say we're moving a rook off the back rank.  If the other rook is on the
     * back rank, then the move is legal.  If the other rook is somewhere else, then the move would
     * be illegal.  So we make the entire board "semilegal" for both rooks, process the move
     * normally, and only when it's time to convert the entire position to an index in the tablebase
     * do we actually decide if the position is fully legal.
     */

    int num_pieces;
    short piece_type[MAX_PIECES];
    short piece_color[MAX_PIECES];
    uint64 legal_squares[MAX_PIECES];
    uint64 semilegal_squares[MAX_PIECES];
    uint64 frozen_pieces_vector;
    int blocking_piece[MAX_PIECES];
    uint64 illegal_black_king_squares;
    uint64 illegal_white_king_squares;
    int last_identical_piece[MAX_PIECES];
    int next_identical_piece[MAX_PIECES];

    int move_restrictions[2];		/* one for each color */
    int stalemate_prune_type;		/* only RESTRICTION_NONE (0) or RESTRICTION_CONCEDE (2) allowed */
    int stalemate_prune_color;

    int entries_fd;
    entry_t *entries;
    futurevector_t *futurevectors;
} tablebase_t;

/* Propagation table
 *
 * This is used to optimize back propagation for large tablebases where the entire entries array
 * can't fit in memory.  Back propagation is done by first building proptable entries and sorting
 * them into a proptable.  The sorted proptable is then merged into the entries array.
 *
 * Currently, proptable entries are 16 bytes (128 bits) - a 32 bit index, 32 more bits of
 * housekeeping, and a 64 bit futurevector.  This is significant because many Pentium architectures
 * use 64 byte cache lines.
 *
 * I'm changing this to make the propentries variable using a 'struct format'.  That's why they're
 * void.
 */

typedef void proptable_entry_t;

proptable_entry_t *proptable = NULL;

proptable_entry_t *proptable1 = NULL;
proptable_entry_t *proptable2 = NULL;
int zeros_fd = -1;

tablebase_t *current_tb = NULL;

int proptable_MBs = 0;
int num_propentries = 0;

/* PROPTABLE_BITS for 16 byte entries:
 *
 * 8 = 256 entries = 4KB (testing)
 * 16 = 64K entries (what I've been using)
 * 20 = 1M entries = 16MB
 * 24 = 16M entries = 256MB
 */

#define MAX_ZEROOFFSET 25

#define SEPERATE_PROPTABLE_FILES 0

#define USE_DUAL_PROPTABLES 1

#define CHECK_KING_LEGALITY_EARLY 1

int verbose = 1;

/* DEBUG_MOVE can be used to print more verbose debugging information about what the program is
 * doing to process a single move.
 */

/* #define DEBUG_MOVE 1 */

/* #define DEBUG_FUTUREMOVE 798 */


/***** UTILITY FUNCTIONS *****/

int fatal_errors = 0;

#define MAX_FATAL_ERRORS 10

void terminate (void)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    char * url;
    FILE * file;

    if (fatal_errors > 0) {
	if ((current_tb != NULL) && (current_tb->xml != NULL)) {
	    context = xmlXPathNewContext(current_tb->xml);
	    result = xmlXPathEvalExpression(BAD_CAST "//error-report", context);

	    if (result->nodesetval->nodeNr > 0) {
		url = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url");
		if (url != NULL) {
		    file = url_fopen(url, "w");
		    xmlDocDump(file, current_tb->xml);
		    fclose(file);
		    xmlFree(url);
		}
	    }
	}
	exit(EXIT_FAILURE);
    } else {
	if ((current_tb != NULL) && (current_tb->xml != NULL)) {
	    context = xmlXPathNewContext(current_tb->xml);
	    result = xmlXPathEvalExpression(BAD_CAST "//completion-report", context);

	    if (result->nodesetval->nodeNr > 0) {
		url = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url");
		if (url != NULL) {
		    file = url_fopen(url, "w");
		    xmlDocDump(file, current_tb->xml);
		    fclose(file);
		    xmlFree(url);
		}
	    }
	}
	exit(EXIT_SUCCESS);
    }
}

void fatal (char * format, ...)
{
    va_list va;
    static char strbuf[256] = {'\0'};

    /* BREAKPOINT */
    if (index(format, '\n') != NULL) fatal_errors ++;

    va_start(va, format);

    vfprintf(stderr, format, va);

    if ((current_tb != NULL) && (current_tb->xml != NULL)) {
	vsnprintf(strbuf + strlen(strbuf), sizeof(strbuf) - strlen(strbuf), format, va);
	if (index(strbuf, '\n') != NULL) {
	    xmlNodePtr tablebase = xmlDocGetRootElement(current_tb->xml);

	    *index(strbuf, '\n') = '\0';
	    xmlNodeAddContent(tablebase, BAD_CAST "   ");
	    xmlNewChild(tablebase, NULL, BAD_CAST "error", BAD_CAST strbuf);
	    xmlNodeAddContent(tablebase, BAD_CAST "\n");

	    memset(strbuf, 0, sizeof(strbuf));
	}
    }

    va_end(va);

    if (fatal_errors >= MAX_FATAL_ERRORS) terminate();
}

void warning (char * format, ...)
{
    va_list va;

    va_start(va, format);
    fputs("WARNING: ", stderr);
    vfprintf(stderr, format, va);
    va_end(va);
}

void info (char * format, ...)
{
    va_list va;

    va_start(va, format);
    if (verbose) vfprintf(stderr, format, va);
    va_end(va);
}

void sigaction_user_interrupt (int signal, siginfo_t * siginfo, void * ucontext)
{
    fatal("Interrupted by user\n");
    terminate();
}

void sigaction_internal_error (int signal, siginfo_t * siginfo, void * ucontext)
{
    fatal("Internal error: %s at 0x%08x\n", strsignal(signal), siginfo->si_addr);
    terminate();
}

/* Matches a string against a NULL-terminated array of strings using case insensitive match.
 * Returns index in array of matching string, or -1 if there was no match.
 */

int find_name_in_array(char * name, char * array[])
{
    int i=0;

    if (name == NULL) return -1;

    while (*array != NULL) {
	if (!strcasecmp(name, *array)) return i;
	array ++;
	i ++;
    }

    return -1;
}

/* do_write() is like the system call write(), but keeps repeating until the write is complete */

int do_write(int fd, void *ptr, int length)
{
    while (length > 0) {
	int writ = write(fd, ptr, length);
	if (writ == -1) {
	    perror("do_write");
	    return -1;
	}
	ptr += writ;
	length -= writ;
    }
    return 0;
}

#define ROW(square) ((square) / 8)
#define COL(square) ((square) % 8)

inline int rowcol2square(int row, int col)
{
    return (col + row*8);
}

/* diagonal_reflection() flips along the a1/h8 diagonal by simply interchanging the row and column */

int diagonal_reflection(int square)
{
    return rowcol2square(COL(square), ROW(square));
}

int horizontal_reflection(int square)
{
    return rowcol2square(ROW(square), 7-COL(square));
}

int vertical_reflection(int square)
{
    return rowcol2square(7-ROW(square), COL(square));
}

void subtract_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec -= src->tv_sec;
    if (dest->tv_usec > src->tv_usec) {
	dest->tv_usec -= src->tv_usec;
    } else {
	dest->tv_usec = 1000000 + dest->tv_usec - src->tv_usec;
	dest->tv_sec --;
    }
}

void add_timeval(struct timeval *dest, struct timeval *src)
{
    dest->tv_sec += src->tv_sec;
    dest->tv_usec += src->tv_usec;
    if (dest->tv_usec >= 1000000) {
	dest->tv_usec -= 1000000;
	dest->tv_sec ++;
    }
}

void sprint_timeval(char *strbuf, struct timeval *timevalp)
{
    if (timevalp->tv_sec < 60) {
	sprintf(strbuf, "%ld.%03lds", timevalp->tv_sec, timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 3600) {
	sprintf(strbuf, "%ldm%02ld.%03lds", timevalp->tv_sec/60, timevalp->tv_sec%60,
		timevalp->tv_usec/1000);
    } else if (timevalp->tv_sec < 24*3600) {
	sprintf(strbuf, "%ldh%02ldm%02ld.%03lds", timevalp->tv_sec/3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    } else {
	sprintf(strbuf, "%ldd%02ldh%02ldm%02ld.%03lds",
		timevalp->tv_sec/(24*3600), (timevalp->tv_sec/3600)%3600,
		(timevalp->tv_sec/60)%60, timevalp->tv_sec%60, timevalp->tv_usec/1000);
    }
}

void fprint_system_time(void)
{
    struct rusage rusage;
    char strbuf[256];

    getrusage(RUSAGE_SELF, &rusage);
    sprint_timeval(strbuf, &rusage.ru_stime);
    fprintf(stderr, "System time: %s\n", strbuf);
}


/***** DYNAMIC STRUCTURES *****/

/* Hoffman uses "dynamic structures" extensively, for its entries and proptable arrays.  A dynamic
 * structure is one whose bit layout is specified at run time by the XML control file.  Since we
 * can't use standard C structures (they require bit layouts to be set at compile time), we've got
 * to do all of this nonsense.
 *
 * Does it slow down the program?  You bet.  But for larger tablebases, which are disk bound and not
 * CPU bound, this actually speeds things up by giving us the flexibility of setting structure
 * layouts based on the needs of individual tablebases, and not having to use generic structures
 * big enough to accommodate every possibility.
 */

inline int get_signed_field(uint32 *ptr, uint32 mask, int offset)
{
    int val;

    /* It is truly amazing how much of a difference commenting out this next idiot check makes in
     * gcc 4.0.4's ability to optimize this code, at least on i386.
     */

    /* if (offset == -1) return 0; */

    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    val = (*ptr >> offset) & mask;

    /* sign extend */
    if (val > (mask >> 1)) val |= (~ (mask >> 1));

    return val;
}

inline void set_signed_field(uint32 *ptr, uint32 mask, int offset, int val)
{
    /* if (offset == -1) return; */

    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

#if 0
    if ((val > 0) && (val > (mask >> 1))) {
	fatal("value too large in set_signed_field\n");
    }
    if ((val < 0) && (val < ~(mask >> 1))) {
	fatal("value too small in set_signed_field\n");
    }
#endif

    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}

inline unsigned int get_unsigned_field(uint32 *ptr, uint32 mask, int offset)
{
    /* if (offset == -1) return 0; */

    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

    return (*ptr >> offset) & mask;
}

inline void set_unsigned_field(uint32 *ptr, uint32 mask, int offset, unsigned int val)
{
    /* if (offset == -1) return; */

    while (offset >= 32) {
	offset -= 32;
	ptr ++;
    }

#if 0
    if (val > mask) {
	fatal("value too large in set_unsigned_field\n");
    }
#endif
    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}

inline uint64 get_unsigned64bit_field(void *fieldptr, uint64 mask, int offset)
{
    uint64 *ptr = (uint64 *)fieldptr;

    /* if (offset == -1) return 0; */

    while (offset >= 64) {
	offset -= 64;
	ptr ++;
    }

    return (*ptr >> offset) & mask;
}

inline void set_unsigned64bit_field(void *fieldptr, uint64 mask, int offset, uint64 val)
{
    uint64 *ptr = (uint64 *)fieldptr;

    /* if (offset == -1) return; */

    while (offset >= 64) {
	offset -= 64;
	ptr ++;
    }

#if 0
    if (val > mask) {
	fatal("value too large in set_unsigned_field\n");
    }
#endif

    *ptr &= (~ (mask << offset));
    *ptr |= (val & mask) << offset;
}


/***** MOVEMENT VECTORS *****/

/* The idea here is to calculate piece movements, and to do it FAST.
 *
 * We build a table of "movements" organized into "directions".  Each direction is just that - the
 * direction that a piece (like a queen) moves.  When we want to check for what movements are
 * possible in a given direction, we run through the direction until we "hit" another pieces - until
 * the bit in the vector matches something already in the position vector.  At the end of the
 * direction, an all-ones vector will "hit" the end of the board and end the direction.  I know,
 * kinda confusing.  It's because it's designed to be fast; we have to do this a lot.
 */

struct movement {
    uint64 vector;
    short square;
};

/* we add one to NUM_MOVEMENTS to leave space at the end for the all-ones bitmask that signals the
 * end of the list
 */

struct movement movements[NUM_PIECES][NUM_SQUARES][NUM_DIR][NUM_MOVEMENTS+1];

/* Pawns are, of course, special.  We have seperate vectors for different types of pawn movements.
 * Each array is indexed first by square number, then by side (WHITE or BLACK - this doesn't exist
 * for other pieces), then by the number of possibilities (at most two normal movements, at most two
 * captures, and one more for the all-ones bitvector to terminate)
 *
 * All of these are FORWARD motions.
 */

struct movement normal_pawn_movements[NUM_SQUARES][2][3];
struct movement capture_pawn_movements[NUM_SQUARES][2][3];

struct movement normal_pawn_movements_bkwd[NUM_SQUARES][2][3];
struct movement capture_pawn_movements_bkwd[NUM_SQUARES][2][3];

/* How many different directions can each piece move in?  Knights have 8 directions because they
 * can't be blocked in any of them.  Pawns are handled separately.
 */

int number_of_movement_directions[NUM_PIECES] = {8,8,4,4,8,0};
int maximum_movements_in_one_direction[NUM_PIECES] = {1,7,7,7,1,0};

enum {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR, KNIGHTmove}
movementdir[5][8] = {
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* King */
    {RIGHT, LEFT, UP, DOWN, DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},	/* Queen */
    {RIGHT, LEFT, UP, DOWN},						/* Rook */
    {DIAG_UL, DIAG_UR, DIAG_DL, DIAG_DR},				/* Bishop */
    {KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove, KNIGHTmove},	/* Knights are special... */
};



char algebraic_notation[64][3];

void init_movements()
{
    int square, piece, dir, mvmt, color;

    for (square=0; square < NUM_SQUARES; square++) {
	bitvector[square] = 1ULL << square;
	algebraic_notation[square][0] = 'a' + square%8;
	algebraic_notation[square][1] = '1' + square/8;
	algebraic_notation[square][2] = '\0';
    }

    for (piece=KING; piece <= KNIGHT; piece++) {

	for (square=0; square < NUM_SQUARES; square++) {

	    for (dir=0; dir < number_of_movement_directions[piece]; dir++) {

		int current_square = square;

		for (mvmt=0; mvmt < maximum_movements_in_one_direction[piece]; mvmt ++) {

#define RIGHT_MOVEMENT_POSSIBLE ((current_square%8)<7)
#define RIGHT2_MOVEMENT_POSSIBLE ((current_square%8)<6)
#define LEFT_MOVEMENT_POSSIBLE ((current_square%8)>0)
#define LEFT2_MOVEMENT_POSSIBLE ((current_square%8)>1)
#define UP_MOVEMENT_POSSIBLE (current_square<56)
#define UP2_MOVEMENT_POSSIBLE (current_square<48)
#define DOWN_MOVEMENT_POSSIBLE (current_square>7)
#define DOWN2_MOVEMENT_POSSIBLE (current_square>15)

		    switch (movementdir[piece][dir]) {
		    case RIGHT:
			if (RIGHT_MOVEMENT_POSSIBLE) {
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case LEFT:
			if (LEFT_MOVEMENT_POSSIBLE) {
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case UP:
			if (UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DOWN:
			if (DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UL:
			if (LEFT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_UR:
			if (RIGHT_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
			    current_square+=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DL:
			if (LEFT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square--;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case DIAG_DR:
			if (RIGHT_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
			    current_square-=8;
			    current_square++;
			    movements[piece][square][dir][mvmt].square = current_square;
			    movements[piece][square][dir][mvmt].vector = BITVECTOR(current_square);
			} else {
			    movements[piece][square][dir][mvmt].square = -1;
			    movements[piece][square][dir][mvmt].vector = allones_bitvector;
			}
			break;
		    case KNIGHTmove:
			current_square=square;
			switch (dir) {
			case 0:
			    if (RIGHT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 1:
			    if (RIGHT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 2:
			    if (LEFT2_MOVEMENT_POSSIBLE && UP_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 + 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 + 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 3:
			    if (LEFT2_MOVEMENT_POSSIBLE && DOWN_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 2 - 8;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 2 - 8);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 4:
			    if (RIGHT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 5:
			    if (RIGHT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square + 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square + 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 6:
			    if (LEFT_MOVEMENT_POSSIBLE && UP2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 + 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 + 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			case 7:
			    if (LEFT_MOVEMENT_POSSIBLE && DOWN2_MOVEMENT_POSSIBLE) {
				movements[piece][square][dir][0].square = square - 1 - 16;
				movements[piece][square][dir][0].vector = BITVECTOR(square - 1 - 16);
				movements[piece][square][dir][1].square = -1;
				movements[piece][square][dir][1].vector = allones_bitvector;
			    } else {
				movements[piece][square][dir][0].square = -1;
				movements[piece][square][dir][0].vector = allones_bitvector;
			    }
			    break;
			}
			break;

		    }
		}

		/* Always put an allones_bitvector at the end of the movement vector
		 * to make sure we stop!
		 */

		movements[piece][square][dir][mvmt].square = -1;
		movements[piece][square][dir][mvmt].vector = allones_bitvector;

	    }
	}
    }

    /* Now for the pawns... */

    for (square=0; square < NUM_SQUARES; square ++) {

	for (color = WHITE; color <= BLACK; color ++) {

	    int forwards_pawn_move = ((color == WHITE) ? 8 : -8);
	    int backwards_pawn_move = ((color == WHITE) ? -8 : 8);

	    /* Forward pawn movements
	     *
	     * An ordinary pawn move... unless its a white pawn on the second rank, or a black
	     * pawn on the seventh.  In these two cases, there is a possible double move as
	     * well.
	     */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		normal_pawn_movements[square][color][mvmt].square = square + forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + forwards_pawn_move);

		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 1)) || ((color == BLACK) && (ROW(square) == 6))) {

		normal_pawn_movements[square][color][mvmt].square = square + 2*forwards_pawn_move;
		normal_pawn_movements[square][color][mvmt].vector = BITVECTOR(square + 2*forwards_pawn_move);

		mvmt ++;

	    }

	    normal_pawn_movements[square][color][mvmt].square = -1;
	    normal_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn movements */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + backwards_pawn_move);
		mvmt ++;
	    }

	    if (((color == WHITE) && (ROW(square) == 3)) || ((color == BLACK) && (ROW(square) == 4))) {

		normal_pawn_movements_bkwd[square][color][mvmt].square = square + 2*backwards_pawn_move;
		normal_pawn_movements_bkwd[square][color][mvmt].vector = BITVECTOR(square + 2*backwards_pawn_move);
		mvmt ++;
	    }

	    normal_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    normal_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	    /* Forward pawn captures. */

	    mvmt = 0;

	    if ((ROW(square) >= 1) && (ROW(square) <= 6)) {

		if (COL(square) > 0) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move - 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements[square][color][mvmt].square
			= square + forwards_pawn_move + 1;
		    capture_pawn_movements[square][color][mvmt].vector
			= BITVECTOR(square + forwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements[square][color][mvmt].square = -1;
	    capture_pawn_movements[square][color][mvmt].vector = allones_bitvector;

	    /* Backwards pawn captures */

	    mvmt = 0;

	    if (((color == WHITE) && (ROW(square) > 1)) || ((color == BLACK) && (ROW(square) < 6))) {

		if (COL(square) > 0) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move - 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move - 1);

		    mvmt ++;

		}

		if (COL(square) < 7) {

		    capture_pawn_movements_bkwd[square][color][mvmt].square
			= square + backwards_pawn_move + 1;
		    capture_pawn_movements_bkwd[square][color][mvmt].vector
			= BITVECTOR(square + backwards_pawn_move + 1);

		    mvmt ++;

		}
	    }

	    capture_pawn_movements_bkwd[square][color][mvmt].square = -1;
	    capture_pawn_movements_bkwd[square][color][mvmt].vector = allones_bitvector;

	}

    }

}

/* This routine is pretty fast, so I just call it once every time the program runs.  It has to be
 * used after any changes to the code above to verify that those complex movement vectors are
 * correct, or at least consistent.  We're using this in a game situation.  We can't afford bugs in
 * this code.
 */

void verify_movements()
{
    int piece;
    int squareA, squareB;
    int dir;
    int color;
    struct movement * movementptr;
    int pawn_option;

    /* For everything except pawns, if it can move from A to B, then it better be able to move from
     * B to A...
     */

    for (piece=KING; piece <= KNIGHT; piece ++) {

	for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

	    for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		int movement_possible = 0;
		int reverse_movement_possible = 0;

		/* check for possible self-movement, if A and B are the same square */

		if (squareA == squareB) {
		    for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {
			for (movementptr = movements[piece][squareA][dir];
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fatal("Self movement possible!? %s %d %d\n",
				  piece_name[piece], squareA, movementptr->square);
			}
		    }
		    continue;
		}

		/* check for possible A to B move */

		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareA][dir];
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fatal("Bad movement square: %s %d %d %d\n",
				  piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fatal("-1 movement lacks allones_bitvector: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fatal("Bad movement square: %s %d %d\n", piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fatal("bitvector does not match destination square: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fatal("multiple idential destinations from same origin: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fatal("allones_bitvector on a legal movement: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    }
		}


		for (dir = 0; dir < number_of_movement_directions[piece]; dir++) {

		    for (movementptr = movements[piece][squareB][dir];
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;
		}


		if (movement_possible && !reverse_movement_possible) {
		    fatal("reverse movement impossible: %s %d %d\n", piece_name[piece], squareA, squareB);
		}

	    }
	}
    }

    /* Pawns are special */

    piece = PAWN;

    for (pawn_option = 0; pawn_option < 4; pawn_option ++) {

	struct movement * fwd_movement;
	struct movement * rev_movement;

	for (color = WHITE; color <= BLACK; color ++) {

	    /* fprintf(stderr, "Pawn option %d; color %s\n", pawn_option, colors[color]); */

	    for (squareA=0; squareA < NUM_SQUARES; squareA ++) {

		for (squareB=0; squareB < NUM_SQUARES; squareB ++) {

		    int movement_possible = 0;
		    int reverse_movement_possible = 0;

		    switch (pawn_option) {
		    case 0:
			fwd_movement = normal_pawn_movements[squareA][color];
			rev_movement = normal_pawn_movements_bkwd[squareB][color];
			break;
		    case 1:
			fwd_movement = normal_pawn_movements_bkwd[squareA][color];
			rev_movement = normal_pawn_movements[squareB][color];
			break;
		    case 2:
			fwd_movement = capture_pawn_movements[squareA][color];
			rev_movement = capture_pawn_movements_bkwd[squareB][color];
			break;
		    case 3:
			fwd_movement = capture_pawn_movements_bkwd[squareA][color];
			rev_movement = capture_pawn_movements[squareB][color];
			break;
		    }

		    /* check for self-movement */

		    if (squareA == squareB) {
			for (movementptr = fwd_movement;
			     (movementptr->vector & BITVECTOR(squareB)) == 0;
			     movementptr++) ;
			if ((movementptr->square != -1) || (movementptr->vector != allones_bitvector)) {
			    fatal("Self movement possible!? PAWN %d %d\n", squareA, movementptr->square);
			}
		    }

		    /* check for possible A to B move */

		    for (movementptr = fwd_movement;
			 (movementptr->vector & BITVECTOR(squareB)) == 0;
			 movementptr++) {
			if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			    fatal("Bad movement square: %s %d %d %d\n",
				  piece_name[piece], squareA, squareB, movementptr->square);
			}
		    }

		    if (movementptr->square == -1) {
			if (movementptr->vector != allones_bitvector) {
			    fatal("-1 movement lacks allones_bitvector: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    } else if ((movementptr->square < 0) || (movementptr->square >= NUM_SQUARES)) {
			fatal("Bad movement square: %s %d %d\n", piece_name[piece], squareA, squareB);
		    } else {
			if (movementptr->square != squareB) {
			    fatal("bitvector does not match destination square: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			if (movement_possible) {
			    fatal("multiple idential destinations from same origin: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
			movement_possible = 1;
			if (movementptr->vector == allones_bitvector) {
			    fatal("allones_bitvector on a legal movement: %s %d %d\n",
				  piece_name[piece], squareA, squareB);
			}
		    }


		    /* check for possible B to A reverse move */

		    for (movementptr = rev_movement;
			 (movementptr->vector & BITVECTOR(squareA)) == 0;
			 movementptr++) ;

		    if (movementptr->square != -1) reverse_movement_possible=1;

		    if (movement_possible && !reverse_movement_possible) {
			fatal("reverse movement impossible: %s %d %d\n",
			      piece_name[piece], squareA, squareB);
		    }
		}
	    }
	}
    }
}


/***** INDICES *****/

/* Basically there are two functions here - one converts an index to a local position, the other
 * converts a local position to an index - but they exist in several different versions, depending
 * on the type of index we're using for a particular tablebase.  These functions are used
 * extensively during all types of back propagation.
 *
 * local_position_to_index() also updates the position's board_vector (which doesn't have to be
 * valid going in), but not the PTM_vector.  It does this to check for illegal en passant positions.
 * It returns either an index into the table, or -1 if the position is illegal.
 *
 * Actually, it doesn't update the board vector anymore because we work on a copy of the position.
 *
 * index_to_local_position(), given an index, fill in a board position.  Obviously has to correspond
 * to local_position_to_index() and it's a big bug if it doesn't.  The boolean that gets returned is
 * TRUE if the operation succeeded and FALSE if the index was illegal.
 *
 * Several issues crop up for all index types.
 *
 * What exactly is an illegal position?  Well, for starters, one that index_to_local_position()
 * reports as illegal, because that's the function that initialize_tablebase() uses to figure which
 * positions are flagged illegal, as well as which positions to consider during back prop, and the
 * program screams if you try to back prop into an illegal position.  So the two functions have to
 * agree on illegality.  But there's also a subtle interaction between the legality tests here and
 * the move counting code in initialize_tablebase().  If we count a move, and it's not considered a
 * futuremove, then it'd better lead to a legal position, because we'll never backprop from an
 * illegal one, and that would imbalance the forward and reverse move counting.  For speed purposes,
 * the move counting code currently does not actually check positions to see if they are illegal.
 * So we can't, for example, flag positions with adjacent kings as illegal without updating that
 * code.
 *
 * En passant.  This is another case where subtle concepts of "legality" show up.  When we back
 * propagate a local position from either a futurebase or intratable, we generate en passant
 * positions simply by running through the pawns on the fourth and fifth ranks.  We look then to see
 * if there was a piece behind the "en passant" pawn (that would have prevented it from moving), but
 * (unlike Nalimov) we don't check if there is an enemy pawn that actually could have captured.
 * Again, the code has to match up between the two places, or we would try to back propagate to a
 * position that had been labeled illegal during initialization by index_to_local_position().
 *
 * Identical pieces.  Identical positions need to generate identical indices.  If we have two
 * identical pieces, then transposing them in a position can't affect the outcome of
 * local_position_to_index().  Right now, I deal with this by making a copy of the local position
 * and sorting identical pieces into ascending position numbers.
 *
 * So how about a static 64-bit vector with bits set for pieces frozen on a single square?
 * Everytime we call index_to_local_position, copy from the static vector into the position
 * structure.  Then we compute the positions of the mobile pieces and plug their bits into the
 * structure's vector at the right places.  Might implement this some day.
 */

boolean check_king_legality(int kingA, int kingB) {
    if ((ROW(kingA) < ROW(kingB) - 1) || (ROW(kingA) > ROW(kingB) + 1)) return 1;
    if ((COL(kingA) < COL(kingB) - 1) || (COL(kingA) > COL(kingB) + 1)) return 1;
    return 0;
}

/* Later in the program, I'll use these indices as the keys in an address calculation insertion
 * sort.  This kind of sort performs well if the keys are evenly distributed, and performs horribly
 * if the keys are clumped together.  Since checkmates occur in groups of similar positions,
 * something has to be done.  "Something" is inversion of the indices in a finite field,
 * specifically a modulo ring with a prime modulus.  The modulus is specified in the XML
 * configuration, and I don't check to make sure it's prime - there are other programs available
 * that do that.
 *
 * Originally, I used the HalfExtendedEuclidian algorithm from Manuel Bronstein's book "Symbolic
 * Integration I".  In the hopes a speed improvement, I switched to using a binary extended GCD
 * algorithm on the advice of Prof. Christof Paar.  The speed improvement wasn't there, but I've
 * stuck with the newer algorithm because it avoids multiplications and divisions, using only right
 * shifts and subtractions, and should therefore be easier to implement for 64-bit indices on a
 * 32-bit architecture.  Also, I've since realized that because we only use this algorithm when the
 * program becomes disk-bound, the speed issue is (mostly) negligible.
 *
 * The binary extended GCD algorithm is based on computing a GCD by repeatedly subtracting the
 * smaller number from the larger one.  A consideration of the equation c = a - b shows that a
 * common multiple of any two of the numbers must be a common multiple of the third (unless it is
 * zero).  Therefore, subtracting preserves common multiples in the result and does not introduce
 * any new common multiples.  Because we are working with a binary architecture, detecting multiples
 * of two is easy, and we can eliminate them by right shifting.  Since subtracting two odd numbers
 * gives an even number, we can right shift by at least one bit per iteration.  Combining the two
 * operations of subtraction and right shifting, we get a GCD algorithm (14.61 in Menezes' Handbook
 * of Applied Cryptography) that requires more iterations than the extended Euclidian algorithm, but
 * still completes in a reasonable time and avoids both multiplication and division.
 *
 * Consider an array of number x[n].  To compute gcd(a,b), we set up x[0]=a and x[1]=b, then
 * repeatedly apply the algorithm below, which preserves the gcd at each step, i.e, each x[n] is a
 * multiple of gcd(a,b).  Each x[n] can be written in terms of a and b: x[n] = a[n] * a + b[n] * b.
 * If a was the prime modulus of our finite field, then finally x[n] = gcd(a,b) = 1, so:
 *
 *        1 = a[n] * a + b[n] * b
 *
 *        1 = b[n] * b  (mod a)
 *
 * i.e, b[n] is the multiplicative inverse of b (mod a).
 *
 * So we need to track the b[n] part of x[n] = a[n] * a + b[n] * b until we reach the GCD of 1.
 *
 * Subtracting (x[n+1] = x[n] - x[n-1]) is easy:
 *
 *                a[n+1] = a[n] - a[n-1]    and    b[n+1] = b[n] - b[n-1]
 *
 * Right shifting (division by 2) is only a little more difficult.  Let's first note that if x[n] is
 * even (the only case in which we'd be right shifting) and a is odd (it's a prime modulus, after
 * all), then either a[n] is even or a[n] and b[n] must both be odd.  So if b[n] is even, then a[n]
 * is also even and we can right shift everything: x[n]/2 = a[n]/2 * a + b[n]/2 * b, while if
 * b[n] is odd, we can add and subtract a * b to obtain:
 *
 *             x[n] = (a[n] + b) * a + (b[n] - a) * b
 *
 *             x[n]/2 = (a[n] + b)/2 * a + (b[n] - a)/2 * b
 *
 * Remember that a[n] gets discarded; b[n] is all we care about computing.
 *
 * So our operations are:
 *
 *    subtract (x > y)    x = x - y                            b[x] = (b[x] - b[y]) mod m
 *
 *    subtract (y > x)    y = y - x                            b[y] = (b[y] - b[x]) mod m
 *
 *    right shift x (b[x] even)     x = x / 2                  b[x] = b[x] / 2
 *
 *    right shift x (b[x] odd)      x = x / 2                  b[x] = ((b[x] - m) / 2) mod m
 *
 *                                                         or  b[x] = ((b[x] + m) / 2) mod m
 *
 * m    -> EAX
 * x    -> EBX
 * y    -> ECX
 * (m+1)/2 -> EDX
 * b[x] -> ESI
 * b[y] -> EDI
 *
 * This is a GNU compiler, so we use AT&T assembler syntax - the destination comes second.
 */

#define ASM_invert_in_finite_field(INDEX, MODULUS)						\
   asm("                                                                                        \
                /* Input                                                                    */  \
                /*                                                                          */  \
                /* EAX - modulus                                                            */  \
                /* ECX - index                                                              */  \
                                                                                                \
                mov %%eax, %%ebx;                                                               \
                mov $0, %%esi;                                                                  \
                mov $1, %%edi;                                                                  \
                                                                                                \
                mov %%eax, %%edx;                                                               \
                add $1, %%edx;                                                                  \
                shr %%edx;                                                                      \
                                                                                                \
                /* while ((y&1) == 0)                                                       */  \
                                                                                                \
           1:   test $1, %%ecx;                                                                 \
                jne 2f;                                                                         \
                                                                                                \
                /*     y >>= 1;                                                             */  \
                shr %%ecx;                                                                      \
                                                                                                \
                /*     if ((by&1) == 0) {                                                   */  \
                /*        by >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        by = ((by + m)/2) mod m;                                          */  \
                /*        by = (((by-1 + m+1)/2) mod m;                                     */  \
                /*        by = ((by-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%edi;                                                                      \
                jnc 1b;                                                                         \
                add %%edx, %%edi;                                                               \
                cmp %%eax, %%edi;                                                               \
                jc  1b;                                                                         \
                sub %%eax, %%edi;                                                               \
                jmp 1b;                                                                         \
                                                                                                \
           2:   /* Is x = y ?  Is x > y ?                                                   */  \
                cmp %%ecx, %%ebx;                                                               \
                jz  6f;                                                                         \
                jc  4f;                                                                         \
                                                                                                \
                /* Yes, x > y                                                               */  \
                /* Set x = x - y                                                            */  \
                sub %%ecx, %%ebx;                                                               \
                                                                                                \
                /* Set b[x] = (b[x] - b[y]) mod m                                           */  \
                sub %%edi, %%esi;                                                               \
                jnc 3f;                                                                         \
                add %%eax, %%esi;                                                               \
                                                                                                \
                /* while ((x&1) == 0)                                                       */  \
                                                                                                \
           3:   test $1, %%ebx;                                                                 \
                jne 2b;                                                                         \
                                                                                                \
                /*     x >>= 1;                                                             */  \
                shr %%ebx;                                                                      \
                                                                                                \
                /*     if ((bx&1) == 0) {                                                   */  \
                /*        bx >>= 1;                                                         */  \
                /*    } else {                                                              */  \
                /*        bx = ((bx + m)/2) mod m;                                          */  \
                /*        bx = (((bx-1 + m+1)/2) mod m;                                     */  \
                /*        bx = ((bx-1)/2 + (m+1)/2) mod m;                                  */  \
                /*    }                                                                     */  \
                /* }                                                                        */  \
                                                                                                \
                shr %%esi;                                                                      \
                jnc 3b;                                                                         \
                add %%edx, %%esi;                                                               \
                cmp %%eax, %%esi;                                                               \
                jc  3b;                                                                         \
                sub %%eax, %%esi;                                                               \
                jmp 3b;                                                                         \
                                                                                                \
                /* y > x                                                                    */  \
                /* Set y = y - x                                                            */  \
           4:   sub %%ebx, %%ecx;                                                               \
                                                                                                \
                /* Set b[y] = (b[y] - b[x]) mod m                                           */  \
                sub %%esi, %%edi;                                                               \
                jnc 1b;                                                                         \
                add %%eax, %%edi;                                                               \
                                                                                                \
                jmp 1b;                                                                         \
                                                                                                \
           6:   mov %%edi, %%ecx;                                                               \
                                                                                                \
                          " : "+c" (INDEX) : "a" (MODULUS) : "bx", "dx", "di", "si", "cc")

uint32 invert_in_finite_field(uint32 b, uint32 m)
{
#if 0
    uint32 x = m;
    uint32 y = b;
    uint32 bx = 0;
    uint32 by = 1;

    int test = b;
    ASM_invert_in_finite_field(test, m);

    while ((y&1) == 0) {
	y >>= 1;
	if ((by&1) == 0) {
	    by >>= 1;
	} else {
	    by = ((by + m)/2)%m;
	}
    }

    while (x != y) {
	if (x > y) {
	    x = x - y;

	    if (bx > by) bx = (bx - by)%m;
	    else bx = (m + bx - by)%m;

	    while ((x&1) == 0) {
		x >>= 1;
		if ((bx&1) == 0) {
		    bx >>= 1;
		} else {
		    bx = ((bx + m)/2)%m;
		}
	    }
	} else {
	    y = y - x;

	    if (by > bx) by = (by - bx)%m;
	    else by = (m + by - bx)%m;

	    while ((y&1) == 0) {
		y >>= 1;
		if ((by&1) == 0) {
		    by >>= 1;
		} else {
		    by = ((by + m)/2)%m;
		}
	    }
	}
    }
    if (x != 1) fatal("x != 1 in invert_finite_field v2\n");

    if (by != test) {
	fatal("%d: assembly inversion (%d) didn't match C code (%d)\n", b, test, by);
    }

    return by;
#else
    ASM_invert_in_finite_field(b, m);
    return b;
#endif
}

/* "Naive" index.  Just assigns a number from 0 to 63 to each square on the board and multiplies
 * them together for the various pieces.  Simple and fast.  Actually is now a little more complex in
 * its white king encoding, since it works with 2-way and 4-way symmetry.
 */

index_t local_position_to_naive_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index |= COL(pos->en_passant_square) << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else if ((piece == tb->white_king) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == tb->white_king) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(pos->piece_position[piece]) << shift_count;
	    shift_count += 2;
	} else {
	    index |= pos->piece_position[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	}
    }

    return index;
}

boolean naive_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square;

	if ((tb->symmetry == 2) && (piece == tb->white_king)) {
	    square = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == tb->white_king)) {
	    square = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else {
	    square = index & 63;
	    index >>= 6;
	}

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which indices are legal and which are
	 * not.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Naive2" index.  Assigns a number from 0 to 63 to each square on the board and multiplies them
 * together for the various pieces.  Differs from "naive" in its handling of multiple identical
 * pieces, which it stores as a base and an offset, thus saving a single bit.  Currently, only
 * pairs of identical pieces are correctly handled.
 */

index_t local_position_to_naive2_index(tablebase_t *tb, local_position_t *pos)
{
    int shift_count = 1;
    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */
    index_t index = pos->side_to_move;  /* WHITE is 0; BLACK is 1 */
    int piece;
    uint8 vals[MAX_PIECES];

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = COL(pos->en_passant_square);
	} else {
	    vals[piece] = pos->piece_position[piece];
	}
    }

    /* What's all this?
     *
     * The idea is to encode two identical pieces using one less bit than needed for encoding them
     * separately, because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (tb->next_paired_piece[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_paired_piece[piece]])
		 && (vals[piece] + 32 < vals[tb->next_paired_piece[piece]]))
		|| ((vals[tb->next_paired_piece[piece]] < vals[piece])
		    && (vals[tb->next_paired_piece[piece]] + 32 >= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_paired_piece[piece]];
		vals[tb->next_paired_piece[piece]] = val;
	    }
	}

	if ((piece == tb->white_king) && (tb->symmetry == 2)) {
	    /* white king is in left half of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 3;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if ((piece == tb->white_king) && (tb->symmetry == 4)) {
	    /* white king is in lower left quarter of board */
	    index |= ROW(vals[piece]) << shift_count;
	    shift_count += 2;
	    index |= COL(vals[piece]) << shift_count;
	    shift_count += 2;
	} else if (tb->last_paired_piece[piece] == -1) {
	    index |= vals[piece] << shift_count;
	    shift_count += 6;  /* because 2^6=64 */
	} else {
	    if (vals[piece] > vals[tb->last_paired_piece[piece]]) {
		index |= (vals[piece] - vals[tb->last_paired_piece[piece]] - 1) << shift_count;
	    } else {
		index |= (64 + vals[piece] - vals[tb->last_paired_piece[piece]] - 1) << shift_count;
	    }
	    shift_count += 5; /* the whole point of "naive2" */
	}
    }

    return index;
}

boolean naive2_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8 vals[MAX_PIECES];

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index & 1;
    index >>= 1;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	if ((tb->symmetry == 2) && (piece == tb->white_king)) {
	    vals[piece] = rowcol2square(index & 7, (index >> 3) & 3);
	    index >>= 5;
	} else if ((tb->symmetry == 4) && (piece == tb->white_king)) {
	    vals[piece] = rowcol2square(index & 3, (index >> 2) & 3);
	    index >>= 4;
	} else if (tb->last_paired_piece[piece] == -1) {
	    vals[piece] = index & 63;
	    index >>= 6;
	} else {
	    vals[piece] = (vals[tb->last_paired_piece[piece]] + (index & 31) + 1) % 64;
	    index >>= 5;

	    if (vals[piece] < vals[tb->last_paired_piece[piece]]) {
		unsigned char val;

		/* One of the important tasks of any index_to_local_position() function is to return
		 * false on all but one of the indices that correspond to identical positions.
		 * Here, that can only happen when two paired pieces are exactly 32 squares apart,
		 * which can be encoded using either piece first.  In this case, we toss out the
		 * index with the larger of the two squares encoded as the base value, and make sure
		 * that the "<" and the ">=" match up just right in the previous function.
		 */

		if (vals[tb->last_paired_piece[piece]] - vals[piece] == 32) return 0;

		val = vals[piece];
		vals[piece] = vals[tb->last_paired_piece[piece]];
		vals[tb->last_paired_piece[piece]] = val;
	    }
	}

    }

    for (piece = 0; piece < tb->num_pieces; piece++) {

	int square = vals[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* The first place we handle restricted pieces, and one of most important, too, because this
	 * function is used during initialization to decide which indices are legal and which are
	 * not.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	/* Identical pieces have to appear in sorted order. */

	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "Simple" index.  Like naive, but only assigns numbers to squares that are legal for a particular
 * piece.  Slower to compute than naive, but more compact for tablebases with lots of movement
 * restrictions on the pieces.
 */

index_t local_position_to_simple_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	index *= tb->total_legal_piece_positions[piece];

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    index += tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    index += tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}
    }

    /* We've still got code that assumes flipping the index's LSB flip side-to-move */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean simple_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = tb->simple_piece_positions[piece][index % tb->total_legal_piece_positions[piece]];
	index /= tb->total_legal_piece_positions[piece];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (square < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 2*8;
		square += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = square + 5*8;
		square += 4*8;
	    }
	}

	/* This should never happen. */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    fatal("Illegal piece position in simple_index_to_local_position!\n");
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }

    if (index != 0) {
	fatal("index != 0 at end of simple_index_to_local_position!\n");
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* "compact" index
 *
 * A combination of the delta encoding for identical pieces used in "naive2", the encoding of
 * restricted pieces used in "simple", plus a paired encoding of the kings so they can never be
 * adjacent.
 *
 * Pairs of identical pieces can be handled in at least three ways that I can think of:
 *
 * 1. Treat the pieces as paired and encode using the full semilegal range for each of them, using
 * delta encoding to cut the total size in half, and then throw out as illegal those positions where
 * the pieces can't be put onto legal squares.  Makes the most sense if the move restrictions are
 * completely overlapping.
 *
 * 2. Treat the pieces as independent and encode each using its legal range, and then throw out as
 * illegal half of those positions where both the pieces are on interchangable legal squares.  Makes
 * the most sense if one of the move restrictions is significantly smaller than the other.
 *
 * 3. Build an array in memory like we do with the kings to encode only the legal possibilities.  No
 * bogus illegal positions here, but doesn't really scale to more than two pieces.
 *
 * Right now, we use method (1) without option.
 *
 * Some additional things could be done to make an even more compact encoding:
 *
 * Take advantage of previous pieces occupying squares to cut encoding down from 64*64*64*...  to
 * 64*63*62*...  Actually, since we've already got the kings encoded pretty compactly, it would be
 * cutting down from 64*64*64*... to 62*61*60*...  Move restrictions would complicate this; maybe
 * only do it for pieces whose move restriction can be fit entirely in the move restrictions of
 * previous pieces.
 *
 * Encode en passant position-wide instead of adding an extra square for each pawn.  Would be a win
 * in positions with lots of pawns.
 *
 * The 'compact' routines are also used for the 'no-en-passant' index type, which is identical to
 * compact except that opposing plus-pawns are encoded as paired pieces.  So long as we leave en
 * passant out of the picture, opposing plus-pawns occupy an identical range of squares and, so long
 * as we know which two squares are occupied, we can always figure out which pawn is white and which
 * is black because they can't jump over each other.  En passant would complicate this, because then
 * the two pawns wouldn't be identical in their ranges.
 */

index_t local_position_to_compact_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;
    uint8 vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    vals[piece] = tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}
    }

    /* Compute the index.
     *
     * We encode two identical pieces using one less bit than needed for encoding them separately,
     * because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if (piece == tb->white_king) {
	    index *= tb->total_legal_compact_king_positions;
	    index += tb->compact_king_indices[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->next_paired_piece[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_paired_piece[piece]])
		 && (vals[piece] + tb->total_legal_piece_positions[piece]/2
		     < vals[tb->next_paired_piece[piece]]))
		|| ((vals[tb->next_paired_piece[piece]] < vals[piece])
		    && (vals[tb->next_paired_piece[piece]] + tb->total_legal_piece_positions[piece]/2
			>= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_paired_piece[piece]];
		vals[tb->next_paired_piece[piece]] = val;
	    }
	}

	if (tb->last_paired_piece[piece] == -1) {
	    index *= tb->total_legal_piece_positions[piece];
	    index += vals[piece];
	} else {
	    index *= tb->total_legal_piece_positions[piece] / 2;

	    if (vals[piece] > vals[tb->last_paired_piece[piece]]) {
		index += (vals[piece] - vals[tb->last_paired_piece[piece]] - 1);
	    } else {
		index += (tb->total_legal_piece_positions[piece] + vals[piece] - vals[tb->last_paired_piece[piece]] - 1);
	    }
	}
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean compact_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8 vals[MAX_PIECES];
    int king_index;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    /* First, split index into an array of encoding values. */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if (piece == tb->white_king) {
	    king_index = index % tb->total_legal_compact_king_positions;
	    index /= tb->total_legal_compact_king_positions;
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] == -1) {
	    vals[piece] = index % tb->total_legal_piece_positions[piece];
	    index /= tb->total_legal_piece_positions[piece];
	} else {
	    vals[piece] = index % (tb->total_legal_piece_positions[piece]/2);
	    index /= tb->total_legal_piece_positions[piece]/2;
	}
    }

    /* Next, back out any delta encoding and convert the encoding numbers to square numbers on the
     * board.  This loop has to run in reverse order over the pieces, since the delta encodings are
     * based on previous encoding numbers, and we're converting to square numbers as we go.  We run
     * a seperate loop here because we might need previous encoding values to back out the deltas.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] != -1) {

	    vals[piece] += vals[tb->last_paired_piece[piece]] + 1;
	    vals[piece] %= tb->total_legal_piece_positions[piece];

	    /* One of the important tasks of any index_to_local_position() function is to return
	     * false on all but one of the indices that correspond to identical positions.  Here,
	     * that can only happen when two paired pieces are exactly half their total legal piece
	     * positions squares apart, which can be encoded using either piece first.  In this
	     * case, we toss out the index with the larger of the two squares encoded as the base
	     * value, and make sure that the "<" and the ">=" match up just right in the previous
	     * function.
	     */

	    if (vals[tb->last_paired_piece[piece]] - vals[piece]
		== tb->total_legal_piece_positions[piece]/2) return 0;
	}

	vals[piece] = tb->simple_piece_positions[piece][vals[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (vals[piece] < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 2*8;
		vals[piece] += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 5*8;
		vals[piece] += 4*8;
	    }
	}

    }

    /* Now we have to decide the actual ordering in the piece array.  Right now, since we only use
     * this code for pairs of identical pieces, we swap if the higher numbered piece is first, then
     * swap (maybe again) if the pieces aren't on legal squares.  The net result is to put them both
     * on legal squares, if possible, and to put the lower numbered square first if both
     * possibilities are legal.
     *
     * This loop also has to run in reverse order for the swap code to work right.  We run a
     * seperate loop here because the legality checks are based on square numbers and not encoding
     * values, and we need for all the previous encoding values to have been converted into square
     * numbers first.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] != -1) {

	    if (vals[piece] < vals[tb->last_paired_piece[piece]]) {
		uint8 val = vals[piece];
		vals[piece] = vals[tb->last_paired_piece[piece]];
		vals[tb->last_paired_piece[piece]] = val;
	    }

	    if (! (tb->legal_squares[piece] & BITVECTOR(vals[piece]))
		|| ! (tb->legal_squares[tb->last_paired_piece[piece]]
		      & BITVECTOR(vals[tb->last_paired_piece[piece]]))) {

		uint8 val = vals[piece];
		vals[piece] = vals[tb->last_paired_piece[piece]];
		vals[tb->last_paired_piece[piece]] = val;
	    }
	}
    }

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = vals[piece];

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in compact_index_to_local_position!\n"); */
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    p->piece_position[tb->white_king] = tb->compact_white_king_positions[king_index];
    p->piece_position[tb->black_king] = tb->compact_black_king_positions[king_index];
    if (p->board_vector & BITVECTOR(p->piece_position[tb->white_king])) return 0;
    if (p->board_vector & BITVECTOR(p->piece_position[tb->black_king])) return 0;
    p->board_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    p->board_vector |= BITVECTOR(p->piece_position[tb->black_king]);
    if (p->side_to_move == WHITE)
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    else
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->black_king]);

#if 0
    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }
#endif

    if (index != 0) {
	fatal("index != 0 at end of compact_index_to_local_position!\n");
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* 'standard' index type */

index_t local_position_to_standard_index(tablebase_t *tb, local_position_t *pos)
{
    index_t index;
    int piece;
    uint8 vals[MAX_PIECES];

    index = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* The way we encode en passant capturable pawns is use the column number of the
	 * pawn.  Since there can never be a pawn (of either color) on the first rank,
	 * this is completely legit.
	 */
	if ((tb->piece_type[piece] == PAWN) && (pos->en_passant_square != -1)
	    && (((tb->piece_color[piece] == WHITE)
		 && (pos->en_passant_square + 8 == pos->piece_position[piece]))
		|| ((tb->piece_color[piece] == BLACK)
		    && (pos->en_passant_square - 8 == pos->piece_position[piece])))) {
	    vals[piece] = tb->simple_piece_indices[piece][COL(pos->en_passant_square)];
	} else {
	    vals[piece] = tb->simple_piece_indices[piece][pos->piece_position[piece]];
	}
    }

    /* Compute the index.
     *
     * We encode two identical pieces using one less bit than needed for encoding them separately,
     * because n identical pieces introduce n! (n factorial) multiplicity.
     *
     * We encode the first piece "normally" and the second piece using a number from 1 to 32
     * (encoded from 0 to 31) that should be added to the square number of the first piece to obtain
     * the square number of the second.  We wrap around when doing that math, so if the first piece
     * is on square 50 and the offset is 20, then the second piece is at square 50+20-64=6.
     *
     * What if the second piece is further away than 32 squares?  Then we swap the pieces with each
     * other before doing anything else...
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if (piece == tb->white_king) {
	    index *= tb->total_legal_compact_king_positions;
	    index += tb->compact_king_indices[pos->piece_position[tb->white_king]]
		[pos->piece_position[tb->black_king]];
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->next_paired_piece[piece] != -1) {

	    if (((vals[piece] < vals[tb->next_paired_piece[piece]])
		 && (vals[piece] + tb->total_legal_piece_positions[piece]/2
		     < vals[tb->next_paired_piece[piece]]))
		|| ((vals[tb->next_paired_piece[piece]] < vals[piece])
		    && (vals[tb->next_paired_piece[piece]] + tb->total_legal_piece_positions[piece]/2
			>= vals[piece]))) {

		unsigned char val;
		val = vals[piece];
		vals[piece] = vals[tb->next_paired_piece[piece]];
		vals[tb->next_paired_piece[piece]] = val;
	    }
	}

	if (tb->last_paired_piece[piece] == -1) {
	    index *= tb->total_legal_piece_positions[piece];
	    index += vals[piece];
	} else {
	    index *= tb->total_legal_piece_positions[piece] / 2;

	    if (vals[piece] > vals[tb->last_paired_piece[piece]]) {
		index += (vals[piece] - vals[tb->last_paired_piece[piece]] - 1);
	    } else {
		index += (tb->total_legal_piece_positions[piece] + vals[piece] - vals[tb->last_paired_piece[piece]] - 1);
	    }
	}
    }

    /* index_to_side_to_move() assumes that side-to-move is the index's LSB */

    index *= 2;
    index += pos->side_to_move;  /* WHITE is 0; BLACK is 1 */

    return index;
}

boolean standard_index_to_local_position(tablebase_t *tb, index_t index, local_position_t *p)
{
    int piece;
    uint8 vals[MAX_PIECES];
    int king_index;

    memset(p, 0, sizeof(local_position_t));
    p->en_passant_square = -1;

    p->side_to_move = index % 2;
    index /= 2;

    /* First, split index into an array of encoding values. */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if (piece == tb->white_king) {
	    king_index = index % tb->total_legal_compact_king_positions;
	    index /= tb->total_legal_compact_king_positions;
	}

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] == -1) {
	    vals[piece] = index % tb->total_legal_piece_positions[piece];
	    index /= tb->total_legal_piece_positions[piece];
	} else {
	    vals[piece] = index % (tb->total_legal_piece_positions[piece]/2);
	    index /= tb->total_legal_piece_positions[piece]/2;
	}
    }

    /* Next, back out any delta encoding and convert the encoding numbers to square numbers on the
     * board.  This loop has to run in reverse order over the pieces, since the delta encodings are
     * based on previous encoding numbers, and we're converting to square numbers as we go.  We run
     * a seperate loop here because we might need previous encoding values to back out the deltas.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] != -1) {

	    vals[piece] += vals[tb->last_paired_piece[piece]] + 1;
	    vals[piece] %= tb->total_legal_piece_positions[piece];

	    /* One of the important tasks of any index_to_local_position() function is to return
	     * false on all but one of the indices that correspond to identical positions.  Here,
	     * that can only happen when two paired pieces are exactly half their total legal piece
	     * positions squares apart, which can be encoded using either piece first.  In this
	     * case, we toss out the index with the larger of the two squares encoded as the base
	     * value, and make sure that the "<" and the ">=" match up just right in the previous
	     * function.
	     */

	    if (tb->total_legal_piece_positions[piece] % 2 == 0) {
		if (vals[tb->last_paired_piece[piece]] - vals[piece]
		    == tb->total_legal_piece_positions[piece]/2) return 0;
	    }
	}

	vals[piece] = tb->simple_piece_positions[piece][vals[piece]];

	/* En passant */
	if ((tb->piece_type[piece] == PAWN) && (vals[piece] < 8)) {
	    if (p->en_passant_square != -1) return 0;  /* can't have two en passant pawns */
	    if (tb->piece_color[piece] == WHITE) {
		if (p->side_to_move != BLACK) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 2*8;
		vals[piece] += 3*8;
	    } else {
		if (p->side_to_move != WHITE) return 0; /* en passant pawn has to be capturable */
		p->en_passant_square = vals[piece] + 5*8;
		vals[piece] += 4*8;
	    }
	}

    }

    /* Now we have to decide the actual ordering in the piece array.  Right now, since we only use
     * this code for pairs of identical pieces, we swap if the higher numbered piece is first, then
     * swap (maybe again) if the pieces aren't on legal squares.  The net result is to put them both
     * on legal squares, if possible, and to put the lower numbered square first if both
     * possibilities are legal.
     *
     * This loop also has to run in reverse order for the swap code to work right.  We run a
     * seperate loop here because the legality checks are based on square numbers and not encoding
     * values, and we need for all the previous encoding values to have been converted into square
     * numbers first.
     */

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	if (tb->last_paired_piece[piece] != -1) {

	    if (vals[piece] < vals[tb->last_paired_piece[piece]]) {
		uint8 val = vals[piece];
		vals[piece] = vals[tb->last_paired_piece[piece]];
		vals[tb->last_paired_piece[piece]] = val;
	    }

	    if (! (tb->legal_squares[piece] & BITVECTOR(vals[piece]))
		|| ! (tb->legal_squares[tb->last_paired_piece[piece]]
		      & BITVECTOR(vals[tb->last_paired_piece[piece]]))) {

		uint8 val = vals[piece];
		vals[piece] = vals[tb->last_paired_piece[piece]];
		vals[tb->last_paired_piece[piece]] = val;
	    }
	}
    }

    for (piece = tb->num_pieces - 1; piece >= 0; piece --) {

	int square = vals[piece];

	if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	/* This can happen if we have multiple identical pieces because we counted semilegal
	 * positions to encode them with.
	 */

	if (!(tb->legal_squares[piece] & BITVECTOR(square))) {
	    /* fprintf(stderr, "Illegal piece position in standard_index_to_local_position!\n"); */
	    return 0;
	}

	p->piece_position[piece] = square;
	if (p->board_vector & BITVECTOR(square)) {
	    return 0;
	}

	p->board_vector |= BITVECTOR(square);
	if (tb->piece_color[piece] == p->side_to_move) {
	    p->PTM_vector |= BITVECTOR(square);
	}
    }

    p->piece_position[tb->white_king] = tb->compact_white_king_positions[king_index];
    p->piece_position[tb->black_king] = tb->compact_black_king_positions[king_index];
    if (p->board_vector & BITVECTOR(p->piece_position[tb->white_king])) return 0;
    if (p->board_vector & BITVECTOR(p->piece_position[tb->black_king])) return 0;
    p->board_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    p->board_vector |= BITVECTOR(p->piece_position[tb->black_king]);
    if (p->side_to_move == WHITE)
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->white_king]);
    else
	p->PTM_vector |= BITVECTOR(p->piece_position[tb->black_king]);

#if 0
    /* Identical pieces have to appear in sorted order. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->last_identical_piece[piece] != -1)
	    && (p->piece_position[piece] < p->piece_position[tb->last_identical_piece[piece]])) {
	    return 0;
	}
    }
#endif

    if (index != 0) {
	fatal("index != 0 at end of standard_index_to_local_position!\n");
	return 0;
    }

    /* If there is an en passant capturable pawn in this position, then there can't be anything
     * on the capture square or on the square right behind it (where the pawn just came from),
     * or its an illegal position.
     */

    if (p->en_passant_square != -1) {
	if (p->board_vector & BITVECTOR(p->en_passant_square)) return 0;
	if (p->side_to_move == WHITE) {
	    if (p->board_vector & BITVECTOR(p->en_passant_square + 8)) return 0;
	} else {
	    if (p->board_vector & BITVECTOR(p->en_passant_square - 8)) return 0;
	}
    }

    return 1;
}

/* Normalization - normalize_position() and denormalize_position()
 *
 * Not all positions are created equal.  For example, interchanging two identical pieces doesn't
 * change the position at all, so a position with rook #1 on e4 and rook #2 on g6 is the same as one
 * with rook #1 on g6 and rook #2 on e4.  When converting to an index, we deal with this by sorting
 * identical pieces so the piece on the lowest numbered square always appears first in the position.
 *
 * But this creates problems when trying to move a piece.  Consider for example, the two rooks.  If
 * we now being moving rook #1 along the e file, it moves to e5, then e6, then e7.  Now, at e7, it
 * has become the rook on the higher numbered square, so the pieces have just "flipped" in the
 * position structure!  Additionally, if we have symmetry involved, then which piece is on the
 * higher numbered square can depend on the reflections required to get the kings to their
 * restricted areas.
 *
 * And we can't simply hide all of this in the guts of the position-to-index functions, because we
 * track futuremoves.  Figuring out "which one" of an identical pair of pieces got captured is
 * critical to figuring out which bit in the futuremoves vector corresponds to this move.
 *
 * So, we deal with this using "normalization".  We call normalize_position() to apply all the
 * reflection and sorting needed to get the position to a point where it can be directly converted
 * to an index.  We record these transformations using the 'reflection' variable and an array of
 * permutations in the position structure, so we can put everything back with
 * denormalize_position().
 *
 * Oh, and we can look into the permutation array to figure out which piece has been swapped where,
 * so we can figure out futuremove bit vectors accordingly.  So the way we move a rook, like in the
 * example above, is to move it e5, normalize, back prop, denormalize, then move it to e6,
 * normalize, back prop, denormalize, move it to e7, etc.
 *
 * We also recompute the board vector in both functions, because the reflections can change it
 * around.
 */

void transpose_pieces(local_position_t *position, int piece1, int piece2)
{
    int square = position->piece_position[piece2];
    int permuted_piece = position->permuted_piece[piece2];

    position->piece_position[piece2] = position->piece_position[piece1];
    position->piece_position[piece1] = square;

    position->permuted_piece[piece2] = position->permuted_piece[piece1];
    position->permuted_piece[piece1] = permuted_piece;
}


void normalize_position(tablebase_t *tb, local_position_t *position)
{
    int piece, piece2;

    /* Reflect the pieces around to get the white king where we want him for symmetry.
     *
     * 2-way symmetry: white king always on left side of board
     *
     * 4-way symmetry: white king always in lower left quarter of board
     *
     * 8-way symmetry: white king always in a1-a4-d4 triangle, and if white king is on a1-d4
     * diagonal, then black king is on or below a1-h8 diagonal
     */

    position->reflection = 0;

    if (tb->symmetry >= 2) {
	if (COL(position->piece_position[tb->white_king]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = horizontal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 4;
	}
    }

    if (tb->symmetry >= 4) {
	if (ROW(position->piece_position[tb->white_king]) >= 4) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = vertical_reflection(position->en_passant_square);
	    }
	    position->reflection |= 2;
	}
    }

    if (tb->symmetry == 8) {
	if (ROW(position->piece_position[tb->white_king]) > COL(position->piece_position[tb->white_king])) {
	    for (piece = 0; piece < tb->num_pieces; piece ++) {
		position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    }
	    if (position->en_passant_square != -1) {
		position->en_passant_square = diagonal_reflection(position->en_passant_square);
	    }
	    position->reflection |= 1;
	}
#if 1
	if (ROW(position->piece_position[tb->white_king]) == COL(position->piece_position[tb->white_king])) {
	    if (ROW(position->piece_position[tb->black_king]) > COL(position->piece_position[tb->black_king])) {
		for (piece = 0; piece < tb->num_pieces; piece ++) {
		    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
		}
		position->reflection |= 1;
	    }
	}
#endif
    }

    /* Sort any identical pieces so that the lowest square number always comes first. */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	piece2 = piece;
	while ((tb->last_identical_piece[piece2] != -1)
	       && (position->piece_position[piece2]
		   < position->piece_position[tb->last_identical_piece[piece2]])) {
	    transpose_pieces(position, piece2, tb->last_identical_piece[piece2]);
	    piece2 = tb->last_identical_piece[piece2];
	}
    }

    /* Now swap identical pieces to try and get them onto legal squares (if needed)
     *
     * This code certainly isn't perfect, but since parse_XML_into_tablebase() currently disallows
     * more than two identical pieces, all it has to do is swap.
     *
     * If the swap doesn't work, we don't care.  This position is then illegal and will get rejected
     * when we try to convert it to an index.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (! (tb->legal_squares[piece] & BITVECTOR(position->piece_position[piece]))) {
	    if (tb->next_identical_piece[piece] != -1) {
		transpose_pieces(position, piece, tb->next_identical_piece[piece]);
	    }
	    if (tb->last_identical_piece[piece] != -1) {
		transpose_pieces(position, piece, tb->last_identical_piece[piece]);
	    }
	}
    }

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }
}

void denormalize_position(tablebase_t *tb, local_position_t *position)
{
    int piece;

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if (position->permuted_piece[piece] != piece) {
	    transpose_pieces(position, piece, position->permuted_piece[piece]);
	}

	if ((position->reflection & 1) == 1) {
	    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	}
	if ((position->reflection & 2) == 2) {
	    position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	}
	if ((position->reflection & 4) == 4) {
	    position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	}
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }

    if (position->en_passant_square != -1) {
	if ((position->reflection & 1) == 1) {
	    position->en_passant_square = diagonal_reflection(position->en_passant_square);
	}
	if ((position->reflection & 2) == 2) {
	    position->en_passant_square = vertical_reflection(position->en_passant_square);
	}
	if ((position->reflection & 4) == 4) {
	    position->en_passant_square = horizontal_reflection(position->en_passant_square);
	}
    }

    position->reflection = 0;
}

index_t normalized_position_to_index(tablebase_t *tb, local_position_t *position)
{
    index_t index;
    int piece;

#if CHECK_KING_LEGALITY_EARLY
    if (! check_king_legality(position->piece_position[tb->white_king], position->piece_position[tb->black_king]))
	return -1;
#endif

    if ((tb->index_type == NO_EN_PASSANT_INDEX) && (position->en_passant_square != -1))
	return -1;

    /* Recompute board_vector, and check for legality of piece positions */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	if ((position->piece_position[piece] < 0) || (position->piece_position[piece] > 63)
	    || !(tb->legal_squares[piece] & BITVECTOR(position->piece_position[piece]))) {
	    /* This can happen if we're probing a restricted tablebase */
	    return -1;
	}

	/* Blocking pawns.  Reject any position where a pawn has "hopped" over the enemy pawn
	 * blocking it.
	 */

	if ((tb->piece_type[piece] == PAWN) && (tb->blocking_piece[piece] != -1)) {
	    if (tb->piece_color[piece] == WHITE) {
		if (position->piece_position[piece] > position->piece_position[tb->blocking_piece[piece]]) {
		    return -1;
		}
	    } else {
		if (position->piece_position[piece] < position->piece_position[tb->blocking_piece[piece]]) {
		    return -1;
		}
	    }
	}

	if (position->board_vector & BITVECTOR(position->piece_position[piece])) return -1;
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }

    /* Check board_vector to make sure an en passant position is legal */

    if (position->en_passant_square != -1) {
	if (position->board_vector & BITVECTOR(position->en_passant_square)) return -1;
	if (position->side_to_move == WHITE) {
	    if (position->board_vector & BITVECTOR(position->en_passant_square + 8)) return -1;
	} else {
	    if (position->board_vector & BITVECTOR(position->en_passant_square - 8)) return -1;
	}
    }

    switch (tb->index_type) {
    case NAIVE_INDEX:
	index = local_position_to_naive_index(tb, position);
	break;
    case NAIVE2_INDEX:
	index = local_position_to_naive2_index(tb, position);
	break;
    case SIMPLE_INDEX:
	index = local_position_to_simple_index(tb, position);
	break;
    case COMPACT_INDEX:
    case NO_EN_PASSANT_INDEX:
	index = local_position_to_compact_index(tb, position);
	break;
    case STANDARD_INDEX:
	index = local_position_to_standard_index(tb, position);
	break;
    default:
	fatal("Unknown index type in local_position_to_index()\n");
	return -1;
    }

    index += tb->index_offset;

    if ((index != -1) && (index != 0) && (tb->modulus != 0)) {
	index = invert_in_finite_field(index, tb->modulus);
    }

    /* Multiplicity - number of non-identical positions that this index corresponds to.  We want to
     * update the original position structure that got passed in.
     */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[tb->white_king]) != COL(position->piece_position[tb->white_king]))
	    || (ROW(position->piece_position[tb->black_king]) != COL(position->piece_position[tb->black_king])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    return index;
}

index_t local_position_to_index(tablebase_t *tb, local_position_t *original)
{
    index_t index;

    /* We don't want to change around the original position, during these next transformations, so
     * we use a copy of it.  We do, however, update the multiplicity in the original structure.
     */

    local_position_t copy = *original;

    normalize_position(tb, &copy);

    index = normalized_position_to_index(tb, &copy);

    original->multiplicity = copy.multiplicity;

    return index;
}

boolean index_to_local_position(tablebase_t *tb, index_t index, int reflection, local_position_t *position)
{
    int ret;
    int piece, piece2;

    if ((index != 0) && (tb->modulus != 0)) {
	index = invert_in_finite_field(index, tb->modulus);
    }

    if (index < tb->index_offset) return 0;
    index -= tb->index_offset;

    switch (tb->index_type) {
    case NAIVE_INDEX:
	ret = naive_index_to_local_position(tb, index, position);
	break;
    case NAIVE2_INDEX:
	ret = naive2_index_to_local_position(tb, index, position);
	break;
    case SIMPLE_INDEX:
	ret = simple_index_to_local_position(tb, index, position);
	break;
    case COMPACT_INDEX:
    case NO_EN_PASSANT_INDEX:
	ret = compact_index_to_local_position(tb, index, position);
	break;
    case STANDARD_INDEX:
	ret = standard_index_to_local_position(tb, index, position);
	break;
    default:
	fatal("Unknown index type in index_to_local_position()\n");
	return 0;
    }

    if (!ret) return 0;

    /* Blocking pawns.  Reject any position where a pawn has "hopped" over the enemy piece blocking
     * it.
     */

    for (piece = 0; piece < tb->num_pieces; piece++) {
	if ((tb->piece_type[piece] == PAWN) && (tb->blocking_piece[piece] != -1)) {
	    if (tb->piece_color[piece] == WHITE) {
		if (position->piece_position[piece] > position->piece_position[tb->blocking_piece[piece]]) {
		    return 0;
		}
	    } else {
		if (position->piece_position[piece] < position->piece_position[tb->blocking_piece[piece]]) {
		    return 0;
		}
	    }
	}
    }

#if CHECK_KING_LEGALITY_EARLY
    if (! check_king_legality(position->piece_position[tb->white_king], position->piece_position[tb->black_king]))
	return 0;
#endif

    if ((tb->symmetry == 8)
	&& (ROW(position->piece_position[tb->white_king]) == COL(position->piece_position[tb->white_king]))
	&& (ROW(position->piece_position[tb->black_king]) > COL(position->piece_position[tb->black_king])))
	return 0;

    /* Multiplicity - number of non-identical positions that this index corresponds to */

    if ((tb->symmetry == 8)
	&& ((ROW(position->piece_position[tb->white_king]) != COL(position->piece_position[tb->white_king]))
	    || (ROW(position->piece_position[tb->black_king]) != COL(position->piece_position[tb->black_king])))) {
	position->multiplicity = 2;
    } else {
	position->multiplicity = 1;
    }

    if (reflection & REFLECTION_DIAGONAL) {
	if (position->multiplicity == 1) return 0;

	/* diagonal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = diagonal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = diagonal_reflection(position->en_passant_square);
    }

    if (reflection & REFLECTION_VERTICAL) {
	/* vertical reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = vertical_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = vertical_reflection(position->en_passant_square);
    }

    if (reflection & REFLECTION_HORIZONTAL) {
	/* horizontal reflection */
	position->board_vector = 0;
	position->PTM_vector = 0;
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    position->piece_position[piece] = horizontal_reflection(position->piece_position[piece]);
	    position->board_vector |= BITVECTOR(position->piece_position[piece]);
	    if (tb->piece_color[piece] == position->side_to_move)
		position->PTM_vector |= BITVECTOR(position->piece_position[piece]);
	}
	if (position->en_passant_square > 0)
	    position->en_passant_square = horizontal_reflection(position->en_passant_square);
    }

    /* Sort any identical pieces so that the lowest square number always comes first.
     *
     * The various index-to-position routines returned sorted piece arrays, but the various symmetry
     * reflections might have upset this.  Some places, particularly the translate_... routines in
     * futurebase back propagation, depend on the pieces being sorted.
     *
     * Note that we initialize the permuted_piece array AFTER this sort.  That's because
     * permuted_piece is used to track the changes that happen after index-to-position and before
     * position-to-index, NOT the changes that happen internally in index-to-position.
     *
     * Also, I don't even attempt to do this if there is no tablebase symmetry.  Not only is it
     * unnecessary in that case, but this can really screw up overlapping piece restrictions.  Since
     * we don't (currently) allow piece restrictions and symmetry at the same time...
     */

    if (tb->symmetry > 1) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    piece2 = piece;
	    while ((tb->last_identical_piece[piece2] != -1)
		   && (position->piece_position[piece2]
		       < position->piece_position[tb->last_identical_piece[piece2]])) {
		transpose_pieces(position, piece2, tb->last_identical_piece[piece2]);
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->permuted_piece[piece] = piece;
    }
    position->reflection = 0;

#if 0
    /* Maybe should do this here, instead of in the various reflection code above. */

    position->board_vector = 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	position->board_vector |= BITVECTOR(position->piece_position[piece]);
    }
#endif

    return 1;
}

int index_to_side_to_move(tablebase_t *tb, index_t index)
{
    local_position_t position;

    if (tb->modulus != 0) {
	if (! index_to_local_position(tb, index, REFLECTION_NONE, &position)) return -1;
	else return position.side_to_move;
    } else {
	return (index - tb->index_offset) & 1;
    }
}

/* check_1000_positions(); check_1000_indices() - used just to double check the code above.
 *
 * I don't use check_1000_positions() anymore because it barks if there are identical pieces in a
 * position that come back sorted after being run through a position->index->position conversion.
 */

int check_1000_positions(tablebase_t *tb)
{
    local_position_t position1;
    local_position_t position2;
    index_t index;
    int positions;
    int piece;
    int ret = 1;

    for (positions=0; positions < 1000; positions ++) {

	memset(&position1, 0, sizeof(position1));

	position1.side_to_move = rand() % 2;
	position1.en_passant_square = -1;

    retry:
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    do {
		position1.piece_position[piece] = rand() % 64;
	    } while (! (BITVECTOR(position1.piece_position[piece]) & tb->legal_squares[piece]));
	}

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if ((tb->last_identical_piece[piece] != -1) &&
		(position1.piece_position[piece] <=
		 position1.piece_position[tb->last_identical_piece[piece]])) goto retry;
	}

	index = local_position_to_index(tb, &position1);

	if (index != -1) {

	    /* PTM_vector wasn't set in position1, so don't check them now */

	    if (!index_to_local_position(tb, index, REFLECTION_NONE, &position2)
		|| (position2.PTM_vector = 0, position2.board_vector = 0,
		    memcmp(&position1, &position2, sizeof(position1)))) {
		fatal("Mismatch in check_1000_positions()\n");
		ret = 0;
	    }
	}
    }

    return ret;
}

int check_1000_indices(tablebase_t *tb)
{
    local_position_t position;
    index_t index;
    index_t index2;
    int positions;
    int ret = 1;

    for (positions=0; positions < 1000; positions ++) {

	index = rand() % (tb->max_index + 1);

	if (index_to_local_position(tb, index, REFLECTION_NONE, &position)) {
	    index2 = local_position_to_index(tb, &position);
	    if (index != index2) {
		fatal("Mismatch in check_1000_indices()\n");
		ret = 0;
	    }
	}
    }

    return ret;
}

/***** XML TABLEBASE INTERACTION *****/

/* parse_format()
 *
 * Parse an XML format specification (for a dynamic structure) into a format structure.  A simple
 * XML format looks something like:
 *
 *   <format>
 *      <dtm bits="8"/>
 *   </format>
 *
 * Essentially, this specifies the layout of a C structure at run-time, and we have to jump through
 * all kinds of obscure nonsense to get dynamic structures.  Basically, we end up doing everything
 * with shifts and masks rather than normal structure operations.
 *
 * The XML format can be specified with either explicit or implicit offsets.  Explicit offsets are
 * just that: <dtm bits="8" offset="8"/> specifies an 8-bit field at an 8-bit offset into the
 * structure.  Implicit offsets assign the offset values counting up from zero (like the first
 * example above).  The two can not be mixed in the same format spec.
 *
 * The total size of a format is silently rounded up to a power-of-two byte boundary.  This is done
 * to make sure that the resulting structures can't straddle buffer boundaries.
 */

boolean parse_format(xmlNodePtr formatNode, struct format *format)
{
    xmlNodePtr child;
    int auto_offset = 0;
    int total_bits = 0;
    int power_of_two;
    int bitnum;
    uint64 bitmask1 = 0;
    uint64 bitmask2 = 0;

    memset(format, 0, sizeof(struct format));

    format->dtm_offset = -1;
    format->movecnt_offset = -1;
    format->index_offset = -1;
    format->futurevector_offset = -1;
    format->flag_offset = -1;
    format->PTM_wins_flag_offset = -1;

    for (child = formatNode->children; child != NULL; child = child->next) {
	if (child->type == XML_ELEMENT_NODE) {
	    char * bitstr = (char *) xmlGetProp(child, BAD_CAST "bits");
	    char * offsetstr = (char *) xmlGetProp(child, BAD_CAST "offset");
	    char * typestr;
	    int bits = (bitstr != NULL) ? atoi(bitstr) : 0;
	    int offset = (offsetstr != NULL) ? atoi(offsetstr) : -1;
	    int format_field = find_name_in_array((char *) child->name, format_fields);

	    if ((bitstr == NULL) &&
		((format_field == FORMAT_FIELD_FLAG) || (format_field == FORMAT_FIELD_PTM_WINS_FLAG))) {
		bits = 1;
	    }

	    if (bitstr != NULL) xmlFree(bitstr);
	    if (offsetstr != NULL) xmlFree(offsetstr);

	    if (format_field == -1) {
		fatal("Unknown field in format: %s\n", (char *) child->name);
		return 0;
	    }
	    if ((bits == 0)
		&& (format_field != FORMAT_FIELD_FLAG) && (format_field != FORMAT_FIELD_PTM_WINS_FLAG)) {
		fatal("Non-zero 'bits' value must be specified in format field '%s'\n",
		      (char *) child->name);
		return 0;
	    }
	    if ((bits != 1)
		&& ((format_field == FORMAT_FIELD_FLAG) || (format_field == FORMAT_FIELD_PTM_WINS_FLAG))) {
		fatal("Format fields 'flag' and 'PTM-wins-flag' only accept bits=\"1\"\n");
		return 0;
	    }

	    if ((offset == -1) && (auto_offset == -1)) {
		fatal("Can't mix explicit and implicit offsets in format\n");
		return 0;
	    }

	    if (offset == -1) {
		offset = auto_offset;
		auto_offset += bits;
	    } else {
		auto_offset = -1;
	    }

	    if ((format_field != FORMAT_FIELD_FUTUREVECTOR) && (offset/32 != (offset+bits-1) / 32)) {
		fatal("Most format fields can't straddle a 32-bit boundary\n");
		return 0;
	    }

	    if (offset/64 != (offset+bits-1) / 64) {
		fatal("Format fields can't straddle a 64-bit boundary\n");
		return 0;
	    }

	    if (offset >= 128) {
		fatal("Formats can't exceed 128 bits\n");
		return 0;
	    }

	    for (bitnum = offset; bitnum < offset + bits; bitnum ++) {
		if (bitnum < 64) {
		    if (bitmask1 & (1LL << bitnum)) {
			fatal("Overlapping format fields (%s)\n", (char *) child->name);
			return 0;
		    }
		    bitmask1 |= (1LL << bitnum);
		} else {
		    if (bitmask2 & (1LL << (bitnum - 64))) {
			fatal("Overlapping format fields (%s)\n", (char *) child->name);
			return 0;
		    }
		    bitmask2 |= (1LL << (bitnum - 64));
		}
	    }

	    if (offset + bits > total_bits) total_bits = offset + bits;

	    switch (format_field) {
	    case FORMAT_FIELD_DTM:
		format->dtm_bits = bits;
		format->dtm_offset = offset;
		format->dtm_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_MOVECNT:
		format->movecnt_bits = bits;
		format->movecnt_offset = offset;
		format->movecnt_mask = (1 << bits) - 1;
		break;
	    case FORMAT_FIELD_INDEX:
		format->index_bits = bits;
		format->index_offset = offset;
		if (bits == 64) format->index_mask = 0xffffffffLL;
		else format->index_mask = (1LL << bits) - 1;
		break;
	    case FORMAT_FIELD_FUTUREVECTOR:
		format->futurevector_bits = bits;
		format->futurevector_offset = offset;
		if (bits == 64) format->futurevector_mask = 0xffffffffLL;
		else format->futurevector_mask = (1LL << bits) - 1;
		break;
	    case FORMAT_FIELD_FLAG:
		typestr = (char *) xmlGetProp(child, BAD_CAST "type");
		format->flag_offset = offset;
		format->flag_type = find_name_in_array(typestr, format_flag_types);
		if (typestr != NULL) xmlFree(typestr);
		if (format->flag_type == -1) {
		    fatal("'type' is a required property in format field 'flag'\n");
		    return 0;
		}
		break;
	    case FORMAT_FIELD_PTM_WINS_FLAG:
		format->PTM_wins_flag_offset = offset;
		break;
	    default:
		fatal("Unknown field in format\n");
		return 0;
	    }
	}
    }

    /* Round up total number of bytes to a power-of-two boundary.  This should probably be a little
     * less dependant on the assumption that MAX_FORMAT_BYTES is no more than 16.
     */

    for (power_of_two = 0; (1 << power_of_two) < total_bits; power_of_two ++);

    if ((1 << power_of_two) != total_bits) {
	fatal("Total bits in format must be a power of two\n");
	return 0;
    }

    format->bits = power_of_two;

    if (total_bits <= 8) {
	format->bytes = 1;
    } else {
	format->bytes = total_bits/8;
    }

    if (format->bytes > MAX_FORMAT_BYTES) {
	fatal("Maximum number of bytes in format exceeded\n");
	return 0;
    }

    return 1;
}

/* Parses XML, creates a tablebase structure corresponding to it, and returns it.
 *
 * I use a DTD and validate the XML input, so there's very little error checking here.  The idea is
 * that the validation provides most of the error checks.
 */

tablebase_t * parse_XML_into_tablebase(xmlDocPtr doc)
{
    tablebase_t *tb;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    xmlNodePtr tablebase;
    xmlNodePtr index_node;
    xmlChar * format;
    xmlChar * index;
    xmlChar * modulus;
    xmlChar * index_symmetry;
    int piece, piece2, square, white_king_square, black_king_square, dir;
    int pass;
    int reverse_index_ordering[MAX_PIECES];

    tb = malloc(sizeof(tablebase_t));
    if (tb == NULL) {
	fatal("Can't malloc tablebase\n");
	return NULL;
    }
    memset(tb, 0, sizeof(tablebase_t));

    tb->xml = doc;

    /* Fetch tablebase from XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//tablebase", context);
    tablebase = result->nodesetval->nodeTab[0];
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Some statistics we'll use if this is a futurebase */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//max-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	tb->max_dtm = atoi((char *) xmlNodeGetContent(result->nodesetval->nodeTab[0]));
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//min-dtm", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	tb->min_dtm = atoi((char *) xmlNodeGetContent(result->nodesetval->nodeTab[0]));
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* If there's a stalemate prune, fetch it */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune[attribute::move='stalemate']", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "type");
	tb->stalemate_prune_type = find_name_in_array((char *) prune_type, restriction_types);
	tb->stalemate_prune_color = find_name_in_array((char *) prune_color, colors);
	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_type != NULL) xmlFree(prune_type);
	if (tb->stalemate_prune_type != RESTRICTION_CONCEDE) {
	    fatal("Stalemates can only be pruned to 'concede'\n");
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Fetch the pieces from the XML */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//piece", context);
    if (xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	fatal("No pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr < 2) {
	fatal("Too few pieces!\n");
	return NULL;
    } else if (result->nodesetval->nodeNr > MAX_PIECES) {
	fatal("Too many pieces!\n");
	return NULL;
    }

    tb->num_pieces = result->nodesetval->nodeNr;

    tb->white_king = -1;
    tb->black_king = -1;

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	xmlChar * color = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "color");
	xmlChar * type = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "type");
	xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");
	xmlChar * index_ordering = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "index-ordering");

	tb->piece_color[piece] = find_name_in_array((char *) color, colors);
	tb->piece_type[piece] = find_name_in_array((char *) type, piece_name);

	if (location == NULL) {
	    if (tb->piece_type[piece] == PAWN) {
		tb->legal_squares[piece] = LEGAL_PAWN_BITVECTOR;
	    } else {
		tb->legal_squares[piece] = allones_bitvector;
	    }
	} else {
	    int j = 0;
	    tb->legal_squares[piece] = 0;
	    while ((location[j] >= 'a') && (location[j] <= 'h')
		   && (location[j+1] >= '1') && (location[j+1] <= '8')) {
		tb->legal_squares[piece]
		    |= BITVECTOR(rowcol2square(location[j+1] - '1', location[j] - 'a'));
		j += 2;
		if ((tb->piece_type[piece] == PAWN) && (j == 2) && (location[j] == '+')) j++;
		while (location[j] == ' ') j ++;
	    }
	    if (location[j] != '\0') {
		fatal("Illegal piece location (%s)\n", location);
	    }
	}

	if ((index_ordering != NULL) && (strcmp((char *) index_ordering, "reverse") == 0)) {
	    reverse_index_ordering[piece] = 1;
	} else {
	    reverse_index_ordering[piece] = 0;
	}

	if ((tb->piece_color[piece] == -1) || (tb->piece_type[piece] == -1)) {
	    fatal("Illegal piece color (%s) or type (%s)\n", color, type);
	}

	if ((tb->piece_color[piece] == WHITE) && (tb->piece_type[piece] == KING)) {
	    if (tb->white_king != -1) {
		fatal("Must have one white king and one black one!\n");
	    } else {
		tb->white_king = piece;
	    }
	}

	if ((tb->piece_color[piece] == BLACK) && (tb->piece_type[piece] == KING)) {
	    if (tb->black_king != -1) {
		fatal("Must have one white king and one black one!\n");
	    } else {
		tb->black_king = piece;
	    }
	}

	if (color != NULL) xmlFree(color);
	if (type != NULL) xmlFree(type);
	if (location != NULL) xmlFree(location);
	if (index_ordering != NULL) xmlFree(index_ordering);
    }

    if ((tb->white_king == -1) || (tb->black_king == -1)) {
	fatal("Must have one white king and one black one!\n");
	return NULL;
    }


    /* We quietly skipped over any plus signs after pawn locations, which mean that the pawn should
     * be advanced as far as possible along its file.  For example, if there is a white pawn at
     * "h2+" and a black pawn at "h7+", we want the white pawn's legal squares expanded all the way
     * to h6, and the black pawn's legal squares expanded all the way to h3.  We couldn't process
     * them immediately because without having parsed all the pieces we didn't know if anything was
     * blocking the file.
     *
     * Having now parsed all of the pieces, go back and expand the legal squares of any "plus pawns"
     * by first running through the pieces and looking for any blocking the plus pawn.  Then expand
     * the plus-pawn's restrictions up its file until it hits the blocking piece.
     *
     * To handle doubled pawns, we do this twice, figuring that we'll expand the leading pawn first,
     * then pick up the trailing pawn on the second pass.  To handle tripled pawns, we need three
     * passes.  To handled quadrupled (!) pawns, we need four.  Simplest is to just run the loop
     * once for however many pieces we've got.
     *
     * What if we specified a black pawn as "a7+ b4+" and a white pawn as "b2+"?  Then the black
     * pawn would be blocked by at b3 by the white pawn, even though the white pawn could move on
     * past (it wouldn't be blocked by the multiple-file black pawn).  I handle this complex case by
     * not allowing plus pawns to start on more than one square.
     *
     * Perhaps this seems like an absurd amount of complexity to introduce for a special case.  In
     * fact, pawns blocking each other are a not-so-special case and I don't see how they can be
     * handled as efficiently as we'd like without all of this.  In particular, we needn't regard
     * pawn moves onto blocked squares as futuremoves, and by pairing opposing pawns in indices we
     * can cut tablebase sizes by a factor of two for each pair.
     */

    /* First, compute which piece, if any, is blocking each plus-pawn.  We do this by stripping out
     * from the blocking piece's legal squares all possible positions of the plus-pawn as we move it
     * forward.  This ensures that a white pawn restricted to "g2 g3", say, will block a black
     * plus-pawn "g7+".  This is OK for non-pawns, too, since knights are the only pieces that can
     * jump and a knight could never be frozen purely along a single file.  Plus-pawns themselves,
     * since their legal_squares haven't been expanded yet, block other pawn-pawns at their origin
     * square.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	tb->blocking_piece[piece] = -1;

	if (tb->piece_type[piece] == PAWN) {

	    xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");
	    uint64 pawn_positions = 0xffffffffffffffffLL;

	    if ((location != NULL) && (location[2] == '+')) {

		int square = rowcol2square(location[1] - '1', location[0] - 'a');
		int dir = (tb->piece_color[piece] == WHITE) ? 8 : -8;

		pawn_positions &= ~BITVECTOR(square);
		square += dir;

		while ((square < 56) && (square > 7) && (tb->blocking_piece[piece] == -1)) {
		    for (piece2 = 0; piece2 < tb->num_pieces; piece2 ++) {
			if ((pawn_positions & tb->legal_squares[piece2]) == BITVECTOR(square)) {
			    tb->blocking_piece[piece] = piece2;
			}
		    }
		    pawn_positions &= ~BITVECTOR(square);
		    square += dir;
		}

		/* This next batch of code is here because we (currently) sort 'identical' pieces
		 * into increasing order when we normalize a position.  Since doubled pawns are
		 * 'identical', the easiest way to handle them is to insure that they always appear
		 * in the correct order in the piece list.
		 */

		if ((tb->blocking_piece[piece] != -1) && (tb->piece_type[tb->blocking_piece[piece]] == PAWN)
		    && (tb->piece_color[tb->blocking_piece[piece]] == tb->piece_color[piece])) {
		    if ((tb->piece_color[piece] == WHITE) && (tb->blocking_piece[piece] < piece)) {
			fatal("Doubled pawns must (currently) appear in board order in piece list\n");
		    }
		    if ((tb->piece_color[piece] == BLACK) && (tb->blocking_piece[piece] > piece)) {
			fatal("Doubled pawns must (currently) appear in board order in piece list\n");
		    }
		}

	    } else {
		/* XXX This is a pawn, but it isn't a plus-pawn.  It can be blocked if it is frozen.
		 * This matters because if a pawn is blocked, then we shouldn't complain if there is
		 * no futurebase or pruning statement for its forward move, but it isn't a big deal,
		 * since we can always just add an extra pruning statement for the non-move.
		 */
	    }

	    if (location != NULL) xmlFree(location);
	}
    }

    /* Now advance plus-pawns as far as they can go without hitting the blocking piece. */

    for (pass = 0; pass < tb->num_pieces; pass ++) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_type[piece] == PAWN) {

		xmlChar * location = xmlGetProp(result->nodesetval->nodeTab[piece], BAD_CAST "location");

		if ((location != NULL) && (location[2] == '+')) {

		    int square = rowcol2square(location[1] - '1', location[0] - 'a');
		    int dir = (tb->piece_color[piece] == WHITE) ? 8 : -8;

		    square += dir;
		    while ((square < 56) && (square > 7)) {
			if ((tb->blocking_piece[piece] != -1)
			    && (BITVECTOR(square) & tb->legal_squares[tb->blocking_piece[piece]])
			    && !(BITVECTOR(square + dir) & tb->legal_squares[tb->blocking_piece[piece]]))
			    break;
			tb->legal_squares[piece] |= BITVECTOR(square);
			square += dir;
		    }
		}

		if (location != NULL) xmlFree(location);
	    }
	}
    }

    /* Now we need to figure out if there are any other pieces identical to this one, because if so,
     * exchanging the two pieces would not change the position, and that has to be taken into
     * account in several places.  Move restrictions on the pieces complicate this, unless they are
     * completely non-overlapping, in which case we don't treat the pieces as identical because they
     * are then distinguishable (kinda like electrons).  The whole point of this code is to group
     * together identical pieces with overlapping move restrictions, and to compute for each group
     * the logical union of their move restrictions, which become the "semilegal" squares for all
     * the pieces in that group.  See the earlier discussion on semilegal squares.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	tb->last_identical_piece[piece] = -1;
	tb->next_identical_piece[piece] = -1;

	tb->semilegal_squares[piece] = tb->legal_squares[piece];

	for (piece2 = 0; piece2 < piece; piece2 ++) {
	    if ((tb->piece_color[piece2] == tb->piece_color[piece])
		&& (tb->piece_type[piece2] == tb->piece_type[piece])) {

		if (tb->semilegal_squares[piece] & tb->semilegal_squares[piece2]) {
		    tb->last_identical_piece[piece] = piece2;
		    tb->semilegal_squares[piece2] |= tb->semilegal_squares[piece];
		    tb->semilegal_squares[piece] |= tb->semilegal_squares[piece2];
		}
	    }
	}

	/* Later, if we're trying to process a position with two identical pieces that aren't on
	 * legal squares, we swap them and see if we can get them onto legal squares that way.  If
	 * there were more than two identical pieces, we'd have to try more combinations, probably a
	 * full set of possible permutations, and the simplest way to do that is to prohibit it here
	 * - at least for now.
	 */

	if (tb->last_identical_piece[piece] != -1) {
	    if (tb->last_identical_piece[tb->last_identical_piece[piece]] != -1) {
		fatal("More than two identical pieces with overlapping move restrictions\n");
		return NULL;
	    }
	    tb->next_identical_piece[tb->last_identical_piece[piece]] = piece;
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Fetch the index type */

    index = xmlGetProp(tablebase, BAD_CAST "index");
    index_node = tablebase;  /* XXX here for backwards compatibility */
    if (index == NULL) {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//index", context);
	if (result->nodesetval->nodeNr == 1) {
	    index_node = result->nodesetval->nodeTab[0];
	    index = xmlGetProp(index_node, BAD_CAST "type");
	    xmlChar * index_offset = xmlGetProp(index_node, BAD_CAST "offset");
	    if (index_offset != NULL) {
		tb->index_offset = atoi((char *) index_offset);
		xmlFree(index_offset);
	    }
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }
    if (index == NULL) {
	tb->index_type = NAIVE_INDEX;
	xmlNewProp(tablebase, BAD_CAST "index", BAD_CAST "naive");
	warning("Index type not expressly specified; assuming NAIVE\n");
    } else {
	tb->index_type = find_name_in_array((char *) index, index_types);
	if (tb->index_type == -1) {
	    fatal("Unknown tablebase index type '%s'\n", index);
	    return NULL;
	}
	xmlFree(index);
	index = NULL;
    }

    /* Now, compute a bitvector for all the pieces that are frozen on single squares.  This
     * 'frozen_pieces_vector' differs from 'blocked_squares' because a square can be blocked by a
     * pawn that is at least partially mobile on a single file.  Frozen pieces, on the other hand,
     * are completely immobile on a single square.
     *
     * We also use this opportunity to remove from the opposing king's legal squares list any
     * squares that a frozen piece can always capture on.  Due to the possibility of interposition
     * between the frozen piece and the king, this means only the first square in the movement.
     *
     * This doesn't work quite right if we had a non-frozen identical piece overlapping the frozen
     * piece, in which case semilegal_squares has already been expanded out to include the union of
     * the two.  At least this doesn't seem to break anything; just introduce an inefficiency.
     *
     * There is a problem with this that led me to introduce the "king-positions" option to turn
     * this off.  Although a king can never move into check from a frozen piece in the current
     * tablebase, if we're using this as a futurebase, and the piece isn't frozen (or frozen on a
     * different square) in the new tablebase, then a frozen piece move from one tablebase to the
     * other can put the king in check this way.  Still, we'll never back prop out of these
     * positions, only into them, so there might be something to be gained from grouping them all
     * together at the end of the tablebase or something.  Still haven't decided the best
     * way to handle this.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	for (square = 0; square < 64; square ++) {
	    if (BITVECTOR(square) == tb->semilegal_squares[piece]) {
		if (tb->frozen_pieces_vector & BITVECTOR(square)) {
		    fatal("More than one piece frozen on %c%c", 'a' + COL(square), '1' + ROW(square));
		    return NULL;
		}
		tb->frozen_pieces_vector |= BITVECTOR(square);

		if ((xmlGetProp(index_node, BAD_CAST "king-positions") == NULL)
		    || !strcmp((char *) xmlGetProp(index_node, BAD_CAST "king-positions"),
			       "no-frozen-checks")) {

		    switch (tb->piece_type[piece]) {
		    case PAWN:
			if (tb->piece_color[piece] == WHITE) {
			    if (COL(square) != 7) tb->illegal_black_king_squares |= BITVECTOR(square + 9);
			    if (COL(square) != 0) tb->illegal_black_king_squares |= BITVECTOR(square + 7);
			} else {
			    if (COL(square) != 7) tb->illegal_white_king_squares |= BITVECTOR(square - 7);
			    if (COL(square) != 0) tb->illegal_white_king_squares |= BITVECTOR(square - 9);
			}
			break;
		    default:
			for (dir=0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {
			    if (movements[tb->piece_type[piece]][square][dir][0].square != -1) {
				if (tb->piece_color[piece] == WHITE) {
				    tb->illegal_black_king_squares
					|= BITVECTOR(movements[tb->piece_type[piece]][square][dir][0].square);
				} else {
				    tb->illegal_white_king_squares
					|= BITVECTOR(movements[tb->piece_type[piece]][square][dir][0].square);
				}
			    }
			}
			break;
		    }
		}

		break;
	    }
	}
    }

    tb->legal_squares[tb->white_king] &= ~ tb->illegal_white_king_squares;
    tb->legal_squares[tb->black_king] &= ~ tb->illegal_black_king_squares;
    tb->semilegal_squares[tb->white_king] &= ~ tb->illegal_white_king_squares;
    tb->semilegal_squares[tb->black_king] &= ~ tb->illegal_black_king_squares;

    /* Strip the locations of frozen pieces off the legal squares bitvectors of all the other
     * pieces.  Like stripping the capture squares off the enemy king's legal bitvector, this is a
     * convenience, so we don't have to list all the free squares for pieces that are not frozen.
     * But we do have to careful about changing this code around, because some index types (like
     * 'simple' and 'compact') implicitly use a piece's legal squares to encode its position, so
     * changing this code can change index encoding.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->semilegal_squares[piece] & tb->frozen_pieces_vector) != tb->semilegal_squares[piece]) {
	    tb->legal_squares[piece] &= ~ tb->frozen_pieces_vector;
	    tb->semilegal_squares[piece] &= ~ tb->frozen_pieces_vector;
	}
    }

    /* get the format */

    format = xmlGetProp(tablebase, BAD_CAST "format");
    if (format != NULL) {
	switch (find_name_in_array((char *) format, formats)) {
	case FORMAT_ONE_BYTE_DTM:
	    tb->format = one_byte_dtm_format;
	    break;
	default:
	    fatal("Unknown tablebase format '%s'\n", format);
	    return NULL;
	}
	xmlFree(format);
    } else {
	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//format", context);
	if (result->nodesetval->nodeNr == 1) {
	    if (! parse_format(result->nodesetval->nodeTab[0], &tb->format)) return NULL;
	} else {
	    xmlNewProp(tablebase, BAD_CAST "format", BAD_CAST "one-byte-dtm");
	    tb->format = one_byte_dtm_format;
	    warning("Format not expressly specified; assuming ONE-BYTE-DTM\n");
	}
	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }

    /* If a custom entries format has been specified, get it too */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//entries-format", context);
    if (result->nodesetval->nodeNr == 1) {
#if (!USE_CONST_ENTRIES_FORMAT)
	if (! parse_format(result->nodesetval->nodeTab[0], &entries_format)) return NULL;
	if (ENTRIES_FORMAT_MOVECNT_BITS == 0) {
	    fatal("Entries format must contain a movecnt field\n");
	    return NULL;
	}
#else
	fatal("Entries format constant in this version of Hoffman\n");
	return NULL;
#endif
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* custom proptable format? */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//proptable-format", context);
    if (result->nodesetval->nodeNr == 1) {
	if (! parse_format(result->nodesetval->nodeTab[0], &proptable_format)) return NULL;
	if (proptable_format.index_bits == 0) {
	    fatal("Proptable format must contain an index field\n");
	    return NULL;
	}
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    /* Extract index symmetry (if it was specified) */

    index_symmetry = xmlGetProp(index_node, BAD_CAST "symmetry");
    if (index_symmetry != NULL) {
	tb->symmetry = atoi((char *) index_symmetry);
	if ((tb->symmetry != 1) && (tb->symmetry != 2) && (tb->symmetry != 4) && (tb->symmetry != 8)) {
	    fatal("Bad index symmetry %d\n", tb->symmetry);
	}
	xmlFree(index_symmetry);
    } else {
	tb->symmetry = 1;
    }

    /* Check piece specification to make sure it matches symmetry
     *
     * XXX Some piece restrictions should be allowed for, so long as the restrictions themselves are
     * symmetric.  For example, a rook restricted to a single row is consistent with 2-way symmetry.
     */

    if ((tb->symmetry == 8) && ((tb->index_type == NAIVE_INDEX) || (tb->index_type == NAIVE2_INDEX))) {
	fatal("8-way symmetry incompatible with naive/naive2 index types\n");
	return NULL;
    }

    if (tb->symmetry >= 4) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (tb->piece_type[piece] == PAWN) {
		fatal("Pawns not allowed with 4/8-way symmetric indices\n");
		return NULL;
	    }
	}
    }

    if (tb->symmetry > 1) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (((tb->piece_type[piece] != PAWN) && (tb->legal_squares[piece] != allones_bitvector))
		|| ((tb->piece_type[piece] == PAWN) && (tb->legal_squares[piece] != LEGAL_PAWN_BITVECTOR))) {
		fatal("Piece restrictions not allowed with symmetric indices (yet)\n");
		return NULL;
	    }
	}
    }

    if (tb->index_type == STANDARD_INDEX) {
	fatal("'standard' index doesn't work (yet)\n");
	return NULL;
    }

    if ((tb->index_type != NO_EN_PASSANT_INDEX) && (tb->index_type != COMPACT_INDEX)
	&& (tb->index_type != STANDARD_INDEX)) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (tb->legal_squares[piece] != tb->semilegal_squares[piece]) {
		fatal("Non-identical overlapping piece restrictions not allowed with this index type\n");
		return NULL;
	    }
	}
    }

    if (tb->index_type == NO_EN_PASSANT_INDEX) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    int col;
	    int row1 = (tb->piece_color[piece] == WHITE) ? 1 : 6;
	    int row3 = (tb->piece_color[piece] == WHITE) ? 3 : 4;
	    int row4 = (tb->piece_color[piece] == WHITE) ? 4 : 3;
	    if (tb->piece_type[piece] != PAWN) continue;
	    for (col = 0; col < 8; col ++) {
		if (tb->legal_squares[piece]
		    & (BITVECTOR(rowcol2square(row1, col)) | BITVECTOR(rowcol2square(row3, col)))) {
		    for (piece2 = 0; piece2 < tb->num_pieces; piece2 ++) {
			if (tb->piece_type[piece2] != PAWN) continue;
			if (tb->piece_color[piece2] == tb->piece_color[piece]) continue;
			if ((col > 0)
			    && (tb->legal_squares[piece2] & BITVECTOR(rowcol2square(row4, col-1)))) {
			    fatal("Can't use 'no-en-passant' index for a tablebase where en-passant captures are possible\n");
			    return NULL;
			}
			if ((col < 7)
			    && (tb->legal_squares[piece2] & BITVECTOR(rowcol2square(row4, col+1)))) {
			    fatal("Can't use 'no-en-passant' index for a tablebase where en-passant captures are possible\n");
			    return NULL;
			}
		    }
		}
	    }
	}
    }

    /* Compute tb->max_index (but see next section of code where it might be modified) */

    switch (tb->index_type) {
    case NAIVE_INDEX:

	/* The "2" is because side-to-play is part of the position; "6" for the 2^6 squares on the board */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index = (2<<(6*tb->num_pieces)) - 1;
	    break;
	case 2:
	    tb->max_index = (2<<(6*tb->num_pieces - 1)) - 1;
	    break;
	case 4:
	    tb->max_index = (2<<(6*tb->num_pieces - 2)) - 1;
	    break;
	}
	break;

    case NAIVE2_INDEX:

	tb->max_index = 2;

	/* do the white king "by hand" */
	switch (tb->symmetry) {
	case 1:
	    tb->max_index <<= 6;
	    break;
	case 2:
	    tb->max_index <<= 5;
	    break;
	case 4:
	    tb->max_index <<= 4;
	    break;
	}

	tb->last_paired_piece[tb->white_king] = -1;
	tb->next_paired_piece[tb->white_king] = -1;

	/* now do everything else */
	for (piece = 1; piece < tb->num_pieces; piece ++) {

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'naive2' index (yet)\n");
		return NULL;
	    }

	    tb->last_paired_piece[piece] = tb->last_identical_piece[piece];
	    tb->next_paired_piece[piece] = tb->next_identical_piece[piece];

	    if (tb->last_paired_piece[piece] == -1) tb->max_index <<= 6;
	    else tb->max_index <<=5;
	}
	tb->max_index --;

	break;

    case SIMPLE_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (square = (reverse_index_ordering[piece] ? 63 : 0);
		 (reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (reverse_index_ordering[piece] ? (square --) : (square ++))) {
		if (! (tb->legal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->simple_piece_indices[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    tb->max_index *= tb->total_legal_piece_positions[piece];
	}

	tb->max_index --;
	break;

    case COMPACT_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;
#if CHECK_KING_LEGALITY_EARLY
		if (! check_king_legality(white_king_square, black_king_square)) continue;
#endif
		tb->compact_white_king_positions[tb->total_legal_compact_king_positions] = white_king_square;
		tb->compact_black_king_positions[tb->total_legal_compact_king_positions] = black_king_square;
		tb->compact_king_indices[white_king_square][black_king_square] = tb->total_legal_compact_king_positions;
		tb->total_legal_compact_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_compact_king_positions;

	tb->last_paired_piece[tb->white_king] = -1;
	tb->next_paired_piece[tb->white_king] = -1;
	tb->last_paired_piece[tb->black_king] = -1;
	tb->next_paired_piece[tb->black_king] = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'compact' index (yet)\n");
		return NULL;
	    }

	    tb->last_paired_piece[piece] = tb->last_identical_piece[piece];
	    tb->next_paired_piece[piece] = tb->next_identical_piece[piece];

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.
	     */

	    for (square = (reverse_index_ordering[piece] ? 63 : 0);
		 (reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

		/* if the pawn is en-passant capturable, add an index for that */
		if ((tb->piece_type[piece] == PAWN)
		    && (((tb->piece_color[piece] == WHITE) && (ROW(square) == 3))
			|| ((tb->piece_color[piece] == BLACK) && (ROW(square) == 4)))) {
		    tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = COL(square);
		    tb->simple_piece_indices[piece][COL(square)] = tb->total_legal_piece_positions[piece];
		    tb->total_legal_piece_positions[piece] ++;
		}
	    }
	    if (tb->last_paired_piece[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else if (tb->total_legal_piece_positions[piece]
		       != tb->total_legal_piece_positions[tb->last_paired_piece[piece]]) {
		fatal("Paired pieces don't have the same number of total legal positions\n");
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;

    case NO_EN_PASSANT_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;
#if CHECK_KING_LEGALITY_EARLY
		if (! check_king_legality(white_king_square, black_king_square)) continue;
#endif
		tb->compact_white_king_positions[tb->total_legal_compact_king_positions] = white_king_square;
		tb->compact_black_king_positions[tb->total_legal_compact_king_positions] = black_king_square;
		tb->compact_king_indices[white_king_square][black_king_square] = tb->total_legal_compact_king_positions;
		tb->total_legal_compact_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_compact_king_positions;

	tb->last_paired_piece[tb->white_king] = -1;
	tb->next_paired_piece[tb->white_king] = -1;
	tb->last_paired_piece[tb->black_king] = -1;
	tb->next_paired_piece[tb->black_king] = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'compact' index (yet)\n");
		return NULL;
	    }

	    tb->last_paired_piece[piece] = tb->last_identical_piece[piece];
	    tb->next_paired_piece[piece] = tb->next_identical_piece[piece];

	    /* Note that we only set blocking_piece for plus-pawns, so if two pieces are mutually
	     * blocking, they must be opposing plus-pawns.
	     */

	    if ((tb->blocking_piece[piece] != -1)
		&& (tb->blocking_piece[tb->blocking_piece[piece]] == piece)) {

		if ((tb->last_paired_piece[piece] != -1) || (tb->next_paired_piece[piece] != -1)) {
		    fatal("Can't have a doubled pawn opposed by enemy pawn (yet)\n");
		    return NULL;
		}
		if ((tb->blocking_piece[piece] > piece) && (tb->piece_color[piece] != WHITE)) {
		    fatal("Mutually blocking pawns must currently be specified white pawn first\n");
		    return NULL;
		}
		if (tb->blocking_piece[piece] > piece) {
		    tb->next_paired_piece[piece] = tb->blocking_piece[piece];
		} else {
		    tb->last_paired_piece[piece] = tb->blocking_piece[piece];
		}
		/* We have to extend the semilegal squares of both blocking pawns because the
		 * pairing is based on 2 pieces on n squares using (n)(n-1)/2 numbers.
		 */
		tb->semilegal_squares[piece] |= tb->semilegal_squares[tb->blocking_piece[piece]];
	    }

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.
	     */

	    for (square = (reverse_index_ordering[piece] ? 63 : 0);
		 (reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;

	    }
	    if (tb->last_paired_piece[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else if (tb->total_legal_piece_positions[piece]
		       != tb->total_legal_piece_positions[tb->last_paired_piece[piece]]) {
		fatal("Paired pieces don't have the same number of total legal positions\n");
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;

    case STANDARD_INDEX:

	/* The "2" is because side-to-play is part of the position */
	tb->max_index = 2;

	for (white_king_square = 0; white_king_square < 64; white_king_square ++) {
	    if (! (tb->legal_squares[tb->white_king] & BITVECTOR(white_king_square))) continue;
	    for (black_king_square = 0; black_king_square < 64; black_king_square ++) {
		if (! (tb->legal_squares[tb->black_king] & BITVECTOR(black_king_square))) continue;
		if ((tb->symmetry >= 2) && (COL(white_king_square) >= 4)) continue;
		if ((tb->symmetry >= 4) && (ROW(white_king_square) >= 4)) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) > COL(white_king_square))) continue;
		if ((tb->symmetry == 8) && (ROW(white_king_square) == COL(white_king_square))
		    && (ROW(black_king_square) > COL(black_king_square))) continue;
#if CHECK_KING_LEGALITY_EARLY
		if (! check_king_legality(white_king_square, black_king_square)) continue;
#endif
		tb->compact_white_king_positions[tb->total_legal_compact_king_positions] = white_king_square;
		tb->compact_black_king_positions[tb->total_legal_compact_king_positions] = black_king_square;
		tb->compact_king_indices[white_king_square][black_king_square] = tb->total_legal_compact_king_positions;
		tb->total_legal_compact_king_positions ++;
	    }
	}
	tb->max_index *= tb->total_legal_compact_king_positions;

	tb->last_paired_piece[tb->white_king] = -1;
	tb->next_paired_piece[tb->white_king] = -1;
	tb->last_paired_piece[tb->black_king] = -1;
	tb->next_paired_piece[tb->black_king] = -1;

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if ((piece == tb->white_king) || (piece == tb->black_king)) continue;

	    if ((tb->last_identical_piece[piece] != -1) && (tb->next_identical_piece[piece] != -1)) {
		fatal("Can't have more than two identical pieces with 'compact' index (yet)\n");
		return NULL;
	    }

	    tb->last_paired_piece[piece] = tb->last_identical_piece[piece];
	    tb->next_paired_piece[piece] = tb->next_identical_piece[piece];

	    /* Note that we only set blocking_piece for plus-pawns, so if two pawns are mutually
	     * blocking, they must be opposing plus-pawns.
	     */

	    if ((tb->blocking_piece[piece] != -1) && (tb->blocking_piece[tb->blocking_piece[piece]] == piece)) {
		if ((tb->last_paired_piece[piece] != -1) || (tb->next_paired_piece[piece] != -1)) {
		    fatal("Can't have a doubled pawn opposed by enemy pawn (yet)\n");
		    return NULL;
		}
		if ((tb->blocking_piece[piece] > piece) && (tb->piece_color[piece] != WHITE)) {
		    fatal("Mutually blocking pawns must currently be specified white pawn first\n");
		    return NULL;
		}
		if (tb->blocking_piece[piece] > piece) {
		    tb->next_paired_piece[piece] = tb->blocking_piece[piece];
		} else {
		    tb->last_paired_piece[piece] = tb->blocking_piece[piece];
		}
		tb->semilegal_squares[piece] |= tb->semilegal_squares[tb->blocking_piece[piece]];
	    }

	    /* We count semilegal and not legal squares here because the pair encoding used for
	     * identical pieces assumes that both pieces occupy the same range of squares.
	     */

	    /* if the pawn is en-passant capturable, add an index for that */
	    if (tb->piece_type[piece] == PAWN) {
		for (square = 0; square < 7; square ++) {
		    if (tb->semilegal_squares[piece]
			& BITVECTOR(rowcol2square((tb->piece_color[piece] == WHITE) ? 3 : 4, square))) {
			tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
			tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
			tb->total_legal_piece_positions[piece] ++;
		    }
		}
	    }

	    for (square = (reverse_index_ordering[piece] ? 63 : 0);
		 (reverse_index_ordering[piece] ? (square >= 0) : (square < 64));
		 (reverse_index_ordering[piece] ? (square --) : (square ++))) {

		if (! (tb->semilegal_squares[piece] & BITVECTOR(square))) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 2) && (COL(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry >= 4) && (ROW(square) >= 4)) continue;
		if ((piece == tb->white_king) && (tb->symmetry == 8) && (ROW(square) > COL(square))) continue;
		tb->simple_piece_positions[piece][tb->total_legal_piece_positions[piece]] = square;
		tb->simple_piece_indices[piece][square] = tb->total_legal_piece_positions[piece];
		tb->total_legal_piece_positions[piece] ++;
	    }

	    if (tb->last_paired_piece[piece] == -1) {
		tb->max_index *= tb->total_legal_piece_positions[piece];
	    } else if (tb->total_legal_piece_positions[piece]
		       != tb->total_legal_piece_positions[tb->last_paired_piece[piece]]) {
		fatal("Paired pieces don't have the same number of total legal positions\n");
	    } else {
		tb->max_index *= tb->total_legal_piece_positions[piece]/2;
	    }
	}

	tb->max_index --;
	break;
    }

    tb->max_index += tb->index_offset;

    /* See if an index modulus was specified for inversion in a finite field */

    modulus = xmlGetProp(tablebase, BAD_CAST "modulus");
    if (modulus != NULL) {
	tb->modulus = strtoll((const char *) modulus, NULL, 0);
	if (tb->modulus <= tb->max_index) {
	    fatal("modulus %d less than max_index %d\n", tb->modulus, tb->max_index);
	    return NULL;
	}
	tb->max_index = tb->modulus - 1;
	xmlFree(modulus);
    }

    /* Fetch the move restrictions */

    context = xmlXPathNewContext(doc);
    result = xmlXPathEvalExpression(BAD_CAST "//move-restriction", context);
    if (! xmlXPathNodeSetIsEmpty(result->nodesetval)) {
	int i;
	for (i=0; i < result->nodesetval->nodeNr; i++) {
	    xmlChar * color_str;
	    xmlChar * type_str;
	    int color;
	    int type;

	    color_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "color");
	    type_str = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "type");

	    color = find_name_in_array((char *) color_str, colors);
	    type = find_name_in_array((char *) type_str, restriction_types);
	    if ((color == -1) || (type == -1)) {
		fatal("Illegal move restriction\n");
	    } else {
		if ((tb->move_restrictions[color] > 0) && (tb->move_restrictions[color] != type)) {
		    fatal("Incompatible move restrictions\n");
		} else {
		    tb->move_restrictions[color] = type;
		}
	    }

	    if (color_str != NULL) xmlFree(color_str);
	    if (type_str != NULL) xmlFree(type_str);
	}
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    return (fatal_errors == 0) ? tb : NULL;
}

/* Parses an XML control file.
 */

tablebase_t * parse_XML_control_file(char *filename)
{
    xmlParserInputBufferPtr dtd_input_buffer;
    xmlDtdPtr dtd;
    xmlDocPtr doc;
    tablebase_t *tb;

    /* load the DTD from memory */

    dtd_input_buffer = xmlParserInputBufferCreateMem(tablebase_dtd, strlen(tablebase_dtd),
						     XML_CHAR_ENCODING_ASCII);
    dtd = xmlIOParseDTD(NULL, dtd_input_buffer, XML_CHAR_ENCODING_ASCII);

    /* load the control file from the specified filename or URL */

    doc = xmlReadFile(filename, NULL, 0);

    /* check if parsing suceeded */
    if (doc == NULL) {
	fatal("'%s' failed XML read\n", filename);
	return NULL;
    }

    /* check if validation suceeded */
    if (! xmlValidateDtd(xmlNewValidCtxt(), doc, dtd)) {
	fatal("'%s' failed XML validatation\n", filename);
	return NULL;
    }

    tb = parse_XML_into_tablebase(doc);
    if (tb == NULL) return NULL;

    /* We don't free the XML doc because the tablebase struct contains a pointer to it */

    xmlFreeDtd(dtd);

    /* dtd_input_buffer appears to have been freed by freeing the dtd; at least, malloc complains if
     * we try to free it here.
     */

    /* xmlFreeParserInputBuffer(dtd_input_buffer); */

    return tb;
}

/* preload_futurebase_from_file() reads a tablebase's XML header and parses it, leaving the file
 * open and ready to begin reading the first entry with fetch_next_DTM_from_disk().
 */

tablebase_t * preload_futurebase_from_file(char *filename)
{
    FILE * file;
    int xml_size;
    char fileptr[16384];	/* XXX hardwired max size of XML */
    xmlDocPtr doc;
    tablebase_t *tb = NULL;
    xmlNodePtr tablebase;
    xmlChar * offsetstr;

    if (rindex(filename, ':') == NULL) {
	file = fopen(filename, "r");
    } else {
	file = url_fopen(filename, "r");
    }

    if (file == NULL) {
	fatal("Can't fopen file '%s'\n", filename);
	return NULL;
    }

    file = zlib_fopen(file, "r");

    if (file == NULL) {
	fatal("Can't zlib_fopen file '%s'\n", filename);
	return NULL;
    }

    for (xml_size = 0; xml_size < sizeof(fileptr); xml_size ++) {
	fileptr[xml_size] = fgetc(file);
	if (fileptr[xml_size] == EOF) {
	    fatal("%s reading '%s'\n", strerror(errno), filename);
	    return NULL;
	}
	if (fileptr[xml_size] == '\0') break;
    }

    doc = xmlReadMemory(fileptr, xml_size, NULL, NULL, 0);

    tb = parse_XML_into_tablebase(doc);

    if (tb == NULL) {
	fatal("Futurebase preload failed: '%s'\n", filename);
	return NULL;
    }

    tb->file = file;

    tablebase = xmlDocGetRootElement(doc);

    offsetstr = xmlGetProp(tablebase, BAD_CAST "offset");
    tb->offset = strtol((const char *) offsetstr, NULL, 0);
    if (offsetstr != NULL) xmlFree(offsetstr);

#if 0
    if (fseek(file, tb->offset, SEEK_SET) != 0) {
	fatal("Seek failed in preload_futurebase_from_file()\n");
	terminate();
    }
#else
    xml_size ++; /* we read one zero byte */
    while (xml_size < tb->offset) {
	fileptr[xml_size ++] = fgetc(file);
    }
#endif

    return tb;
}

void unload_futurebase(tablebase_t *tb)
{
    if (tb->xml != NULL) xmlFreeDoc(tb->xml);
    tb->xml = NULL;
    if (tb->file != NULL) {
	if (fclose(tb->file) != 0) {
	    warning("fclose failed during unload_futurebase()\n");
	}
    }
    tb->file = NULL;
}

/* Given a tablebase, change its XML structure to reflect the fact that the tablebase has now
 * actually been built.  Adds a dummy "offset" property to the root element which will be adjusted
 * later to reflect the actual byte offset of the tablebase entries, and a "generated-by" block
 * indicating the program, time, and host that generated the data.
 */

xmlDocPtr finalize_XML_header(tablebase_t *tb, char *options)
{
    xmlNodePtr tablebase, node;
    char hostname[256];
    struct hostent *he;
    struct rusage rusage;
    char strbuf[256];
    int passnum;

    tablebase = xmlDocGetRootElement(tb->xml);

    xmlNewProp(tablebase, BAD_CAST "offset", BAD_CAST "0x1000");

    xmlNodeAddContent(tablebase, BAD_CAST "   ");
    node = xmlNewChild(tablebase, NULL, BAD_CAST "tablebase-statistics", NULL);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%d", tb->max_index + 1);
    xmlNewChild(node, NULL, BAD_CAST "indices", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_PNTM_mated_positions);
    xmlNewChild(node, NULL, BAD_CAST "PNTM-mated-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_legal_positions);
    xmlNewChild(node, NULL, BAD_CAST "legal-positions", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_stalemate_positions);
    xmlNewChild(node, NULL, BAD_CAST "stalemate-positions", BAD_CAST strbuf);

    /* If we generating a full tablebase, report both white-wins-positions and black-wins-positions.
     * If we generating a bitbase, report only one or the other of white-wins-positions or
     * white-wins-or-draws-positions.
     */

    if ((tb->format.dtm_bits > 0) || (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS)) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%lld", player_wins[0]);
	xmlNewChild(node, NULL, BAD_CAST "white-wins-positions", BAD_CAST strbuf);
    }
    if (tb->format.dtm_bits > 0) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%lld", player_wins[1]);
	xmlNewChild(node, NULL, BAD_CAST "black-wins-positions", BAD_CAST strbuf);
    }
    if (tb->format.flag_type == FORMAT_FLAG_WHITE_DRAWS) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%lld", total_legal_positions - player_wins[1]);
	xmlNewChild(node, NULL, BAD_CAST "white-wins-or-draws-positions", BAD_CAST strbuf);
    }

    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_moves);
    xmlNewChild(node, NULL, BAD_CAST "forward-moves", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%lld", total_futuremoves);
    xmlNewChild(node, NULL, BAD_CAST "futuremoves", BAD_CAST strbuf);
    if (tb->format.dtm_bits > 0) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", max_dtm);
	xmlNewChild(node, NULL, BAD_CAST "max-dtm", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", min_dtm);
	xmlNewChild(node, NULL, BAD_CAST "min-dtm", BAD_CAST strbuf);
    }
    xmlNodeAddContent(node, BAD_CAST "\n   ");

    xmlNodeAddContent(tablebase, BAD_CAST "\n   ");

    node = xmlNewChild(tablebase, NULL, BAD_CAST "generation-statistics", NULL);

    gethostname(hostname, sizeof(hostname));
    he = gethostbyname(hostname);

    getrusage(RUSAGE_SELF, &rusage);

    gettimeofday(&program_end_time, NULL);

    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewChild(node, NULL, BAD_CAST "host", BAD_CAST he->h_name);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewChild(node, NULL, BAD_CAST "program", BAD_CAST "Hoffman $Revision: 1.385 $ $Locker: baccala $");
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    xmlNewTextChild(node, NULL, BAD_CAST "args", BAD_CAST options);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&program_start_time.tv_sec));
    xmlNewChild(node, NULL, BAD_CAST "start-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    strftime(strbuf, sizeof(strbuf), "%c %Z", localtime(&program_end_time.tv_sec));
    xmlNewChild(node, NULL, BAD_CAST "completion-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprint_timeval(strbuf, &rusage.ru_utime);
    xmlNewChild(node, NULL, BAD_CAST "user-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprint_timeval(strbuf, &rusage.ru_stime);
    xmlNewChild(node, NULL, BAD_CAST "system-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    /* Note that we modified program_end_time here to compute the real time used by the program */
    subtract_timeval(&program_end_time, &program_start_time);
    sprint_timeval(strbuf, &program_end_time);
    xmlNewChild(node, NULL, BAD_CAST "real-time", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%ld", rusage.ru_majflt);
    xmlNewChild(node, NULL, BAD_CAST "page-faults", BAD_CAST strbuf);
    xmlNodeAddContent(node, BAD_CAST "\n      ");
    sprintf(strbuf, "%ld", rusage.ru_minflt);
    xmlNewChild(node, NULL, BAD_CAST "page-reclaims", BAD_CAST strbuf);

    if (USE_PROPTABLES) {
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", entries_write_stalls);
	xmlNewChild(node, NULL, BAD_CAST "entries-write-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", entries_read_stalls);
	xmlNewChild(node, NULL, BAD_CAST "entries-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", proptable_read_stalls);
	xmlNewChild(node, NULL, BAD_CAST "proptable-read-stalls", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprintf(strbuf, "%d", proptable_writes);
	xmlNewChild(node, NULL, BAD_CAST "proptable-writes", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &entries_write_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "entries-write-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &entries_read_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "entries-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_read_stall_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-read-stall-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_write_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-write-time", BAD_CAST strbuf);
	xmlNodeAddContent(node, BAD_CAST "\n      ");
	sprint_timeval(strbuf, &proptable_preload_time);
	xmlNewChild(node, NULL, BAD_CAST "proptable-preload-time", BAD_CAST strbuf);
    }

    for (passnum = 0; passnum < total_passes; passnum ++) {
	xmlNodePtr passNode;

	xmlNodeAddContent(node, BAD_CAST "\n      ");
	passNode = xmlNewChild(node, NULL, BAD_CAST "pass", NULL);

	xmlNewProp(passNode, BAD_CAST "type", BAD_CAST pass_type[passnum]);

	subtract_timeval(&pass_end_times[passnum], &pass_start_times[passnum]);
	sprint_timeval(strbuf, &pass_end_times[passnum]);
	xmlNewProp(passNode, BAD_CAST "real-time", BAD_CAST strbuf);

	if (! strcmp(pass_type[passnum], "intratable")) {
	    if (ENTRIES_FORMAT_DTM_BITS > 0) {
		sprintf(strbuf, "%d", pass_target_dtms[passnum]);
		xmlNewProp(passNode, BAD_CAST "dtm", BAD_CAST strbuf);
	    }
	    sprintf(strbuf, "%d", positions_finalized[passnum]);
	    xmlNewProp(passNode, BAD_CAST "positions-finalized", BAD_CAST strbuf);
	    sprintf(strbuf, "%lld", backproped_moves[passnum]);
	    xmlNewProp(passNode, BAD_CAST "moves-generated", BAD_CAST strbuf);
	}
    }

    xmlNodeAddContent(node, BAD_CAST "\n   ");

    xmlNodeAddContent(tablebase, BAD_CAST "\n");

    return tb->xml;
}


/***** INDICES AND POSITIONS *****/

inline void flip_side_to_move_local(local_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

inline void flip_side_to_move_global(global_position_t *position)
{
    if (position->side_to_move == WHITE)
	position->side_to_move = BLACK;
    else
	position->side_to_move = WHITE;
}

/* invert_colors_of_global_position - just what its name implies
 *
 * We used to use this when propagating from a futurebase, but now it's only use is in the probe
 * code.  It translates a position for a tablebase built for the opposite colors, say a K+R vs K
 * endgame that we now want to probe where the rook is black, not white.  If there are pawns in the
 * game, this function has to reflect the board around a horizontal centerline.
 */

void invert_colors_of_global_position(global_position_t *global)
{
    int squareA;

    for (squareA=0; squareA < NUM_SQUARES/2; squareA++) {
	unsigned char pieceA;
	unsigned char pieceB;
	int squareB = rowcol2square(7-ROW(squareA),COL(squareA));

	pieceA = global->board[squareA];
	pieceB = global->board[squareB];

	if ((pieceA >= 'A') && (pieceA <= 'Z')) {
	    pieceA += 'a' - 'A';
	} else if ((pieceA >= 'a') && (pieceA <= 'z')) {
	    pieceA += 'A' - 'a';
	}

	if ((pieceB >= 'A') && (pieceB <= 'Z')) {
	    pieceB += 'a' - 'A';
	} else if ((pieceB >= 'a') && (pieceB <= 'z')) {
	    pieceB += 'A' - 'a';
	}
	
	global->board[squareA] = pieceB;
	global->board[squareB] = pieceA;
    }

    if (global->side_to_move == WHITE) {
	global->side_to_move = BLACK;
	if (global->en_passant_square != -1) global->en_passant_square -= 3*8;
    } else {
	global->side_to_move = WHITE;
	if (global->en_passant_square != -1) global->en_passant_square += 3*8;
    }
}

/* translate_foreign_index_to_local_position() - one of our key, key functions, used extensively
 * during futurebase back propagation.  It takes an index into a foreign tablebase and converts it
 * to a position in the local tablebase (the tablebase we're processing).  Of course, the pieces
 * might not match up between the two tablebases, but there are only a finite number of possible
 * differences:
 *
 * 1. There can be an "extra" piece in the foreign tablebase that doesn't appear in the
 * local tablebase.
 *
 * 2. There can be up to two "missing" pieces in the local tablebase that don't appear in
 * the foreign tablebase.
 *
 * 3. There can be one piece (the "restricted" piece) that matches up, but is on a square flagged
 * illegal for it in the local tablebase.
 *
 * If there are additional differences not covered in this list (more than one extra piece, for
 * example), or if the index isn't legal in the foreign tablebase, the function returns -1.
 * Otherwise, the return value is a 32 bit integer split into four eight bit fields:
 *
 * bits 0-7:   local tb piece number of missing piece #1
 * bits 8-15:  local tb piece number of restricted piece
 * bits 16-23: foreign tb piece number of extra piece
 * bits 24-31: local tb piece number of missing piece #2
 *
 * If any of the fields are unused (because there is no corresponding piece), it's value is 0x80.
 * If there are two missing pieces and only one of them is a pawn, the pawn will always be returned
 * as missing piece #1.  If there are multiple identical missing pieces, the last one will always be
 * returned as the missing piece(s).
 *
 * The function does not depend on the indexing scheme used by the foreign tablebase.  Instead, it
 * uses index_to_local_position() on the foreign tablebase.
 *
 * The only thing I don't like about this function right now is that it returns -1 if there is more
 * than one restricted piece, and we certainly could have liberal tablebases with lots of restricted
 * pieces that we want to back-prop from.
 *
 * XXX need to ASSERT that sizeof(..._pieces_processed_bitvector) is at least MAX_PIECES!!
 */

#define NONE 0x80

int translate_foreign_position_to_local_position(tablebase_t *tb1, local_position_t *foreign,
						 tablebase_t *tb2, local_position_t *local,
						 int invert_colors)
{
    int foreign_piece;
    int local_piece;
    int restricted_piece = NONE;
    int missing_piece1 = NONE;
    int missing_piece2 = NONE;
    int extra_piece = NONE;
    short local_pieces_processed_bitvector = 0;
    short foreign_pieces_processed_bitvector = 0;

    memset(local, 0, sizeof(local_position_t));

    for (local_piece = 0; local_piece < tb2->num_pieces; local_piece ++) {
	local->piece_position[local_piece] = -1;
	local->permuted_piece[local_piece] = local_piece;
    }

    local->en_passant_square = foreign->en_passant_square;
    local->side_to_move = foreign->side_to_move;

    if (invert_colors) flip_side_to_move_local(local);

    /* First, see if we can slot foreign pieces into the local tablebase on semilegal squares. */

    for (foreign_piece = 0; foreign_piece < tb1->num_pieces; foreign_piece ++) {

	int sq = foreign->piece_position[foreign_piece];

	if (invert_colors) sq = rowcol2square(7 - ROW(sq), COL(sq));

	for (local_piece = 0; local_piece < tb2->num_pieces; local_piece ++) {

	    if ((tb1->piece_type[foreign_piece] == tb2->piece_type[local_piece])
		&& (invert_colors
		    ? (tb1->piece_color[foreign_piece] != tb2->piece_color[local_piece])
		    : (tb1->piece_color[foreign_piece] == tb2->piece_color[local_piece]))
		&& (tb2->semilegal_squares[local_piece] & BITVECTOR(sq))
		&& !(local_pieces_processed_bitvector & (1 << local_piece))) {

		local->piece_position[local_piece] = sq;
		local->board_vector |= BITVECTOR(sq);
		if (tb2->piece_color[local_piece] == local->side_to_move)
		    local->PTM_vector |= BITVECTOR(sq);

		local_pieces_processed_bitvector |= (1 << local_piece);
		foreign_pieces_processed_bitvector |= (1 << foreign_piece);

		break;
	    }
	}
    }

    /* If that didn't work for a foreign piece, see if we can slip it in on a non-semilegal square
     * (a semiillegal square?)  Now, you might wonder if a different ordering of pieces might result
     * in a successful assignment onto semilegal squares, where the current ordering would fail, but
     * that's not so, because different semilegal groups of identical pieces never overlap
     * (otherwise they would have been formed into a single group).  So for each piece type of a
     * given color, there is only a single semilegal group for a given square.  But restricted
     * pieces are a bit different, since until we've done all the pieces, we can't tell which ones
     * are unassigned and thus available for a restricted piece.  That's why we run this next loop
     * seperate from the first.
     */

    for (foreign_piece = 0; foreign_piece < tb1->num_pieces; foreign_piece ++) {

	int sq = foreign->piece_position[foreign_piece];

	if (foreign_pieces_processed_bitvector & (1 << foreign_piece)) continue;

	if (invert_colors) sq = rowcol2square(7 - ROW(sq), COL(sq));

	if (restricted_piece != NONE) {
	    /* more than one restricted piece in translation */
	    return -1;
	}

	for (local_piece = 0; local_piece < tb2->num_pieces; local_piece ++) {

	    if ((tb1->piece_type[foreign_piece] == tb2->piece_type[local_piece])
		&& (invert_colors
		    ? (tb1->piece_color[foreign_piece] != tb2->piece_color[local_piece])
		    : (tb1->piece_color[foreign_piece] == tb2->piece_color[local_piece]))
		&& !(local_pieces_processed_bitvector & (1 << local_piece))) {

		local->piece_position[local_piece] = sq;
		local->board_vector |= BITVECTOR(sq);
		if (tb2->piece_color[local_piece] == local->side_to_move)
		    local->PTM_vector |= BITVECTOR(sq);

		local_pieces_processed_bitvector |= (1 << local_piece);
		foreign_pieces_processed_bitvector |= (1 << foreign_piece);

		restricted_piece = local_piece;

		break;
	    }
	}

	if (local_piece == tb2->num_pieces) {
	    if (extra_piece != NONE) {
#if 0
		fatal("More than one extra piece in translation\n");
#endif
		return -1;
	    }
	    extra_piece = foreign_piece;
	}
    }


    /* Make sure all the local pieces but one or two have been accounted for. */

    for (local_piece = 0; local_piece < tb2->num_pieces; local_piece ++) {
	if (!(local_pieces_processed_bitvector & (1 << local_piece))) {
	    if (missing_piece1 == NONE) {
		missing_piece1 = local_piece;
	    } else if (missing_piece2 == NONE) {
		if (tb2->piece_type[local_piece] == PAWN) {
		    missing_piece2 = missing_piece1;
		    missing_piece1 = local_piece;
		} else {
		    missing_piece2 = local_piece;
		}
	    } else {
		fatal("More than one missing piece in translation\n");
		return -1;
	    }
	}
    }

    return ((missing_piece2 << 24) | (extra_piece << 16) | (restricted_piece << 8) | missing_piece1);

}

int translate_foreign_index_to_local_position(tablebase_t *tb1, index_t index1, int reflection,
					      tablebase_t *tb2, local_position_t *local, int invert_colors)
{
    local_position_t foreign_position;

    if (! index_to_local_position(tb1, index1, reflection, &foreign_position)) {
#ifdef DEBUG_FUTUREMOVE
	if (index1 == DEBUG_FUTUREMOVE) {
	    info("translate_foreign_index_to_local_position: index_to_local_position failed\n");
	}
#endif
	return -1;
    }

    return translate_foreign_position_to_local_position(tb1, &foreign_position, tb2, local, invert_colors);
}

/* This function works just like previous one.  So much so that I've considered wrapping them
 * together, but since this one is already written, I'll just leave it alone for now.
 *
 * It's only use now is by the probing code (see next function).
 */

index_t global_position_to_local_position(tablebase_t *tb, global_position_t *global, local_position_t *local)
{
    int square;
    tablebase_t fake_tb;
    local_position_t fake_position;

    memset(&fake_tb, 0, sizeof(fake_tb));
    memset(&fake_position, 0, sizeof(fake_position));

    fake_position.side_to_move = global->side_to_move;
    fake_position.en_passant_square = global->en_passant_square;

    for (square = 0; square < NUM_SQUARES; square ++) {
	if ((global->board[square] != 0) && (global->board[square] != ' ')) {
	    int color;
	    int type;

	    for (color = WHITE; color <= BLACK; color ++) {
		for (type = KING; type <= PAWN; type ++) {

		    if (global->board[square] == global_pieces[color][type]) {
			fake_tb.piece_color[fake_tb.num_pieces] = color;
			fake_tb.piece_type[fake_tb.num_pieces] = type;
			fake_position.piece_position[fake_tb.num_pieces] = square;
			fake_tb.num_pieces ++;
		    }
		}
	    }
	}
    }

    return translate_foreign_position_to_local_position(&fake_tb, &fake_position, tb, local, 0);
}

index_t global_position_to_index(tablebase_t *tb, global_position_t *global)
{
    local_position_t local;

    if (global_position_to_local_position(tb, global, &local) != 0x80808080) return -1;

    return local_position_to_index(tb, &local);
}

/* index_to_global_position()
 *
 * Used during Nalimov tablebase verification (by running through all indices in a tablebase), as
 * well as during probe code to consider possible captures and promotions because they may lead out
 * of the current tablebase.
 *
 * Massively simplified from an earlier implementation because I want to contain the details of
 * indexing to the local position routines.  Probably a little bit slower now, but not too much.
 *
 * Seems never to be used on a tablebase under construction; only on a finished one.
 */

boolean index_to_global_position(tablebase_t *tb, index_t index, global_position_t *global)
{
    local_position_t local;
    int piece;

    memset(global, 0, sizeof(global_position_t));

    if (! index_to_local_position(tb, index, REFLECTION_NONE, &local)) return 0;

    global->side_to_move = local.side_to_move;
    global->en_passant_square = local.en_passant_square;

    for (piece = 0; piece < tb->num_pieces; piece++) {
	global->board[local.piece_position[piece]]
	    = global_pieces[tb->piece_color[piece]][tb->piece_type[piece]];
    }

    return 1;
}


/***** PARSING FEN TO/FROM POSITION STRUCTURES *****/

boolean place_piece_in_local_position(tablebase_t *tb, local_position_t *pos, int square, int color, int type)
{
    int piece;

    if (pos->board_vector & BITVECTOR(square)) return 0;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == type) && (tb->piece_color[piece] == color)) {
	    pos->piece_position[piece] = square;
	    pos->board_vector |= BITVECTOR(square);
	    if (color == pos->side_to_move) pos->PTM_vector |= BITVECTOR(square);
	    return 1;
	}
    }

    return 0;
}

boolean place_piece_in_global_position(global_position_t *position, int square, int color, int type)
{
    position->board[square] = global_pieces[color][type];
    return 1;
}

boolean parse_FEN_to_local_position(char *FEN_string, tablebase_t *tb, local_position_t *pos)
{
    int row, col;
    int piece;

    memset(pos, 0, sizeof(local_position_t));
    pos->en_passant_square = -1;

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	pos->piece_position[piece] = -1;
	pos->permuted_piece[piece] = piece;
    }

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_local_position(tb, pos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    return 1;
}

boolean parse_FEN_to_global_position(char *FEN_string, global_position_t *pos)
{
    int row, col;

    memset(pos, 0, sizeof(global_position_t));
    pos->en_passant_square = -1;

    for (row=7; row>=0; row--) {
	for (col=0; col<=7; col++) {
	    switch (*FEN_string) {
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
		/* subtract one here since the 'for' loop will bump col by one */
		col += *FEN_string - '0' - 1;
		if (col > 7) return 0;
		break;

	    case 'k':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, KING)) return 0;
		break;
	    case 'K':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, KING)) return 0;
		break;

	    case 'q':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, QUEEN)) return 0;
		break;
	    case 'Q':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, QUEEN)) return 0;
		break;

	    case 'r':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, ROOK)) return 0;
		break;
	    case 'R':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, ROOK)) return 0;
		break;

	    case 'b':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, BISHOP)) return 0;
		break;
	    case 'B':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, BISHOP)) return 0;
		break;

	    case 'n':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, KNIGHT)) return 0;
		break;
	    case 'N':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, KNIGHT)) return 0;
		break;

	    case 'p':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), BLACK, PAWN)) return 0;
		break;
	    case 'P':
		if (!place_piece_in_global_position(pos, rowcol2square(row, col), WHITE, PAWN)) return 0;
		break;
	    }
	    FEN_string++;
	}
	if (row > 0) {
	  if (*FEN_string != '/') return 0;
	  else FEN_string++;
	}
    }

    if (*FEN_string != ' ') return 0;
    while (*FEN_string == ' ') FEN_string ++;

    if (*FEN_string == 'w') {
      pos->side_to_move = WHITE;
    } else if (*FEN_string == 'b') {
      pos->side_to_move = BLACK;
    } else {
      return 0;
    }

    FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* skip castling rights (if they exist) */

    while ((*FEN_string == '-') || (*FEN_string == 'K') || (*FEN_string == 'Q')
	   || (*FEN_string == 'k') || (*FEN_string == 'q')) FEN_string ++;

    while (*FEN_string == ' ') FEN_string ++;

    /* If en passant square was specified, parse it */

    if ((FEN_string[0] >= 'a') && (FEN_string[0] <= 'h')
	&& (FEN_string[1] >= '1') && (FEN_string[1] <= '8')) {
	pos->en_passant_square = rowcol2square(FEN_string[1] - '1', FEN_string[0] - 'a');
    }

    /* maybe we should return error here if there's still more to the string */

    return 1;
}

/* Note that the buffer in this function is static... */

char * global_position_to_FEN(global_position_t *position)
{
    static char buffer[256];
    char *ptr = buffer;
    int empty_squares;
    int row, col;

    for (row=7; row>=0; row--) {
	empty_squares=0;
	for (col=0; col<=7; col++) {
	    if ((position->board[rowcol2square(row, col)] == ' ') || (position->board[rowcol2square(row,col)] == 0)) {
		empty_squares++;
	    } else {
		if (empty_squares > 0) {
		    *(ptr++) = '0' + empty_squares;
		    empty_squares = 0;
		}
		*(ptr++) = position->board[rowcol2square(row,col)];
	    }
	}
	if (empty_squares > 0) {
	    *(ptr++) = '0' + empty_squares;
	}
	if (row > 0) *(ptr++) = '/';
    }

    *(ptr++) = ' ';

    *(ptr++) = (position->side_to_move == WHITE) ? 'w' : 'b';

    /* no castling rights */

    *(ptr++) = ' ';
    *(ptr++) = '-';
    *(ptr++) = ' ';

    if (position->en_passant_square == -1) {
	*(ptr++) = '-';
    } else {
	*(ptr++) = 'a' + COL(position->en_passant_square);
	*(ptr++) = '1' + ROW(position->en_passant_square);
    }

    *(ptr++) = '\0';

    return buffer;
}

char * index_to_FEN(tablebase_t *tb, index_t index)
{
    global_position_t global;
    index_to_global_position(tb, index, &global);
    return global_position_to_FEN(&global);
}

/* This routine looks at "movestr" to try and figure out if it is a valid move from this global
 * position.  If so, it changes the global position to reflect the move and returns true.
 * Otherwise, it leaves the global position alone and returns false.
 */

boolean parse_move_in_global_position(char *movestr, global_position_t *global)
{
    int origin_square, destination_square;
    int is_capture = 0;
    unsigned char promotion_piece = '\0';

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	origin_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == 'x') {
	is_capture = 1;
	movestr ++;
    }

    if (movestr[0] >= 'a' && movestr[0] <= 'h' && movestr[1] >= '1' && movestr[1] <= '8') {
	destination_square = movestr[0]-'a' + (movestr[1]-'1')*8;
	movestr += 2;
    } else {
	return 0;
    }

    if (movestr[0] == '=') {
	movestr ++;
	promotion_piece = movestr[0];
    }

    if (!(global->board[origin_square] >= 'A' && global->board[origin_square] <= 'Z')
	&& global->side_to_move == WHITE)
	return 0;

    if (!(global->board[origin_square] >= 'a' && global->board[origin_square] <= 'z')
	&& global->side_to_move == BLACK)
	return 0;

    if (global->board[destination_square] >= 'A' && !is_capture) return 0;

    if (!(global->board[destination_square] >= 'A' && global->board[destination_square] <= 'Z')
	&& is_capture && global->side_to_move == BLACK)
	return 0;

    if (!(global->board[destination_square] >= 'a' && global->board[destination_square] <= 'z')
	&& is_capture && global->side_to_move == WHITE)
	return 0;

    global->board[destination_square] = promotion_piece ? promotion_piece : global->board[origin_square];
    global->board[origin_square] = 0;
    if (global->side_to_move == WHITE)
	global->side_to_move = BLACK;
    else
	global->side_to_move = WHITE;

    global->en_passant_square = -1;

    if ((global->board[destination_square] == 'P') && (origin_square == destination_square - 16)) {
	global->en_passant_square = destination_square - 8;
    }
    if ((global->board[destination_square] == 'p') && (origin_square == destination_square + 16)) {
	global->en_passant_square = destination_square + 8;
    }

    return 1;
}


/* ENTRY RING BUFFERS
 *
 * In order to avoid copying file buffers in the kernel, which would really hurt our performance, we
 * turn off kernel buffering on the entries and proptable files by passing O_DIRECT to open().  This
 * makes disk read/write DMA operations go directly to user space buffers (which must now be page
 * aligned) and avoids any copying in the kernel.  It also means that we must now do our own
 * buffering, making extensive use of POSIX asynchronous I/O operations.  For the entries file,
 * which we update in memory and so must write back to disk, I use a ring buffering scheme.
 *
 * Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed) uses four colors to
 * illustrate the concept.  I'll use five - blue (input started but not yet complete), green (input
 * complete), yellow (currently processing), red (output started but not yet complete), and purple
 * (output done; input not yet started).  In our case, the buffers turn from blue to green and from
 * red to purple by themselves and we can detect the color difference between blue and green and
 * between red and purple by looking to see if their asynchronous read or write operation completed.
 * So we need two pointers, one to the single yellow buffer, and one to the first red or purple
 * buffer.  If the red/purple pointer catches up to the yellow pointer, then it means that there are
 * no read or purple buffers at the moment.
 *
 * The only functions "exported" from this section are the singly called init_entry_buffers(),
 * fetch_entry(), and store_entry().
 *
 * I'm aiming right now for a target buffer size of 128 KB, since that's my kernel's maximum
 * internal request size.  So, 128 KB / 4 byte entries = 32 K entries = 1<<15
 */

#define LEFTSHIFT(val,bits) (((bits) > 0) ? ((val) << (bits)) : ((val) >> (-(bits))))

#if USE_PROPTABLES

#define NUM_ENTRY_BUFFERS 4
#define ENTRY_BUFFER_ENTRIES (1<<12)
#define ENTRY_BUFFER_BYTES LEFTSHIFT(ENTRY_BUFFER_ENTRIES, ENTRIES_FORMAT_BITS - 3)

struct entry_buffer {
    entry_t *buffer;
    index_t start;
    struct aiocb aiocb;
};

struct entry_buffer entry_buffers[NUM_ENTRY_BUFFERS];

int yellow_entry_buffer = 0;
int first_purple_red_entry_buffer = 0;

/* Arrange to read buffernum (i.e, turn it blue).  'buffer' must be allocated (and page aligned),
 * and 'start' must indicate the index number (not the byte number) at which we want to start our
 * read, always of ENTRY_BUFFER_BYTES bytes.
 */

void turn_entry_buffer_blue(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= LEFTSHIFT(entry_buffers[buffernum].start, ENTRIES_FORMAT_BITS - 3);

    if (aio_read(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_read for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_green(int buffernum)
{
    const struct aiocb * aiocbs[1];
    int retval;

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer read to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_read_stall_time, &tv2);
	entries_read_stalls ++;
    }

    retval = aio_return(&entry_buffers[buffernum].aiocb);

    if (retval == 0) {
	/* zero byte read - this is OK the first time through */
	memset(entry_buffers[buffernum].buffer, 0, ENTRY_BUFFER_BYTES);
    } else if ((retval != ENTRY_BUFFER_BYTES)
	       && (retval != LEFTSHIFT(current_tb->max_index % ENTRY_BUFFER_ENTRIES,
				       ENTRIES_FORMAT_BITS - 3)))  {
	fprintf(stderr, "entry buffer aio_read didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

/* Arrange to write buffernum (i.e, turn it red).  Again, 'buffer' must be allocated and 'start'
 * must indicate the index number at which we want to start our write.
 */

void turn_entry_buffer_red(int fd, int buffernum)
{
    memset(&entry_buffers[buffernum].aiocb, 0, sizeof(struct aiocb));
    entry_buffers[buffernum].aiocb.aio_fildes = fd;
    entry_buffers[buffernum].aiocb.aio_buf = entry_buffers[buffernum].buffer;
    entry_buffers[buffernum].aiocb.aio_nbytes = ENTRY_BUFFER_BYTES;
    entry_buffers[buffernum].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;
    entry_buffers[buffernum].aiocb.aio_offset
	= LEFTSHIFT(entry_buffers[buffernum].start, ENTRIES_FORMAT_BITS - 3);

    if (aio_write(& entry_buffers[buffernum].aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_write for entry buffer\n");
	kill(getpid(), SIGSTOP);
    }
}

void wait_for_entry_buffer_purple(int buffernum)
{
    const struct aiocb * aiocbs[1];

    if (aio_error(&entry_buffers[buffernum].aiocb) == EINPROGRESS) {
	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);

	/* fprintf(stderr, "Waiting for entry buffer write to complete\n"); */
	aiocbs[0] = &entry_buffers[buffernum].aiocb;
	aio_suspend(aiocbs, 1, NULL);

	gettimeofday(&tv2, NULL);
	subtract_timeval(&tv2, &tv1);
	add_timeval(&entries_write_stall_time, &tv2);
	entries_write_stalls ++;
    }

    if (aio_return(&entry_buffers[buffernum].aiocb) != ENTRY_BUFFER_BYTES) {
	fprintf(stderr, "entry buffer aio_write didn't return ENTRY_BUFFER_BYTES\n");
	kill(getpid(), SIGSTOP);
    }
}

void init_entry_buffers(tablebase_t *tb)
{
    int alignment = fpathconf(tb->entries_fd, _PC_REC_XFER_ALIGN);
    int buffernum;

    for (buffernum = 0; buffernum < NUM_ENTRY_BUFFERS; buffernum ++) {
	if (posix_memalign((void **) &entry_buffers[buffernum], alignment, ENTRY_BUFFER_BYTES) != 0) {
	    fatal("Can't posix_memalign entries buffer\n");
	    terminate();
	}
	entry_buffers[buffernum].start = buffernum * ENTRY_BUFFER_ENTRIES;
	turn_entry_buffer_blue(tb->entries_fd, buffernum);
    }

    wait_for_entry_buffer_green(0);
}

/* Make sure that 'index' is in the yellow entry buffer.  All these colors remind me of the game
 * Twister, thus the name of this function...
 */

void twister(tablebase_t *tb, index_t index)
{
    if ((index < entry_buffers[yellow_entry_buffer].start)
	|| (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	/* The index we're looking for isn't in the yellow buffer.  Play Twister. */

	int next_entry_buffer = yellow_entry_buffer + 1;
	if (next_entry_buffer >= NUM_ENTRY_BUFFERS) next_entry_buffer = 0;

	/* Have we caught up with our first purple/red buffer?  Wait until the write has finished
	 * and start the read.
	 */

	if (next_entry_buffer == first_purple_red_entry_buffer) {

	    wait_for_entry_buffer_purple(first_purple_red_entry_buffer);

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* Now, next_entry_buffer is at least blue.  Wait for it to turn green. */

	wait_for_entry_buffer_green(next_entry_buffer);

	/* Check to see if any of the trailing red buffers have turned purple.  If so, turn them
	 * blue.  We do this towards the end here, because if we had to block waiting for
	 * next_entry_buffer to become green, some of the reds might have turned purple.
	 */

	while ((first_purple_red_entry_buffer != yellow_entry_buffer)
	       && (aio_error(&entry_buffers[first_purple_red_entry_buffer].aiocb) != EINPROGRESS)) {

	    /* arrange to read first_purple_red_entry_buffer (i.e, turn it blue) */

	    entry_buffers[first_purple_red_entry_buffer].start += ENTRY_BUFFER_ENTRIES * NUM_ENTRY_BUFFERS;
	    if (entry_buffers[first_purple_red_entry_buffer].start > tb->max_index) {
		entry_buffers[first_purple_red_entry_buffer].start -= tb->max_index + 1;
		entry_buffers[first_purple_red_entry_buffer].start /= ENTRY_BUFFER_ENTRIES;
		entry_buffers[first_purple_red_entry_buffer].start *= ENTRY_BUFFER_ENTRIES;
	    }

	    turn_entry_buffer_blue(tb->entries_fd, first_purple_red_entry_buffer);

	    /* advance first_purple_red_entry_buffer */

	    first_purple_red_entry_buffer ++;
	    if (first_purple_red_entry_buffer >= NUM_ENTRY_BUFFERS) first_purple_red_entry_buffer = 0;
	}

	/* queue a write operation for yellow_entry_buffer (i.e, turn it red) */

	turn_entry_buffer_red(tb->entries_fd, yellow_entry_buffer);

	/* Move on to the next buffer to be processed.  We waited for it to be green, remember? */

	yellow_entry_buffer = next_entry_buffer;
    }

    /* Now, as silly as this sounds, we might have done all of that and still not have a valid
     * buffer if the calling routine isn't going through the index numbers in order.  Complain, and
     * wait for a special read to finish on the buffer.  We don't bother with a write because we
     * just flipped buffers above, so our yellow buffer was green a split second ago.
     */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {

	fprintf(stderr, "fetch_entry_pointer(): special read; needed %d had %d\n",
		index, entry_buffers[yellow_entry_buffer].start);  /* BREAKPOINT */

	entry_buffers[yellow_entry_buffer].start = (index / ENTRY_BUFFER_ENTRIES) * ENTRY_BUFFER_ENTRIES;

	turn_entry_buffer_blue(tb->entries_fd, yellow_entry_buffer);

	wait_for_entry_buffer_green(yellow_entry_buffer);
    }

    /* If we STILL don't have a valid buffer, well, give up, I guess. */

    if ((index < entry_buffers[yellow_entry_buffer].start)
	       || (index >= (entry_buffers[yellow_entry_buffer].start + ENTRY_BUFFER_ENTRIES))) {
	fprintf(stderr, "Can't fetch in fetch_entry_pointer\n");
    }
}

#endif /* USE_PROPTABLES */

/* Fetch an entry pointer from a preloaded tablebase - we're reading from a compressed file
 * (possibly over the network)
 */

inline entry_t * fetch_entry_pointer(tablebase_t *tb, index_t index)
{
    static char entry[MAX_FORMAT_BYTES];
    static tablebase_t *cached_tb = NULL;
    static index_t cached_index = 0;
    int retval;

    if (tb->file == NULL) {
	fatal("fetch_entry_pointer() called on a non-preloaded tablebase\n");
	terminate();
    }

    if (tb->format.bits == 3) {

	/* Special case for the very common one-byte-DTM format */

	if ((cached_tb == tb) && (index == cached_index)) return entry;

	/* Do it this way for now to avoid seeks, which fail on network/gzip FILEs */

	if (index < tb->next_read_index) {
	    if (fseek(tb->file, tb->offset + index, SEEK_SET) != 0) {
		fatal("Seek failed in fetch_entry_pointer()\n");
	    } else {
		tb->next_read_index = index;
	    }
	}

	do {

	    if ((retval = fgetc(tb->file)) == EOF) {
		fatal("fetch_entry_pointer() hit EOF reading from disk\n");
	    }
	    tb->next_read_index ++;

	} while (tb->next_read_index <= index);

	entry[0] = retval;

    } else {

	if ((cached_tb == tb) && (LEFTSHIFT(index, tb->format.bits - 3)
				  == LEFTSHIFT(cached_index, tb->format.bits - 3))) return entry;

	/* Do it this way for now to avoid seeks, which fail on network/gzip FILEs */

	if (LEFTSHIFT(index, tb->format.bits - 3)
	    < LEFTSHIFT(tb->next_read_index, tb->format.bits - 3)) {
	    if (fseek(tb->file, tb->offset + LEFTSHIFT(index, tb->format.bits - 3), SEEK_SET) != 0) {
		fatal("Seek failed in fetch_entry_pointer()\n");
	    }
	}

	do {

	    retval = fread(entry, tb->format.bytes, 1, tb->file);
	    if (retval != 1) {
		fatal("fetch_entry_pointer() hit EOF reading from disk\n");
	    }

	    switch (tb->format.bits) {
	    case 0:
		tb->next_read_index = (tb->next_read_index + 8) & ~7;
		break;
	    case 1:
		tb->next_read_index = (tb->next_read_index + 4) & ~3;
		break;
	    case 2:
		tb->next_read_index = (tb->next_read_index + 2) & ~1;
		break;
	    default:
		tb->next_read_index = tb->next_read_index + 1;
		break;
	    }
	} while (LEFTSHIFT(index, tb->format.bits - 3)
		 >= LEFTSHIFT(tb->next_read_index, tb->format.bits - 3));
    }

    cached_tb = tb;
    cached_index = index;
    return entry;
}

inline entry_t * fetch_current_entry_pointer(index_t index)
{

#if USE_PROPTABLES

    /* we're using proptables, so make sure we've got the right buffer and then return the pointer */

    twister(current_tb, index);

    return (void *) (entry_buffers[yellow_entry_buffer].buffer)
	+ LEFTSHIFT(index - entry_buffers[yellow_entry_buffer].start, ENTRIES_FORMAT_BITS - 3);
#else

    /* entries array exists in memory - so just return a pointer into it */

    return (void *)(current_tb->entries) + LEFTSHIFT(index, ENTRIES_FORMAT_BITS - 3);

#endif

}


/* MORE TABLEBASE OPERATIONS - those that probe and manipulate individual position entries
 *
 * "Designed to multi-thread"
 *
 * Keep atomic operations confined to single functions.  Design functions so that functions calling
 * them don't need to know the details of table format, either.
 *
 * These "add one" functions (atomically) add one to the count in question, subtract one from the
 * total move count, and flag the position as 'ready for propagation' (maybe this is just a move
 * count of zero) if the total move count goes to zero.
 *
 * PTM = Player to Move
 * PNTM = Player not to Move
 *
 */

#define MOVECNT_PTM_WINS_PROPED (ENTRIES_FORMAT_MOVECNT_MASK)
#define MOVECNT_PNTM_WINS_PROPED (ENTRIES_FORMAT_MOVECNT_MASK - 1)
#define MOVECNT_PTM_WINS_UNPROPED (ENTRIES_FORMAT_MOVECNT_MASK - 2)
#define MOVECNT_STALEMATE (ENTRIES_FORMAT_MOVECNT_MASK - 3)
#define MOVECNT_MAX (ENTRIES_FORMAT_MOVECNT_MASK - 4)
#define MOVECNT_PNTM_WINS_UNPROPED (0)

inline int get_raw_DTM(tablebase_t *tb, index_t index)
{
    return get_signed_field(fetch_entry_pointer(tb, index),
			    tb->format.dtm_mask,
			    tb->format.dtm_offset + ((index << tb->format.bits) % 8));
}

inline int get_entry_raw_DTM(index_t index)
{
    if (ENTRIES_FORMAT_DTM_BITS == 0) return 0;
    return get_signed_field(fetch_current_entry_pointer(index),
			    ENTRIES_FORMAT_DTM_MASK,
			    ENTRIES_FORMAT_DTM_OFFSET + ((index << ENTRIES_FORMAT_BITS) % 8));
}

inline void set_entry_raw_DTM(index_t index, int dtm)
{
    if (ENTRIES_FORMAT_DTM_BITS == 0) return;
    set_signed_field(fetch_current_entry_pointer(index),
		     ENTRIES_FORMAT_DTM_MASK,
		     ENTRIES_FORMAT_DTM_OFFSET + ((index << ENTRIES_FORMAT_BITS) % 8),
		     dtm);
}

inline int get_entry_movecnt(index_t index)
{
    return get_unsigned_field(fetch_current_entry_pointer(index),
			      ENTRIES_FORMAT_MOVECNT_MASK,
			      ENTRIES_FORMAT_MOVECNT_OFFSET + ((index << ENTRIES_FORMAT_BITS) % 8));
}

inline void set_entry_movecnt(index_t index, int movecnt)
{
    set_unsigned_field(fetch_current_entry_pointer(index),
		       ENTRIES_FORMAT_MOVECNT_MASK,
		       ENTRIES_FORMAT_MOVECNT_OFFSET + ((index << ENTRIES_FORMAT_BITS) % 8),
		       movecnt);
}

inline int get_flag(tablebase_t *tb, index_t index)
{
    return get_unsigned_field(fetch_current_entry_pointer(index),
			      1,
			      tb->format.flag_offset + ((index << tb->format.bits) % 8));
}

inline int get_entry_flag(index_t index)
{
    return get_unsigned_field(fetch_current_entry_pointer(index),
			      1,
			      ENTRIES_FORMAT_FLAG_OFFSET + ((index << ENTRIES_FORMAT_BITS) % 8));
}

inline short does_PTM_win(index_t index)
{
    return (get_entry_movecnt(index) == MOVECNT_PTM_WINS_PROPED)
	|| (get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED);
}

inline short does_PNTM_win(index_t index)
{
    return (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_PROPED)
	|| (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED);
}

/* Get the result in a format suitable for a one-byte DTM tablebase
 *
 * 0 = draw
 * 1 = PNTM in check (illegal position)
 * N = mate in N-1
 * -1 = PTM checkmated
 * -N = PNTM will have a mate in N-1 after this move
 *
 * The difference between get_DTM (here) and get_raw_DTM (above) is that if the DTM value is less
 * than zero (PNTM wins), but movecnt is still greater than zero, then there are still moves that
 * might let PTM slip off the hook, so in that case we indicate draw.
 */

int get_entry_DTM(index_t index)
{
    return (does_PTM_win(index) || does_PNTM_win(index)) ? get_entry_raw_DTM(index) : 0;
}

inline boolean is_position_valid(tablebase_t *tb, index_t index)
{
    return (get_raw_DTM(tb, index) != 1);
}

/* Five possible ways we can initialize a tablebase entry for a position:
 *  - it's illegal
 *  - PNTM's mated
 *  - PTM's mated
 *  - stalemate
 *  - any other position, with 'movecnt' possible moves out the position
 */

void initialize_entry(tablebase_t *tb, index_t index, int movecnt, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE) {
	fprintf(stderr, "initialize index %d %s movecnt %d; dtm %d\n",
		index, index_to_FEN(tb, index), movecnt, dtm);
    }
#endif

    if (dtm > 0) positive_passes_needed[dtm] = 1;
    if (dtm < 0) negative_passes_needed[-dtm] = 1;

    set_entry_movecnt(index, movecnt);
    if (ENTRIES_FORMAT_DTM_BITS > 0) set_entry_raw_DTM(index, dtm);
}

void initialize_entry_as_illegal(tablebase_t *tb, index_t index)
{
    /* An "illegal" position is something like one with two pieces both on the same square.  An
     * illegal position in the chess sense, of PNTM being in check, is handled below.  So this
     * function needs to flag the position in such a way that nothing will ever get done with it; in
     * particular, no attempt will ever be made to back propagate it.  Setting everything to zero
     * does the trick.  The zero movecnt doesn't matter, since we'll never back propagate into this
     * position, and the zero DTM ensures that it will always be treated like a draw during
     * a back prop pass - i.e, no attempt will ever be made to finalize it.
     */

    initialize_entry(tb, index, 0, 0);
}

void initialize_entry_with_PTM_mated(tablebase_t *tb, index_t index)
{
    /* This is a classic checkmate - PTM is in check and has no semi-legal moves, let along legal
     * ones.  The case where PTM has semi-legal but no legal moves is handled below, in
     * add_one_to_PNTM_wins().  DTM is -1 here - PNTM wins.
     */

    initialize_entry(tb, index, MOVECNT_PNTM_WINS_UNPROPED, -1);
    total_legal_positions ++;
}

void initialize_entry_with_PNTM_mated(tablebase_t *tb, index_t index)
{
    /* This kind of position is "illegal" in the chess sense - PNTM's king can be captured.  The
     * design of Hoffman is simplified somewhat by treating this as a legal position, and then back
     * propagating from it to determine the true checkmate positions, one ply earlier, that can't
     * avoid this kind of illegal position.  DTM is one here - PTM wins.
     */

    initialize_entry(tb, index, MOVECNT_PTM_WINS_UNPROPED, 1);
    total_PNTM_mated_positions ++;
}

void initialize_entry_with_stalemate(tablebase_t *tb, index_t index)
{
    /* The only way this function gets called is if the number of semi-legal moves out of the
     * position is zero and we're not in check.  A "semi-legal" move is one that might not actually
     * be legal (because it would move into check), but will be back-propagated in the tablebase.  A
     * stalemate that arises from a position with semi-legal moves but no legal moves will get
     * handled in add_one_to_PNTM_wins() once all of the semi-legal moves have been eliminated.  In
     * short, because there are no semi-legal moves out of this position, we'll never back propagate
     * into this position, so setting movecnt = 1 is an acceptable way of flagging this as a
     * stalemate, since this position's movecnt should never get decremented.
     */

    if (tb->stalemate_prune_type == RESTRICTION_CONCEDE) {
	if (index_to_side_to_move(tb, index) == tb->stalemate_prune_color) {
	    initialize_entry(tb, index, MOVECNT_PTM_WINS_UNPROPED, 2);
	} else {
	    initialize_entry(tb, index, MOVECNT_PNTM_WINS_UNPROPED, -2);
	}
    } else {
	initialize_entry(tb, index, MOVECNT_STALEMATE, 0);
	total_stalemate_positions ++;
    }

    total_legal_positions ++;
}

void initialize_entry_with_movecnt(tablebase_t *tb, index_t index, int movecnt)
{
    if (movecnt > MOVECNT_MAX) {
	fatal("Attempting to initialize position with a movecnt that won't fit in field!\n");
    }

    initialize_entry(tb, index, movecnt, 0);
    total_legal_positions ++;
}

inline void PTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("PTM_wins; index=%d; dtm=%d\n", index, dtm);
#endif

    if (dtm < 0) {
	fatal("Negative distance to mate in PTM_wins!?\n");
    } else if ((get_entry_movecnt(index) != MOVECNT_PTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PTM_WINS_UNPROPED)) {
	set_entry_movecnt(index, MOVECNT_PTM_WINS_UNPROPED);
	set_entry_raw_DTM(index, dtm);
	positive_passes_needed[dtm] = 1;
    } else if (dtm < get_entry_raw_DTM(index)) {
	/* This can happen if we get a PTM mate during futurebase back prop, then, later during
	 * futurebase back prop or during intra-table back prop, improve upon the mate.
	 */
	set_entry_raw_DTM(index, dtm);
	positive_passes_needed[dtm] = 1;
    }
}

inline void add_one_to_PNTM_wins(tablebase_t *tb, index_t index, int dtm)
{
#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("add_one_to_PNTM_wins; index=%d; dtm=%d; table dtm=%d\n", index, dtm, get_entry_raw_DTM(index));
#endif

    if (dtm > 0) {
	fatal("Positive distance to mate in PNTM_wins!?\n");
    } else if ((get_entry_movecnt(index) != MOVECNT_PTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_PROPED)
	       && (get_entry_movecnt(index) != MOVECNT_PNTM_WINS_UNPROPED)
	       && (get_entry_movecnt(index) != MOVECNT_STALEMATE)) {

	/* We should never get here with MOVECNT_PNTM_WINS_UNPROPED (or PROPED) because we have to
	 * have decremented the movecnt already to zero to have gotten either of those flags.
	 */

	set_entry_movecnt(index, get_entry_movecnt(index) - 1);

	if ((dtm < get_entry_raw_DTM(index)) && (get_entry_raw_DTM(index) <= 0)) {
	    /* Since this is PNTM wins, PTM will make the move leading to the slowest mate. */
	    set_entry_raw_DTM(index, dtm);
	}

	if (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED) {  /* i.e, zero */
	    /* The DTM passed in was the one that pushed movecnt to zero, but it might be the best
	     * line, so that's why we fetch entry DTM here.
	     */
	    negative_passes_needed[-get_entry_raw_DTM(index)] = 1;
	}
    }
}


/***** PROPAGATION TABLES *****/

void commit_entry(index_t index, int dtm, uint8 PTM_wins_flag, int movecnt, futurevector_t futurevector)
{
    int i;

#if 0
    /* Skip everything if the position isn't valid.  In particular, we don't track futuremove
     * propagation for illegal positions.
     */

    if (get_entry_raw_DTM(index) == 1) return;
#endif

    /* Somewhat of a special case here.  First of all, futurevector is non-zero only on the first
     * back-propagation pass, when we back prop from the futurebases.  Also, if we're not using
     * proptables, then I use a seperate array for the futurevectors, which got filled in when we
     * initialized the tablebase.  In that case, we now check off the futurevectors in that array as
     * we back prop.  If we are using proptables, then this gets done during the initialization pass
     * and we don't use the seperate array.
     */

    if ((! USE_PROPTABLES) && (futurevector != 0)) {

	if ((futurevector & current_tb->futurevectors[index]) != futurevector) {
	    /* This could happen simply if the futuremove has already been considered */
	    /* XXX In particular, I need to turn this off right now for symmetric tablebases */
#if 0
	    global_position_t global;
	    index_to_global_position(current_tb, index, &global);
	    fprintf(stderr, "Futuremove discrepancy: %s\n", global_position_to_FEN(&global));
#endif
	    return;
	}

	current_tb->futurevectors[index] ^= futurevector;
    }

    if (PROPTABLE_FORMAT_DTM_BITS > 0) {
	if (dtm > 0) {
	    PTM_wins(current_tb, index, dtm);
	} else if (dtm < 0) {
	    for (i=0; i<movecnt; i++) {
		add_one_to_PNTM_wins(current_tb, index, dtm);
	    }
	}
    } else if (PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET != -1) {
	if (PTM_wins_flag) {
	    PTM_wins(current_tb, index, dtm);
	} else {
	    for (i=0; i<movecnt; i++) {
		add_one_to_PNTM_wins(current_tb, index, dtm);
	    }
	}
    } else {
	fatal("Can't handle proptable formats without either a DTM field or PTM wins flag\n");
    }
}

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int reflection);

void back_propagate_index(index_t index, int target_dtm)
{
    /* Symmetry.
     *
     * The only case we really have to worry about here is diagonal symmetry, because in both
     * horizontal and vertical symmetry all of the positions neatly double up, so anytime we'd have
     * a move backprop into our symmetry restriction from outside it, a matching move will backprop
     * from inside out.
     *
     * For diagonal symmetry however, things aren't so neat, because squares along the diagonal map
     * to themselves.  So positions where both kings are on the diagonal don't have a matching
     * double, while the other positions do.  We deal with this here by backproping both the
     * position itself and its matching pair (if one exists).  If one doesn't exist, then
     * back_propagate_index_within_table() will quickly detect this case (when index_to_position
     * returns false).  We also doubled the movecnt of "paired" positions during initialization,
     * because moves will be backproped twice from doubled positions to doubled positions, not just
     * assumed like the horizontal or vertical cases.
     */

    if (((get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED)
	 || (get_entry_movecnt(index) == MOVECNT_PNTM_WINS_UNPROPED))
	&& ((ENTRIES_FORMAT_DTM_BITS == 0) || (get_entry_DTM(index) == target_dtm))) {

	back_propagate_index_within_table(current_tb, index, REFLECTION_NONE);
	if (current_tb->symmetry == 8) {
	    back_propagate_index_within_table(current_tb, index, REFLECTION_DIAGONAL);
	}
	positions_finalized[total_passes] ++;

	/* Track "player wins" statistics.  We don't want to count illegal (PNTM mated)
	 * positions, so we don't increment anything if DTM is 1.
	 */

	if (get_entry_movecnt(index) == MOVECNT_PTM_WINS_UNPROPED) {
	    set_entry_movecnt(index, MOVECNT_PTM_WINS_PROPED);
	    if (target_dtm > 1) player_wins[index_to_side_to_move(current_tb, index)] ++;
	} else {
	    set_entry_movecnt(index, MOVECNT_PNTM_WINS_PROPED);
	    player_wins[1 - index_to_side_to_move(current_tb, index)] ++;
	}

    }

}

#if USE_PROPTABLES

/* When propagating a change from one position to another, we go through this table to do it.  By
 * maintaining this table sorted, we avoid the random accesses that would be required to propagate
 * directly from one position to another.  It only makes sense to use a propagation table if the
 * tablebase can't fit in memory.  If the tablebase does fit in memory, we bypass almost this entire
 * section of code.
 *
 * We insert into the propagation table using an "address calculation insertion sort".  Knuth
 * described it by analogy to shelving books.  You're sorting the books as you place them onto the
 * shelf; that makes it an "insertion sort" (as opposed to something like an exchange sort, where
 * you place them first and then sort by swapping).  You look at the author's last name to try and
 * "guess" where it should go on the shelf - "Alfors" all the way to the left; "Munkres" about in
 * the middle; "van der Waerden" towards the right.  That's the "address calculation" part.
 *
 * We do this with indices, dividing them by a scaling factor to get an offset into the propagation
 * table (in memory).  This type of sort works well if the indices are well spread out, and not so
 * well in they are clumped together.  That's why we invert indices in a finite field - to spread
 * out the mating positions that naturally clump together into groups of similar positions.  Once we
 * start having to move things around too much to do an insertion, we write the current proptable
 * out to disk, zero out the memory, and start again fresh.
 *
 * Once we've got a bunch of proptables written to disk, we then need to read them back in.  We do
 * this "semi-sequentially" - each individual table is read sequentially, even though we need to
 * jump our reads around between them.  We run the entries from each table through a sort tree to
 * produce a single stream of sorted proptable entries, which are then committed into the tablebase.
 *
 * To optimize all of this, we simultaneously read one set of proptables and write another set while
 * making a single pass through the tablebase.
 */

int proptable_entries = 0;
int proptable_merges = 0;

#define PROPTABLE_ELEM(n)  ((void *)proptable + PROPTABLE_FORMAT_BYTES * (n))

index_t get_propentry_index(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned_field(ptr, PROPTABLE_FORMAT_INDEX_MASK, PROPTABLE_FORMAT_INDEX_OFFSET);
}

void set_propentry_index(proptable_entry_t *propentry, index_t index)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned_field(ptr, PROPTABLE_FORMAT_INDEX_MASK, PROPTABLE_FORMAT_INDEX_OFFSET, index);
}

futurevector_t get_propentry_futurevector(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned64bit_field(ptr, PROPTABLE_FORMAT_FUTUREVECTOR_MASK, PROPTABLE_FORMAT_FUTUREVECTOR_OFFSET);
}

void set_propentry_futurevector(proptable_entry_t *propentry, futurevector_t futurevector)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned64bit_field(ptr, PROPTABLE_FORMAT_FUTUREVECTOR_MASK, PROPTABLE_FORMAT_FUTUREVECTOR_OFFSET, futurevector);
}

int get_propentry_dtm(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    if (PROPTABLE_FORMAT_DTM_BITS > 0) {
	return get_signed_field(ptr, PROPTABLE_FORMAT_DTM_MASK, PROPTABLE_FORMAT_DTM_OFFSET);
    } else {
	return 0;
    }
}

void set_propentry_dtm(proptable_entry_t *propentry, int distance)
{
    uint32 *ptr = (uint32 *) propentry;
    if (PROPTABLE_FORMAT_DTM_BITS > 0) {
	set_signed_field(ptr, PROPTABLE_FORMAT_DTM_MASK, PROPTABLE_FORMAT_DTM_OFFSET, distance);
    }
}

int get_propentry_movecnt(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    return get_unsigned_field(ptr, PROPTABLE_FORMAT_MOVECNT_MASK, PROPTABLE_FORMAT_MOVECNT_OFFSET);
}

void set_propentry_movecnt(proptable_entry_t *propentry, int movecnt)
{
    uint32 *ptr = (uint32 *) propentry;
    set_unsigned_field(ptr, PROPTABLE_FORMAT_MOVECNT_MASK, PROPTABLE_FORMAT_MOVECNT_OFFSET, movecnt);
}

int get_propentry_PTM_wins_flag(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;

    /* This one is a little different.  A proptable can have either a PTM wins flag or a DTM field.
     * If the caller requests the PTM wins flag and it doesn't exist in this format, then use the
     * DTM field to "emulate" it.
     */

    if (PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET != -1) {
	return get_unsigned_field(ptr, 1, PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET);
    } else {
	return (get_propentry_dtm(ptr) > 0) ? 1 : 0;
    }
}

void set_propentry_PTM_wins_flag(proptable_entry_t *propentry, int PTM_wins_flag)
{
    uint32 *ptr = (uint32 *) propentry;
    if (PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET != -1) {
	set_unsigned_field(ptr, 1, PROPTABLE_FORMAT_PTM_WINS_FLAG_OFFSET, PTM_wins_flag);
    }
}

void insert_at_propentry(int propentry, proptable_entry_t * pentry)
{
#ifdef DEBUG_MOVE
    if (get_propentry_index(pentry) == DEBUG_MOVE)
	fprintf(stderr, "insert_at_propentry; index=%d; propentry=%d\n",
		get_propentry_index(pentry), propentry);
#endif

    memcpy(PROPTABLE_ELEM(propentry), pentry, PROPTABLE_FORMAT_BYTES);

    proptable_entries ++;

#ifdef DEBUG_MOVE
    if (get_propentry_index(pentry) == DEBUG_MOVE)
	fprintf(stderr, "Propentry: %llx %llx\n", *((uint64 *) pentry), *(((uint64 *) pentry) + 1));
#endif
}

void merge_at_propentry(int propentry, proptable_entry_t *src)
{
    uint32 *dest = (uint32 *) PROPTABLE_ELEM(propentry);
    int dest_dtm = get_propentry_dtm(dest);
    int src_dtm = get_propentry_dtm(src);

    proptable_merges ++;

#ifdef DEBUG_MOVE
    if (get_propentry_index(PROPTABLE_ELEM(propentry)) == DEBUG_MOVE)
	fprintf(stderr, "merge_at_propentry; index=%d; propentry=%d; src_dtm=%d\n",
		get_propentry_index(PROPTABLE_ELEM(propentry)), propentry, src_dtm);
#endif

    if (src_dtm > 0) {
	/* DTM > 0 - this move lets PTM mate from this position.  Update the proptable entry if
	 * either we don't have any PTM mates yet (table's dtm <= 0), or if this new mate is faster
	 * than the old one.
	 */
	if ((dest_dtm <= 0) || (src_dtm < dest_dtm)) {
	    set_propentry_dtm(dest, src_dtm);
	}
    } else if (src_dtm < 0) {
	/* DTM < 0 - this move lets PNTM mate from this position.  Update the proptable entry only
	 * if we don't have any PTM mates (table's dtm <= 0) and this PNTM mate is slower than the
	 * old one.
	 */
	if ((dest_dtm <= 0) && (src_dtm < dest_dtm)) {
	    set_propentry_dtm(dest, src_dtm);
	}
    }

    /* PTM wins flag is logical OR of the two flags being combined. */
    if (get_propentry_PTM_wins_flag(src) && (! get_propentry_PTM_wins_flag(dest))) {
	set_propentry_PTM_wins_flag(dest, 1);
    }

    set_propentry_movecnt(dest, get_propentry_movecnt(dest) + get_propentry_movecnt(src));

    if (get_propentry_futurevector(dest) & get_propentry_futurevector(src)) {
	global_position_t global;
	index_to_global_position(current_tb, get_propentry_index(PROPTABLE_ELEM(propentry)), &global);
	/* This might happen just because of symmetry issues */
#if 0
	fprintf(stderr, "Futuremoves multiply handled: %s\n", global_position_to_FEN(&global));
#endif
    }

    set_propentry_futurevector(dest, get_propentry_futurevector(dest) | get_propentry_futurevector(src));
}

void commit_proptable_entry(proptable_entry_t *propentry)
{
    uint32 *ptr = (uint32 *) propentry;
    index_t index = get_propentry_index(propentry);
    int dtm = get_propentry_dtm(ptr);
    uint8 PTM_wins_flag = get_propentry_PTM_wins_flag(ptr);
    int movecnt = get_propentry_movecnt(ptr);
    futurevector_t futurevector = get_propentry_futurevector(ptr);

    commit_entry(index, dtm, PTM_wins_flag, movecnt, futurevector);
}


int num_proptables = 0;
int proptable_output_fd = -1;

struct aiocb proptable_output_aiocb;
int proptable_write_in_progress = 0;

/* proptable_full() - dump out to disk and empty table
 *
 * If we're using dual proptables, then we switch to the empty table and start background async
 * operations to dump the full one out to disk, and then zero it out.
 */

void finalize_proptable_write(void)
{
    const struct aiocb * aiocbs[1];
    int ret;

    if (!proptable_write_in_progress) return;

    aiocbs[0] = &proptable_output_aiocb;
    aio_suspend(aiocbs, 1, NULL);

    ret = aio_return(&proptable_output_aiocb);

    if (ret != num_propentries * PROPTABLE_FORMAT_BYTES) {
	fprintf(stderr, "proptable aio_write returned %d, not PROPTABLE_BYTES\n", ret);
	kill(getpid(), SIGSTOP);
    }

    /* Whichever proptable is in use, we just finished writing the other one, so zero it out.
     * If we don't USE_DUAL_PROPTABLES, then proptable1 and proptable2 have the same value.
     */

    if (proptable == proptable1) memset(proptable2, 0, num_propentries * PROPTABLE_FORMAT_BYTES);
    else memset(proptable1, 0, num_propentries * PROPTABLE_FORMAT_BYTES);

    proptable_write_in_progress = 0;
}

void proptable_full(void)
{
    char outfilename[256];
    struct timeval tv1, tv2;

    if (proptable_entries == 0) return;

#if SEPERATE_PROPTABLE_FILES
    sprintf(outfilename, "propfile%04d_out", num_proptables);
#else
    sprintf(outfilename, "propfile_out");
#endif

    if (proptable_output_fd == -1) {
	proptable_output_fd = open(outfilename, O_WRONLY | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
    }
    if (proptable_output_fd == -1) {
	fatal("Can't open '%s' for writing propfile\n", outfilename);
	return;
    }

    /* XXX redo this by recording this data into an array and generating the XML when we're done */
#if 0
    xmlNodeAddContent(current_tb->current_pass_stats, BAD_CAST "\n      ");
    node = xmlNewChild(current_tb->current_pass_stats, NULL, BAD_CAST "proptable", NULL);
    sprintf(strbuf, "%d", proptable_entries);
    xmlNewProp(node, BAD_CAST "entries", BAD_CAST strbuf);
    sprintf(strbuf, "%d", proptable_merges);
    xmlNewProp(node, BAD_CAST "merges", BAD_CAST strbuf);
    sprintf(strbuf, "%d%%", (100*proptable_entries)/num_propentries);
    xmlNewProp(node, BAD_CAST "occupancy", BAD_CAST strbuf);
#endif

    fprintf(stderr, "Writing proptable block %d with %d entries (%d%% occupancy)\n",
	    num_proptables, proptable_entries, (100*proptable_entries)/num_propentries);

    /* If we USE_DUAL_PROPTABLES, and there was a write already running, make sure it's done. */
    finalize_proptable_write();

    gettimeofday(&tv1, NULL);

    /* Hitting a disk full condition is by no means out of the question here!
     *
     * And I haven't really dealt with that yet, so XXX.
     *
     * We do fire off an asynchronous write if we're using dual proptables.  That makes the most
     * sense if the output proptables are on their own disk; otherwise, it might more more sense to
     * break the write down into a series of smaller ones that we can scatter with the reads.
     */

    /* do_write(proptable_output_fd, proptable, num_propentries * sizeof(proptable_entry_t)); */

    memset(&proptable_output_aiocb, 0, sizeof(struct aiocb));
    proptable_output_aiocb.aio_fildes = proptable_output_fd;
    proptable_output_aiocb.aio_buf = proptable;
    proptable_output_aiocb.aio_nbytes = num_propentries * PROPTABLE_FORMAT_BYTES;
#if SEPERATE_PROPTABLE_FILES
    proptable_output_aiocb.aio_offset = 0;
#else
    proptable_output_aiocb.aio_offset = num_proptables * num_propentries * PROPTABLE_FORMAT_BYTES;
#endif
    proptable_output_aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;

    if (aio_write(& proptable_output_aiocb) != 0) {
	fprintf(stderr, "Can't enqueue aio_write for proptable\n");
	kill(getpid(), SIGSTOP);
    }

    proptable_write_in_progress = 1;

#if USE_DUAL_PROPTABLES
    if (proptable == proptable1) proptable = proptable2;
    else proptable = proptable1;
#else
    finalize_proptable_write();
#endif

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_write_time, &tv2);
    proptable_writes ++;

    num_proptables ++;
    proptable_entries = 0;
    proptable_merges = 0;

#if SEPERATE_PROPTABLE_FILES
    close(proptable_output_fd);
    proptable_output_fd = -1;
#endif
}

/* proptable_finalize()
 *
 * Start a new set of proptables and commit the old set into the entries array.
 */

/* fetch_next_propentry()
 *
 * proptable_buffer[propbuf(tablenum, buffernum)]
 *         a malloc'ed buffer of PROPTABLE_BUFFER_SIZE bytes
 * proptable_buffer_index[tablenum]
 *         the local (relative to buffer) entry number of the NEXT entry in the buffer to be read
 * proptable_input_fds[tablenum]
 *         file descriptor of this proptable
 * proptable_current_buffernum[tablenum]
 *         current buffernum (from 0 to BUFFERS_PER_PROPTABLE) for this table
 */

int *proptable_input_fds;
proptable_entry_t **proptable_buffer;
struct aiocb *proptable_aiocb;
int *proptable_buffer_index;
int *proptable_current_buffernum;

/* Proptable buffering settings.
 *
 * Based on a paper I read about disk throughput using Linux asynchronous I/O, 256 KB seems to be a
 * good target buffer size to shoot for.  Also, there's currently nothing in the code to deal with
 * the case where the buffers are so large relative to the proptable that the first set of AIO reads
 * more than completely consumes the proptable.  Since the smallest proptable we can specify (the -P
 * option) is 1 MB, and I'm currently using 4 BUFFERS_PER_PROPTABLE, 256 KB is also the largest
 * buffer size we can use with our smallest proptable size and not break the code.  Since
 * proptable_entry_t is currently hardwired at 16 bytes, 1<<14 (16 K) entries per buffer gives 256
 * KB buffers.
 *
 * Adjusting these numbers is actually quite tricky.  Make the buffers too small or too few, and
 * you'll be stalling because you've emptied your pipeline.  Make the buffers too big or too many,
 * and you'll stall because your pipeline is full of big, slow reads that you don't need yet.
 * Probably want to look at adjusting these things dynamically at some point; perhaps keep the
 * buffer size constant and adjust on the fly the number of buffers in the rings.
 *
 * I _assume_ that these numbers read full disk blocks on disk block multiples (otherwise the direct
 * I/O stuff will scream and fail).  I've also found out from the linux-kernel mailing list that
 * /sys/block/DEV/queue/max_sectors_kb gives the maximum size (in KB) of the kernel internal
 * requests.  My disk shows 128 KB there, so I've bumped 256 KB down to 128 KB.  (1<<13 entries)
 */

#define PROPTABLE_BUFFER_ENTRIES (1<<13)
#define PROPTABLE_BUFFER_BYTES (PROPTABLE_BUFFER_ENTRIES * PROPTABLE_FORMAT_BYTES)
#define BUFFERS_PER_PROPTABLE 4

#define propbuf(tablenum, buffernum) (((tablenum) * BUFFERS_PER_PROPTABLE) + buffernum)

#define current_propbuf(tablenum) propbuf(tablenum, proptable_current_buffernum[tablenum])

void fetch_next_propentry(int tablenum, proptable_entry_t *dest)
{
    const struct aiocb * aiocbs[1];
    uint32 offset;
    int ret;

    do {

	/* First, look for additional entries in the in-memory buffer.  Entries with zero
	 * index are empty slots and are skipped.
	 */

	while (proptable_buffer_index[tablenum] < PROPTABLE_BUFFER_ENTRIES) {

	    if (get_propentry_index(proptable_buffer[current_propbuf(tablenum)]
				    + PROPTABLE_FORMAT_BYTES * (proptable_buffer_index[tablenum])) != 0) {
		memcpy(dest,
		       proptable_buffer[current_propbuf(tablenum)]
		       + PROPTABLE_FORMAT_BYTES * (proptable_buffer_index[tablenum]),
		       PROPTABLE_FORMAT_BYTES);

		proptable_buffer_index[tablenum] ++;
		return;
	    }

	    proptable_buffer_index[tablenum] ++;
	}

	/* Finished with this buffer.  Issue a read request for what its next contents should be
	 * (unless we've reached EOF).
	 */

	/* I'm reading Donald Knuth's description of ring buffers in section 1.4.4 of AOCP (3ed).
	 * He uses three colors to illustrate the operation of these things - red (read not yet
	 * complete), green (read complete), and yellow (currently processing).  In our case, the
	 * buffers turn from red to green themselves and we can detect their color (by looking to
	 * see if their asynchronous read operation completed).  So we only need a single pointer,
	 * to the single yellow buffer.
	 */

	offset = proptable_aiocb[current_propbuf(tablenum)].aio_offset
	    + PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE;
	if (offset % (num_propentries * PROPTABLE_FORMAT_BYTES)
	    < PROPTABLE_BUFFER_BYTES * BUFFERS_PER_PROPTABLE) offset = 0;

	memset(&proptable_aiocb[current_propbuf(tablenum)], 0, sizeof(struct aiocb));
	proptable_aiocb[current_propbuf(tablenum)].aio_fildes = proptable_input_fds[tablenum];
	proptable_aiocb[current_propbuf(tablenum)].aio_buf = proptable_buffer[current_propbuf(tablenum)];
	proptable_aiocb[current_propbuf(tablenum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	proptable_aiocb[current_propbuf(tablenum)].aio_sigevent.sigev_notify = SIGEV_NONE;
	proptable_aiocb[current_propbuf(tablenum)].aio_offset = offset;

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    if (aio_read(& proptable_aiocb[current_propbuf(tablenum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }

	}

	/* On to the next buffer. */

	proptable_current_buffernum[tablenum] ++;
	proptable_current_buffernum[tablenum] %= BUFFERS_PER_PROPTABLE;

	/* Wait for it to finish its disk read, if necessary */

	if (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0) {

	    ret = aio_error(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret == EINPROGRESS) {
		struct timeval tv1, tv2;
		gettimeofday(&tv1, NULL);

		/* fprintf(stderr, "Waiting for proptable buffer read to complete\n"); */
		aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
		aio_suspend(aiocbs, 1, NULL);

		gettimeofday(&tv2, NULL);
		subtract_timeval(&tv2, &tv1);
		add_timeval(&proptable_read_stall_time, &tv2);
		proptable_read_stalls ++;
	    } else if (ret != 0) {
		fprintf(stderr, "Error return %d from proptable aio_read\n", ret);
	    }

	    ret = aio_return(&proptable_aiocb[current_propbuf(tablenum)]);

	    if (ret != PROPTABLE_BUFFER_BYTES) {
		fprintf(stderr, "proptable aio_read returned %d, not PROPTABLE_BUFFER_BYTES\n", ret);
		kill(getpid(), SIGSTOP);
	    }
	}

	/* Start at the beginning of the buffer, and keep looking */

	proptable_buffer_index[tablenum] = 0;

    } while (proptable_aiocb[current_propbuf(tablenum)].aio_offset != 0);

    /* No, we're really at the end! */

    /* XXX could be a problem if max_index + 1 won't fit in the index element */
    set_propentry_index(dest, current_tb->max_index + 1);
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index);
void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector);

void proptable_finalize(int target_dtm)
{
    int i;
    int tablenum, bufnum;
    int num_input_proptables;
    struct timeval tv1, tv2;

    void *sorting_network;
    int *proptable_num;
    int highbit;
    int network_node;

#if SEPERATE_PROPTABLE_FILES
    char infilename[256];
    char outfilename[256];
#else
    int proptable_input_fd;
#endif

#define SORTING_NETWORK_ELEM(n)  (sorting_network + PROPTABLE_FORMAT_BYTES * (n))

    index_t index;

    /* Flush out anything in the last proptable, and wait for its write to complete */
    proptable_full();
    finalize_proptable_write();

    num_input_proptables = num_proptables;

    if (proptable_output_fd != -1) {
	close(proptable_output_fd);
	proptable_output_fd = -1;
    }

    num_proptables = 0;

    for (highbit = 1; highbit <= num_input_proptables; highbit <<= 1);

    proptable_buffer = (proptable_entry_t **)
	malloc(BUFFERS_PER_PROPTABLE * num_input_proptables * PROPTABLE_FORMAT_BYTES);
    proptable_aiocb = (struct aiocb *)
	calloc(BUFFERS_PER_PROPTABLE * num_input_proptables, sizeof(struct aiocb));
    proptable_buffer_index = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_current_buffernum = (int *) calloc(num_input_proptables, sizeof(int));
    proptable_input_fds = (int *) calloc(num_input_proptables, sizeof(int));

    if ((proptable_buffer == NULL) || (proptable_input_fds == NULL)
	|| (proptable_buffer_index == NULL)) {
	fprintf(stderr, "Can't malloc proptable buffers in proptable_finalize()\n");
	return;
    }

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	rename("propfile_out", "propfile_in");
	proptable_input_fd = open("propfile_in", O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fd == -1) {
	    fatal("Can't open 'propfile_in' for reading propfile\n");
	    return;
	}
    }
#endif

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
#if SEPERATE_PROPTABLE_FILES
	sprintf(infilename, "propfile%04d_in", tablenum);
	sprintf(outfilename, "propfile%04d_out", tablenum);
	rename(outfilename, infilename);
	proptable_input_fds[tablenum] = open(infilename, O_RDONLY | O_LARGEFILE | O_DIRECT);
	if (proptable_input_fds[tablenum] == -1) {
	    fatal("Can't open '%s' for reading propfile\n", infilename);
	    return;
	}
#else
	proptable_input_fds[tablenum] = proptable_input_fd;
#endif
    }

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	int alignment = fpathconf(proptable_input_fds[tablenum], _PC_REC_XFER_ALIGN);

	for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	    if (posix_memalign((void **) &proptable_buffer[propbuf(tablenum, bufnum)],
			       alignment, PROPTABLE_BUFFER_BYTES) != 0) {
		fatal("Can't posix_memalign proptable buffer\n");
		return;
	    }
	}
    }

    /* I run this loop in the opposite direction from the last one because I want the reads
     * for the initial buffers for all the tables to be first in the queue.
     */

    for (bufnum = 0; bufnum < BUFFERS_PER_PROPTABLE; bufnum ++) {
	for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_fildes = proptable_input_fds[tablenum];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_buf = proptable_buffer[propbuf(tablenum, bufnum)];
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_nbytes = PROPTABLE_BUFFER_BYTES;
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_sigevent.sigev_notify = SIGEV_NONE;
#if SEPERATE_PROPTABLE_FILES
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset = PROPTABLE_BUFFER_BYTES * bufnum;
#else
	    proptable_aiocb[propbuf(tablenum, bufnum)].aio_offset
		= tablenum * num_propentries * PROPTABLE_FORMAT_BYTES + PROPTABLE_BUFFER_BYTES * bufnum;
#endif

	    if (aio_read(& proptable_aiocb[propbuf(tablenum, bufnum)]) != 0) {
		fprintf(stderr, "Can't enqueue aio_read for proptable\n");
		kill(getpid(), SIGSTOP);
	    }
	}
    }

    /* Wait for initial read to finish on each input proptable */

    gettimeofday(&tv1, NULL);

    for (tablenum = 0; tablenum < num_input_proptables; tablenum ++) {
	const struct aiocb * aiocbs[1];
	aiocbs[0] = &proptable_aiocb[current_propbuf(tablenum)];
	aio_suspend(aiocbs, 1, NULL);
    }

    gettimeofday(&tv2, NULL);
    subtract_timeval(&tv2, &tv1);
    add_timeval(&proptable_preload_time, &tv2);

    sorting_network = malloc(2*highbit * PROPTABLE_FORMAT_BYTES);
    proptable_num = malloc(2*highbit * sizeof(int));

    if ((sorting_network == NULL) || (proptable_num == NULL)) {
	fatal("Can't malloc sorting network in proptable_finalize()\n");
	return;
    }

    /* Initialize the sorting network.
     *
     * First, fill in the upper half of the network with either the first entry from a proptable,
     * or an "infinite" entry for slots with no proptables.  Then, sort into the lower half
     * of the network.
     */

    for (i = 0; i < highbit; i ++) {
	if (i < num_input_proptables) {
	    fetch_next_propentry(i, SORTING_NETWORK_ELEM(highbit + i));
	    proptable_num[highbit + i] = i;
	} else {
	    /* XXX could be a problem if max_index + 1 won't fit in the index element */
	    set_propentry_index(SORTING_NETWORK_ELEM(highbit + i), current_tb->max_index + 1);
	    proptable_num[highbit + i] = -1;
	}
    }

    for (network_node = highbit-1; network_node > 0; network_node --) {
	if (get_propentry_index(SORTING_NETWORK_ELEM(2*network_node))
	    < get_propentry_index(SORTING_NETWORK_ELEM(2*network_node + 1))) {
	    memcpy(SORTING_NETWORK_ELEM(network_node),
		   SORTING_NETWORK_ELEM(2*network_node), PROPTABLE_FORMAT_BYTES);
	    proptable_num[network_node] = proptable_num[2*network_node];
	} else {
	    memcpy(SORTING_NETWORK_ELEM(network_node),
		   SORTING_NETWORK_ELEM(2*network_node + 1), PROPTABLE_FORMAT_BYTES);
	    proptable_num[network_node] = proptable_num[2*network_node+1];
	}
    }

    /* Now, process the data through the sorting network. */

    for (index = 0; index <= current_tb->max_index; index ++) {

	futurevector_t futurevector = 0;
	futurevector_t possible_futuremoves;

	if (get_propentry_index(SORTING_NETWORK_ELEM(1)) < index) {
	    fatal("Out-of-order entries in sorting network\n");
	}

	if (target_dtm == 0) {
	    possible_futuremoves = initialize_tablebase_entry(current_tb, index);
	}

	while (get_propentry_index(SORTING_NETWORK_ELEM(1)) == index ) {

#ifdef DEBUG_MOVE
	    if (index == DEBUG_MOVE)
		fprintf(stderr, "Commiting sorting element 1: %llx %llx\n",
			*((uint64 *) SORTING_NETWORK_ELEM(1)), *(((uint64 *) SORTING_NETWORK_ELEM(1)) + 1));
#endif

	    commit_proptable_entry(SORTING_NETWORK_ELEM(1));

	    if (get_propentry_futurevector(SORTING_NETWORK_ELEM(1)) & futurevector) {
		global_position_t global;
		index_to_global_position(current_tb, get_propentry_index(SORTING_NETWORK_ELEM(1)), &global);
		fatal("Futuremoves multiply handled: %s\n", global_position_to_FEN(&global));
	    }

	    futurevector |= get_propentry_futurevector(SORTING_NETWORK_ELEM(1));

	    fetch_next_propentry(proptable_num[1], SORTING_NETWORK_ELEM(highbit + proptable_num[1]));

	    network_node = highbit + proptable_num[1];

	    while (network_node > 1) {
		network_node >>= 1;
		if (get_propentry_index(SORTING_NETWORK_ELEM(2*network_node))
		    < get_propentry_index(SORTING_NETWORK_ELEM(2*network_node+1))) {
		    memcpy(SORTING_NETWORK_ELEM(network_node),
			   SORTING_NETWORK_ELEM(2*network_node), PROPTABLE_FORMAT_BYTES);
		    proptable_num[network_node] = proptable_num[2*network_node];
		} else {
		    memcpy(SORTING_NETWORK_ELEM(network_node),
			   SORTING_NETWORK_ELEM(2*network_node + 1), PROPTABLE_FORMAT_BYTES);
		    proptable_num[network_node] = proptable_num[2*network_node+1];
		}
	    }
	}

	/* Don't track futuremoves for illegal (DTM 1) positions */

	if ((target_dtm == 0) && (get_entry_DTM(index) != 1)) {

	    if ((futurevector & possible_futuremoves) != futurevector) {
		/* Commented out because if we're not using DTM this code will run for illegal positions */
#if 0
		global_position_t global;
		index_to_global_position(current_tb, index, &global);
		fprintf(stderr, "Futuremove discrepancy: %d %s\n", index, global_position_to_FEN(&global)); /* BREAKPOINT */
#endif
	    } else {
		finalize_futuremove(current_tb, index, possible_futuremoves ^ futurevector);
	    }
	}

	if (target_dtm != 0) back_propagate_index(index, target_dtm);

    }

    for (i = 0; i < num_input_proptables * BUFFERS_PER_PROPTABLE; i ++) {
	free(proptable_buffer[i]);
    }

    free(proptable_buffer_index);
    free(proptable_buffer);
    free(proptable_input_fds);

    free(sorting_network);
    free(proptable_num);

#if !SEPERATE_PROPTABLE_FILES
    if (num_input_proptables > 0) {
	close(proptable_input_fd);
	unlink("propfile_in");
    }
#else
    for (i = 0; i < num_input_proptables; i ++) {
	close(proptable_input_fds[i]);
	sprintf(infilename, "propfile%04d_in", i);
	unlink(infilename);
    }
#endif

    /* Flush out anything in the last proptable, and wait for its write to complete */
    proptable_full();
    finalize_proptable_write();
}

void insert_into_proptable(proptable_entry_t *pentry)
{
    int propentry;
    int zerooffset;
    index_t index = get_propentry_index(pentry);
    static int scaling_factor = 0;

    /* I had a bug here with the scaling_factor rounding down - that's why we increment by one */

    if (scaling_factor == 0) {
	scaling_factor = current_tb->max_index / num_propentries;
	scaling_factor ++;
	info("Scaling factor %d\n", scaling_factor);
    }

 retry:

    /* We need an index into the proptable that maintains the index sort order of the entries. */

    propentry = index / scaling_factor;

    if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	/* empty slot: insert at propentry */
	/* proptable[propentry] = entry; */
	insert_at_propentry(propentry, pentry);
	return;
    } else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	/* entry at slot with identical index: merge at propentry */
	/* proptable[propentry] += entry; */
	merge_at_propentry(propentry, pentry);
	return;
    } else if (get_propentry_index(PROPTABLE_ELEM(propentry)) > index) {
	/* entry at slot greater than index to be inserted */
	while ((get_propentry_index(PROPTABLE_ELEM(propentry)) > index) && (propentry > 0)) propentry --;
	if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	    /* empty slot at lower end of a block all gt than index: insert there */
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	    /* identical slot in a block: merge there */
	    /* proptable[propentry] += entry; */
	    merge_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) > index) {
	    /* we're at the beginning of the table and the first entry is gt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (get_propentry_index(PROPTABLE_ELEM(zerooffset)) == 0) {
		    /* proptable[1:zerooffset] = proptable[0:zerooffset-1]; */
		    memmove(proptable + PROPTABLE_FORMAT_BYTES, proptable,
			    (zerooffset) * PROPTABLE_FORMAT_BYTES);
		    /* proptable[0] = entry; */
		    insert_at_propentry(0, pentry);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* still in the block; propentry is lt index and propentry+1 is gt index: fall through */
	}
    } else {
	/* entry at slot less than index to be inserted */
	while ((get_propentry_index(PROPTABLE_ELEM(propentry)) != 0)
	       && (get_propentry_index(PROPTABLE_ELEM(propentry)) < index)
	       && (propentry < num_propentries - 1)) propentry ++;
	if (get_propentry_index(PROPTABLE_ELEM(propentry)) == 0) {
	    /* empty slot at upper end of a block all lt than index: insert there */
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) == index) {
	    /* identical slot in a block: merge there */
	    /* proptable[propentry] += entry; */
	    merge_at_propentry(propentry, pentry);
	    return;
	} else if (get_propentry_index(PROPTABLE_ELEM(propentry)) < index) {
	    /* we're at the end of the table and the last entry is lt index */
	    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
		if (get_propentry_index(PROPTABLE_ELEM(num_propentries - 1 - zerooffset)) == 0) {
		    /* proptable[num_propentries-zerooffset-1 : num_propentrys-2]
		     *    = proptable[num_propentries-zerooffset : num_propentries-1];
		     */
		    memmove(proptable + (num_propentries - 1 - zerooffset) * PROPTABLE_FORMAT_BYTES,
			    proptable + (num_propentries - zerooffset) * PROPTABLE_FORMAT_BYTES,
			    (zerooffset) * PROPTABLE_FORMAT_BYTES);
		    /* proptable[num_propentries-1] = entry; */
		    insert_at_propentry(num_propentries - 1, pentry);
		    return;
		}
	    }
	    /* ran out of space - table is "full" */
	    proptable_full();
	    goto retry;
	} else {
	    /* propentry is gt index and propentry-1 is lt index */
	    propentry --;
	}
    }

    /* We found a boundary within a block: propentry is lt index and propentry+1 is gt index */

    for (zerooffset = 1; zerooffset <= MAX_ZEROOFFSET; zerooffset ++) {
	if ((propentry + zerooffset < num_propentries - 1)
	    && (get_propentry_index(PROPTABLE_ELEM(propentry+zerooffset)) == 0)) {
	    /* proptable[propentry+2 : propentry+zerooffset]
	     *    = proptable[propentry+1 : propentry+zerooffset-1];
	     */
	    memmove(proptable + PROPTABLE_FORMAT_BYTES * (propentry + 2),
		    proptable + PROPTABLE_FORMAT_BYTES * (propentry + 1),
		    (zerooffset-1) * PROPTABLE_FORMAT_BYTES);
	    /* proptable[propentry+1] = entry; */
	    insert_at_propentry(propentry+1, pentry);
	    return;
	}
	if ((propentry - zerooffset >= 0)
	    && (get_propentry_index(PROPTABLE_ELEM(propentry-zerooffset)) == 0)) {
	    /* proptable[propentry-zerooffset : propentry-1]
	     *    = proptable[propentry-zerooffset+1 : propentry];
	     */
	    memmove(proptable + PROPTABLE_FORMAT_BYTES * (propentry - zerooffset),
		    proptable + PROPTABLE_FORMAT_BYTES * (propentry - zerooffset + 1),
		    zerooffset * PROPTABLE_FORMAT_BYTES);
	    /* proptable[propentry] = entry; */
	    insert_at_propentry(propentry, pentry);
	    return;
	}
    }

    /* zerooffset > MAX_ZEROOFFSET: ran of space - table is "full" */
    proptable_full();
    goto retry;
}

#endif /* USE_PROPTABLES */

void insert_or_commit_propentry(index_t index, short dtm, short movecnt,
				futurevector_t futurevector)
{
    uint8 PTM_wins_flag;
#if USE_PROPTABLES
    char entry[MAX_FORMAT_BYTES];
    void *ptr = entry;
#endif

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	printf("insert_or_commit_proptable; index=%d; dtm=%d; movecnt=%d; futurevector=0x%llx\n",
	       index, dtm, movecnt, futurevector);
#endif

    /* The only time it makes sense to use a PTM-wins-flag in the proptable is if we're generating a
     * bitbase (because otherwise we need a DTM field in the proptable).  Positive or negative DTM
     * values translate directly through to PTM wins or to its inverse, PNTM wins.  The oddball is
     * zero DTM, a draw, which only happens here if we're back propagating from a DTM futurebase.
     * In that case, we need to look at the sense of the bitbase (white-wins or white-draws), as
     * well as which player is PTM to decide if we should set or clear the propentry's flag.
     */

    if (dtm != 0) {
	PTM_wins_flag = (dtm > 0) ? 1 : 0;
    } else {
	int win_side = ((current_tb->format.flag_type == FORMAT_FLAG_WHITE_WINS) ? WHITE : BLACK);
	PTM_wins_flag = (index_to_side_to_move(current_tb, index) == win_side) ? 0 : 1;
    }

    backproped_moves[total_passes] ++;

#if !USE_PROPTABLES

    commit_entry(index, dtm, PTM_wins_flag, movecnt, futurevector);

#else


    memset(ptr, 0, PROPTABLE_FORMAT_BYTES);

    set_propentry_index(ptr, index);
    set_propentry_dtm(ptr, dtm);
    set_propentry_movecnt(ptr, movecnt);
    set_propentry_futurevector(ptr, futurevector);

    set_propentry_PTM_wins_flag(ptr, PTM_wins_flag);

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	fprintf(stderr, "Propentry: %llx %llx\n", *((uint64 *) ptr), *(((uint64 *) ptr) + 1));
#endif

    insert_into_proptable(ptr);

#endif

}


/* target_dtm == 0 is special because the initialization / futurebase back prop pass
 *
 */

int propagation_pass(int target_dtm)
{
    index_t index;

    if (((target_dtm > 0) && (target_dtm > (ENTRIES_FORMAT_DTM_MASK >> 1)))
	|| ((target_dtm < 0) && (target_dtm < -(ENTRIES_FORMAT_DTM_MASK >> 1)))) {
	fatal("DTM entry field size exceeded\n");
	terminate();
    }

    gettimeofday(&pass_start_times[total_passes], NULL);
    if (pass_type[total_passes] == NULL) pass_type[total_passes] = "intratable";
    pass_target_dtms[total_passes] = target_dtm;

#if USE_PROPTABLES
    proptable_finalize(target_dtm);
#else
    for (index = 0; index <= current_tb->max_index; index ++) {
	back_propagate_index(index, target_dtm);
    }
#endif

    gettimeofday(&pass_end_times[total_passes], NULL);

    total_backproped_moves += backproped_moves[total_passes];

    if (positions_finalized[total_passes] > 0) {
	if (target_dtm > max_dtm) max_dtm = target_dtm;
	if (target_dtm < min_dtm) min_dtm = target_dtm;
    }

    info("Pass %3d complete; %d positions finalized\n", target_dtm, positions_finalized[total_passes]);

    total_passes ++;

    return positions_finalized[total_passes-1];
}

/***** FUTUREBASES *****/

/* Subroutines to backpropagate an individual index, or an individual local position (these are the
 * "mini" routines), or a set of local positions that differ only in the en passant square.
 *
 * The idea behind the en passant handling is this.  If we back propagate a position with the en
 * passant square set, then that's the only position we process.  If we back prop a position without
 * the en passant square set, then we process not only that position, but also any positions just
 * like it that have en passant set.  The idea being that we set en passant if we actually need it,
 * and we clear it if we don't need it, so if it's clear we need to process positions where it was
 * set, but we didn't use it.
 */

void propagate_index_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
				     short movecnt, int futuremove, index_t current_index)
{
    if (futuremove == -1) {
	global_position_t global;

	index_to_global_position(tb, current_index, &global);
	fatal("Futuremove never assigned: %s %s\n", global_position_to_FEN(&global),
	      movestr[global.side_to_move][futuremove]);

	return;
    }

#ifdef DEBUG_FUTUREMOVE
    if (future_index == DEBUG_FUTUREMOVE) {
	info("futurebase backprop; current_index=%d\n", current_index);
    }
#endif

    /* We insert even if dtm is zero because we have to track futuremoves */

    if (futurebase->format.dtm_bits > 0) {

	int dtm = get_raw_DTM(futurebase, future_index);

	if (dtm > 0) {
	    insert_or_commit_propentry(current_index, -dtm, movecnt, FUTUREVECTOR(futuremove));
	} else if (dtm < 0) {
	    insert_or_commit_propentry(current_index, -dtm+1, movecnt, FUTUREVECTOR(futuremove));
	} else {
	    insert_or_commit_propentry(current_index, 0, movecnt, FUTUREVECTOR(futuremove));
	}

    } else {

	boolean flag = get_flag(futurebase, future_index);
	int stm = index_to_side_to_move(futurebase, future_index);

	/* What happens if we're back propagating a flag from a color-inverted futurebase?
	 *
	 * Well, first of all, a "white-wins" flag in an inverted futurebase becomes a "black-wins"
	 * flag here, which is basically a "NOT white-draws" flag, so we have to be careful to
	 * backprop from draw flags to win flags and from win flags to draw flags if the colors have
	 * been inverted.  Other than that, since the side to move we just fetched is in the
	 * futurebase, the white/black sense of the flag matches with it, so we don't need to invert
	 * anything to figure out if this is a PTM win or a PNTM win.
	 */

	/* I use twos here because there's a lot of stuff that gets cut out for the special case of 1 */

	if ((flag && (stm == WHITE)) || (!flag && (stm == BLACK))) {
	    insert_or_commit_propentry(current_index, -2, movecnt, FUTUREVECTOR(futuremove));
	} else {
	    insert_or_commit_propentry(current_index, 2, movecnt, FUTUREVECTOR(futuremove));
	}

    }
}

void propagate_minilocal_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_local_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_minilocal_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

void propagate_mini_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
						  int futuremove, local_position_t *current_position)
{
    index_t current_index;

    /* Look up the position in the current tablebase... */

    current_index = normalized_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup local position in futurebase propagation!\n");
#endif
	return;
    }

    /* local_position_to_index() updated the position structure's multiplicity, so we know it's
     * correct.  It actually should be a little more complex than this, but since we're only dealing
     * with 8-way symmetry where multiplicity is either 1 or 2, this should do.  If we're
     * backproping from a single multiplicity position into one with double multiplicity, then this
     * function will get called twice on the same index, because that index will get generated
     * twice during back prop from the single future position, but since we're using the futuremove
     * number to toss out additional function calls, we can safely just use the multiplicity here
     * without worrying about it getting called again.
     */

    propagate_index_from_futurebase(tb, futurebase, future_index, current_position->multiplicity,
				    futuremove, current_index);
}

void propagate_normalized_position_from_futurebase(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
					      int futuremove, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I took care in the calling routines to update board_vector specifically so we can
	     * check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_mini_normalized_position_from_futurebase(tb, futurebase, future_index, futuremove, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* Reflections.
 *
 * If the futurebase has greater symmetry than the tablebase under construction, then we have to
 * apply a series of reflections to each futurebase position in order to get all the corresponding
 * positions in the current tablebase.  This utility function computes them.
 *
 * If we're back propagating from a futurebase with greater symmetry, then a single futurebase index
 * will correspond to several positions in the current tablebase.  We'll need to apply some
 * reflections to get those additional positions, so compute here how many of them we'll need.  It's
 * a fairly easy calculation, since our symmetry options are currently limited to 1/2/4/8, so a
 * simple ratio suffices, except if both tablebases have symmetry 8, in which case the more complex
 * effects of diagonal symmetry require a double conversion no matter what.
 */


int compute_reflections(tablebase_t *tb, tablebase_t *futurebase, int *reflections)
{
    int max_reflection;

    max_reflection = futurebase->symmetry / tb->symmetry;
    if ((futurebase->symmetry == 8) && (tb->symmetry == 8)) max_reflection = 2;

    reflections[0] = REFLECTION_NONE;
    if (futurebase->symmetry == 8) reflections[1] = REFLECTION_DIAGONAL;
    if (futurebase->symmetry == 4) reflections[1] = REFLECTION_VERTICAL;
    if (futurebase->symmetry == 2) reflections[1] = REFLECTION_HORIZONTAL;
    if (max_reflection >= 4) {
	if (futurebase->symmetry == 8) {
	    /* This is either the 8 -> 2 or 8 -> 1 cases */
	    reflections[2] = reflections[0] | REFLECTION_VERTICAL;
	    reflections[3] = reflections[1] | REFLECTION_VERTICAL;
	} else {
	    /* This is the 4 -> 1 case */
	    reflections[2] = reflections[0] | REFLECTION_HORIZONTAL;
	    reflections[3] = reflections[1] | REFLECTION_HORIZONTAL;
	}
    }
    if (max_reflection == 8) {
	/* The 8 -> 1 case */
	reflections[4] = reflections[0] | REFLECTION_HORIZONTAL;
	reflections[5] = reflections[1] | REFLECTION_HORIZONTAL;
	reflections[6] = reflections[2] | REFLECTION_HORIZONTAL;
	reflections[7] = reflections[3] | REFLECTION_HORIZONTAL;
    }

    return max_reflection;
}



/* Back propagate promotion moves
 *
 * Passed a piece (a global position character) that the pawn is promoting into.  Searches
 * futurebase for positions with that piece on the last rank and back-props.
 */

void propagate_moves_from_promotion_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					       int invert_colors_of_futurebase,
					       int pawn)
{
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece2;
    int true_pawn;
    int reflection;
    int max_reflection;
    int reflections[8];

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    max_reflection = compute_reflections(tb, futurebase, reflections);

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position (the pawn that
	     * promoted) and one piece extra (what it promoted into).  There can be no pieces on
	     * restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, reflection[reflections],
					  &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		pawn = conversion_result & 0xff;                      /* missing_piece1 */
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece == NONE) || (pawn == NONE) || (missing_piece2 != NONE)) {
		    fatal("Conversion error during promotion back-prop\n");
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != -1) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical pieces.
		 * Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.  If we've got
		 * a futurebase position with both queens on the back rank, then we have to consider the
		 * possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.  We can safely 'break' here due
		     * to identical pieces being sorted into ascending square number.  If we've
		     * backed up to an extra piece that isn't on the back rank, then there can't be
		     * any more identical pieces on the back rank.
		     */

		    if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
			break;

		    /* There has to be an empty square right behind where the pawn came from, and it
		     * has to be at least semilegal for the pawn.
		     */

		    if (!(position.board_vector & BITVECTOR(promotion_sq - promotion_move))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move;

			/* Normalize the position, and back prop it. */

			normalize_position(tb, &position);

			true_pawn = position.permuted_piece[pawn];

			/* If the futurebase prunes stalemates to be victories for the queening
			 * color, then a queen is as good as a rook or a bishop.
			 */

			if ((futurebase->stalemate_prune_type == RESTRICTION_CONCEDE)
			    && (futurebase->stalemate_prune_color == tb->piece_color[pawn])
			    && (! futurebase->invert_colors)
			    && futurebase->piece_type[extra_piece] == QUEEN) {

			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotions[true_pawn]
									  + QUEEN - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotions[true_pawn]
									  + ROOK - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotions[true_pawn]
									  + BISHOP - 1,
									  &position);

			} else {
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotions[true_pawn]
									  + futurebase->piece_type[extra_piece] - 1,
									  &position);
			}

			/* We may be about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &=~ BITVECTOR(position.piece_position[pawn]);
		    }

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == tb->num_pieces) {
			    fatal("Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }
}

void propagate_moves_from_promotion_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
						       int invert_colors_of_futurebase,
						       int pawn)
{
    index_t future_index;
    local_position_t foreign_position;
    local_position_t position;
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int true_captured_piece;
    int true_pawn;
    int reflection;
    int max_reflection;
    int reflections[8];

    int promotion_color = tb->piece_color[pawn];
    int first_back_rank_square = ((promotion_color == WHITE) ? 56 : 0);
    int last_back_rank_square = ((promotion_color == WHITE) ? 63 : 7);
    int promotion_move = ((promotion_color == WHITE) ? 8 : -8);

    max_reflection = compute_reflections(tb, futurebase, reflections);

    /* We could limit the range of future_index here */

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be two pieces missing from the local position (the pawn that
	     * promoted and the piece it captured) and one piece extra (what it promoted into).
	     * There can be no pieces on restricted squares.
	     */

	    if (! index_to_local_position(futurebase, future_index, reflections[reflection],
					  &foreign_position)) continue;

	    conversion_result = translate_foreign_position_to_local_position(futurebase, &foreign_position,
									     tb, &position,
									     invert_colors_of_futurebase);

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		missing_piece1 = conversion_result & 0xff;
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece == NONE) || (missing_piece1 != pawn) || (missing_piece2 == NONE)) {
		    fatal("Conversion error during promotion capture back-prop\n");
		    continue;
		}

		/* This can happen if the futurebase is more liberal than the current tablebase. */

		if (restricted_piece != NONE) continue;

		/* Since the last move had to have been a promotion move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != -1) continue;

		/* Whatever color the promoted piece is, after the promotion it must be the other
		 * side to move.
		 */

		if (position.side_to_move == promotion_color) continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		/* We need an extra loop in here to handle futurebases with multiple identical
		 * pieces.  Let's say we're back propagating from a Q+Q endgame into a Q+P endgame.
		 * If we've got a futurebase position with both queens on the back rank, then we
		 * have to consider the possibility that the pawn could promote into either of them.
		 *
		 * Move restrictions can really mess with this, but right now we don't compute
		 * tablebases with non-identical overlapping move restrictions on otherwise
		 * identical pieces, and with that caveat we're OK.  If the move restrictions don't
		 * overlap, then there's no way the pieces can swap with each other.  And if the
		 * move restrictions are identical, then that will be noted in the
		 * last_identical_piece array that we use below.
		 */

		do {

		    int promotion_sq = foreign_position.piece_position[extra_piece];

		    if (invert_colors_of_futurebase)
			promotion_sq = rowcol2square(7 - ROW(promotion_sq), COL(promotion_sq));

		    /* The extra piece has to be on the back rank.  We can safely 'break' here due
		     * to identical pieces being sorted into ascending square number.  If we've
		     * backed up to an extra piece that isn't on the back rank, then there can't be
		     * any more identical pieces on the back rank.
		     */


		    if ((promotion_sq < first_back_rank_square) || (promotion_sq > last_back_rank_square))
			break;

		    /* Put the piece that was captured onto the board on the promotion square. */

		    position.piece_position[missing_piece2] = promotion_sq;

		    /* Consider first a capture to the left (white's left).  There has to be an
		     * empty square where the pawn came from, and it has to be at least semilegal.
		     */

		    if ((COL(promotion_sq) != 0)
			&& !(position.board_vector & BITVECTOR(promotion_sq - promotion_move - 1))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move - 1))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move - 1;

			/* Back propagate the resulting position */

			normalize_position(tb, &position);

			true_captured_piece = position.permuted_piece[missing_piece2];
			true_pawn = position.permuted_piece[pawn];

			/* This function also back props any similar positions with one of the pawns
			 * from the side that didn't promote in an en passant state.
			 */

			if ((futurebase->stalemate_prune_type == RESTRICTION_CONCEDE)
			    && (futurebase->stalemate_prune_color == tb->piece_color[pawn])
			    && (! futurebase->invert_colors)
			    && futurebase->piece_type[extra_piece] == QUEEN) {

			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + QUEEN - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + ROOK - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + BISHOP - 1,
									  &position);

			} else {
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
									  &position);
			}

			/* We're about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		    }

		    /* Now consider a capture to the right (white's right).  Again, there has to be
		     * an empty square where the pawn came from, and it has to be semilegal.
		     */

		    if ((COL(promotion_sq) != 7)
			&& !(position.board_vector & BITVECTOR(promotion_sq - promotion_move + 1))
			&& (tb->semilegal_squares[pawn] & BITVECTOR(promotion_sq - promotion_move + 1))) {

			/* Because the promoted piece was 'extra' it doesn't appear in the local
			 * position, so we don't have to worry about taking it off the board.  Put
			 * the missing pawn on the seventh (or second).
			 */

			position.piece_position[pawn] = promotion_sq - promotion_move + 1;

			normalize_position(tb, &position);

			true_captured_piece = position.permuted_piece[missing_piece2];
			true_pawn = position.permuted_piece[pawn];

			if ((futurebase->stalemate_prune_type == RESTRICTION_CONCEDE)
			    && (futurebase->stalemate_prune_color == tb->piece_color[pawn])
			    && (! futurebase->invert_colors)
			    && futurebase->piece_type[extra_piece] == QUEEN) {

			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + QUEEN - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + ROOK - 1,
									  &position);
			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + BISHOP - 1,
									  &position);

			} else {

			    propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
									  promotion_captures[true_pawn][true_captured_piece] + futurebase->piece_type[extra_piece] - 1,
									  &position);
			}

			/* We're about to use this position again, so put the board_vector back... */

			denormalize_position(tb, &position);
			position.board_vector &= ~BITVECTOR(position.piece_position[pawn]);
		    }

		    /* Remove the piece from the promotion square, at least in board_vector.  We'll
		     * change its position next time around this do/while loop, if there's another
		     * possibility for the "extra" piece.
		     */

		    position.board_vector &= ~BITVECTOR(promotion_sq);

		    /* If there's an piece identical to the extra piece in the futurebase's
		     * position, then figure out which of our pieces it was mapped to, swap them,
		     * and try again.
		     */

		    if (futurebase->last_identical_piece[extra_piece] != -1) {

			int piece;

			int new_promotion_sq
			    = foreign_position.piece_position[futurebase->last_identical_piece[extra_piece]];

			if (invert_colors_of_futurebase)
			    new_promotion_sq = rowcol2square(7 - ROW(new_promotion_sq), COL(new_promotion_sq));

			for (piece = 0; piece < tb->num_pieces; piece ++) {
			    if (position.piece_position[piece] == new_promotion_sq) {
				position.piece_position[piece] = promotion_sq;
				break;
			    }
			}

			if (piece == tb->num_pieces) {
			    fatal("Couldn't back up to an identical piece in promotion back prop\n");
			    break;
			}
		    }

		    extra_piece = futurebase->last_identical_piece[extra_piece];

		} while (extra_piece != -1);
	    }
	}
    }
}

/* Propagate moves from a futurebase that resulted from capturing one of the pieces in the current
 * tablebase.
 *
 * I'm thinking of changing that "invert_colors_of_futurebase" flag to be a subroutine that gets
 * passed in.  It could be a pointer to invert_colors_of_global_position to do what it does now.  Or
 * it could be a "reflect board around vertical axis" to move a d4 pawn to e4.  Also see my comments
 * on invert_colors_of_global position.
 */

void consider_possible_captures(tablebase_t *tb, tablebase_t *futurebase, index_t future_index,
				local_position_t *position,
				int capturing_piece, int captured_piece)
{
    int dir;
    struct movement *movementptr;
    int true_captured_piece;
    int true_capturing_piece;

    /* We only want to consider pieces of the side which captured... */

    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) return;

    /* Put the captured piece on the capturing piece's square (from the future position).  */

    position->piece_position[captured_piece] = position->piece_position[capturing_piece];

    /* When we finally convert the position to an index (in local_position_to_index()), we'll make a
     * copy of the position and normalize it by sorting the identical pieces so that they are in
     * ascending order.  But we have to at least be aware of this here, in order to figure out which
     * piece "actually" got captured (we're always called with captured_piece set to the last piece
     * number of any identical pieces), so we can figure out which futuremove number to use.
     */

    /* Now consider all possible backwards movements of the capturing piece. */

    if (tb->piece_type[capturing_piece] != PAWN) {

	/* If the square we put the captured piece on isn't semilegal for it, then don't consider
	 * this capturing piece in this future position any more.  This is after the "if" instead of
	 * before it because an en passant pawn capture is special, since then the capturing piece
	 * ends up on a different square from the captured piece.
	 */

	if (!(tb->semilegal_squares[captured_piece]
	      & BITVECTOR(position->piece_position[captured_piece]))) {
	    return;
	}

	for (dir = 0; dir < number_of_movement_directions[tb->piece_type[capturing_piece]]; dir++) {

	    /* Make sure we start each movement of the capturing piece from the capture square */

	    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

	    for (movementptr = movements[tb->piece_type[capturing_piece]][position->piece_position[capturing_piece]][dir];
		 (movementptr->vector & position->board_vector) == 0;
		 movementptr++) {

		/* We already checked that the captured piece was on a semilegal square for it.  Now
		 * check the capturing piece.
		 */

		if (! (tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

		/* Move the capturing piece, normalize the position, and back prop it.
		 *
		 * We have to figure out the "true" capturing and captured pieces, which might not
		 * be the pieces we started with (see comments on normalization).
		 *
		 * normalize_position() and denormalize_position() both update board_vector.  This
		 * is good for normalization because I want to check for en passant legality before
		 * I call local_position_to_index().  It just makes the code a little more robust at
		 * this point, because then there should be no reason for local_position_to_index()
		 * to return -1.  After denormalization though, we do want to clear the bit in
		 * board_vector for the capturing_piece, because we're about to move it somewhere
		 * else, and we don't want that for loop above us to get the idea that there's
		 * a piece on a square that's actually vacant.
		 */

		position->piece_position[capturing_piece] = movementptr->square;

		normalize_position(tb, position);

		true_capturing_piece = position->permuted_piece[capturing_piece];
		true_captured_piece = position->permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      position);

		denormalize_position(tb, position);
		position->board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

    } else {

	/* Yes, pawn captures are special */

	for (movementptr = capture_pawn_movements_bkwd[position->piece_position[capturing_piece]][tb->piece_color[capturing_piece]];
	     movementptr->square != -1;
	     movementptr++) {

	    /* Is there anything on the square the pawn had to capture from? */

	    if ((movementptr->vector & position->board_vector) != 0) continue;

	    /* Move back the capturing pawn and see if it came from a semilegal square for it. */

	    position->piece_position[capturing_piece] = movementptr->square;
	    if (! (tb->semilegal_squares[capturing_piece] & movementptr->vector)) continue;

	    /* And if the captured piece is also on a semilegal square for it... */

	    if ((tb->semilegal_squares[captured_piece]
		 & BITVECTOR(position->piece_position[captured_piece]))) {

		normalize_position(tb, position);

		true_capturing_piece = position->permuted_piece[capturing_piece];
		true_captured_piece = position->permuted_piece[captured_piece];

		propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
							      futurecaptures[true_capturing_piece][true_captured_piece],
							      position);

		denormalize_position(tb, position);

		position->board_vector &= ~BITVECTOR(movementptr->square);

	    }

	    /* The en passant special case: if both the piece that captured and the piece that was
	     * captured are both pawns, and either a white pawn captured from the fifth rank, or a
	     * black pawn captured from the fourth, then there are two possible back prop positions
	     * - the obvious one we just handled, and the one where the captured pawn was in an en
	     * passant state.  We also make sure right away that the rank is clear where the pawn
	     * had to come from, and the rank is clear where the pawn had to go to, ensuring that an
	     * en passant move was even possible.
	     */

	    if ((tb->piece_type[captured_piece] == PAWN)
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]-8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[captured_piece]+8))) {

		if ((tb->piece_color[capturing_piece] == BLACK) && (ROW(movementptr->square) == 3)) {

		    /* A black pawn capturing a white one (en passant)
		     *
		     * The white pawn is actually a rank higher than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] += 8;

		    if ((tb->semilegal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			normalize_position(tb, position);

			true_capturing_piece = position->permuted_piece[capturing_piece];
			true_captured_piece = position->permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								      futurecaptures[true_capturing_piece][true_captured_piece],
								      position);

			denormalize_position(tb, position);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] -= 8;
		}

		if ((tb->piece_color[capturing_piece] == WHITE) && (ROW(movementptr->square) == 4)) {

		    /* A white pawn capturing a black one (en passant)
		     *
		     * The black pawn is actually a rank lower than usual.
		     */

		    position->en_passant_square = position->piece_position[captured_piece];
		    position->piece_position[captured_piece] -= 8;

		    if ((tb->semilegal_squares[captured_piece]
			 & BITVECTOR(position->piece_position[captured_piece]))) {

			position->board_vector &= ~BITVECTOR(position->en_passant_square);
			position->board_vector |= BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector |= BITVECTOR(movementptr->square);

			normalize_position(tb, position);

			true_capturing_piece = position->permuted_piece[capturing_piece];
			true_captured_piece = position->permuted_piece[captured_piece];

			propagate_normalized_position_from_futurebase(tb, futurebase, future_index,
								 futurecaptures[true_capturing_piece][true_captured_piece],
								 position);

			denormalize_position(tb, position);

			position->board_vector |= BITVECTOR(position->en_passant_square);
			position->board_vector &= ~BITVECTOR(position->piece_position[captured_piece]);
			position->board_vector &= ~BITVECTOR(movementptr->square);
		    }

		    /* Yes, we're in a for loop and could might this position again, so put things
		     * back where they came from...
		     */

		    position->en_passant_square = -1;
		    position->piece_position[captured_piece] += 8;
		}
	    }

	}

    }

    /* Put the capturing piece back where it came from (on the capture square) so that we can use
     * this local position again (on another call to this function) to consider other potential
     * capturing pieces without having to copy or recreate the entire local position structure.
     */


    position->piece_position[capturing_piece] = position->piece_position[captured_piece];

}

void propagate_moves_from_capture_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					     int invert_colors_of_futurebase)
{
    index_t future_index;
    local_position_t position;
    int piece;
    uint32 conversion_result;
    int extra_piece, restricted_piece, captured_piece, missing_piece2;
    int reflection;
    int max_reflection;
    int reflections[8];

    max_reflection = compute_reflections(tb, futurebase, reflections);

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* It's tempting to break out the loop here if the position isn't a win, but if we want to
	 * track futuremoves in order to make sure we don't miss one (probably a good idea), then
	 * the simplest way to do that is to run this loop even for draws.
	 */

	for (reflection = 0; reflection < max_reflection; reflection ++) {

	    /* Take the position from the futurebase and translate it into a local position for the
	     * current tablebase.  If the futurebase index was illegal, the function will return -1.
	     * Otherwise, there should be one piece missing from the local position: the piece that
	     * was captured.  There could possibly be one piece on a restricted square, as well.  If
	     * so, then it must be the piece that moved in order to capture.
	     */

	    /* XXX If the futurebase is more liberal than the tablebase, then there will be
	     * positions with multiple restricted pieces that should be quietly ignored.
	     */

	    conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
									  reflections[reflection],
									  tb, &position,
									  invert_colors_of_futurebase);

#ifdef DEBUG_FUTUREMOVE
	    if (future_index == DEBUG_FUTUREMOVE) {
		info("capture backprop; reflection=%d; conversion_result=%x\n", reflection, conversion_result);
	    }
#endif

	    if (conversion_result != -1) {

		extra_piece = (conversion_result >> 16) & 0xff;
		restricted_piece = (conversion_result >> 8) & 0xff;
		captured_piece = conversion_result & 0xff;           /* missing_piece1 */
		missing_piece2 = (conversion_result >> 24) & 0xff;

		if ((extra_piece != NONE) || (captured_piece == NONE) || (missing_piece2 != NONE)) {
#if 0
		    fatal("Conversion error during capture back-prop (extra piece %d; missing_piece1 %d, missing_piece2 %d\n", extra_piece, missing_piece1, missing_piece2);
#endif
		    continue;
		}

		/* Since the last move had to have been a capture move, there is absolutely no way
		 * we could have en passant capturable pawns in the futurebase position.
		 */

		if (position.en_passant_square != -1) continue;

		/* Since the position resulted from a capture, we only want to consider future
		 * positions where the side to move is not the side that captured.
		 */

		if (position.side_to_move != tb->piece_color[captured_piece])
		    continue;

		/* We're going to back step a half move now */

		flip_side_to_move_local(&position);

		if (restricted_piece == NONE) {

		    /* No pieces were on restricted squares.  Consider them all as the possible
		     * capturing piece.
		     */

		    for (piece = 0; piece < tb->num_pieces; piece++) {

			consider_possible_captures(tb, futurebase, future_index, &position,
						   piece, captured_piece);
		    }

		} else {

		    /* One piece was on a restricted square.  It's the obvious capturing piece, but
		     * it's not the only possible one, because it might be possible to swap it with
		     * an identical piece that would put it on a semilegal square and put the other
		     * piece on the restricted square.  The simplest way to understand this is in
		     * terms of semilegal group - each square on the board can only have a single
		     * semilegal group for a given piece type and color.  A restricted piece is on a
		     * square whose semilegal group is already full.  If the square's semilegal
		     * group is in fact empty, then there's only one restricted piece we need to
		     * consider.  Otherwise, we need to consider each piece in the semilegal group
		     * as the possible restricted piece.
		     */

		    int restricted_square = position.piece_position[restricted_piece];

		    consider_possible_captures(tb, futurebase, future_index, &position,
					       restricted_piece, captured_piece);

		    for (piece = 0; piece < tb->num_pieces; piece++) {

			if ((tb->piece_color[piece] == tb->piece_color[restricted_piece])
			    && (tb->piece_type[piece] == tb->piece_type[restricted_piece])
			    && (tb->semilegal_squares[piece] & BITVECTOR(restricted_square))) {

			    position.piece_position[restricted_piece] = position.piece_position[piece];
			    position.piece_position[piece] = restricted_square;

			    consider_possible_captures(tb, futurebase, future_index, &position,
						       restricted_piece, captured_piece);

			    position.piece_position[piece] = position.piece_position[restricted_piece];
			}
		    }
		}
	    }
	}
    }
}

/* A "normal" futurebase is one that's identical to our own in terms of the number and types
 * of pieces.  It differs only in the frozen positions of the pieces.
 *
 * XXX not sure how to handle symmetry changes here.  At the moment it's not an issue, since we
 * don't allow frozen pieces in symmetric tablebases.
 */

void propagate_moves_from_normal_futurebase(tablebase_t *tb, tablebase_t *futurebase,
					    int invert_colors_of_futurebase)
{
    index_t future_index;
    local_position_t parent_position;
    local_position_t current_position; /* i.e, last position that moved to parent_position */
    uint32 conversion_result;
    int extra_piece, restricted_piece, missing_piece1, missing_piece2;
    int piece;
    int dir;
    struct movement *movementptr;
    int origin_square;

    for (future_index = 0; future_index <= futurebase->max_index; future_index ++) {

	/* Translate the futurebase index into a local position.  We have exactly the same number
	 * and type of pieces here, but exactly one of them is on a restricted square (according to
	 * the current tablebase).  If more than one of them was on a restricted square, then
	 * there'd be no way we could get to this futurebase with a single move.  On the other hand,
	 * if none of them were on restricted squares, then this would be a position in the current
	 * tablebase.
	 */

	/* XXX If the futurebase is more liberal than the tablebase, then there will be positions
	 * with multiple restricted pieces that should be quietly ignored.
	 */

	conversion_result = translate_foreign_index_to_local_position(futurebase, future_index,
								      REFLECTION_NONE,
								      tb, &current_position,
								      invert_colors_of_futurebase);

	if (conversion_result != -1) {

	    extra_piece = (conversion_result >> 16) & 0xff;
	    restricted_piece = (conversion_result >> 8) & 0xff;
	    missing_piece1 = conversion_result & 0xff;
	    missing_piece2 = (conversion_result >> 24) & 0xff;

	    if ((missing_piece1 != NONE) || (extra_piece != NONE) || (restricted_piece == NONE)) {
		fatal("Conversion error during normal back-prop\n");
		continue;
	    }

	    piece = restricted_piece;

	    origin_square = current_position.piece_position[piece];

	    /* We've moving BACKWARDS in the game, so this has to be a piece of the player who is
	     * NOT TO PLAY here - this is the LAST move we're considering, not the next move.
	     */

	    if (tb->piece_color[piece] == current_position.side_to_move)
		continue;


	    /* If there are any en passant capturable pawns in the position, then the last move had
	     * to have been a pawn move.  In fact, in this case, we already know exactly what the
	     * last move had to have been.
	     */

	    if (current_position.en_passant_square != -1) {

		if (tb->piece_type[piece] != PAWN) continue;

		if (((tb->piece_color[piece] == WHITE)
		     && (current_position.piece_position[piece] != current_position.en_passant_square + 8))
		    || ((tb->piece_color[piece] == BLACK)
			&& (current_position.piece_position[piece] != current_position.en_passant_square - 8))) {

		    /* No reason to complain here.  Maybe some other pawn was the en passant pawn. */
		    continue;
		}

		flip_side_to_move_local(&current_position);
		current_position.en_passant_square = -1;

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);
		if (tb->piece_color[piece] == WHITE)
		    current_position.piece_position[piece] -= 16;
		else
		    current_position.piece_position[piece] += 16;

		current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		/* We never back out into a restricted position.  Since we've already decided
		 * that this is the only possible back-move from this point, well...
		 */

		if (! (tb->semilegal_squares[piece]
		       & BITVECTOR(current_position.piece_position[piece]))) {
		    continue;
		}

		propagate_local_position_from_futurebase(tb, futurebase, future_index,
							 futuremoves[piece][origin_square],
							 &current_position);

		continue;

	    }

	    /* Abuse of notation here.  We just want to keep a copy of current_position because we
	     * change it around a lot during the loops below.
	     */

	    parent_position = current_position;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    /* What about captures?  Well, first of all, there are no captures here!  We're
		     * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		     * Captures are handled by back-propagation from futurebases, not here in the
		     * movement code.  The piece moving had to come from somewhere, and that
		     * somewhere will now be an empty square, so once we've hit another piece along
		     * a movement vector, there's absolutely no need to consider anything further.
		     */

		    for (movementptr
			     = movements[tb->piece_type[piece]][parent_position.piece_position[piece]][dir];
			 (movementptr->vector & parent_position.board_vector) == 0;
			 movementptr++) {

			/* We never back out into a restricted position (obviously) */

			if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

			/* Back stepping a half move here involves several things: flipping the
			 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
			 * the piece (backwards), and considering a bunch of additional positions
			 * identical to the base position except that a single one of the pawns on the
			 * fourth or fifth ranks was capturable en passant.
			 *
			 * Of course, the only way we could have gotten an en passant pawn is if THIS
			 * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
			 * additional en passant positions is taken care of in
			 * propagate_one_move_within_table()
			 */

			flip_side_to_move_local(&current_position);

			/* I go to the trouble to update board_vector here so we can check en passant
			 * legality in propagate_one_move_within_table().
			 */

			current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

			current_position.piece_position[piece] = movementptr->square;

			current_position.board_vector |= BITVECTOR(movementptr->square);

			propagate_local_position_from_futurebase(tb, futurebase, future_index,
								 futuremoves[piece][origin_square],
								 &current_position);
		    }
		}

	    } else {

		/* Usual special case for pawns */

		for (movementptr = normal_pawn_movements_bkwd[parent_position.piece_position[piece]][tb->piece_color[piece]];
		     (movementptr->vector & parent_position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Do we have a backwards pawn move here?
		     *
		     * Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		     * created it.  We handle that as a special case above, so we shouldn't have to
		     * worry about clearing en passant pawns here - there should be none.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     *
		     * But we start with an extra check to make sure this isn't a double pawn move, it
		     * which case it would result in an en passant position, not the non-en passant
		     * position we are in now (en passant got taken care of in the special case above).
		     */

		    if (((movementptr->square - parent_position.piece_position[piece]) == 16)
			|| ((movementptr->square - parent_position.piece_position[piece]) == -16)) {
			continue;
		    }

		    current_position = parent_position;

		    flip_side_to_move_local(&current_position);

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    current_position.board_vector &= ~BITVECTOR(current_position.piece_position[piece]);

		    current_position.piece_position[piece] = movementptr->square;

		    current_position.board_vector |= BITVECTOR(current_position.piece_position[piece]);

		    propagate_local_position_from_futurebase(tb, futurebase, future_index,
							     futuremoves[piece][origin_square],
							     &current_position);

		}
	    }
	}
    }
}

/* compute_extra_and_missing_piece()
 *
 * See comments for translate_foreign_position_to_local_position(), since this function mimicks that
 * one, except that this function works on an entire tablebase, while the other one works on a
 * single position within the tablebase.
 */

boolean compute_extra_and_missing_pieces(tablebase_t *tb, tablebase_t *futurebase, char *filename)
{
    int piece;
    int future_piece;
    int piece_vector;
    int color;

    futurebase->extra_piece = -1;
    futurebase->missing_pawn = -1;
    futurebase->missing_non_pawn = -1;

    /* Check futurebase to make sure its move restriction(s) match our own */

    for (color = 0; color < 2; color ++) {
	if ((futurebase->move_restrictions[color] != RESTRICTION_NONE)
	    && (futurebase->move_restrictions[color]
		!= tb->move_restrictions[futurebase->invert_colors ? 1 - color : color])) {
	    fatal("'%s': Futurebase doesn't match move restrictions!\n", filename);
	    return 0;
	}
    }

    /* The futurebase can have different pieces than the current tablebase.  There can be a single
     * extra piece, as well as a missing pawn and/or a missing non-pawn.  Find them.
     */

    /* piece_vector - set a bit for every piece in current tablebase */
    piece_vector = (1 << tb->num_pieces) - 1;

    for (future_piece = 0; future_piece < futurebase->num_pieces; future_piece ++) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    if (! (piece_vector & (1 << piece))) continue;
	    if ((tb->piece_type[piece] == futurebase->piece_type[future_piece])
		&& ((!futurebase->invert_colors &&
		     (tb->piece_color[piece] == futurebase->piece_color[future_piece]))
		    || (futurebase->invert_colors &&
			(tb->piece_color[piece] != futurebase->piece_color[future_piece])))) {
		piece_vector ^= (1 << piece);
		break;
	    }
	}
	if (piece == tb->num_pieces) {
	    if ((futurebase->extra_piece == -1) && (futurebase->piece_type[future_piece] != PAWN)) {
		futurebase->extra_piece = future_piece;
	    } else {
		fatal("'%s': Couldn't find future piece in tablebase\n", filename);
		return 0;
	    }
	}
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] == PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	if ((tb->piece_type[piece] != PAWN) && (piece_vector & (1 << piece))) break;
    }
    if (piece != tb->num_pieces) {
	futurebase->missing_non_pawn = piece;
	piece_vector ^= (1 << piece);
    }

    if (piece_vector != 0) {
	fatal("'%s': Too many missing pieces in futurebase\n", filename);
	return 0;
    }

    return 1;
}

/* Back propagates from all the futurebases.
 *
 * Should be called after the tablebase has been initialized, but before intra-table propagation.
 *
 * Runs through the parsed XML control file, pulls out all the futurebases, and back-propagates each
 * one.
 *
 * Returns true, or false if something went wrong
 */

boolean back_propagate_all_futurebases(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int i;

    /* Fetch the futurebases from the XML */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//futurebase", context);

    for (i=0; i < result->nodesetval->nodeNr; i++) {
	xmlChar * filename;
	xmlChar * type;
	xmlChar * colors_property;
	tablebase_t * futurebase;

	filename = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "filename");
	if (filename == NULL) {
	    filename = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "url");
	}

	if (filename == NULL) {
	    fatal("No filename or URL specified in futurebase element\n");
	    continue;
	}

	futurebase = preload_futurebase_from_file((char *) filename);

	/* load_futurebase_from_file() already printed some kind of error message */
	if (futurebase == NULL) return 0;

	futurebase->invert_colors = 0;
	colors_property = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "colors");
	if (colors_property != NULL) {
	    if (!strcasecmp((char *) colors_property, "invert")) futurebase->invert_colors = 1;
	    xmlFree(colors_property);
	}

	if (! compute_extra_and_missing_pieces(tb, futurebase, (char *) filename)) continue;

	/* Various combinations of missing/extra pieces are legal for different futurebase types.
	 */

	type = xmlGetProp(result->nodesetval->nodeTab[i], BAD_CAST "type");

	if ((type != NULL) && !strcasecmp((char *) type, "capture")) {

	    /* It's a capture futurebase.  Futurebase should have exactly one less piece than the
	     * current tablebase.
	     */

	    if (futurebase->extra_piece != -1) {
		fatal("'%s': Extra piece in capture futurebase\n", filename);
		continue;
	    }

	    if ((futurebase->missing_pawn != -1) && (futurebase->missing_non_pawn != -1)) {
		fatal("'%s': Too many missing pieces in capture futurebase\n", filename);
		continue;
	    }

	    if ((futurebase->missing_pawn == -1) && (futurebase->missing_non_pawn == -1)) {
		fatal("'%s': No missing pieces in capture futurebase\n", filename);
		continue;
	    }

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) filename);
		propagate_moves_from_capture_futurebase(tb, futurebase, futurebase->invert_colors);
	    }

	} else if ((type != NULL) && !strcasecmp((char *) type, "promotion")) {

	    /* It's a promotion futurebase.  Futurebase should have exactly the same number of
	     * pieces as the current tablebase, and one of our pawns should have promoted into
	     * something else.  Determine what the pawn promoted into.
	     */

	    if (futurebase->extra_piece == -1) {
		fatal("'%s': No extra piece in promotion futurebase\n", filename);
		continue;
	    }

	    if (futurebase->missing_non_pawn != -1) {
		fatal("'%s': Missing non-pawn in promotion futurebase\n", filename);
		continue;
	    }

	    if (futurebase->missing_pawn == -1) {
		fatal("'%s': No missing pawn in promotion futurebase\n", filename);
		continue;
	    }

	    /* Ready to go. */

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) filename);
		propagate_moves_from_promotion_futurebase(tb, futurebase, futurebase->invert_colors,
							  futurebase->missing_pawn);
	    }

	} else if ((type != NULL)
		   && (!strcasecmp((char *) type, "promotion-capture") ||
		       !strcasecmp((char *) type, "capture-promotion"))) {

	    /* It's a promotion capture futurebase.  Futurebase should have exactly one less piece
	     * than the current tablebase, and one of our pawns should have promoted into something
	     * else.
	     */

	    if (futurebase->extra_piece == -1) {
		fatal("'%s': No extra piece in promotion capture futurebase\n", filename);
		continue;
	    }

	    if (futurebase->missing_non_pawn == -1) {
		fatal("'%s': No missing non-pawn in promotion capture futurebase\n", filename);
		continue;
	    }

	    if (futurebase->missing_pawn == -1) {
		fatal("'%s': No missing pawn in promotion capture futurebase\n", filename);
		continue;
	    }

	    /* Ready to go. */

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) filename);
		propagate_moves_from_promotion_capture_futurebase(tb, futurebase, futurebase->invert_colors,
								  futurebase->missing_pawn);
	    }

	} else if ((type != NULL) && !strcasecmp((char *) type, "normal")) {

	    if (futurebase->extra_piece != -1) {
		fatal("'%s': Extra piece in normal futurebase\n", filename);
		continue;
	    }

	    if ((futurebase->missing_pawn != -1) || (futurebase->missing_non_pawn != -1)) {
		fatal("'%s': Missing pieces in normal futurebase\n", filename);
		continue;
	    }

	    if (fatal_errors == 0) {
		info("Back propagating from '%s'\n", (char *) filename);
		propagate_moves_from_normal_futurebase(tb, futurebase, futurebase->invert_colors);
	    }

	} else {

	    fatal("'%s': Unknown back propagation type (%s)\n", (char *) filename, (char *) type);
	    continue;

	}

	if (type != NULL) xmlFree(type);
	if (filename != NULL) xmlFree(filename);
	unload_futurebase(futurebase);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    return (fatal_errors == 0);
}

/***** PRUNING *****/

/* If we don't want to fully analyze out the tree past the table we're now building, we prune some
 * possible futuremoves.  Of course, this will affect the accuracy of the table; the table is a
 * result of BOTH the position it was set up for AND the pruning decisions (and any pruning
 * decisions made on the futurebases used to calculate this one).
 *
 * We specify pruning in a simple way - by omitting future tables for moves we don't want to
 * consider.  This can be dangerous, so we require this feature to be specifically enabled.  Right
 * now, there are two possibilities we can specify in the XML control file; one to allow moves to be
 * DISCARDED; the other to allow victory to be CONCEDED to the side that makes the move.
 *
 * So, if we are white, and assuming that this is a table with a frozen white pawn on e3, we can
 * prune by simply ignoring Pe4 as a possible move.  If there is a black pawn on the g-file, and we
 * don't want to compute out what happens after it queens, we can prune by treating Pg1=X as a forced
 * win for black.
 *
 * We might want to "partially" prune a move like Pg1=X by looking a half-move into the future to
 * see if we can immediately take the new piece and simplify that way.  To do so, we would construct
 * a futurebase for the piece combination resulting after Pg1=X, probably leaving X frozen on g1,
 * make one pass through that futurebase (this is currently unimplemented) and flag everything else
 * a win for black.  This approach avoids having to step a half-move into the future during back
 * propagation.  The advantages of this are three-fold.  First, it simplifies the program, and
 * that's a big plus from a quality control standpoint.  Second, it avoids the random accesses that
 * would be required to probe into the tablebase, replacing them with a series of sequential sweeps,
 * and for a big tablebase that's probably a significant performance win.  Finally, it's a lot more
 * flexible.  We can make two, or three, or five sweeps through that tablebase, looking a few more
 * moves into the future for forced reductions.
 *
 * For example, let's say we're looking at a Q-and-P vs. Q-and-P endgame.  There are four completely
 * mobile pieces (2 Ks and 2 Qs), and this is easy.  But if one of the pawns queens, then we've got
 * a more complex game with five mobile pieces, and that's too complex.  But we don't want to
 * completely discard all possible enemy promotions, if we can immediately capture the new queen (or
 * the old one).  So we construct a special tablebase for a queen frozen on the queening square,
 * back prop a tablebase for a Q-and-P vs. Q endgame into it, make a pass or two through it, then
 * feed it into our current tablebase.
 *
 * And finally, we want to label in the file header that this pruning was done.  In particular, if
 * we use a pruned tablebase to compute another (earlier) pruned tablebase, we want to make sure the
 * pruning is consistent, i.e. "our" side has to stay the same.  This is guaranteed by explicitly
 * flagging in the XML header which sides can be pruned in which way (concede or discard).
 */

int all_futuremoves_handled = 1;
futurevector_t unpruned_white_futuremoves;
futurevector_t unpruned_black_futuremoves;

void finalize_futuremove(tablebase_t *tb, index_t index, futurevector_t futurevector) {

    int futuremove;
    int stm = index_to_side_to_move(tb, index);

    if (futurevector & (stm == WHITE ? unpruned_white_futuremoves : unpruned_black_futuremoves)) {
	global_position_t global;
	index_to_global_position(tb, index, &global);
	fatal("Futuremoves not handled: %d %s", index, global_position_to_FEN(&global));
	for (futuremove = 0; futuremove < num_futuremoves[stm]; futuremove ++) {
	    if (futurevector & FUTUREVECTOR(futuremove)
		& (stm == WHITE ? unpruned_white_futuremoves : unpruned_black_futuremoves)) {
		fatal(" %s", movestr[stm][futuremove]);
	    }
	}
	fatal("\n");
	all_futuremoves_handled = 0;
    }

    /* concede - we treat these unhandled futuremoves as forced wins for PTM */

    if (futurevector & (stm == WHITE ? conceded_white_futuremoves : conceded_black_futuremoves)) {
	/* PTM_wins(tb, index, 1, 1); */
	/* We insert here with DTM=2 (mate in one), movecnt=1 (XXX), and no futuremove */
	/* XXX I bet we want to insert with position's multiplicity as movecnt */
	insert_or_commit_propentry(index, 2, 1, 0);
    }

    /* discard - we ignore these unhandled futuremoves by decrementing movecnt */

    if (futurevector & (stm == WHITE ? discarded_white_futuremoves : discarded_black_futuremoves)) {
	for (futuremove = 0; futuremove < num_futuremoves[stm]; futuremove ++) {
	    if (futurevector & FUTUREVECTOR(futuremove)
		& (stm == WHITE ? discarded_white_futuremoves : discarded_black_futuremoves)) {

		/* tb->entries[index].movecnt --; */
		/* XXX this isn't handled right - a draw is different from a discard */
		insert_or_commit_propentry(index, 0, 0, 0);
	    }
	}
    }
}

boolean have_all_futuremoves_been_handled(tablebase_t *tb) {

    index_t index;

    for (index = 0; index <= tb->max_index; index ++) {
	if (get_entry_DTM(index) != 1) {
	    finalize_futuremove(tb, index, tb->futurevectors[index]);
	}
    }

    return all_futuremoves_handled;
}

/* assign_numbers_to_futuremoves()
 *
 * We could just dismiss any moves that aren't handled by our futurebases, but I've found this to be
 * a source of error, since moves tend to get overlooked this way.  We're also concerned with the
 * more sobering possibility of a single move getting processed twice by two different futurebases.
 *
 * So we assign numbers, bit positions in a bit vector, actually, to each futuremove.  When we
 * initialize the tablebase, we set bits in the vector (each position has its own vector) for each
 * futuremove possible from that position.  As we back propagate futuremoves, we check the bit to
 * make sure it's still set, then clear it.  After we've back propagated all the futurebases, we run
 * through the entire tablebase, making sure that the only bits that remain set correspond to prune
 * statements.
 *
 * This function not only assigns the numbers, but also prints an identifying string, such as "KxP"
 * or "Re4", into the movestr array for each number assigned.  This string will then be matched
 * against the pruning statements specified in the configuration file.  Sometimes the strings will
 * repeat.  For example, if we have two pawns and an enemy queen, we'll probably end up with two
 * different bit positions, both assigned as "QxP".  The reason is that there are probably positions
 * where the queen could take either pawn, so both possibilities have to be tracked.
 *
 * Because we need a "futurevector" for each position in the tablebase, we want to keep it as small
 * as possible, so we try to use as few bit positions as possible.  In particular, we track white
 * and black futuremoves seperately (since from a given position only one or the other will be
 * possible) and we try to reuse bit positions for pawn capture-promotions if the pawns are
 * sufficiently restricted so that only one or the other could capture the enemy piece in a given
 * position.
 *
 * We could do a lot better, though.  For moves that are pruned without any matching futurebase,
 * there's really no reason to track them at all, since there are no futurebases that could possibly
 * generate them.  The pruning for such moves could be performed during tablebase initialization.
 */

void assign_numbers_to_futuremoves(tablebase_t *tb) {

    int piece;
    int captured_piece;
    int capturing_piece;
    int sq;
    int dir;
    int i;
    struct movement *movementptr;
    uint64 possible_captures[MAX_PIECES];

    /* Start by computing a board vector (possible_captures) showing all possible squares where each
     * piece can capture onto.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	possible_captures[piece] = 0;

	for (sq = 0; sq < 64; sq ++) {

	    /* We make the checks here using legal_squares and not semilegal_squares because
	     * we're assigning futuremove numbers to individual pieces that can capture.  The
	     * movements we consider here, being captures, would take us to a futurebase anyway,
	     * so there's no question of whether the resulting position is fully legal or not.
	     */

	    if (tb->legal_squares[piece] & BITVECTOR(sq)) {
		if (tb->piece_type[piece] != PAWN) {
		    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {
			for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			     movementptr->square != -1; movementptr++) {

			    possible_captures[piece] |= movementptr->vector;

			    /* If we hit a frozen piece, then this movement direction ends here */
			    if (movementptr->vector & tb->frozen_pieces_vector) break;
			}
		    }
		} else {
		    for (movementptr = capture_pawn_movements[sq][tb->piece_color[piece]];
			 movementptr->square != -1; movementptr++) {

			possible_captures[piece] |= movementptr->vector;
		    }
		}
	    }
	}
    }

    /* Now, consider all possible pairs of pieces that might capture, and assign a number (in the
     * futurecaptures array) to each pair.  We'll ultimately use this number as an index into a bit
     * vector to determine if this capture has been handled in any particular position.  However,
     * there's a common enough "special" case: the two pieces are frozen (or at least sufficiently
     * restricted) so that the capture can never occur.  Go to the trouble of checking for this.
     */

    for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    futurecaptures[capturing_piece][captured_piece] = -1;
	    promotion_captures[capturing_piece][captured_piece] = -1;

	    if (tb->piece_color[capturing_piece] == tb->piece_color[captured_piece]) continue;

	    if (tb->piece_type[capturing_piece] != PAWN) {

		if (possible_captures[capturing_piece] & tb->legal_squares[captured_piece]) {

		    char * my_movestr
			= movestr[tb->piece_color[capturing_piece]]
			[num_futuremoves[tb->piece_color[capturing_piece]]];

		    sprintf(my_movestr, "%cx%c",
			    piece_char[tb->piece_type[capturing_piece]],
			    piece_char[tb->piece_type[captured_piece]]);

		    futurecaptures[capturing_piece][captured_piece]
			= num_futuremoves[tb->piece_color[capturing_piece]] ++;
		}

	    } else {

		/* if it's a pawn-takes-pawn situation, check for en passant as well */

		if ((possible_captures[capturing_piece] & tb->legal_squares[captured_piece])
		    | ((tb->piece_type[captured_piece] == PAWN)
		       && (((tb->piece_color[capturing_piece] == WHITE)
			    ? ((possible_captures[capturing_piece] & 0x0000ff0000000000LL) >> 8)
			    : ((possible_captures[capturing_piece] & 0x0000000000ff0000LL) << 8))
			   & tb->legal_squares[captured_piece]))) {

		    int futuremoves_needed;
		    int candidate_futuremove = -1;
		    int candidate_piece = -1;
		    char candidate_movestr[MOVESTR_CHARS];

		    /* start by dishing out a non-promotion futurecapture */

		    char * my_movestr
			= movestr[tb->piece_color[capturing_piece]]
			[num_futuremoves[tb->piece_color[capturing_piece]]];

		    sprintf(my_movestr, "%cx%c",
			    piece_char[tb->piece_type[capturing_piece]],
			    piece_char[tb->piece_type[captured_piece]]);

		    futurecaptures[capturing_piece][captured_piece]
			= num_futuremoves[tb->piece_color[capturing_piece]] ++;

		    /* Keep going only if it's a pawn capture that results in promotion */

		    if (! (possible_captures[capturing_piece] & tb->legal_squares[captured_piece]
			   & ((tb->piece_color[capturing_piece] == WHITE)
			      ? 0xff00000000000000LL : 0x00000000000000ffLL))) {
			continue;
		    }

		    futuremoves_needed = PROMOTION_POSSIBILITIES;
		    sprintf(candidate_movestr, "Px%c=%c",
			    piece_char[tb->piece_type[captured_piece]],
			    piece_char[promoted_pieces[0]]);

		    /* Be conservative about handing out bit positions in the futurevector.  Look
		     * through the other pieces that have been assigned bit positions and see if we
		     * can find one with an identical movestr that can never capture onto the
		     * squares that our piece can capture onto and reuse its bit positions.
		     *
		     * This code could be a lot more aggressively conservative, but for now I settle
		     * for handling the common simple case of pawns more than two files apart never
		     * being able to capture the same piece.  I only look at futuremoves for the
		     * current captured_piece, and only so far as the current capturing_piece.
		     * That's why the nesting order of the two captured_piece and capturing_piece
		     * loops is important above.  First we look for a candidate futuremove, then we
		     * try to bust it by looking for overlaps.  We only check the movestr for the
		     * first of the PROMOTION_POSSIBILITIES, since if it matched for the first one,
		     * it will have to match for the remaining ones, too.
		     */

		    for (piece = 0; piece < capturing_piece; piece ++) {
			if (tb->piece_color[piece] != tb->piece_color[capturing_piece]) continue;
			if (promotion_captures[piece][captured_piece] != -1) {
			    if ((! (possible_captures[capturing_piece] & possible_captures[piece]))
				&& (! strcmp(candidate_movestr, movestr[tb->piece_color[piece]][promotion_captures[piece][captured_piece]]))) {
				candidate_futuremove = promotion_captures[piece][captured_piece];
				candidate_piece = piece;
			    }
			}
		    }

		    for (piece = 0; piece < capturing_piece; piece ++) {
			if (tb->piece_color[piece] != tb->piece_color[capturing_piece]) continue;
			if (piece == candidate_piece) continue;
			if (promotion_captures[piece][captured_piece] != -1) {
			    if ((candidate_futuremove != -1)
				&& (promotion_captures[piece][captured_piece] >= candidate_futuremove)
				&& (promotion_captures[piece][captured_piece] <
				    candidate_futuremove + futuremoves_needed)) {
				candidate_futuremove = -1;
				break;
			    }
			}
		    }

		    if (candidate_futuremove == -1) {
			candidate_futuremove = num_futuremoves[tb->piece_color[capturing_piece]];
		    }

		    promotion_captures[capturing_piece][captured_piece] = candidate_futuremove;

		    strcpy(movestr[tb->piece_color[capturing_piece]][candidate_futuremove],
			   candidate_movestr);

		    if (futuremoves_needed > 1) {
			for (i=1; i<futuremoves_needed; i++) {
			    sprintf(movestr[tb->piece_color[capturing_piece]][candidate_futuremove + i],
				    "Px%c=%c", piece_char[tb->piece_type[captured_piece]],
				    piece_char[promoted_pieces[i]]);
			}
		    }

		    if (candidate_futuremove + futuremoves_needed
			> num_futuremoves[tb->piece_color[capturing_piece]]) {
			num_futuremoves[tb->piece_color[capturing_piece]]
			    = candidate_futuremove + futuremoves_needed;
		    }
		}
	    }
	}
    }

    /* We also want to consider all promotions.  We don't wrap this into the pawn code that follows
     * because we want to count all promotions together, not a set for each destination square.
     * This is a special case of a more general problem that this code doesn't address yet.  We want
     * to minimize the assigned numbers to keep the futuremove bit vector small, so we want to reuse
     * those numbers if we're sure that two moves can't happen from different squares.  I.e, if a
     * king is restricted to the f1/h3 rectangle, then it can move to e1 from f1 and it can move to
     * h4 from h3, but there is no single position from which it can move to both e1 and h4.  So we
     * can use the same position in the bit vector for Ke1 and Kh4.  But we don't (yet).
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {
	promotions[piece] = -1;
	if (tb->piece_type[piece] == PAWN) {
	    for (sq = (tb->piece_color[piece] == WHITE ? 48 : 8);
		 sq <= (tb->piece_color[piece] == WHITE ? 55 : 15); sq++) {
		if (tb->legal_squares[piece] & BITVECTOR(sq)) {
		    promotions[piece] = num_futuremoves[tb->piece_color[piece]];

		    for (i = 0; promoted_pieces[i] != 0; i ++) {
			sprintf(movestr[tb->piece_color[piece]][promotions[piece] + i],
				"P=%c", piece_char[promoted_pieces[i]]);
		    }

		    num_futuremoves[tb->piece_color[piece]] += PROMOTION_POSSIBILITIES;
		    break;
		}
	    }
	}
    }

    /* And now all piece moves outside their restriction.  We record a futuremove for each possible
     * destination square that the piece can reach outside its move restriction.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	for (sq = 0; sq < 64; sq ++) futuremoves[piece][sq] = -1;

	for (sq = 0; sq < 64; sq ++) {

	    /* Consider as _starting_ squares only those within the piece's movement restriction */

	    if (! (tb->legal_squares[piece] & BITVECTOR(sq))) continue;

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][sq][dir];
			 movementptr->square != -1; movementptr++) {

			/* If we hit a frozen piece, movement has to stop.  We don't consider
			 * captures here; they were handled above.
			 */

			if (movementptr->vector & tb->frozen_pieces_vector) break;

			/* Don't assign futuremoves to king moves onto illegal squares (those that
			 * would place the king in check from a frozen piece)
			 */

			if ((piece == tb->white_king)
			    && (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
			if ((piece == tb->black_king)
			    && (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

			/* If the piece is moving outside its legal squares, it's a futuremove.  Why
			 * not semilegal squares here?  Because any legal position would (possibly
			 * after permuting the pieces) have each piece on a legal square, after
			 * which we would consider possible futuremoves outside the restriction.
			 */

			if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square]
				    = num_futuremoves[tb->piece_color[piece]];
				sprintf(movestr[tb->piece_color[piece]][num_futuremoves[tb->piece_color[piece]]],
					"%c%c%c", piece_char[tb->piece_type[piece]],
					'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				num_futuremoves[tb->piece_color[piece]] ++;
			    }
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[sq][tb->piece_color[piece]];
		     movementptr->square != -1; movementptr++) {

		    /* If we hit a frozen piece, movement has to stop.  We don't consider captures
		     * here; they were handled above.
		     */

		    if (movementptr->vector & tb->frozen_pieces_vector) break;

		    if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			/* might want to put the promotion code here */

		    } else {

			/* If the pawn is moving outside its restricted squares, it's a futuremove,
			 * unless the pawn is blocked, in which case the pawn will never be able to
			 * move outside its restriction (except via capture).
			 */

			if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
			    && (tb->blocking_piece[piece] == -1)) {
			    if (futuremoves[piece][movementptr->square] == -1) {
				futuremoves[piece][movementptr->square]
				    = num_futuremoves[tb->piece_color[piece]];
				sprintf(movestr[tb->piece_color[piece]][num_futuremoves[tb->piece_color[piece]]],
					"%c%c%c", piece_char[tb->piece_type[piece]],
					'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				num_futuremoves[tb->piece_color[piece]] ++;
			    }
			}
		    }
		}
	    }
	}
    }

    info("%d possible WHITE futuremoves\n", num_futuremoves[WHITE]);
    info("%d possible BLACK futuremoves\n", num_futuremoves[BLACK]);

    if (! USE_PROPTABLES) {
	if (num_futuremoves[WHITE] > sizeof(futurevector_t)*8) {
	    fatal("Too many futuremoves - %d!  (only %d bits futurevector_t)\n",
		  num_futuremoves[WHITE], sizeof(futurevector_t)*8);
	    terminate();
	}
	if (num_futuremoves[BLACK] > sizeof(futurevector_t)*8) {
	    fatal("Too many futuremoves - %d!  (only %d bits futurevector_t)\n",
		  num_futuremoves[BLACK], sizeof(futurevector_t)*8);
	    terminate();
	}
    } else {
	if (num_futuremoves[WHITE] > PROPTABLE_FORMAT_FUTUREVECTOR_BITS) {
	    fatal("Too many futuremoves - %d!  (only %d futurevector bits in proptable format)\n",
		  num_futuremoves[WHITE], PROPTABLE_FORMAT_FUTUREVECTOR_BITS);
	    terminate();
	}
	if (num_futuremoves[BLACK] > PROPTABLE_FORMAT_FUTUREVECTOR_BITS) {
	    fatal("Too many futuremoves - %d!  (only %d futurevector bits in proptable format)\n",
		  num_futuremoves[BLACK], PROPTABLE_FORMAT_FUTUREVECTOR_BITS);
	    terminate();
	}
    }
}

void print_futuremoves(void)
{
    int i;

    for (i=0; i < num_futuremoves[WHITE]; i ++) {
	info("WHITE Futuremove %i: %s\n", i, movestr[WHITE][i]);
    }
    for (i=0; i < num_futuremoves[BLACK]; i ++) {
	info("BLACK Futuremove %i: %s\n", i, movestr[BLACK][i]);
    }
}

/* assign_pruning_statement() - a helper function for compute_pruned_futuremoves()
 *
 * searches the tablebase's XML pruning statements for one matching (more or less identically) the
 * specified color and string.  If there is a match, set the corresponding bit in the
 * pruned_futuremoves bit vector.  The function can be called more than once for a given bit, but
 * probably shouldn't be.  For example, the function might be called on the same bit for "PxQ=Q" if
 * there are two pawns that can promote into a queen.  The function also allows a trailing "any" in
 * the prune statement to act as a wildcard; "Pany" would match "Pf6", for example, and "P=any"
 * would match "P=Q".  If there are multiple prune statements that match a given bit, only the first
 * one is used; the rest are silently (!) ignored.
 */

void assign_pruning_statement(tablebase_t *tb, int color, char *pruning_statement, int futuremove)
{
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int type;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_move = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "move");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");

	type = find_name_in_array((char *) prune_type, restriction_types);

	if ((find_name_in_array((char *) prune_color, colors) == color)
	    && (!strcasecmp((char *) prune_move, pruning_statement)
		|| (!strcasecmp("any", (char *) prune_move + strlen((char *) prune_move) - 3)
		    && !strncasecmp((char *) prune_move, pruning_statement,
				    strlen((char *) prune_move) - 3)))) {

	    if (color == WHITE) {

		if (pruned_white_futuremoves & FUTUREVECTOR(futuremove)) {
		    warning("Multiple pruning statements ('%s') match a futuremove\n", pruning_statement);
		}

		pruned_white_futuremoves |= FUTUREVECTOR(futuremove);

		if (type == RESTRICTION_CONCEDE) {
		    conceded_white_futuremoves |= FUTUREVECTOR(futuremove);
		    if (discarded_white_futuremoves & FUTUREVECTOR(futuremove)) {
			fatal("Conflicting pruning statements ('%s') match a futuremove\n",
			      pruning_statement);
		    }
		}
		if (type == RESTRICTION_DISCARD) {
		    discarded_white_futuremoves |= FUTUREVECTOR(futuremove);
		    if (conceded_white_futuremoves & FUTUREVECTOR(futuremove)) {
			fatal("Conflicting pruning statements ('%s') match a futuremove\n",
			      pruning_statement);
		    }
		}

	    } else {

		if (pruned_black_futuremoves & FUTUREVECTOR(futuremove)) {
		    warning("Multiple pruning statements ('%s') match a futuremove\n", pruning_statement);
		}

		pruned_black_futuremoves |= FUTUREVECTOR(futuremove);

		if (type == RESTRICTION_CONCEDE) {
		    conceded_black_futuremoves |= FUTUREVECTOR(futuremove);
		    if (discarded_black_futuremoves & FUTUREVECTOR(futuremove)) {
			fatal("Conflicting pruning statements ('%s') match a futuremove\n",
			      pruning_statement);
		    }
		}
		if (type == RESTRICTION_DISCARD) {
		    discarded_black_futuremoves |= FUTUREVECTOR(futuremove);
		    if (conceded_black_futuremoves & FUTUREVECTOR(futuremove)) {
			fatal("Conflicting pruning statements ('%s') match a futuremove\n",
			      pruning_statement);
		    }
		}
	    }
	}

	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_move != NULL) xmlFree(prune_move);
	if (prune_type != NULL) xmlFree(prune_type);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);
}

/* This is where we parse pruning statements.  Fill in the pruned_futuremoves bit vector with bits
 * set for the various pruned moves.
 *
 * XXX something else I'd like to do here is to flag all of the pruning statements to make
 * sure we've used each one, and complain if any are left unused.
 */

boolean compute_pruned_futuremoves(tablebase_t *tb) {

    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int prune;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int i;

    /* Check pruning statements for consistency, and record stalemate pruning if specified */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//prune", context);

    for (prune = 0; prune < result->nodesetval->nodeNr; prune ++) {
	xmlChar * prune_color = xmlGetProp(result->nodesetval->nodeTab[prune],
					   BAD_CAST "color");
	xmlChar * prune_type = xmlGetProp(result->nodesetval->nodeTab[prune],
					  BAD_CAST "type");
	int color = find_name_in_array((char *) prune_color, colors);
	int type = find_name_in_array((char *) prune_type, restriction_types);

	if (type != tb->move_restrictions[color]) {
	    fatal("Prune statements don't match tablebase restrictions\n");
	}

	if (prune_color != NULL) xmlFree(prune_color);
	if (prune_type != NULL) xmlFree(prune_type);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    if (fatal_errors != 0) return 0;

    /* for each possible captured_piece (everything but the two kings), check for capture
       futurebases
     */

    for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

	    if (futurecaptures[capturing_piece][captured_piece] != -1) {

		char * movestr1 = movestr[tb->piece_color[capturing_piece]][futurecaptures[capturing_piece][captured_piece]];

		assign_pruning_statement(tb, tb->piece_color[capturing_piece], movestr1,
					 futurecaptures[capturing_piece][captured_piece]);
	    }
	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	if (tb->piece_type[pawn] != PAWN) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	    if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->legal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->legal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    if (promotion_captures[pawn][captured_piece] == -1) continue;

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		char * movestr1 = movestr[tb->piece_color[pawn]][promotion_captures[pawn][captured_piece] + i];

		assign_pruning_statement(tb, tb->piece_color[pawn], movestr1,
					 promotion_captures[pawn][captured_piece] + i);
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    char * movestr1 = movestr[tb->piece_color[pawn]][promotions[pawn] + i];

	    assign_pruning_statement(tb, tb->piece_color[pawn], movestr1, promotions[pawn] + i);
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    for (piece = 0; piece < tb->num_pieces; piece ++) {

	for (sq = 0; sq < 64; sq ++) {
	    if (futuremoves[piece][sq] != -1) {

		char * movestr1 = movestr[tb->piece_color[piece]][futuremoves[piece][sq]];

		assign_pruning_statement(tb, tb->piece_color[piece], movestr1, futuremoves[piece][sq]);
	    }
	}
    }

    unpruned_white_futuremoves = ~pruned_white_futuremoves;
    unpruned_black_futuremoves = ~pruned_black_futuremoves;

    return (fatal_errors == 0);
}


/* check_pruning()
 *
 * We run this function after we've assigned numbers to the futuremoves, but before we initialize
 * the tablebase.
 *
 * Check the futurebases to see if there are any for a given futuremove.  If not, check to make sure
 * the futuremove is pruned.  Otherwise, signal an error and exit right now.  Just because this test
 * is passed doesn't mean a particular futuremove is handled in a particular position (that's why we
 * use the bit vector), but if the test fails, well, then we know (almost) for sure that we'd get to
 * the end of program with unhandled futurebases, so we can save ourselves a long computation by
 * making this basic check now.
 *
 * There is an off chance that piece restrictions will prevent a futuremove from taking place, but
 * this code will conclude nevertheless that it is possible and demand either a prune statement or a
 * futurebase.  In this rare case, introducing an extraneous prune statement or two should solve the
 * problem.
 */

boolean check_pruning(tablebase_t *tb, int *max_dtm, int *min_dtm) {

    tablebase_t **futurebases;
    int num_futurebases;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    int fbnum;
    int piece;
    int captured_piece;
    int capturing_piece;
    int pawn;
    int sq;
    int futurebase_cnt;
    int i;


    /* First, preload all futurebases */

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//futurebase", context);
    num_futurebases = result->nodesetval->nodeNr;
    futurebases = malloc(sizeof(tablebase_t *) * num_futurebases);
    if (futurebases == NULL) {
	fatal("Can't malloc futurebases array\n");
	return 0;
    }

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	xmlChar * filename;
	xmlChar * colors_property;

	filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "filename");
	if (filename == NULL) {
	    filename = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "url");
	}
	if (filename == NULL) {
	    fatal("No filename or URL specified in futurebase element\n");
	    continue;
	}

	futurebases[fbnum] = preload_futurebase_from_file((char *) filename);

	/* load_futurebase_from_file() already printed some kind of error message */
	if (futurebases[fbnum] == NULL) continue;

	if (futurebases[fbnum]->symmetry < tb->symmetry) {
	    fatal("Futurebases can't be less symmetric than the tablebase under construction\n");
	    continue;
	}

	if (futurebases[fbnum]->max_dtm > *max_dtm) *max_dtm = futurebases[fbnum]->max_dtm;
	if (futurebases[fbnum]->min_dtm < *min_dtm) *min_dtm = futurebases[fbnum]->min_dtm;

	futurebases[fbnum]->invert_colors = 0;
	colors_property = xmlGetProp(result->nodesetval->nodeTab[fbnum], BAD_CAST "colors");
	if (colors_property != NULL) {
	    if (!strcasecmp((char *) colors_property, "invert")) futurebases[fbnum]->invert_colors = 1;
	    xmlFree(colors_property);
	}

	compute_extra_and_missing_pieces(tb, futurebases[fbnum], (char *)filename);
	if (filename != NULL) xmlFree(filename);
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    if (fatal_errors != 0) return 0;

    /* for each possible captured_piece (i.e, everything but the two kings) check for capture
     * futurebases
     */

    for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	futurebase_cnt = 0;

	/* I've made this a bit more liberal now, because if we're dealing with move restrictions,
	 * then we might have a missing piece in the futurebase line up with one of our pieces that
	 * is identical to captured_piece in the sense that it's the same color and type, but not
	 * identical in the sense of next_identical_piece.
	 */

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if (tb->piece_type[captured_piece] == PAWN) {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_pawn] == tb->piece_color[captured_piece])
		    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
	    } else {
		if ((futurebases[fbnum]->extra_piece == -1)
		    && (futurebases[fbnum]->missing_non_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_non_pawn] == tb->piece_color[captured_piece])
		    && (futurebases[fbnum]->missing_pawn == -1)) futurebase_cnt ++;
	    }
	}

	/* If no such futurebase exists, then for every other piece, see if the piece restrictions
	 * would permit it to capture the original piece in question.  If so, there must be a prune
	 * statement, or it's an error.
	 */

	if (futurebase_cnt == 0) {

	    for (capturing_piece = 0; capturing_piece < tb->num_pieces; capturing_piece ++) {

		if (futurecaptures[capturing_piece][captured_piece] != -1) {

		    if (tb->piece_color[capturing_piece] == WHITE) {
			if (! (pruned_white_futuremoves
			       & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]))) {
			    fatal("No futurebase or pruning for WHITE move %s\n",
				  movestr[WHITE][futurecaptures[capturing_piece][captured_piece]]);
			    return 0;
			}
		    } else {
			if (! (pruned_black_futuremoves
			       & FUTUREVECTOR(futurecaptures[capturing_piece][captured_piece]))) {
			    fatal("No futurebase or pruning for BLACK move %s\n",
				  movestr[BLACK][futurecaptures[capturing_piece][captured_piece]]);
			    return 0;
			}
		    }
		}
	    }
	}
    }

    /* Pawns - check for both promotion and promotion capture futurebases here.  Same idea. */

    for (pawn = 0; pawn < tb->num_pieces; pawn ++) {

	int promoted_pieces_handled;

	if (tb->piece_type[pawn] != PAWN) continue;

	/* First, we're looking for promotion capture futurebases. */

	for (captured_piece = 0; captured_piece < tb->num_pieces; captured_piece ++) {

	    if ((captured_piece == tb->white_king) || (captured_piece == tb->black_king)) continue;

	    /* Check to see if the pawn can even be on a square where a promotion capture is
	     * possible.
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[pawn] & 0x00ff000000000000LL)) break;
	    } else {
		if (! (tb->legal_squares[pawn] & 0x000000000000ff00LL)) break;
	    }

	    /* Check to see that the other piece can be on a square where it could be promotion
	     * captured.  It's still possible that the other piece could be on a back rank, but
	     * never on a square where it could be captured by the pawn, but we leave that
	     * possibility unchecked.  It'd probably be best to tie this code in with the code in
	     * assign_numbers_to_futuremoves() - maybe by flagging which captures it was determined
	     * that promotion was possible in?
	     */

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (tb->legal_squares[captured_piece] & 0xff00000000000000LL)) continue;
	    } else {
		if (! (tb->legal_squares[captured_piece] & 0x00000000000000ffLL)) continue;
	    }

	    /* check all futurebases for a 'promotion capture' with captured_piece missing */

	    promoted_pieces_handled = 0;

	    if (promotion_captures[pawn][captured_piece] == -1) continue;

	    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
		if ((futurebases[fbnum]->extra_piece != -1)
		    && (futurebases[fbnum]->piece_color[futurebases[fbnum]->extra_piece]
			== (futurebases[fbnum]->invert_colors ? 1 - tb->piece_color[pawn] : tb->piece_color[pawn]))
		    && (futurebases[fbnum]->missing_non_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_non_pawn]
			== tb->piece_color[captured_piece])
		    && (tb->piece_type[futurebases[fbnum]->missing_non_pawn]
			== tb->piece_type[captured_piece])
		    && (futurebases[fbnum]->missing_pawn != -1)
		    && (tb->piece_color[futurebases[fbnum]->missing_pawn] == tb->piece_color[pawn])) {

		    promoted_pieces_handled
			|= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);

		    /* If the futurebase prunes stalemates, then a queen suffices for a rook or bishop. */

		    if ((futurebases[fbnum]->stalemate_prune_type == RESTRICTION_CONCEDE)
			&& (futurebases[fbnum]->stalemate_prune_color == tb->piece_color[pawn])
			&& (! futurebases[fbnum]->invert_colors)
			&& (futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece] == QUEEN)) {

			promoted_pieces_handled |= (1 << ROOK);
			promoted_pieces_handled |= (1 << BISHOP);
		    }
		}
	    }

	    /* If no such futurebase exists, then for every other piece, see if the piece
	     * restrictions would permit it to capture the original piece in question.  If so, there
	     * must be a prune statement, or it's an error.
	     */

	    for (i = 0; promoted_pieces[i] != 0; i ++) {

		if (promoted_pieces_handled & (1 << promoted_pieces[i])) continue;

		if (tb->piece_color[pawn] == WHITE) {
		    if (! (pruned_white_futuremoves
			   & FUTUREVECTOR(promotion_captures[pawn][captured_piece] + i))) {
			fatal("No futurebase or pruning for WHITE move %s\n",
			      movestr[WHITE][promotion_captures[pawn][captured_piece] + i]);
			return 0;
		    }
		} else {
		    if (! (pruned_black_futuremoves
			   & FUTUREVECTOR(promotion_captures[pawn][captured_piece] + i))) {
			fatal("No futurebase or pruning for BLACK move %s\n",
			      movestr[BLACK][promotion_captures[pawn][captured_piece] + i]);
			return 0;
		    }
		}
	    }
	}

	/* straight promotion futurebases */

	if (promotions[pawn] == -1) continue;

	promoted_pieces_handled = 0;

	for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	    if ((futurebases[fbnum]->extra_piece != -1)
		&& (futurebases[fbnum]->missing_non_pawn == -1)
		&& (futurebases[fbnum]->missing_pawn != -1)) {

		promoted_pieces_handled
		    |= (1 << futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece]);

		/* If the futurebase prunes stalemates, then a queen suffices for a rook or bishop. */

		if ((futurebases[fbnum]->stalemate_prune_type == RESTRICTION_CONCEDE)
		    && (futurebases[fbnum]->stalemate_prune_color == tb->piece_color[pawn])
		    && (! futurebases[fbnum]->invert_colors)
		    && (futurebases[fbnum]->piece_type[futurebases[fbnum]->extra_piece] == QUEEN)) {

		    promoted_pieces_handled |= (1 << ROOK);
		    promoted_pieces_handled |= (1 << BISHOP);
		}
	    }
	}

	for (i = 0; promoted_pieces[i] != 0; i ++) {

	    if (promoted_pieces_handled & (1 << promoted_pieces[i])) continue;

	    if (tb->piece_color[pawn] == WHITE) {
		if (! (pruned_white_futuremoves & FUTUREVECTOR(promotions[pawn] + i))) {
		    fatal("No futurebase or pruning for WHITE move %s\n",
			  movestr[WHITE][promotions[pawn] + i]);
		    return 0;
		}
	    } else {
		if (! (pruned_black_futuremoves & FUTUREVECTOR(promotions[pawn] + i))) {
		    fatal("No futurebase or pruning for BLACK move %s\n",
			  movestr[BLACK][promotions[pawn] + i]);
		    return 0;
		}
	    }
	}
    }

    /* Check for any futurebases that match our piece types exactly.  It (or they) must correspond
     * to restricted piece movements.
     */

    futurebase_cnt = 0;

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	if ((futurebases[fbnum]->extra_piece == -1)
	    && (futurebases[fbnum]->missing_pawn == -1)
	    && (futurebases[fbnum]->missing_non_pawn == -1)) futurebase_cnt ++;
    }

    /* I'd like to construct a mask of all allowable squares for each color and type of piece, and
     * verify that the futurebases or pruning actually account for all possible restricted
     * movements.  This would let me catch early things like forgetting to specify a g4 tablebase
     * for a pawn frozen on g2.  For now, we only check for missing pruning if there are no "normal"
     * futurebases at all.
     */

    if (futurebase_cnt == 0) {
	for (piece = 0; piece < tb->num_pieces; piece ++) {
	    for (sq = 0; sq < 64; sq ++) {
		if (futuremoves[piece][sq] != -1) {

		    if (tb->piece_color[piece] == WHITE) {
			if (! (pruned_white_futuremoves & FUTUREVECTOR(futuremoves[piece][sq]))) {
			    fatal("No futurebase or pruning for WHITE move %s\n",
				  movestr[WHITE][futuremoves[piece][sq]]);
			    return 0;
			}
		    } else {
			if (! (pruned_black_futuremoves & FUTUREVECTOR(futuremoves[piece][sq]))) {
			    fatal("No futurebase or pruning for BLACK move %s\n",
				  movestr[BLACK][futuremoves[piece][sq]]);
			    return 0;
			}
		    }
		}
	    }
	}
    }

    /* Unload the futurebases (for now; we'll need them again later) */

    for (fbnum = 0; fbnum < num_futurebases; fbnum ++) {
	unload_futurebase(futurebases[fbnum]);
    }

    return 1;
}


/***** INTRA-TABLE MOVE PROPAGATION *****/

/* We've got a move that needs to be propagated, so we back out one half-move to all of the
 * positions that could have gotten us here and update their counters in various obscure ways.
 */

void propagate_one_minimove_within_table(tablebase_t *tb, index_t future_index, local_position_t *current_position)
{
    index_t current_index;
    int dtm = get_entry_DTM(future_index);

    current_index = local_position_to_index(tb, current_position);

    if (current_index == -1) {
#if !CHECK_KING_LEGALITY_EARLY
	/* This can happen if we don't fully check en passant legality (but right now, we do) */
	fprintf(stderr, "Can't lookup position in intratable propagation!\n");
#endif
	return;
    }

#ifdef DEBUG_MOVE
    if (current_index == DEBUG_MOVE)
	printf("propagate_one_minimove_within_table:  current_index=%d; dtm=%d\n", current_index, dtm);
#endif

    /* Parent position is the FUTURE position.  We now back-propagate to
     * the current position, which is the PAST position.
     *
     * If the player to move in the FUTURE position wins, then we add one to that
     * player's win count in the PAST position.  On other other hand, if the player not
     * to move in the FUTURE position wins, then the player to move in the PAST position
     * has a winning move (the one we're considering).
     */

    if (dtm > 0) {
	insert_or_commit_propentry(current_index, -dtm, 1, 0);
    } else if (dtm < 0) {
	insert_or_commit_propentry(current_index, -dtm+1, 1, 0);
    } else if (get_entry_movecnt(future_index) == MOVECNT_PTM_WINS_UNPROPED) {
	insert_or_commit_propentry(current_index, -2, 1, 0);
    } else if (get_entry_movecnt(future_index) == MOVECNT_PNTM_WINS_UNPROPED) {
	insert_or_commit_propentry(current_index, 2, 1, 0);
    } else {
	fatal("Intra-table back prop doesn't match dtm or movecnt\n");
    }
}

void propagate_one_move_within_table(tablebase_t *tb, index_t future_index, local_position_t *position)
{
    int piece;

    /* We may need to consider a bunch of additional positions here that are identical to the base
     * position except that a single one of the pawns on the fourth or fifth ranks was capturable en
     * passant.
     * 
     * We key off the en_passant flag in the position that was passed in.  If it's set, then we're
     * back propagating a position that requires en passant, so we just do it.  Otherwise, we're
     * back propagating a position that doesn't require en passant, so we check for additional
     * en passant positions.
     */

    propagate_one_minimove_within_table(tb, future_index, position);

    if (position->en_passant_square == -1) {

	for (piece = 0; piece < tb->num_pieces; piece ++) {

	    if (tb->piece_color[piece] == position->side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    /* I've taken care to update board_vector in the routine that calls here specifically so
	     * we can check for en passant legality here.
	     */

	    if ((tb->piece_color[piece] == WHITE)
		&& (ROW(position->piece_position[piece]) == 3)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] - 16))) {
		position->en_passant_square = position->piece_position[piece] - 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    if ((tb->piece_color[piece] == BLACK)
		&& (ROW(position->piece_position[piece]) == 4)
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 8))
		&& !(position->board_vector & BITVECTOR(position->piece_position[piece] + 16))) {
		position->en_passant_square = position->piece_position[piece] + 8;
		propagate_one_minimove_within_table(tb, future_index, position);
	    }

	    position->en_passant_square = -1;
	}
    }
}

/* back_propagate_index_within_table()
 *
 * Once the final status of an index has been determined, this function back propagates all moves
 * (within the tablebase) from the corresponding position.
 */

void back_propagate_index_within_table(tablebase_t *tb, index_t index, int reflection)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    /* This can fail if the reflection isn't valid for this index */

    if (! index_to_local_position(tb, index, reflection, &position)) return;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	info("back_propagate_index_within_table; index=%d\n", index);
#endif

    flip_side_to_move_local(&position);

    /* If there are any en passant capturable pawns in the position, then the last move had to
     * have been a pawn move.  In fact, in this case, we already know exactly what the last move
     * had to have been.
     */

    if (position.en_passant_square != -1) {

	int en_passant_pawn = -1;

	for (piece = 0; piece < tb->num_pieces; piece++) {

	    if (tb->piece_color[piece] != position.side_to_move) continue;
	    if (tb->piece_type[piece] != PAWN) continue;

	    if (((tb->piece_color[piece] == WHITE)
		 && (position.piece_position[piece] - 8 == position.en_passant_square))
		|| ((tb->piece_color[piece] == BLACK)
		    && (position.piece_position[piece] + 8 == position.en_passant_square))) {
		if (en_passant_pawn != -1) fatal("Two en passant pawns in back prop?!\n");
		en_passant_pawn = piece;
	    }
	}
	if (en_passant_pawn == -1) {
	    fatal("No en passant pawn in back prop!?\n");
	} else {

	    position.en_passant_square = -1;

	    /* I go to the trouble to update board_vector here so we can check en passant
	     * legality in propagate_one_move_within_table().
	     */

	    position.board_vector &= ~BITVECTOR(position.piece_position[en_passant_pawn]);

	    if (tb->piece_color[en_passant_pawn] == WHITE)
		position.piece_position[en_passant_pawn] -= 16;
	    else
		position.piece_position[en_passant_pawn] += 16;

	    position.board_vector |= BITVECTOR(position.piece_position[en_passant_pawn]);

	    /* We never back out into a restricted position.  Since we've already decided that this
	     * is the only legal back-move from this point, well...
	     */

	    if (! (tb->semilegal_squares[en_passant_pawn]
		   & BITVECTOR(position.piece_position[en_passant_pawn]))) {
		return;
	    }

	    propagate_one_move_within_table(tb, index, &position);
	}

	return;
    }

    /* foreach (mobile piece of player NOT TO PLAY) { */

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We've moving BACKWARDS in the game, so we want the pieces of the player who is NOT TO
	 * PLAY here - this is the LAST move we're considering, not the next move.
	 */

	if (tb->piece_color[piece] != position.side_to_move)
	    continue;

	origin_square = position.piece_position[piece];

	position.board_vector &= ~BITVECTOR(origin_square);

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		/* What about captures?  Well, first of all, there are no captures here!  We're
		 * moving BACKWARDS in the game... and pieces don't appear out of thin air.
		 * Captures are handled by back-propagation from futurebases, not here in the
		 * movement code.  The piece moving had to come from somewhere, and that somewhere
		 * will now be an empty square, so once we've hit another piece along a movement
		 * vector, there's absolutely no need to consider anything further.
		 */

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* We never back out into a restricted position (obviously) */

		    if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		    /* Back stepping a half move here involves several things: flipping the
		     * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		     * the piece (backwards), and considering a bunch of additional positions
		     * identical to the base position except that a single one of the pawns on the
		     * fourth or fifth ranks was capturable en passant.
		     *
		     * Of course, the only way we could have gotten an en passant pawn is if THIS
		     * MOVE created it.  Since this isn't a pawn move, that can't happen.  Checking
		     * additional en passant positions is taken care of in
		     * propagate_one_move_within_table()
		     */

		    /* I go to the trouble to update board_vector here so we can check en passant
		     * legality in propagate_one_move_within_table().
		     */

		    position.piece_position[piece] = movementptr->square;

		    position.board_vector |= BITVECTOR(movementptr->square);

		    propagate_one_move_within_table(tb, index, &position);

		    position.board_vector &= ~BITVECTOR(movementptr->square);
		}
	    }

	} else {

	    /* Usual special case for pawns */

	    for (movementptr = normal_pawn_movements_bkwd[origin_square][tb->piece_color[piece]];
		 (movementptr->vector & position.board_vector) == 0;
		 movementptr++) {

		/* We never back out into a restricted position (obviously) */

		if (! (tb->semilegal_squares[piece] & movementptr->vector)) continue;

		/* Do we have a backwards pawn move here?
		 *
		 * Back stepping a half move here involves several things: flipping the
		 * side-to-move flag, clearing any en passant pawns into regular pawns, moving
		 * the piece (backwards), and considering a bunch of additional positions
		 * identical to the base position except that a single one of the pawns on the
		 * fourth or fifth ranks was capturable en passant.
		 *
		 * Of course, the only way we could have gotten an en passant pawn is if THIS MOVE
		 * created it.  We handle that as a special case above, so we shouldn't have to
		 * worry about clearing en passant pawns here - there should be none.  Checking
		 * additional en passant positions is taken care of in
		 * propagate_one_move_within_table()
		 *
		 * But we start with an extra check to make sure this isn't a double pawn move, in
		 * which case it would result in an en passant position, not the non-en passant
		 * position we are in now (en passant got taken care of in the special case
		 * above)...  unless we are using the "no-en-passant" index type, in which case we
		 * don't consider en passant at all, and so have to handle the double move here.
		 */

		if (((movementptr->square - origin_square) == 16)
		    || ((movementptr->square - origin_square) == -16)) {
		    if (tb->index_type != NO_EN_PASSANT_INDEX) continue;
		}

		/* I go to the trouble to update board_vector here so we can check en passant
		 * legality in propagate_one_move_within_table().
		 */

		position.piece_position[piece] = movementptr->square;

		position.board_vector |= BITVECTOR(movementptr->square);

		propagate_one_move_within_table(tb, index, &position);

		position.board_vector &= ~BITVECTOR(movementptr->square);
	    }
	}

	position.piece_position[piece] = origin_square;
	position.board_vector |= BITVECTOR(origin_square);
    }
}

/* initialize_tablebase()
 *
 * This is another critical function; don't be deceived by the tame word 'initialize'.
 *
 * We determine that a position is won for the player not to move (PNTM) if all possible moves (of
 * the player to move) lead to a won game for PNTM.  We count down this total during back
 * propagation, so it stands to reason that we need an accurate count to start with.  Thus the
 * importance of this function.
 *
 * Basically, there are two types of moves we need to consider in each position:
 *
 * 1. non-capture, non-promotion, non-restricted moves
 *
 * We just add these up and then count them down during intra-table propagation, depending on the
 * integrity of the program's algorithm to make sure that every move counted forward gets considered
 * as a move backward.
 *
 * 2. everything else (futuremoves)
 *
 * These always lead to a different tablebase (a futurebase).  The only way we handle them is
 * through inter-table back propagation.  We keep a seperate count of futuremoves because, unlike
 * intratable moves, we might miss some of these moves if we don't have a complete set of
 * futurebases.  So we count futuremoves by themselves (as well as part of the standard count), and
 * count them down normally during a single sweep through our futurebases.  If that takes care of
 * everything fine.  Otherwise, during our first pass through the current tablebase, we'll find that
 * some of the futuremoves remain unaccounted for.  If they occur with the "good guys" as PTM, we
 * just double-check that the restriction is OK, subtract the remaining futuremoves out from the
 * standard count, and keep going.  But if the "bad guys" are PTM, then some more work is needed.
 * The position is marked won for PTM, unless we want to step forward another half move.  In this
 * case, we compute all possible next moves (or maybe just captures), and search for them in our
 * tablebases.  If any of them are marked drawn or won, we can safely back-propagate this.
 * Otherwise, the position has to be marked won for PTM, as before.
 *
 * There's a real serious speed penalty here, because this half-move-forward algorithm requires
 * random access lookups in the futurebases.  A possible way to address this would be to create an
 * intermediate tablebase for the half move following the capture/promotion.  This could be done by
 * building a tablebase with a queen (and another one with a knight) frozen on the queening square.
 * Any possible move of the queen or knight would result in a win for the moving side.  A similar
 * shortcut could be done for a capture, though the only real justification (from a performance
 * perspective) would be on promotions.
 *
 */

int PTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    struct movement *movementptr;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is NOT to move... */

	if (tb->piece_color[piece] == position->side_to_move) continue;

	/* We might have removed the piece from the position... */

	if (position->piece_position[piece] == -1) continue;

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][position->piece_position[piece]][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[position->piece_position[piece]][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

	    }
	}
    }

    return 0;
}

int PNTM_in_check(tablebase_t *tb, local_position_t *position)
{
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;

    for (piece = 0; piece < tb->num_pieces; piece++) {

	/* We only want to consider pieces of the side which is to move... */

	if (tb->piece_color[piece] != position->side_to_move) continue;

	origin_square = position->piece_position[piece];

	if (tb->piece_type[piece] != PAWN) {

	    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
		     (movementptr->vector & position->board_vector) == 0;
		     movementptr++) {
		}

		/* Now check to see if the movement ended because we hit against the king
		 * of the opposite color.  If so, we're in check.
		 */

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

	    }
	} else {
	    for (movementptr = capture_pawn_movements[origin_square][tb->piece_color[piece]];
		 movementptr->square != -1;
		 movementptr++) {

		if ((position->side_to_move == WHITE)
		    && (movementptr->square == position->piece_position[tb->black_king])) return 1;

		if ((position->side_to_move == BLACK)
		    && (movementptr->square == position->piece_position[tb->white_king])) return 1;

	    }
	}
    }

    return 0;
}

futurevector_t initialize_tablebase_entry(tablebase_t *tb, index_t index)
{
    local_position_t position;
    int piece;
    int dir;
    int origin_square;
    struct movement *movementptr;
    int i;

#ifdef DEBUG_MOVE
    if (index == DEBUG_MOVE)
	fprintf(stderr, "Initializing %d\n", index);
#endif

    if (! index_to_local_position(tb, index, REFLECTION_NONE, &position)) {

	initialize_entry_as_illegal(tb, index);
	return 0;

    } else {

	/* Now we need to count moves.  FORWARD moves. */
	int movecnt = 0;
	int futuremovecnt = 0;
	futurevector_t futurevector = 0;

	/* En passant:
	 *
	 * We're just counting moves here.  In particular, we don't compute the indices of the
	 * resulting positions.  If we did, we'd have to worry about clearing en passant status
	 * from any of fourth or fifth rank pawns, but we don't have to worry about it.
	 *
	 * We do have to count one or two possible extra en passant pawn captures, though...
	 */


	for (piece = 0; piece < tb->num_pieces; piece++) {

	    /* We only want to consider pieces of the side which is to move... */

	    if (tb->piece_color[piece] != position.side_to_move) continue;

	    origin_square = position.piece_position[piece];
	    position.board_vector &= ~BITVECTOR(origin_square);

	    if (tb->piece_type[piece] != PAWN) {

		for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

		    for (movementptr = movements[tb->piece_type[piece]][origin_square][dir];
			 (movementptr->vector & position.board_vector) == 0;
			 movementptr++) {

#if CHECK_KING_LEGALITY_EARLY
			if (piece == tb->white_king) {
			    if (! check_king_legality(movementptr->square,
						      position.piece_position[tb->black_king])) continue;
			}
			if (piece == tb->black_king) {
			    if (! check_king_legality(movementptr->square,
						      position.piece_position[tb->white_king])) continue;
			}
#endif

			/* Completely discard king moves into check by frozen pieces */

			if ((piece == tb->white_king)
			    && (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
			if ((piece == tb->black_king)
			    && (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

			/* Move the piece, so we can test the new position for check */

			position.piece_position[piece] = movementptr->square;

			position.board_vector |= BITVECTOR(movementptr->square);

			/* If we're NOT moving into check AND the piece is moving outside its legal
			 * squares AND we can't permute the pieces into a position where everything
			 * is legal, we regard this as a futuremove (since it will require back prop
			 * from futurebases).  We could just check if local_position_to_index()
			 * returns a valid index, but checking the legal_squares bitvector first
			 * makes this a little faster.
			 */

			if (! PTM_in_check(tb, &position)) {

			    if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& (local_position_to_index(tb, &position) == -1)) {

				if (futuremoves[piece][movementptr->square] == -1) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("No futuremove: %s %c%c%c\n", global_position_to_FEN(&global),
					  piece_char[tb->piece_type[piece]],
					  'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				}
				if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				    fatal("Duplicate futuremove!\n");
				}
				futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
				futuremovecnt ++;
			    }

			    movecnt ++;
			}

			position.board_vector &= ~BITVECTOR(movementptr->square);

		    }

		    /* Now check to see if the movement ended because we hit against another piece
		     * of the opposite color.  If so, add another move for the capture.
		     *
		     * Actually, we check to see that we DIDN'T hit a piece of our OWN color.  The
		     * difference is that this way we don't register a capture if we hit the end of
		     * the list of movements in a given direction.
		     *
		     * We also check to see if the capture was against the enemy king! in which case
		     * this position is a "mate in 0" (i.e, illegal)
		     */

#if CHECK_KING_LEGALITY_EARLY
		    if (piece == tb->white_king) {
			if (! check_king_legality(movementptr->square, position.piece_position[tb->black_king]))
			    continue;
		    }
		    if (piece == tb->black_king) {
			if (! check_king_legality(movementptr->square, position.piece_position[tb->white_king]))
			    continue;
		    }
#endif
		    /* Completely discard king moves into check by frozen pieces */

		    if ((piece == tb->white_king)
			&& (tb->illegal_white_king_squares & BITVECTOR(movementptr->square))) continue;
		    if ((piece == tb->black_king)
			&& (tb->illegal_black_king_squares & BITVECTOR(movementptr->square))) continue;

		    if ((movementptr->vector & position.PTM_vector) == 0) {

			for (i = 0; i < tb->num_pieces; i ++) {
			    if (movementptr->square == position.piece_position[i]) {
				if ((i == tb->black_king) || (i == tb->white_king)) {
				    initialize_entry_with_PNTM_mated(tb, index);
				    return 0;
				}

				position.piece_position[i] = -1;
				position.piece_position[piece] = movementptr->square;

				if (! PTM_in_check(tb, &position)) {

				    if (futurecaptures[piece][i] == -1) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    }
				    if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    }

				    futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				    futuremovecnt ++;
				    movecnt ++;
				}

				position.piece_position[i] = movementptr->square;

				break;
			    }
			}
			if (i == tb->num_pieces) {
			    fatal("Couldn't match capture!\n");
			}
		    }
		}

	    } else {

		/* Pawns, as always, are special */

		for (movementptr = normal_pawn_movements[origin_square][tb->piece_color[piece]];
		     (movementptr->vector & position.board_vector) == 0;
		     movementptr++) {

		    /* Move the piece.  The in-check test below require this. */

		    position.piece_position[piece] = movementptr->square;
		    position.board_vector |= BITVECTOR(movementptr->square);

		    /* What about pawn promotions here?  Well, we're looking to see if the moving
		     * side is in check after the pawn move, and the only way the pawn could affect
		     * this is by blocking the check.  It still blocks no matter what it promotes
		     * into, so we don't have to distinguish between promotion and non-promotion
		     * moves here.
		     */

		    if (! PTM_in_check(tb, &position)) {

			/* If the piece is a pawn and we're moving to the last rank, then this has
			 * to be a promotion move, in fact, PROMOTION_POSSIBILITIES moves.  (queen,
			 * knight, maybe rook and bishop).  As such, they will require back
			 * propagation from futurebases and must therefore be flagged as
			 * futuremoves.
			 */

			if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			    if (promotions[piece] == -1) {
				global_position_t global;
				index_to_global_position(tb, index, &global);
				fatal("No futuremove: %s %c=?\n", global_position_to_FEN(&global),
				      piece_char[tb->piece_type[piece]]);
			    }
			    if (futurevector & FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES)) {
				fatal("Duplicate futuremove!\n");
			    }
			    futurevector |= FUTUREVECTORS(promotions[piece], PROMOTION_POSSIBILITIES);
			    futuremovecnt += PROMOTION_POSSIBILITIES;
			    movecnt += PROMOTION_POSSIBILITIES;

			} else {

			    /* If a piece is moving outside its legal squares AND we can't permute
			     * the pieces into a position where everything is legal, we regard this
			     * as a futuremove (since it will require back prop from futurebases).
			     */

			    if (!(tb->legal_squares[piece] & BITVECTOR(movementptr->square))
				&& (local_position_to_index(tb, &position) == -1)) {

				if (futuremoves[piece][movementptr->square] == -1) {
				    global_position_t global;
				    index_to_global_position(tb, index, &global);
				    fatal("No futuremove: %s %c%c%c\n", global_position_to_FEN(&global),
					  piece_char[tb->piece_type[piece]],
					  'a' + COL(movementptr->square), '1' + ROW(movementptr->square));
				}
				if (futurevector & FUTUREVECTOR(futuremoves[piece][movementptr->square])) {
				    fatal("Duplicate futuremove!\n");
				}
				futurevector |= FUTUREVECTOR(futuremoves[piece][movementptr->square]);
				futuremovecnt ++;
			    }

			    movecnt ++;
			}
		    }

		    position.board_vector &= ~BITVECTOR(movementptr->square);

		}


		/* Pawn captures.
		 *
		 * In this part of the code, we're just counting forward moves, and all captures
		 * are futurebase moves, so the only difference to us whether this is a
		 * promotion move or not is how many futuremoves get recorded.
		 */

		for (movementptr = capture_pawn_movements[origin_square][tb->piece_color[piece]];
		     movementptr->square != -1;
		     movementptr++) {

		    /* If we're capturing to the last rank, then this has to be a promotion move, in
		     * fact, PROMOTION_POSSIBILITIES moves.  (queen, knight, maybe rook and bishop).
		     */

		    int is_promotion_capture =
			((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0));

		    /* A special check for en passant captures.  */

		    if (movementptr->square == position.en_passant_square) {

			for (i = 0; i < tb->num_pieces; i ++) {
			    if ((i == tb->white_king) || (i == tb->black_king)) continue;
			    if (movementptr->square + (tb->piece_color[piece] == WHITE ? -8 : 8)
				== position.piece_position[i]) {

				position.piece_position[piece] = position.en_passant_square;
				position.board_vector |= BITVECTOR(position.en_passant_square);
				position.board_vector &= ~BITVECTOR(position.piece_position[i]);
				position.piece_position[i] = -1;

				if (! PTM_in_check(tb, &position)) {
				    if (futurecaptures[piece][i] == -1) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    }
				    if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    }
				    futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				    futuremovecnt ++;
				    movecnt ++;
				}

				position.piece_position[i] = position.en_passant_square
				    + (tb->piece_color[piece] == WHITE ? -8 : 8);
				position.board_vector |= BITVECTOR(position.piece_position[i]);
				position.board_vector &= ~BITVECTOR(position.en_passant_square);

				break;
			    }
			}
			continue;
		    }

		    if (((movementptr->vector & position.board_vector) == 0)
			|| ((movementptr->vector & position.PTM_vector) != 0)) continue;

		    for (i = 0; i < tb->num_pieces; i ++) {
			if (movementptr->square == position.piece_position[i]) {
			    if ((i == tb->black_king) || (i == tb->white_king)) {
				initialize_entry_with_PNTM_mated(tb, index);
				return 0;
			    }

			    position.piece_position[i] = -1;
			    position.piece_position[piece] = movementptr->square;

			    if (! PTM_in_check(tb, &position)) {
				if (! is_promotion_capture) {
				    if (futurecaptures[piece][i] == -1) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    }
				    if (futurevector & FUTUREVECTOR(futurecaptures[piece][i])) {
					fatal("Duplicate futuremove!\n");
				    }
				    futurevector |= FUTUREVECTOR(futurecaptures[piece][i]);
				    futuremovecnt ++;
				    movecnt ++;
				} else {
				    if (promotion_captures[piece][i] == -1) {
					global_position_t global;
					index_to_global_position(tb, index, &global);
					fatal("No futuremove: %s %cx%c=*\n", global_position_to_FEN(&global),
					      piece_char[tb->piece_type[piece]],
					      piece_char[tb->piece_type[i]]);
				    }
				    if (futurevector
					& FUTUREVECTORS(promotion_captures[piece][i],
							PROMOTION_POSSIBILITIES)) {
					fatal("Duplicate futuremove!\n");
				    }
				    futurevector |= FUTUREVECTORS(promotion_captures[piece][i],
								  PROMOTION_POSSIBILITIES);
				    futuremovecnt += PROMOTION_POSSIBILITIES;
				    movecnt += PROMOTION_POSSIBILITIES;
				}
			    }

			    position.piece_position[i] = movementptr->square;
			    break;
			}
		    }

		    if (i == tb->num_pieces) {
			fatal("Couldn't match pawn capture!\n");
		    }


		}

	    }

	    position.board_vector |= BITVECTOR(origin_square);
	    position.piece_position[piece] = origin_square;

	}

	/* Finally, if every possible moves leads us into check, we determine if we're in check,
	 * being the difference between this being checkmate or stalemate.
	 */

	if (movecnt == 0) {
	    if (PTM_in_check(tb, &position)) {
		initialize_entry_with_PTM_mated(tb, index);
	    } else {
		initialize_entry_with_stalemate(tb, index);
	    }
	    return 0;
	} else {

	    total_moves += movecnt;
	    total_futuremoves += futuremovecnt;

	    /* What's this?  Well, diagonal symmetry is more difficult to handle than other types of
	     * symmetry because the piece along the diagonal don't actually move when you reflect
	     * the board.  So, here, we double the movecnt to account for the symmetry so long as
	     * the white king isn't on the a1/h8 diagonal.
	     *
	     * Other kinds of symmetry (horizontal and vertical) we can basically ignore at this
	     * point, but please explain why.
	     */

	    /* Symmetry and multiplicty.  If we're using a symmetric index, then there might be more
	     * than one actual board position that corresponds to a given index value.  The number
	     * of non-identical board positions for a given index is called its multiplicity.  So
	     * here we multiply the movecnt by the multiplicity of the position to get the total
	     * number of moves out of all possible positions that correspond to this index.
	     */

	    movecnt *= position.multiplicity;

	    initialize_entry_with_movecnt(tb, index, movecnt);

#ifdef DEBUG_MOVE
	    if (index == DEBUG_MOVE) {
		/* other fields were printed by DEBUG_MOVE statement in initialize_entry() */
		info("   futurevector 0x%llx\n", futurevector);
	    }
#endif

	    return futurevector;
	}
    }
}

void initialize_tablebase(tablebase_t *tb)
{
    index_t index;

    for (index=0; index <= tb->max_index; index++) {
	tb->futurevectors[index] = initialize_tablebase_entry(tb, index);
    }
}

/* Intra-table propagation is almost trivial.  Keep making passes over the tablebase first until
 * we've hit dtm_limit, which means we've processed everything from the futurebases, then until no
 * more progress is made on a given pass.
 */

void propagate_all_moves_within_tablebase(tablebase_t *tb, int lower_dtm_limit, int upper_dtm_limit)
{
    int dtm = 1;

    /* DTM 1 positions are illegal (PNTM is in check), so back prop from these positions is not
     * necessary because we don't count moves into check as part of movecnt.
     */

    positive_passes_needed[1] = 0;

    while ((dtm <= upper_dtm_limit) || (-dtm >= lower_dtm_limit)) {

	/* PTM wins */
	if (positive_passes_needed[dtm]) propagation_pass(dtm);

	/* PNTM wins */
	if (negative_passes_needed[dtm]) propagation_pass(-dtm);

	dtm ++;
    }

    while (1) {

	/* PTM wins */
	if (positive_passes_needed[dtm]) propagation_pass(dtm);
	else break;

	/* PNTM wins */
	if (negative_passes_needed[dtm]) propagation_pass(-dtm);
	else break;

	dtm ++;
    }

}

void write_tablebase_to_file(tablebase_t *tb, char *filename, char *options)
{
    xmlDocPtr doc;
    int index;
    FILE *file = NULL;
    xmlNodePtr tablebase;
    xmlChar *buf;
    int size;
    int padded_size;
    char str[16];
    char entrybuf[MAX_FORMAT_BYTES];
    void *entry = entrybuf;
    int dtm;
    int raw_dtm;

    if (filename != NULL) {
	if (rindex(filename, ':') == NULL) {
	    file = fopen(filename, "w");
	} else {
	    file = url_fopen(filename, "w");
	}
    } else {
	xmlXPathContextPtr context;
	xmlXPathObjectPtr result;

	context = xmlXPathNewContext(tb->xml);
	result = xmlXPathEvalExpression(BAD_CAST "//output", context);

	if (result->nodesetval->nodeNr == 1) {
	    if ((filename = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "filename"))
		!= NULL) {
		file = fopen(filename, "w");
	    } else if ((filename = (char *) xmlGetProp(result->nodesetval->nodeTab[0], BAD_CAST "url"))
		       != NULL) {
		file = url_fopen(filename, "w");
	    }
	}

	xmlXPathFreeObject(result);
	xmlXPathFreeContext(context);
    }

    if (file == NULL) {
	fatal("Can't open output tablebase\n");
	terminate();
    }

    file = zlib_fopen(file, "w");

    if (file == NULL) {
	fatal("Can't zlib_fopen output tablebase\n");
	terminate();
    }

    info("Writing '%s'\n", filename);

    doc = finalize_XML_header(tb, options);

    /* We want at least one zero byte after the XML header, because that's how we figure out where
     * it ends when we read it back it, and I also want to align the tablebase on a four-byte
     * boundary for the hell of it.  (size+5)&(~3) achieves these goals.  I then modify the XML
     * header with the updated string that gives the offset to the tablebase, and make sure that its
     * size hasn't changed.
     */

    xmlDocDumpMemory(doc, &buf, &size);
    padded_size = (size+5)&(~3);

    sprintf(str, "0x%04x", padded_size);

    tablebase = xmlDocGetRootElement(doc);
    xmlSetProp(tablebase, BAD_CAST "offset", BAD_CAST str);

    xmlDocDumpMemory(doc, &buf, &size);

    if (padded_size != ((size+5)&(~3))) {
	fatal("sizes don't match in write_tablebase_to_file\n");
	terminate();
    }

    if (fwrite(buf, padded_size, 1, file) != 1) {
	fatal("Tablebase write failed\n");
	terminate();
    }

    xmlFree(buf);

    for (index = 0; index <= tb->max_index; index ++) {

	dtm = get_entry_DTM(index);
	raw_dtm = get_entry_raw_DTM(index);

	if (tb->format.dtm_bits > 0) {
	    /* If we're saving movecnt, then use the raw DTM, else "cook" it. */
	    set_signed_field(entry, tb->format.dtm_mask,
			     tb->format.dtm_offset + ((index << tb->format.bits) % 8),
			     (tb->format.movecnt_bits > 0) ? raw_dtm : dtm);
	}

	if (tb->format.movecnt_bits > 0) {
	    int movecnt = get_entry_movecnt(index);
	    set_unsigned_field(entry, tb->format.movecnt_mask,
			       tb->format.movecnt_offset + ((index << tb->format.bits) % 8),
			       movecnt);
	}

	switch (tb->format.flag_type) {
	case FORMAT_FLAG_WHITE_WINS:
	    set_unsigned_field(entry, 1,
			       tb->format.flag_offset + ((index << tb->format.bits) % 8),
			       (index_to_side_to_move(tb, index) == WHITE)
			       ? does_PTM_win(index) : does_PNTM_win(index));
	    break;
	case FORMAT_FLAG_WHITE_DRAWS:
	    set_unsigned_field(entry, 1,
			       tb->format.flag_offset + ((index << tb->format.bits) % 8),
			       (index_to_side_to_move(tb, index) == WHITE)
			       ? !does_PNTM_win(index) : !does_PTM_win(index));
	    break;
	}

	/* If the next index will be aligned on a byte boundary, write out what we've buffered */

	if ((((index + 1) << tb->format.bits) % 8) == 0) {
	    if (fwrite(entry, tb->format.bytes, 1, file) != 1) {
		fatal("Tablebase write failed\n");
		terminate();
	    }
	}
    }

    /* If the last index plus one wasn't on a byte boundary, write out what we've buffered */
    
    if (((index << tb->format.bits) % 8) != 0) {
	if (fwrite(entry, tb->format.bytes, 1, file) != 1) {
	    fatal("Tablebase write failed\n");
	    terminate();
	}
    }

    if (fclose(file) != 0) {
	fatal("Tablebase write failed\n");
	terminate();
    }
}

/* The "master routine" for tablebase generation.
 *
 * Many of these subroutines have already printed error messages of their own if they return
 * an error indication, which is why we just silently return in many cases.
 */

boolean generate_tablebase_from_control_file(char *control_filename, char *output_filename, char *options) {

    tablebase_t *tb;
    int max_dtm = 0;
    int min_dtm = 0;
    xmlXPathContextPtr context;
    xmlXPathObjectPtr result;
    struct rlimit rlimit;

    tb = parse_XML_control_file(control_filename);
    if (tb == NULL) return 0;

    /* Need this no matter what.  I want to replace it with a global static tablebase for everything. */
    current_tb = tb;

    context = xmlXPathNewContext(tb->xml);
    result = xmlXPathEvalExpression(BAD_CAST "//output", context);
    if ((result->nodesetval->nodeNr == 0) && (output_filename == NULL)) {
	fatal("Output filename must be specified either on command line or with <output> tag\n");
	return 0;
    }
    if ((result->nodesetval->nodeNr > 0) && (output_filename != NULL)) {
	warning("WARNING: Output filename specified on command line overrides <output> tag\n");
    }
    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);

    num_propentries = proptable_MBs * 1024 * 1024 / PROPTABLE_FORMAT_BYTES;

#if USE_PROPTABLES
	if (num_propentries == 0) {
	    fatal("Using proptables, but proptable size not specified\n");
	    return 0;
	}
	tb->entries_fd = open("entries", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE | O_DIRECT, 0666);
	if (tb->entries_fd == -1) {
	    fatal("Can't open 'entries' for read-write: %s\n", strerror(errno));
	    return 0;
	}
	init_entry_buffers(tb);
#else
	tb->entries = (entry_t *) malloc(LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3));
	if (tb->entries == NULL) {
	    fatal("Can't malloc tablebase entries: %s\n", strerror(errno));
	    return 0;
	}
	memset(tb->entries, 0, LEFTSHIFT(tb->max_index + 1, ENTRIES_FORMAT_BITS - 3));
#endif

#if USE_PROPTABLES
#if USE_DUAL_PROPTABLES
	/* This is here so we can use O_DIRECT when writing the proptable out to disk.  1024 is a guess. */
	if (posix_memalign((void **) &proptable1, 1024, num_propentries * PROPTABLE_FORMAT_BYTES) != 0) {
	    fatal("Can't posix_memalign proptable: %s\n", strerror(errno));
	    return 0;
	}
	/* POSIX doesn't guarantee that the memory will be zeroed (but Linux seems to zero it) */
	memset(proptable1, 0, num_propentries * PROPTABLE_FORMAT_BYTES);

	if (posix_memalign((void **) &proptable2, 1024, num_propentries * PROPTABLE_FORMAT_BYTES) != 0) {
	    fatal("Can't posix_memalign proptable: %s\n", strerror(errno));
	    return 0;
	}
	memset(proptable2, 0, num_propentries * PROPTABLE_FORMAT_BYTES);

	proptable = proptable1;

#if ZERO_PROPTABLES_USING_DISK
	zeros_fd = open("zeros", O_RDWR | O_CREAT | O_TRUNC | O_LARGEFILE, 0666);
	if (zeros_fd == -1) {
	    fatal("Can't open 'zeros' for writing zero propfile: %s\n", strerror(errno));
	    return 0;
	}
	do_write(zeros_fd, proptable1, num_propentries * PROPTABLE_FORMAT_BYTES);
#endif
#else
	/* This is here so we can use O_DIRECT when writing the proptable out to disk.  1024 is a guess. */
	if (posix_memalign((void **) &proptable, 1024, num_propentries * PROPTABLE_FORMAT_BYTES) != 0) {
	    fatal("Can't posix_memalign proptable: %s\n", strerror(errno));
	    return 0;
	}
	/* POSIX doesn't guarantee that the memory will be zeroed (but Linux seems to zero it) */
	memset(proptable, 0, num_propentries * PROPTABLE_FORMAT_BYTES);

	proptable1 = proptable;
	proptable2 = proptable;
#endif
#endif

    assign_numbers_to_futuremoves(tb);
    print_futuremoves();
    if (! compute_pruned_futuremoves(tb)) return 0;
    if (! check_pruning(tb, &max_dtm, &min_dtm)) return 0;

    if (! check_1000_indices(tb)) return 0;
    /* check_1000_positions(tb); */  /* This becomes a problem with symmetry, among other things */

#if !USE_PROPTABLES

	/* No proptables.  Allocate a futurevectors array, initialize the tablebase, back propagate
	 * the futurebases (noting which futuremoves have been handled in the futurevectors array),
	 * and run through the futurevectors array checking for unhandled futuremoves.
	 */

	/* tb->futurevectors = (futurevector_t *) calloc(tb->max_index + 1, sizeof(futurevector_t)); */
	tb->futurevectors = (futurevector_t *) malloc((tb->max_index + 1) * sizeof(futurevector_t));
	if (tb->futurevectors == NULL) {
	    fatal("Can't malloc tablebase futurevectors: %s\n", strerror(errno));
	    return 0;
	}
	memset(tb->futurevectors, 0, (tb->max_index + 1) * sizeof(futurevector_t));

	/* Due to the heavily random access pattern of memory during back propagation, this
	 * application performs horribly if required to swap.  Attempt to lock all of its pages into
	 * memory, and die with a fatal error if we couldn't.  It seems better to die here, so we
	 * can detect this condition and rerun with either simpler tablebases (if there are pawns
	 * that can be factored) or using proptables.
	 *
	 * I'm finding that this system call is dangerous on Linux.  If you haven't set a resource
	 * limit, it can hang the machine if you try to lock more memory than the system physically
	 * possesses.  So I check first to make sure that a limit has been set before attempting the
	 * lock.
	 *
	 * The #ifdef keeps this from even being attempted on a Windows system.
	 */

#ifdef RLIMIT_MEMLOCK

	if (getrlimit(RLIMIT_MEMLOCK, &rlimit) == -1) {
	    warning("Can't getrlimit RLIMIT_MEMLOCK: %s\n", strerror(errno));
	} else if (rlimit.rlim_cur != 0) {
	    if (mlockall(MCL_CURRENT) == -1) {
		fatal("Can't mlockall memory: %s\n", strerror(errno));
		return 0;
	    }
	}

#endif

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "initialization";

	info("Initializing tablebase\n");
	initialize_tablebase(tb);

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	info("Total legal positions: %lld\n", total_legal_positions);
	info("Total moves: %lld\n", total_moves);

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futurebase backprop";

	if (! back_propagate_all_futurebases(tb)) return 0;

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futuremove check";

	info("Checking futuremoves...\n");
	/* propagation_pass(0); */
	if (! have_all_futuremoves_been_handled(tb)) return 0;
	info("All futuremoves handled under move restrictions\n");

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	free(tb->futurevectors);
	tb->futurevectors=NULL;

#else

	/* Using proptables.  No futurevectors array.  We back propagate the futurebases into the
	 * proptable, then in a single pass initialize the entries array and commit the proptable
	 * into it, checking each position move as we go to make sure its futuremoves are handled.
	 */

	gettimeofday(&pass_start_times[total_passes], NULL);
	pass_type[total_passes] = "futurebase backprop";

	if (! back_propagate_all_futurebases(tb)) return 0;
	proptable_full();  /* flush moves out to disk */
	finalize_proptable_write();

	gettimeofday(&pass_end_times[total_passes], NULL);
	total_passes ++;

	info("Initializing tablebase...\n");
	pass_type[total_passes] = "initialization";
	propagation_pass(0);
	proptable_full();  /* flush moves out to disk */
	finalize_proptable_write();

	info("Total legal positions: %lld\n", total_legal_positions);
	info("Total moves: %lld\n", total_moves);

	info("All futuremoves handled under move restrictions\n");

#endif

    /* We add one to dtm_limit here because, even if there are intra-table passes with no
     * progress made, we want to process at least one pass beyond the maximum mate-in value we
     * saw during futurebase back-prop.
     */

    info("Intra-table propagating\n");
    propagate_all_moves_within_tablebase(tb, min_dtm-1, max_dtm+1);

    write_tablebase_to_file(tb, output_filename, options);

    return 1;
}

/***** PROBING NALIMOV TABLEBASES *****/

#ifdef USE_NALIMOV

int EGTBProbe(int wtm, unsigned char board[64], int sqEnP, int *score);

int IInitializeTb(char *pszPath);

int FTbSetCacheSize(void    *pv, unsigned long   cbSize );

#define EGTB_CACHE_DEFAULT (1024*1024)

void *EGTB_cache;

char *nalimov_path = ".";

void init_nalimov_code(void)
{
    int nalimov_num;

    nalimov_num = IInitializeTb(nalimov_path);
    printf("%d piece Nalimov tablebases found\n", nalimov_num);
    EGTB_cache = malloc(EGTB_CACHE_DEFAULT);
    if (EGTB_cache == NULL) {
	fprintf(stderr, "Can't malloc EGTB cache\n");
    } else {
	FTbSetCacheSize(EGTB_cache, EGTB_CACHE_DEFAULT);
    }
}

char * nalimov_to_english(int score)
{
    static char buffer[256];

    if (score > 0) {
	sprintf(buffer, "mate in %d", ((65536-4)/2)-score+1);
    } else if (score < 0) {
	sprintf(buffer, "mated in %d", ((65536-4)/2)+score);
    } else {
	sprintf(buffer, "draw");
    }

    return buffer;
}

void verify_tablebase_against_nalimov(tablebase_t *tb)
{
    index_t index;
    global_position_t global;
    local_position_t local;
    int score;

    info("Verifying tablebase against Nalimov\n");

    for (index = 0; index <= tb->max_index; index++) {
	if (index_to_global_position(tb, index, &global)) {

	    index_to_local_position(tb, index, REFLECTION_NONE, &local);

	    if (PNTM_in_check(tb, &local)) {

		/* I've learned the hard way not to probe a Nalimov tablebase for an illegal position... */

	    } else if ((global.en_passant_square != -1)
		       && ((global.board[global.en_passant_square - 9] != 'P')
			   || (global.en_passant_square == 40)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square - 7] != 'P')
			   || (global.en_passant_square == 47)
			   || (global.side_to_move == BLACK))
		       && ((global.board[global.en_passant_square + 7] != 'p')
			   || (global.en_passant_square == 16)
			   || (global.side_to_move == WHITE))
		       && ((global.board[global.en_passant_square + 9] != 'p')
			   || (global.en_passant_square == 23)
			   || (global.side_to_move == WHITE))) {

		/* Nor does Nalimov like it if the en passant pawn can't actually be captured by
		 * another pawn.
		 */

	    } else if (EGTBProbe(global.side_to_move == WHITE, global.board, global.en_passant_square, &score) == 1) {

		if (tb->format.dtm_bits > 0) {

		    int dtm = get_raw_DTM(tb, index);

		    if (dtm > 0) {
			if ((dtm-1) != ((65536-4)/2)-score+1) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mate in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, dtm-1);
			}
		    } else if (dtm < 0) {
			if ((-dtm-1) != ((65536-4)/2)+score) {
			    printf("%s (%d): Nalimov says %s (%d), but we say mated in %d\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), score, -dtm-1);
			}
		    } else if (dtm == 0) {
			if (score != 0) {
			    printf("%s (%d): Nalimov says %s (%d), but we say draw\n",
				   global_position_to_FEN(&global), index,
				   nalimov_to_english(score), ((65536-4)/2)+score);
			}
		    }
		}

		if (tb->format.flag_type != FORMAT_FLAG_NONE) {

		    boolean flag = get_flag(tb, index);

		    if (global.side_to_move == BLACK) score *= -1;

		    if (flag && (score < 0)) {
			fprintf(stderr, "%s (%d): Nalimov says black wins, but we say white wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if (flag && (tb->format.flag_type == FORMAT_FLAG_WHITE_WINS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say white wins\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (score > 0)) {
			fprintf(stderr, "%s (%d): Nalimov says white wins, but we say black wins or draws\n",
				global_position_to_FEN(&global), index);
		    } else if ((!flag) && (tb->format.flag_type == FORMAT_FLAG_WHITE_DRAWS) && (score == 0)) {
			fprintf(stderr, "%s (%d): Nalimov says draw, but we say black wins\n",
				global_position_to_FEN(&global), index);
		    }
		}
	    } else {
		fprintf(stderr, "%s (%d): Nalimov says illegal, but we don't\n",
			global_position_to_FEN(&global), index);
	    }
	}
    }
}

#endif /* USE_NALIMOV */


/* Search an array of tablebases for a global position.  Array should be terminated with a NULL ptr.
 */

boolean search_tablebases_for_global_position(tablebase_t **tbs, global_position_t *global_position,
					      tablebase_t **tbptr, index_t *indexptr)
{
    index_t index;

    for (; *tbs != NULL; tbs++) {
	index = global_position_to_index(*tbs, global_position);
	if (index != -1) {
	    *tbptr = *tbs;
	    *indexptr = index;
	    return 1;
	}
    }

    return 0;
}

void print_score(tablebase_t *tb, index_t index, char *ptm, char *pntm)
{
    /* int dtm = fetch_DTM_from_disk(tb, index); */
    /* int dtm = get_entry_DTM(index); */
    int dtm = get_raw_DTM(tb, index);

    if (dtm == 0) {
	printf("Draw\n");
    } else if (dtm == 1) {
	printf("Illegal position\n");
    } else if (dtm > 1) {
	printf("%s moves and wins in %d\n", ptm, dtm-1);
    } else if (dtm < 0) {
	printf("%s wins in %d\n", pntm, -dtm-1);
    }
}

int main(int argc, char *argv[])
{
    /* Make sure this tablebase array is one bigger than we need, so it can be NULL terminated */
    tablebase_t *tb, **tbs;
    global_position_t global_position;
    boolean global_position_valid = 0;
    int argi;
    int i;
    int c;
    int generating=0;
    int probing=0;
    int verify=0;
    char *output_filename = NULL;
    extern char *optarg;
    extern int optind;
    char options_string[256];
    char *options_string_ptr = options_string;
    struct sigaction action;

    /* Set signal handlers */

    memset(&action, 0, sizeof(action));
    action.sa_flags = SA_SIGINFO;
    action.sa_sigaction = sigaction_user_interrupt;
    if (sigaction(SIGINT, &action, NULL) == -1) {
	warning("Can't install SIGINTR handler: %s\n", strerror(errno));
    }

    action.sa_sigaction = sigaction_internal_error;
    if (sigaction(SIGSEGV, &action, NULL) == -1) {
	warning("Can't install SIGSEGV handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGILL, &action, NULL) == -1) {
	warning("Can't install SIGILL handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGFPE, &action, NULL) == -1) {
	warning("Can't install SIGFPE handler: %s\n", strerror(errno));
    }
    if (sigaction(SIGBUS, &action, NULL) == -1) {
	warning("Can't install SIGBUS handler: %s\n", strerror(errno));
    }

    /* Figure how we were called.  This is just to record in the XML output for reference purposes. */

    for (i=0; i<argc; i++) {
	strncpy(options_string_ptr, argv[i], options_string + sizeof(options_string) - options_string_ptr);
	options_string_ptr += strlen(argv[i]);
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
	*options_string_ptr = ' ';
	options_string_ptr ++;
	if (options_string_ptr >= options_string + sizeof(options_string)) break;
    }
    options_string[sizeof(options_string) - 1] = '\0';

    gettimeofday(&program_start_time, NULL);

    init_movements();
    verify_movements();

    while (1) {
	c = getopt(argc, argv, "qgpvo:n:P:");

	if (c == -1) break;

	switch (c) {

	case 'g':
	    generating = 1;
	    break;
	case 'p':
	    probing = 1;
	    break;
	case 'v':
	    verify = 1;
	    break;
	case 'q':
	    verbose = 0;
	    break;
#ifdef USE_NALIMOV
	case 'n':
	    nalimov_path = optarg;
	    break;
#endif
	case 'o':
	    output_filename = optarg;
	    break;
	case 'P':
	    /* set size of proptable in megabytes */
	    proptable_MBs = strtol(optarg, NULL, 0);
	    break;
	}
    }

    if (generating && probing) {
	fatal("Only one of the generating (-g) and probing (-p) options can be specified\n");
	terminate();
    }

    if (!generating && !probing && !verify) {
	fatal("At least one of generating (-g), probing (-p), or verify (-v) must be specified\n");
	terminate();
    }

    if (!generating && (output_filename != NULL)) {
	fatal("An output filename can not be specified when probing or verifying\n");
	terminate();
    }

    /* Generating */

    if (generating) {
	generate_tablebase_from_control_file(argv[optind], output_filename, options_string);
	terminate();
    }

    /* Probing / Verifying */

#ifdef USE_NALIMOV
    init_nalimov_code();
#endif

    i = 0;
    /* calloc (unlike malloc) zeros memory */
    tbs = calloc(argc - optind + 1, sizeof(tablebase_t *));

    for (argi=optind; argi<argc; argi++) {
	info("Loading '%s'\n", argv[argi]);
	tbs[i] = preload_futurebase_from_file(argv[argi]);
	if (tbs[i] == NULL) {
	    fatal("Error loading '%s'\n", argv[argi]);
	} else {
#ifdef USE_NALIMOV
	    if (verify) verify_tablebase_against_nalimov(tbs[i]);
#endif
	    i++;
	}
    }

    if (!probing) terminate();

    /* Probing only */

    read_history(".hoffman_history");

    while (1) {
	char *buffer;
	local_position_t pos;
	local_position_t nextpos;
	int piece, dir;
	struct movement * movementptr;
	global_position_t global_capture_position;
	int score;
	index_t index;

	buffer = readline(global_position_valid ? "FEN or move? " : "FEN? ");
	if (buffer == NULL) break;
	if (*buffer == '\0') continue;
	add_history(buffer);

	if (!(global_position_valid && parse_move_in_global_position(buffer, &global_position))
	    && !parse_FEN_to_global_position(buffer, &global_position)) {
	    printf(global_position_valid ? "Bad FEN or move\n\n" : "Bad FEN\n\n");
	    continue;
	}

	global_position_valid = 1;

	if (search_tablebases_for_global_position(tbs, &global_position, &tb, &index)) {

	    index_t index2;
	    char *ptm, *pntm;

	    /* 'index' is the index of the current position; 'index2' will be the index
	     * of the various next positions that we'll consider
	     */

	    printf("FEN %s\n", global_position_to_FEN(&global_position));
	    printf("Index %d\n", index);

	    if (global_position.side_to_move == WHITE) {
		ptm = "White";
		pntm = "Black";
	    } else {
		ptm = "Black";
		pntm = "White";
	    }

	    print_score(tb, index, ptm, pntm);

#ifdef USE_NALIMOV
		if (EGTBProbe(global_position.side_to_move == WHITE, global_position.board, -1, &score) == 1) {
		    printf("\nNalimov score: ");
		    if (score > 0) {
			printf("%s moves and wins in %d\n", ptm, ((65536-4)/2)-score+1);
		    } else if (score < 0) {
			printf("%s wins in %d\n", pntm, ((65536-4)/2)+score);
		    } else {
			printf("DRAW\n");
		    }
		}
#endif

	    /* Now we want to print a move list */

	    for (piece = 0; piece < tb->num_pieces; piece++) {

		/* We only want to consider pieces of the side which is to move... */

		if (tb->piece_color[piece] != global_position.side_to_move)
		    continue;

		if (tb->piece_type[piece] != PAWN) {

		    for (dir = 0; dir < number_of_movement_directions[tb->piece_type[piece]]; dir++) {

			if ((! index_to_local_position(tb, index, REFLECTION_NONE, &pos))
			    && (! index_to_local_position(tb, index, REFLECTION_DIAGONAL, &pos))) continue;

			nextpos = pos;

			flip_side_to_move_local(&nextpos);
			nextpos.en_passant_square = -1;

			for (movementptr = movements[tb->piece_type[piece]][pos.piece_position[piece]][dir];
			     (movementptr->vector & pos.board_vector) == 0;
			     movementptr++) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			}

			/* Now we consider possible captures */

			index_to_global_position(tb, index, &global_capture_position);

			if ((movementptr->vector & pos.PTM_vector) == 0) {

			    if ((movementptr->square == pos.piece_position[tb->black_king])
				|| (movementptr->square == pos.piece_position[tb->white_king])) {

				/* printf("MATE\n"); */

			    } else {
				tablebase_t *tb2;
				global_position_t reversed_position;

				global_capture_position.board[pos.piece_position[piece]] = 0;
				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       tb->piece_type[piece]);

				if (global_capture_position.side_to_move == WHITE)
				    global_capture_position.side_to_move = BLACK;
				else
				    global_capture_position.side_to_move = WHITE;

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s   ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s   NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square]);
				}
			    }
			}
			/* end of capture search */
		    }

		} else {

		    /* PAWNs */

		    if (! index_to_local_position(tb, index, REFLECTION_NONE, &pos))
			index_to_local_position(tb, index, REFLECTION_DIAGONAL, &pos);
		    nextpos = pos;
		    flip_side_to_move_local(&nextpos);

		    /* normal pawn moves */

		    for (movementptr = normal_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 (movementptr->vector & pos.board_vector) == 0;
			 movementptr++) {

			if ((ROW(movementptr->square) != 0) && (ROW(movementptr->square) != 7)) {

			    nextpos.piece_position[piece] = movementptr->square;

			    index2 = local_position_to_index(tb, &nextpos);

			    /* This is the next move, so we reverse the sense of PTM and PNTM */

			    if ((index2 != -1) && is_position_valid(tb, index2)) {
				printf("   %s%s    ",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
				print_score(tb, index2, pntm, ptm);
			    }

			} else {

			    /* non-capture promotion */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %s%s=%c  ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %s%s=%c  NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }
			}
		    }

		    /* capture pawn moves */

		    for (movementptr = capture_pawn_movements[pos.piece_position[piece]][tb->piece_color[piece]];
			 movementptr->square != -1;
			 movementptr++) {

			if (movementptr->square == pos.en_passant_square) {

			    /* en passant capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    if (tb->piece_color[piece] == WHITE) {
				global_capture_position.board[pos.en_passant_square - 8] = 0;
			    } else {
				global_capture_position.board[pos.en_passant_square + 8] = 0;
			    }

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }

			    continue;
			}

			if ((movementptr->vector & pos.PTM_vector) != 0) continue;

			if ((ROW(movementptr->square) == 7) || (ROW(movementptr->square) == 0)) {

			    /* promotion capture */

			    tablebase_t *tb2;
			    global_position_t reversed_position;
			    int *promoted_piece;

			    index_to_global_position(tb, index, &global_capture_position);

			    flip_side_to_move_global(&global_capture_position);

			    global_capture_position.board[pos.piece_position[piece]] = 0;

			    for (promoted_piece = promoted_pieces; *promoted_piece; promoted_piece ++) {

				place_piece_in_global_position(&global_capture_position, movementptr->square,
							       tb->piece_color[piece],
							       *promoted_piece);

				reversed_position = global_capture_position;
				invert_colors_of_global_position(&reversed_position);

				if (search_tablebases_for_global_position(tbs, &global_capture_position,
									  &tb2, &index2)
				    || search_tablebases_for_global_position(tbs, &reversed_position,
									     &tb2, &index2)) {

				    if (is_position_valid(tb2, index2)) {
					printf ("   %sx%s=%c ",
						algebraic_notation[pos.piece_position[piece]],
						algebraic_notation[movementptr->square],
						piece_char[*promoted_piece]);
					print_score(tb2, index2, pntm, ptm);
				    }
				} else {
				    printf("   %sx%s=%c NO DATA\n",
					   algebraic_notation[pos.piece_position[piece]],
					   algebraic_notation[movementptr->square],
					   piece_char[*promoted_piece]);
				}
			    }

			    continue;
			}

			if ((movementptr->square == pos.piece_position[tb->black_king])
			    || (movementptr->square == pos.piece_position[tb->white_king])) {

			    /* printf("MATE\n"); */

			} else {
			    tablebase_t *tb2;
			    global_position_t reversed_position;

			    global_capture_position.board[pos.piece_position[piece]] = 0;
			    place_piece_in_global_position(&global_capture_position, movementptr->square,
							   tb->piece_color[piece],
							   tb->piece_type[piece]);

			    flip_side_to_move_global(&global_capture_position);

			    reversed_position = global_capture_position;
			    invert_colors_of_global_position(&reversed_position);

			    if (search_tablebases_for_global_position(tbs, &global_capture_position,
								      &tb2, &index2)
				|| search_tablebases_for_global_position(tbs, &reversed_position,
									 &tb2, &index2)) {

				if (is_position_valid(tb2, index2)) {
				    printf ("   %sx%s   ",
					    algebraic_notation[pos.piece_position[piece]],
					    algebraic_notation[movementptr->square]);
				    print_score(tb2, index2, pntm, ptm);
				}
			    } else {
				printf("   %sx%s   NO DATA\n",
				       algebraic_notation[pos.piece_position[piece]],
				       algebraic_notation[movementptr->square]);
			    }
			}
		    }
		    /* end of capture search */


		}

	    }
	}
    }
    write_history(".hoffman_history");
    printf("\n");

    exit(EXIT_SUCCESS);
}
