#! /usr/bin/perl
# -*- fill-column: 100; -*-

use strict;

use IO::Zlib;
use XML::LibXML;

use DBI;

use English;
$LIST_SEPARATOR = undef;

# Our original XML control file

my $XMLparser = XML::LibXML->new();
#$XMLparser->validation(1);
$XMLparser->load_ext_dtd(0);

# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package XML_prefix_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;
	return 0 if (defined $self->{'truncate'});

	my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	if ($search_result != -1) {
	    substr($$bufref, $search_result - length($self->{'trailing data'}) + length("</tablebase>")) = "";
	    $result = length($$bufref);
	    $self->{'truncate'} = 1;
	} else {
	    $self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	}
	return $result;
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

# Create an in-memory SQL database

my $dbh = DBI->connect("dbi:SQLite:dbname=:memory:", "", "",
		       { RaiseError => 1 } ) or die $DBI::errstr;

$dbh->do("CREATE TABLE timings(tablebase, futurebases, indices, time, max_dtm)");

my $insert = $dbh->prepare("INSERT INTO timings VALUES(?, ?, ?, ?, ?)");

sub time2sec {
    my ($timestr) = @_;

    if ($timestr =~ m/(([0-9]+)m)?([0-9.]+)s/) {
	return 60*$2+$3;
    } else {
	return "";
    }
}

sub extract_timings {
    my ($filename) = @_;

    tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open futurebase $filename\n";
    tie *FILE, 'XML_prefix_only', *ZFILE;

    my $XMLfuturebase = $XMLparser->parse_fh(*FILE)->getDocumentElement();

    close(FILE);

    my $futurebases = "";

    foreach my $node ($XMLfuturebase->findnodes('//futurebase')) {
	$futurebases .= $node->find('@filename') . " ";
    }

    $insert->execute($XMLfuturebase->find('//output/@filename'),
		     $futurebases,
		     $XMLfuturebase->find('//indices'),
#		     &time2sec($XMLfuturebase->find('//real-time')),
		     &time2sec($XMLfuturebase->find('//user-time')),
		     $XMLfuturebase->find('//max-dtm'));
}


if ($#ARGV >= 0) {
    foreach my $file (@ARGV) { &extract_timings($file); }
}


my $subroutine_sth = $dbh->prepare("SELECT indices FROM timings WHERE tablebase = ?");

sub indices {
    my ($tablebase) = @_;
    my $indices = 0;

    $subroutine_sth->execute($tablebase);

    while (my @row = $subroutine_sth->fetchrow_array) {
	#print $row[0], " ";
	$indices += $row[0];
    }

    return $indices;
}



my $sth = $dbh->prepare("SELECT tablebase, futurebases, indices, time, max_dtm FROM timings");

$sth->execute();

while ( my @row = $sth->fetchrow_array ) {
    my $futureindices = 0;
    foreach my $futurebase (split(' ', $row[1])) {
	$futureindices += &indices($futurebase);
    }
    #print "$row[0] $row[2] $futureindices $row[3]\n";
    print "$row[0] $row[2] $row[4] $row[3]\n";
}
