#! /usr/bin/perl
#
# PAWNGEN - generates a directory full of Hoffman XML control files to
# analyze a particular pawn configuration
#

@white_pawns = ('a5', 'b2', 'd4', 'g2', 'h3');
@black_pawns = ('a6', 'd5', 'd6', 'g6', 'h7');

my @earliest_black_pawns = (6,5,0,6,0,0,6,7);
my @next_black_pawns = (0,0,0,5,0,0,5,5);
my @earliest_white_pawns = (5,2,0,4,0,0,2,3);
my @next_white_pawns = (6,6,0,0,0,0,4,4);

my $max_free_pieces = 4;

my $concede_stalemates = 1;

my $url_prefix = "ftp://vger.freesoft.org/Hoffman/analysis2/";
my $completion_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=complete&amp;tb=";
my $error_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=error&amp;tb=";

my @white_queens;
my @black_queens;

if ($concede_stalemates) {
    @white_queens = ('', 'q');
    @black_queens = ('', 'q', 'n');
} else {
    @white_queens = ('', 'q', 'r', 'b', 'n');
    @black_queens = ('', 'q', 'r', 'b', 'n');
}


my %queen_names;

$queen_names{'q'} = "queen";
$queen_names{'r'} = "rook";
$queen_names{'b'} = "bishop";
$queen_names{'n'} = "knight";

my %queen_caps;

$queen_caps{'q'} = 'Q';
$queen_caps{'r'} = 'R';
$queen_caps{'b'} = 'B';
$queen_caps{'n'} = 'N';

sub filename {
    my ($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen) = @_;

    my $total_white_pawns = eval(join('+',@$white_pawns_by_rows));
    my $total_black_pawns = eval(join('+',@$black_pawns_by_rows));

    my $free_pieces =  2 + ($white_queen ? 1 : 0) + ($black_queen ? 1 : 0);

    my $total_pieces = $free_pieces + $total_white_pawns + $total_black_pawns;

    my $filename = "k";

    $filename .= $white_queens[$white_queen];

    if ($total_pieces <= $max_free_pieces) {
	$filename .= "p" if ($total_white_pawns == 1);
	$filename .= "pp" if ($total_white_pawns == 2);
    } else {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$white_pawns_by_rows[$row] >= 1) {
		$filename .= chr(97 + $row) . chr(48 + $earliest_white_pawns[$row]);
	    }
	    if ($$white_pawns_by_rows[$row] >= 2) {
		$filename .= chr(97 + $row) . chr(48 + $next_white_pawns[$row]);
	    }
	}
    }

    $filename .= "k";
    $filename .= $black_queens[$black_queen];

    if ($total_pieces <= $max_free_pieces) {
	$filename .= "p" if ($total_black_pawns == 1);
	$filename .= "pp" if ($total_black_pawns == 2);
    } else {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$black_pawns_by_rows[$row] >= 2) {
		$filename .= chr(97 + $row) . chr(48 + $next_black_pawns[$row]);
	    }
	    if ($$black_pawns_by_rows[$row] >= 1) {
		$filename .= chr(97 + $row) . chr(48 + $earliest_black_pawns[$row]);
	    }
	}
    }

    return $filename . ".htb";
}

my %generated_filenames;

sub invert_filename {
    my ($filename) = @_;

    return undef if ($concede_stalemates);

    if ($filename =~ s/^kk(..)\./k\1k./ or $filename =~ s/^kk(.)\./k\1k./) {
	return $filename;
    } elsif ($filename =~ m/^k(.)k(.)\./ and index("qrbnp", $1) > index("qrbnp", $2)) {
	$filename =~ s/^k(.)k(.)\./k\2k\1./;
	return $filename;
    } else {
	return undef;
    }
}

sub add_futurebase {
    my ($filename, $type, $array) = @_;

    if (not grep(/$filename/, @$array)) {
	push @$array, $filename;
	if (defined &invert_filename($filename)) {
	    $filename = &invert_filename($filename);
	    print OUT "   <futurebase url=\"$url_prefix$filename\" colors=\"invert\" type=\"$type\"/>\n";
	} else {
	    print OUT "   <futurebase url=\"$url_prefix$filename\" type=\"$type\"/>\n";
	}
    }
}

sub generate_control_file_rows {
    my ($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen) = @_;

    my $total_white_pawns = eval(join('+',@$white_pawns_by_rows));
    my $total_black_pawns = eval(join('+',@$black_pawns_by_rows));

    my $total_pieces = 2 + $total_white_pawns + $total_black_pawns
	+ ($white_queen ? 1 : 0) + ($black_queen ? 1 : 0);

    my $queenable_white_pawns = 0;
    my $queenable_black_pawns = 0;

    my @futurebases;

    return if defined &invert_filename(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen));

    return if (exists $generated_filenames{&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen)});
    $generated_filenames{&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen)} = &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);

    my $symmetry;

    if ($total_pieces <= $max_free_pieces) {
	$symmetry = "2-way";
	$symmetry = "8-way" if ($total_white_pawns == 0 and $total_black_pawns == 0);
    }

    my $cntl_filename = &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
    $cntl_filename =~ s/htb$/xml/;

    #open (OUT, ">&STDOUT") || die "open";
    #open (OUT, ">/dev/null") || die "open";
    open (OUT, ">$cntl_filename") || die "open";

    print OUT "<tablebase>\n";
    print OUT "   <move-restriction color=\"white\" type=\"discard\"/>\n";
    print OUT "   <move-restriction color=\"black\" type=\"concede\"/>\n";
    if (defined $symmetry) {
	print OUT "   <index type=\"compact\" symmetry=\"$symmetry\"/>\n";
    } else {
	print OUT "   <index type=\"compact\"/>\n";
    }
    print OUT "   <format><dtm bits=\"8\"/></format>\n";
    print OUT "   <piece color=\"white\" type=\"king\"/>\n";
    print OUT "   <piece color=\"black\" type=\"king\"/>\n";
    print OUT "   <piece color=\"white\" type=\"$queen_names{$white_queens[$white_queen]}\"/>\n" if $white_queen;
    print OUT "   <piece color=\"black\" type=\"$queen_names{$black_queens[$black_queen]}\"/>\n" if $black_queen;

    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row] >= 1) {
	    my $location = chr(97 + $row) . chr(48 + $earliest_white_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"white\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"white\" type=\"pawn\"/>\n";
	    }
	}
	if ($$white_pawns_by_rows[$row] >= 2) {
	    my $location = chr(97 + $row) . chr(48 + $next_white_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"white\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"white\" type=\"pawn\"/>\n";
	    }
	}
	if ($$white_pawns_by_rows[$row] and not $$black_pawns_by_rows[$row]) {
	    $queenable_white_pawns ++;
	}
	if ($$black_pawns_by_rows[$row] and not $$white_pawns_by_rows[$row]) {
	    $queenable_black_pawns ++;
	}
    }

    for (my $row = 0; $row < 8; $row ++) {
	if ($$black_pawns_by_rows[$row] >= 1) {
	    my $location = chr(97 + $row) . chr(48 + $earliest_black_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"black\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"black\" type=\"pawn\"/>\n";
	    }
	}
	if ($$black_pawns_by_rows[$row] >= 2) {
	    my $location = chr(97 + $row) . chr(48 + $next_black_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"black\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"black\" type=\"pawn\"/>\n";
	    }
	}
    }

    if (not $white_queen) {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$white_pawns_by_rows[$row] and not $$black_pawns_by_rows[$row]) {
		$$white_pawns_by_rows[$row] --;
		for (my $white_queen = 1; $white_queen <= $#white_queens; $white_queen ++) {
		    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows,
					      $white_queen, $black_queen), "promotion", \@futurebases);
		    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows,
					      $white_queen, 0), "capture-promotion", \@futurebases)
			if $black_queen;
		}
		$$white_pawns_by_rows[$row] ++;
	    }
	}
    } else {
	&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, 0, $black_queen), "capture", \@futurebases);
    }
    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row]) {
	    $$white_pawns_by_rows[$row] --;
	    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
	    $$white_pawns_by_rows[$row] ++;
	}
    }

    if (not $black_queen) {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$black_pawns_by_rows[$row] and not $$white_pawns_by_rows[$row]) {
		$$black_pawns_by_rows[$row] --;
		for (my $black_queen = 1; $black_queen <= $#black_queens; $black_queen ++) {
		    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows,
					      $white_queen, $black_queen), "promotion", \@futurebases);
		    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows,
					      0, $black_queen), "capture-promotion", \@futurebases)
			if $white_queen;
		}
		$$black_pawns_by_rows[$row] ++;
	    }
	}
    } else {
	&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, 0), "capture", \@futurebases);
    }
    for (my $row = 0; $row < 8; $row ++) {
	if ($$black_pawns_by_rows[$row]) {
	    $$black_pawns_by_rows[$row] --;
	    &add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
	    $$black_pawns_by_rows[$row] ++;
	}
    }

    # Now check to see if any of our pawns can capture pawns on adjacent files

    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row]) {
	    if ($row > 0 and $$black_pawns_by_rows[$row - 1]) {
		$$white_pawns_by_rows[$row] --;
		$$black_pawns_by_rows[$row - 1] --;
		$$white_pawns_by_rows[$row - 1] ++;
		&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
		$$white_pawns_by_rows[$row] ++;
		$$black_pawns_by_rows[$row - 1] ++;
		$$white_pawns_by_rows[$row - 1] --;
	    }
	    if ($row < 7 and $$black_pawns_by_rows[$row + 1]) {
		$$white_pawns_by_rows[$row] --;
		$$black_pawns_by_rows[$row + 1] --;
		$$white_pawns_by_rows[$row + 1] ++;
		&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
		$$white_pawns_by_rows[$row] ++;
		$$black_pawns_by_rows[$row + 1] ++;
		$$white_pawns_by_rows[$row + 1] --;
	    }
	}
	if ($$black_pawns_by_rows[$row]) {
	    if ($row > 0 and $$white_pawns_by_rows[$row - 1]) {
		$$black_pawns_by_rows[$row] --;
		$$white_pawns_by_rows[$row - 1] --;
		$$black_pawns_by_rows[$row - 1] ++;
		&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
		$$black_pawns_by_rows[$row] ++;
		$$white_pawns_by_rows[$row - 1] ++;
		$$black_pawns_by_rows[$row - 1] --;
	    }
	    if ($row < 7 and $$white_pawns_by_rows[$row + 1]) {
		$$black_pawns_by_rows[$row] --;
		$$white_pawns_by_rows[$row + 1] --;
		$$black_pawns_by_rows[$row + 1] ++;
		&add_futurebase(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "capture", \@futurebases);
		$$black_pawns_by_rows[$row] ++;
		$$white_pawns_by_rows[$row + 1] ++;
		$$black_pawns_by_rows[$row + 1] --;
	    }
	}
    }

    if ($queenable_white_pawns) {
	if ($white_queen) {
	    print OUT "   <prune color=\"white\" move=\"P=any\" type=\"discard\"/>\n";
	} else {
	    # if we don't consider all white queening possibilities...
	    foreach my $queen ('q', 'r', 'b', 'n') {
		if (not grep /$queen/, @white_queens) {
		    print OUT "   <prune color=\"white\" move=\"P=$queen_caps{$queen}\" type=\"discard\"/>\n";
		}
	    }
	}
    }
    if ($queenable_black_pawns) {
	if ($black_queen) {
	    print OUT "   <prune color=\"black\" move=\"P=any\" type=\"concede\"/>\n";
	}
    }
    print OUT "   <prune color=\"white\" move=\"Px$queen_caps{$black_queens[$black_queen]}\" type=\"discard\"/>\n"
	if $black_queen and $total_white_pawns;
    print OUT "   <prune color=\"black\" move=\"Px$queen_caps{$white_queens[$white_queen]}\" type=\"concede\"/>\n"
	if $white_queen and $total_black_pawns;

    print OUT "   <prune color=\"black\" move=\"stalemate\" type=\"concede\"/>\n" if $concede_stalemates;
    print OUT "   <generation-controls>\n";
    print OUT "      <output url=\"$url_prefix",
    &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "\"/>\n";
    print OUT "      <completion-report url=\"$completion_url$cntl_filename\"/>\n";
    print OUT "      <error-report url=\"$error_url$cntl_filename\"/>\n";
    print OUT "   </generation-controls>\n";
    print OUT "</tablebase>\n";

    close OUT;

    print MAKEFILE &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), ":";
    foreach my $futurebase (@futurebases) {
	$futurebase = &invert_filename($futurebase) if defined &invert_filename($futurebase);
	print MAKEFILE " $futurebase";
    }
    print MAKEFILE "\n";

}


sub generate_control_file_set {
    my ($white_pawns_by_row, $black_pawns_by_row) = @_;

    #my $total_white_pawns = eval(join('+',@$white_pawns_by_row));
    #my $total_black_pawns = eval(join('+',@$black_pawns_by_row));

    for (my $white_queen = 0; $white_queen <= $#white_queens; $white_queen ++) {
	for (my $black_queen = 0; $black_queen <= $#black_queens; $black_queen ++) {
	    &generate_control_file_rows($white_pawns_by_row, $black_pawns_by_row, $white_queen, $black_queen);
	}
    }
}

sub generate_control_files {
    my ($white_pawns_by_row, $black_pawns_by_row, $next_pawn) = @_;

    if ($next_pawn < 8) {
	my $pawncnt_limit = $$white_pawns_by_row[$next_pawn];
	for (my $pawncnt = 0; $pawncnt <= $pawncnt_limit; $pawncnt ++) {
	    $$white_pawns_by_row[$next_pawn] = $pawncnt;
	    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
	    if (($pawncnt == 0) and ($pawncnt_limit > 0)) {
		# could the pawn have been captured by an adjacent enemy pawn?
		if (($next_pawn > 0) and ($$black_pawns_by_row[$next_pawn - 1] != 0)) {
		    $$black_pawns_by_row[$next_pawn - 1] --;
		    $$black_pawns_by_row[$next_pawn] ++;
		    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
		    $$black_pawns_by_row[$next_pawn] --;
		    $$black_pawns_by_row[$next_pawn - 1] ++;
		}
		if (($next_pawn < 7) and ($$black_pawns_by_row[$next_pawn + 1] != 0)) {
		    $$black_pawns_by_row[$next_pawn + 1] --;
		    $$black_pawns_by_row[$next_pawn] ++;
		    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
		    $$black_pawns_by_row[$next_pawn] --;
		    $$black_pawns_by_row[$next_pawn + 1] ++;
		}
	    }
	}
    } elsif ($next_pawn < 16) {
	my $pawncnt_limit = $$black_pawns_by_row[$next_pawn - 8];
	for (my $pawncnt = 0; $pawncnt <= $pawncnt_limit; $pawncnt ++) {
	    $$black_pawns_by_row[$next_pawn - 8] = $pawncnt;
	    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
	    if (($pawncnt == 0) and ($pawncnt_limit > 0)) {
		# could the pawn have been captured by an adjacent enemy pawn?
		if (($next_pawn - 8 > 0) and ($$white_pawns_by_row[$next_pawn - 8 - 1] != 0)) {
		    $$white_pawns_by_row[$next_pawn - 8 - 1] --;
		    $$white_pawns_by_row[$next_pawn - 8] ++;
		    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
		    $$white_pawns_by_row[$next_pawn - 8] --;
		    $$white_pawns_by_row[$next_pawn - 8 - 1] ++;
		}
		if (($next_pawn - 8 < 7) and ($$white_pawns_by_row[$next_pawn - 8 + 1] != 0)) {
		    $$white_pawns_by_row[$next_pawn - 8 + 1] --;
		    $$white_pawns_by_row[$next_pawn - 8] ++;
		    &generate_control_files($white_pawns_by_row, $black_pawns_by_row, $next_pawn + 1);
		    $$white_pawns_by_row[$next_pawn - 8] --;
		    $$white_pawns_by_row[$next_pawn - 8 + 1] ++;
		}
	    }
	}
    } else {
	&generate_control_file_set($white_pawns_by_row, $black_pawns_by_row);
    }
}

open (MAKEFILE, ">makefile") || die "open";
#open (MAKEFILE, ">/dev/null") || die "open";

&generate_control_files([1,1,0,1,0,0,1,1],[1,0,0,2,0,0,1,1]);
