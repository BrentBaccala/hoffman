#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# PAWNGEN - generates a directory full of Hoffman XML control files to
# analyze a particular pawn configuration
#

use IO::Zlib;

use Data::Dumper;

my $for_real = 0;

use English;
$LIST_SEPARATOR = undef;

#open(DEBUG,">&STDOUT");

my $analysis = "analysis4";

@white_pawns = ('a5', 'b2', 'd4', 'g2', 'h3');
@black_pawns = ('a6', 'd5', 'd6', 'g6', 'h7');

my @earliest_black_pawns = (6,5,0,6,0,0,6,7);
my @next_black_pawns = (0,0,0,5,0,0,5,5);
my @earliest_white_pawns = (5,2,0,4,0,0,2,3);
my @next_white_pawns = (6,6,0,0,0,0,4,4);

my $max_free_pieces = 4;

my $concede_stalemates = 0;

my $url_prefix = "ftp://vger.freesoft.org/Hoffman/$analysis/";
my $completion_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=complete&amp;tb=";
my $error_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=error&amp;tb=";

my @white_queens;
my @black_queens;

if ($concede_stalemates) {
    @white_queens = ('', 'q');
    @black_queens = ('', 'q', 'n');
} else {
    @white_queens = ('', 'q');
    #@white_queens = ('', 'q', 'r', 'b', 'n');
    @black_queens = ('', 'q', 'r', 'b', 'n');
}

my $allow_black_to_queen = 0;


my %queen_names;

$queen_names{'q'} = "queen";
$queen_names{'r'} = "rook";
$queen_names{'b'} = "bishop";
$queen_names{'n'} = "knight";

my %queen_caps;

$queen_caps{'q'} = 'Q';
$queen_caps{'r'} = 'R';
$queen_caps{'b'} = 'B';
$queen_caps{'n'} = 'N';

my @todo_list;

if ($for_real) {
    open (MAKEFILE, ">makefile") || die "open";
} else {
    open (MAKEFILE, ">/dev/null") || die "open";
}

#push @todo_list, [[1,1,0,1,0,0,1,1],[1,0,0,2,0,0,1,1],0,0];
#push @todo_list, [[0,1,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],0,0];

#&generate_todo_list;

# position format - K[pieces][pawn locations]K[pieces][pawn locations]

my $white_queens_allowed = 1;
my $black_queens_allowed = 0;

my %positions;

# inverse sort

sub isort {
    return sort {$b cmp $a} @_;
}

sub filename {
    my ($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen) = @_;

    my $total_white_pawns = eval(join('+',@$white_pawns_by_rows));
    my $total_black_pawns = eval(join('+',@$black_pawns_by_rows));

    my $free_pieces =  2 + ($white_queen ? 1 : 0) + ($black_queen ? 1 : 0);

    my $total_pieces = $free_pieces + $total_white_pawns + $total_black_pawns;

    my $filename = "k";

    $filename .= $white_queens[$white_queen];

    if ($total_pieces <= $max_free_pieces) {
	$filename .= "p" if ($total_white_pawns == 1);
	$filename .= "pp" if ($total_white_pawns == 2);
    } else {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$white_pawns_by_rows[$row] >= 1) {
		$filename .= chr(97 + $row) . chr(48 + $earliest_white_pawns[$row]);
	    }
	    if ($$white_pawns_by_rows[$row] >= 2) {
		$filename .= chr(97 + $row) . chr(48 + $next_white_pawns[$row]);
	    }
	}
    }

    $filename .= "k";
    $filename .= $black_queens[$black_queen];

    if ($total_pieces <= $max_free_pieces) {
	$filename .= "p" if ($total_black_pawns == 1);
	$filename .= "pp" if ($total_black_pawns == 2);
    } else {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$black_pawns_by_rows[$row] >= 2) {
		$filename .= chr(97 + $row) . chr(48 + $next_black_pawns[$row]);
	    }
	    if ($$black_pawns_by_rows[$row] >= 1) {
		$filename .= chr(97 + $row) . chr(48 + $earliest_black_pawns[$row]);
	    }
	}
    }

    return $filename . ".htb";
}

my %generated_filenames;

sub invert_filename {
    my ($filename) = @_;

    # I don't trust inversion.
    return undef;

    return undef if ($concede_stalemates);

    if ($filename =~ s/^kk(..)\./k\1k./ or $filename =~ s/^kk(.)\./k\1k./) {
	return $filename;
    } elsif ($filename =~ m/^k(.)k(.)\./ and index("qrbnp", $1) > index("qrbnp", $2)) {
	$filename =~ s/^k(.)k(.)\./k\2k\1./;
	return $filename;
    } else {
	return undef;
    }
}

sub deepcopy {
    my @retval;

    foreach my $val (@_) {
	if (ref $val) {
	    my @copy = &deepcopy(@$val);
	    push @retval, \@copy;
	} else {
	    push @retval, $val;
	}
    }

    return @retval;
}

sub add_futurebase {
    my ($type, $array, @parameters) = @_;
    my $filename = &filename(@parameters);

    if (not grep(/$filename/, @$array)) {
	push @$array, $filename;
	if (defined &invert_filename($filename)) {
	    $filename = &invert_filename($filename);
	    print OUT "   <futurebase url=\"$url_prefix$filename\" colors=\"invert\" type=\"$type\"/>\n";
	} else {
	    print OUT "   <futurebase url=\"$url_prefix$filename\" type=\"$type\"/>\n";
	    if (not exists $generated_filenames{$filename}) {
		push @todo_list, &deepcopy(\@parameters);
	    }
	}
    }
}

sub normalize_position {
    my ($position) = @_;

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    return "$white_base@white_pawns$black_base@black_pawns";
}

sub generate_control_file {
    my ($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen) = @_;

    my $total_white_pawns = eval(join('+',@$white_pawns_by_rows));
    my $total_black_pawns = eval(join('+',@$black_pawns_by_rows));

    my $total_pieces = 2 + $total_white_pawns + $total_black_pawns
	+ ($white_queen ? 1 : 0) + ($black_queen ? 1 : 0);

    my $queenable_white_pawns = 0;
    my $queenable_black_pawns = 0;

    my @futurebases;

    return if defined &invert_filename(&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen));

    # print $white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen, "\n";

    return if (exists $generated_filenames{&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen)});
    $generated_filenames{&filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen)} = &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);

    my $symmetry;

    if ($total_pieces <= $max_free_pieces) {
	$symmetry = "2-way";
	$symmetry = "8-way" if ($total_white_pawns == 0 and $total_black_pawns == 0);
    }

    my $cntl_filename = &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
    $cntl_filename =~ s/htb$/xml/;

    if ($for_real) {
	open (OUT, ">$cntl_filename") || die "open";
    } else {
	open (OUT, ">&STDOUT") || die "open";
    }

    print OUT "<tablebase>\n";
    print OUT "   <move-restriction color=\"white\" type=\"discard\"/>\n";
    print OUT "   <move-restriction color=\"black\" type=\"concede\"/>\n";
    if (defined $symmetry) {
	print OUT "   <index type=\"compact\" symmetry=\"$symmetry\"/>\n";
    } else {
	print OUT "   <index type=\"compact\"/>\n";
    }
    print OUT "   <format><dtm bits=\"8\"/></format>\n";
    print OUT "   <piece color=\"white\" type=\"king\"/>\n";
    print OUT "   <piece color=\"black\" type=\"king\"/>\n";
    print OUT "   <piece color=\"white\" type=\"$queen_names{$white_queens[$white_queen]}\"/>\n" if $white_queen;
    print OUT "   <piece color=\"black\" type=\"$queen_names{$black_queens[$black_queen]}\"/>\n" if $black_queen;

    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row] >= 1) {
	    my $location = chr(97 + $row) . chr(48 + $earliest_white_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"white\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"white\" type=\"pawn\"/>\n";
	    }
	}
	if ($$white_pawns_by_rows[$row] >= 2) {
	    my $location = chr(97 + $row) . chr(48 + $next_white_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"white\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"white\" type=\"pawn\"/>\n";
	    }
	}
	if ($$white_pawns_by_rows[$row] and not $$black_pawns_by_rows[$row]) {
	    $queenable_white_pawns ++;
	}
	if ($$black_pawns_by_rows[$row] and not $$white_pawns_by_rows[$row]) {
	    $queenable_black_pawns ++;
	}
    }

    # Do the black pawns in reverse order here so that doubled pawns appear in board
    # order, as is (currently) required by Hoffman.

    for (my $row = 0; $row < 8; $row ++) {
	if ($$black_pawns_by_rows[$row] >= 2) {
	    my $location = chr(97 + $row) . chr(48 + $next_black_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"black\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"black\" type=\"pawn\"/>\n";
	    }
	}
	if ($$black_pawns_by_rows[$row] >= 1) {
	    my $location = chr(97 + $row) . chr(48 + $earliest_black_pawns[$row]) . "+";
	    if ($total_pieces > $max_free_pieces) {
		print OUT "   <piece color=\"black\" type=\"pawn\" location=\"$location\"/>\n";
	    } else {
		print OUT "   <piece color=\"black\" type=\"pawn\"/>\n";
	    }
	}
    }

    if (not $white_queen) {
	for (my $row = 0; $row < 8; $row ++) {
	    if ($$white_pawns_by_rows[$row] and not $$black_pawns_by_rows[$row]) {
		$$white_pawns_by_rows[$row] --;
		for (my $white_queen = 1; $white_queen <= $#white_queens; $white_queen ++) {
		    &add_futurebase("promotion", \@futurebases,
				    $white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
		    &add_futurebase("capture-promotion", \@futurebases,
				    $white_pawns_by_rows, $black_pawns_by_rows, $white_queen, 0)
			if $black_queen;
		}
		$$white_pawns_by_rows[$row] ++;
	    }
	}
    } else {
	&add_futurebase("capture", \@futurebases,
			$white_pawns_by_rows, $black_pawns_by_rows, 0, $black_queen);
    }
    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row]) {
	    $$white_pawns_by_rows[$row] --;
	    &add_futurebase("capture", \@futurebases,
			    $white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
	    $$white_pawns_by_rows[$row] ++;
	}
    }

    if (not $black_queen) {
	if ($allow_black_to_queen) {
	    for (my $row = 0; $row < 8; $row ++) {
		if ($$black_pawns_by_rows[$row] and not $$white_pawns_by_rows[$row]) {
		    $$black_pawns_by_rows[$row] --;
		    for (my $black_queen = 1; $black_queen <= $#black_queens; $black_queen ++) {
			&add_futurebase("promotion", \@futurebases,
					$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
			&add_futurebase("capture-promotion", \@futurebases,
					$white_pawns_by_rows, $black_pawns_by_rows, 0, $black_queen)
			    if $white_queen;
		    }
		    $$black_pawns_by_rows[$row] ++;
		}
	    }
	}
    } else {
	&add_futurebase("capture", \@futurebases,
			$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, 0);
    }
    for (my $row = 0; $row < 8; $row ++) {
	if ($$black_pawns_by_rows[$row]) {
	    $$black_pawns_by_rows[$row] --;
	    &add_futurebase("capture", \@futurebases,
			    $white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
	    $$black_pawns_by_rows[$row] ++;
	}
    }

    # Now check to see if any of our pawns can capture pawns on adjacent files

    for (my $row = 0; $row < 8; $row ++) {
	if ($$white_pawns_by_rows[$row]) {
	    if ($row > 0 and $$black_pawns_by_rows[$row - 1]) {
		$$white_pawns_by_rows[$row] --;
		$$black_pawns_by_rows[$row - 1] --;
		$$white_pawns_by_rows[$row - 1] ++;
		&add_futurebase("capture", \@futurebases,
				$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
		$$white_pawns_by_rows[$row] ++;
		$$black_pawns_by_rows[$row - 1] ++;
		$$white_pawns_by_rows[$row - 1] --;
	    }
	    if ($row < 7 and $$black_pawns_by_rows[$row + 1]) {
		$$white_pawns_by_rows[$row] --;
		$$black_pawns_by_rows[$row + 1] --;
		$$white_pawns_by_rows[$row + 1] ++;
		&add_futurebase("capture", \@futurebases,
				$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
		$$white_pawns_by_rows[$row] ++;
		$$black_pawns_by_rows[$row + 1] ++;
		$$white_pawns_by_rows[$row + 1] --;
	    }
	}
	if ($$black_pawns_by_rows[$row]) {
	    if ($row > 0 and $$white_pawns_by_rows[$row - 1]) {
		$$black_pawns_by_rows[$row] --;
		$$white_pawns_by_rows[$row - 1] --;
		$$black_pawns_by_rows[$row - 1] ++;
		&add_futurebase("capture", \@futurebases,
				$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
		$$black_pawns_by_rows[$row] ++;
		$$white_pawns_by_rows[$row - 1] ++;
		$$black_pawns_by_rows[$row - 1] --;
	    }
	    if ($row < 7 and $$white_pawns_by_rows[$row + 1]) {
		$$black_pawns_by_rows[$row] --;
		$$white_pawns_by_rows[$row + 1] --;
		$$black_pawns_by_rows[$row + 1] ++;
		&add_futurebase("capture", \@futurebases,
				$white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen);
		$$black_pawns_by_rows[$row] ++;
		$$white_pawns_by_rows[$row + 1] ++;
		$$black_pawns_by_rows[$row + 1] --;
	    }
	}
    }

    if ($queenable_white_pawns) {
	if ($white_queen) {
	    print OUT "   <prune color=\"white\" move=\"P=any\" type=\"discard\"/>\n";
	    if ($black_queen) {
		print OUT "   <prune color=\"white\" move=\"Px$queen_caps{$black_queens[$black_queen]}=any\" type=\"discard\"/>\n";
	    }
	} else {
	    # if we don't consider all white queening possibilities...
	    foreach my $queen ('q', 'r', 'b', 'n') {
		if (not grep /$queen/, @white_queens) {
		    print OUT "   <prune color=\"white\" move=\"P=$queen_caps{$queen}\" type=\"discard\"/>\n";
		}
	    }
	}
    }
    if ($queenable_black_pawns) {
	if ($black_queen or not $allow_black_to_queen) {
	    print OUT "   <prune color=\"black\" move=\"P=any\" type=\"concede\"/>\n";
	    if ($white_queen) {
		print OUT "   <prune color=\"black\" move=\"Px$queen_caps{$white_queens[$white_queen]}=any\" type=\"concede\"/>\n";
	    }
	}
    }
    print OUT "   <prune color=\"white\" move=\"Px$queen_caps{$black_queens[$black_queen]}\" type=\"discard\"/>\n"
	if $black_queen and $total_white_pawns;
    print OUT "   <prune color=\"black\" move=\"Px$queen_caps{$white_queens[$white_queen]}\" type=\"concede\"/>\n"
	if $white_queen and $total_black_pawns;

    print OUT "   <prune color=\"black\" move=\"stalemate\" type=\"concede\"/>\n" if $concede_stalemates;
    print OUT "   <generation-controls>\n";
    print OUT "      <output url=\"$url_prefix",
    &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), "\"/>\n";
    print OUT "      <completion-report url=\"$completion_url$cntl_filename\"/>\n";
    print OUT "      <error-report url=\"$error_url$cntl_filename\"/>\n";
    print OUT "   </generation-controls>\n";
    print OUT "</tablebase>\n";

    close OUT;

    print MAKEFILE &filename($white_pawns_by_rows, $black_pawns_by_rows, $white_queen, $black_queen), ":";
    foreach my $futurebase (@futurebases) {
	$futurebase = &invert_filename($futurebase) if defined &invert_filename($futurebase);
	print MAKEFILE " $futurebase";
    }
    print MAKEFILE "\n";

}


# Critical to the operation of this algorithm is the sorting of the pawn positions.
# First of all, we keep pawn positions sorted so that there's no way to confuse "a5 b6"
# with "b6 a5".  Next, we sort white pawn in inverse sort order, so that "a5" comes
# before "a2".  This makes plus-pawns work easy and well - we just run through
# the pawns in (inverse) sort order, and advance each plus-pawn until it hits something.

sub consider_position {
    my ($position) = @_;

    my @white_captures, @black_captures;
    my @white_promotions, @black_promotions;
    my @white_capture_promotions, @black_capture_promotions;
    my @white_normals, @black_normals;

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    #return if (exists $positions{$position});
    #$positions{$position} = undef;
    #print "Considering $position\n";

    return if (exists $positions{"$white_base@white_pawns$black_base@black_pawns"});
    $positions{"$white_base@white_pawns$black_base@black_pawns"} = undef;
    print DEBUG "Considering $position as $white_base@white_pawns$black_base@black_pawns\n";

    # if we were considering pawn-pieces captured, that would be here

    my $pawns = $white_pawns . $black_pawns;

    foreach $white_pawn (unpack "(a2)*", $white_pawns) {
	#print "$white_pawn\n";
	# first, try to queen the pawn
	if ($white_queens_allowed and $white_pawn =~ /.7/) {
	    if ($position !~ /^K[QRBN]/) {
		my $position2 = $position;
		$position2 =~ s/$white_pawn//;
		$position2 =~ s/^K/KQ/;
		#print "  $position2\n";
		#&consider_position($position2);
		push @white_promotions, $position2;
	    }
	    # if other black pieces allowed, consider capture promotions here
	}
	# now try to move the pawn forward
	if ($white_pawn !~ /.7/) {
	    my $forward_move = $white_pawn;
	    $forward_move =~ tr/[2-7]/[3-8]/;
	    if ($pawns !~ /$forward_move/) {
		my $position2 = $position;
		# have to consider queening
		$position2 =~ s/$white_pawn/$forward_move/;
		#print "  $forward_move $position2\n";
		#&consider_position($position2);
		push @white_normals, $position2;

		if ($forward_move =~ /.3/) {
		    my $forward_move2 = $forward_move;
		    $forward_move2 =~ tr/3/4/;
		    if ($pawns !~ /$forward_move2/) {
			my $position3 = $position;
			$position3 =~ s/$white_pawn/$forward_move2/;
			#print "  $forward_move2 $position3\n";
			#&consider_position($position3);
			push @white_normals, $position3;
		    }
		}
	    }
	}
	# can the pawn capture another pawn?
	if ($white_pawn !~ /.7/) {
	    if ($white_pawn !~ /a./) {
		my $capture_move = $white_pawn;
		$capture_move =~ tr/[2-7]/[3-8]/;
		$capture_move =~ tr/[b-h]/[a-g]/;
		if ($black_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$white_pawn/$capture_move/;
		    #print "    $position4\n";
		    #&consider_position($position4);
		    push @white_captures, $position4;
		}
		# en passant capture?
		if ($capture_move =~ /.6/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/6/5/;
		    if ($black_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$white_pawn/$capture_move/;
			#print "    $position5\n";
			#&consider_position($position5);
			push @white_captures, $position5;
		    }
		}
	    }
	    if ($white_pawn !~ /h./) {
		my $capture_move = $white_pawn;
		$capture_move =~ tr/[2-7]/[3-8]/;
		$capture_move =~ tr/[a-g]/[b-h]/;
		if ($black_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$white_pawn/$capture_move/;
		    #print "    $position4\n";
		    #&consider_position($position4);
		    push @white_captures, $position4;
		}
		# en passant capture?
		if ($capture_move =~ /.6/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/6/5/;
		    if ($black_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$white_pawn/$capture_move/;
			#print "    $position5\n";
			#&consider_position($position5);
			push @white_captures, $position5;
		    }
		}
	    }
	}
	# can the pawn be captured by the black king?
	my ($protector1, $protector2);
	if ($white_pawn !~ /a./) {
	    $protector1 = $white_pawn;
	    $protector1 =~ tr/[b-h]/[a-g]/;
	    $protector1 =~ tr/[2-7]/[1-6]/;
	} else {
	    $protector1 = "XX";
	}
	if ($white_pawn !~ /h./) {
	    $protector2 = $white_pawn;
	    $protector2 =~ tr/[a-g]/[b-h]/;
	    $protector2 =~ tr/[2-7]/[1-6]/;
	} else {
	    $protector2 = "XX";
	}
	if ($white_pawns !~ /$protector1/ and $white_pawns !~ /$protector2/) {
	    my $position6 = $position;
	    $position6 =~ s/$white_pawn//;
	    #&consider_position($position6);
	    push @black_captures, $position6;
	}
    }

    #print "\n";

    foreach $black_pawn (unpack "(a2)*", $black_pawns) {
	#print "$black_pawn\n";
	# first, try to queen the pawn
	if ($black_queens_allowed and $black_pawn =~ /.2/) {
	    if ($position !~ /\BK[QRBN]/) {
		my $position2 = $position;
		$position2 =~ s/$black_pawn//;
		$position2 =~ s/\BK/KQ/;
		#print "  $position2\n";
		#&consider_position($position2);
		push @black_promotions, $position2;

		# consider capture promotions
		if ($position2 =~ /^K[QRBN]/) {
		    $position2 =~ s/^K[QRBN]/K/;
		    #print "  $position2\n";
		    #&consider_position($position2);
		    push @black_capture_promotions, $position2;
		}
	    }
	}
	# now try to move the pawn forward
	if ($black_pawn !~ /.2/) {
	    my $forward_move = $black_pawn;
	    $forward_move =~ tr/[2-7]/[1-6]/;
	    if ($pawns !~ /$forward_move/) {
		my $position2 = $position;
		# have to consider queening
		$position2 =~ s/$black_pawn/$forward_move/;
		#print "  $forward_move $position2\n";
		#&consider_position($position2);
		push @black_normals, $position2;

		if ($forward_move =~ /.6/) {
		    my $forward_move2 = $forward_move;
		    $forward_move2 =~ tr/6/5/;
		    if ($pawns !~ /$forward_move2/) {
			my $position3 = $position;
			$position3 =~ s/$black_pawn/$forward_move2/;
			#print "  $forward_move2 $position3\n";
			#&consider_position($position3);
			push @black_normals, $position3;
		    }
		}
	    }
	}
	# can the pawn capture another pawn?
	if ($black_pawn !~ /.2/) {
	    if ($black_pawn !~ /a./) {
		my $capture_move = $black_pawn;
		$capture_move =~ tr/[2-7]/[1-6]/;
		$capture_move =~ tr/[b-h]/[a-g]/;
		if ($white_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$black_pawn/$capture_move/;
		    #print "    $position4\n";
		    #&consider_position($position4);
		    push @black_captures, $position4;
		}
		# en passant capture?
		if ($capture_move =~ /.3/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/3/4/;
		    if ($white_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$black_pawn/$capture_move/;
			#print "    $position5\n";
			#&consider_position($position5);
			push @black_captures, $position5;
		    }
		}
	    }
	    if ($black_pawn !~ /h./) {
		my $capture_move = $black_pawn;
		$capture_move =~ tr/[2-7]/[1-6]/;
		$capture_move =~ tr/[a-g]/[b-h]/;
		if ($white_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$black_pawn/$capture_move/;
		    #print "     $position4\n";
		    #&consider_position($position4);
		    push @black_captures, $position4;
		}
		# en passant capture?
		if ($capture_move =~ /.3/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/3/4/;
		    if ($white_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$black_pawn/$capture_move/;
			#print "    $position5\n";
			#&consider_position($position5);
			push @black_captures, $position5;
		    }
		}
	    }
	}
	# can the pawn be captured by the white king?
	my ($protector1, $protector2);
	if ($black_pawn !~ /a./) {
	    $protector1 = $black_pawn;
	    $protector1 =~ tr/[b-h]/[a-g]/;
	    $protector1 =~ tr/[2-7]/[3-8]/;
	} else {
	    $protector1 = "XX";
	}
	if ($black_pawn !~ /h./) {
	    $protector2 = $black_pawn;
	    $protector2 =~ tr/[a-g]/[b-h]/;
	    $protector2 =~ tr/[2-7]/[3-8]/;
	} else {
	    $protector2 = "XX";
	}
	if ($black_pawns !~ /$protector1/ and $black_pawns !~ /$protector2/) {
	    my $position6 = $position;
	    $position6 =~ s/$black_pawn//;
	    #&consider_position($position6);
	    push @white_captures, $position6;
	}
    }

    # if both sides have non-king, non-pawns, have to consider captures here
    if ($position =~ /^K[QRBN]/) {
	my $position7 = $position;
	$position7 =~ s/^K[QRBN]/K/;
	#&consider_position($position7);
	push @black_captures, $position7;
    }

    foreach my $new_position (@white_captures, @black_captures,
			      @white_promotions, @black_promotions,
			      @white_capture_promotions, @black_capture_promotions,
			      @white_normals, @black_normals) {
	&consider_position($new_position);
    }
}

# Returns a list of the positions assigned or checked

sub assignorcheckallpositions {
    my ($target, $prefix, @sequence) = @_;
    my $first = shift @sequence;
    my @retval = ();

    if (not defined $first) {

	my $white_pawns = $prefix;
	$white_pawns =~ s/^(K[QRBN]*)//;
	my $white_base = $1;
	$white_pawns =~ s/K.*//;
	my @white_pawns = isort unpack "(a2)*", $white_pawns;

	my $black_pawns = $prefix;
	$black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
	my $black_base = $1;
	my @black_pawns = sort unpack "(a2)*", $black_pawns;

	my $position = "$white_base@white_pawns$black_base@black_pawns";

	if (defined $target) {
	    print DEBUG "Assigning $target to $position\n";
	    $positions{$position} = $target;
	    return $position;
	} elsif (exists $positions{$position} and not defined $positions{$position}) {
	    print DEBUG "Considering $position (exists and unassigned)\n";
	    return $position;
	} else {
	    print DEBUG "Considering $position (doesn't exist or already assigned)\n";
	    return ();
	}

    } elsif ($first =~ m:^K:) {

	return &assignorcheckallpositions($target, $prefix . $first, @sequence);

    } elsif ($first =~ m:^(..)\+$:) {

	# plus pawns - advance them as far as they can go without hitting another pawn

	my $pawn = $1;
	if ($prefix =~ m:^K[^K]*$:) {
	    # white plus-pawn
	    #print "white pawn = $pawn\n";
	    while ($pawn !~ /8/ and "$prefix@sequence" !~ /$pawn/) {
		my @current = &assignorcheckallpositions($target, $prefix . $pawn, @sequence);
		return () if ($#current == -1);
		push @retval, @current;
		$pawn =~ tr/[2-7]/[3-8]/;
	    }
	} else {
	    # black plus-pawn
	    while ($pawn !~ /1/ and "$prefix@sequence" !~ /$pawn/) {
		my @current = &assignorcheckallpositions($target, $prefix . $pawn, @sequence);
		return () if ($#current == -1);
		push @retval, @current;
		$pawn =~ tr/[2-7]/[1-6]/;
	    }
	}

    } elsif ($first ne "") {

	# conventional restriction

	foreach $square (unpack "(a2)*", $first) {
	    if ($prefix !~ /$square/) {
		my @current = &assignorcheckallpositions($target, $prefix . $square, @sequence);
		return () if ($#current == -1);
		push @retval, @current;
	    }
	}

    } else {

	# unrestricted pawn

	foreach $row ('2' .. '7') {
	    foreach $col ('a' .. 'h') {
		my @current = &assignorcheckallpositions($target, $prefix . $col . $row, @sequence);
		# Can't return here; need to run this through for an assign
		push @retval, @current;
	    }
	}

    }

    return @retval;
}

sub assignallpositions {
    &assignorcheckallpositions(@_);
}

# Checks all positions resulting from a given pattern and returns either 0 (if at least one
# of them either doesn't exist in our table or has already been assigned) or a count
# of the number of unique positions matched by the pattern.

sub checkallpositions {

    my @positions = &assignorcheckallpositions(undef, @_);

    print DEBUG "Checking @_ : $#positions @positions\n";

    # This Perl equivalent to "sort | uniq" might not be portable to other versions
    # of Perl (I'm using 5.8.8), as it modifies the array being sorted.

    my @unique_positions = grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @positions;

    print DEBUG "Unique: $#unique_positions @unique_positions\n";

    #return 1 + $#positions;
    return 1 + $#unique_positions;
}

sub assign_file {
    my ($filename) = @_;
    my ($white_pieces, $black_pieces);
    my @white_pawns;
    my @black_pawns;

    #open(FILE, "<$filename");
    tie *FILE, 'IO::Zlib', $filename, "rb" or die "Can't open $filename";

    while (<FILE>) {
	$_ = lc $_;
	last if m|</tablebase>|;
	if (m|<piece|) {
	    my ($color) = m|color="([^"]*)"|;
	    my ($type) = m|type="([^"]*)"|;
	    my ($location) = m|location="([^"]*)"|;  #"
	    $location = "" if not defined $location;

	    die "Can't have non-pawn restrictions ($filename)\n" if ($type ne "pawn" and $location ne "");

	    #print "$color $type $location\n";

	    if ($color eq "white") {
		if ($type eq "knight") {
		    $white_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $white_pieces .= uc substr($type, 0, 1);
		} else {
		    push @white_pawns, $location;
		}
	    } else {
		if ($type eq "knight") {
		    $black_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $black_pieces .= uc substr($type, 0, 1);
		} else {
		    push @black_pawns, $location;
		}
	    }
	}
    }
    close(FILE);

    #print DEBUG "$white_pieces@white_pawns$black_pieces@black_pawns\n";
    &assignallpositions($filename, $white_pieces, (isort @white_pawns), $black_pieces, (sort @black_pawns));
}

sub genset {
    my ($position) = @_;

    print DEBUG "Genset $position\n";

    # We search for plus-pawn positions by trying to back up each pawn as far as it can go,
    # going through the pawns in order, so we want them sorted so that the trailing pawn
    # comes first.  For white pawns, this means standard sort order (a4 then a5), for
    # black pawns this means reverse sort order (a5 then a4)
    #
    # Once we are testing for positions, we'll be moving the plus-pawns forward, so we want
    # them with lead pawn first.  That means inverse sort order for white (a5 then a4),
    # and standard sort order for black (a4 then a5).
    #
    # XXX - A possible problem with these regex's - the "B" for bishop could get confused
    # with a "b" for a b-pawn, but that isn't a problem if we always use caps B for
    # bishop and lowercase b for pawns.

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;

    #print "genset: $white_base @white_pawns $black_base @black_pawns\n";

    # There's two different ways we can expand the location of each pawn - by turning it into
    # a plus-pawn, or by explicitly adding to its list of squares.  It's really not clear
    # just what combination of these ways is best, so we try them all, keeping count of
    # which of them could assign the most positions, and use that at the end.

    my $white_limit = (1 << length($white_pawns)/2);
    my $black_limit = (1 << length($black_pawns)/2);

    my $best_count = 0;
    my @best_white_pawns;
    my @best_black_pawns;

    for (my $white_pawn_types = 0; $white_pawn_types < $white_limit; $white_pawn_types ++) {
	for (my $black_pawn_types = 0; $black_pawn_types < $black_limit; $black_pawn_types ++) {

	    my @white_pawns = sort unpack "(a2)*", $white_pawns;
	    my @black_pawns = isort unpack "(a2)*", $black_pawns;

	    my $running_white_pawn_types = $white_pawn_types;
	    my $running_black_pawn_types = $black_pawn_types;

	    foreach my $white_pawn (@white_pawns) {

		if ($running_white_pawn_types & 1) {

		    $white_pawn .= "+";

		    if (&checkallpositions($white_base, (isort @white_pawns),
					   $black_base, (sort @black_pawns))) {
			while ($white_pawn =~ m/^(.[3-7])/) {
			    $white_pawn =~ tr/[3-7]/[2-6]/;
			    if (not &checkallpositions($white_base, (isort @white_pawns),
						       $black_base, (sort @black_pawns))) {
				$white_pawn =~ tr/[2-6]/[3-7]/;
				last;
			    }
			}
		    }

		} else {

		    # consider advancing white pawn

		    while ($white_pawn =~ m/(.[2-6])$/) {
			my $lastpawn = $1;
			$lastpawn =~ tr/[2-6]/[3-7]/;

			#last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
			$white_pawn .= $lastpawn;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $white_pawn = substr($white_pawn, 0, -2);
			    last;
			}
		    }

		    # consider retreating white pawn

		    while ($white_pawn =~ m/^(.[3-7])/) {
			my $lastpawn = $1;
			$lastpawn =~ tr/[3-7]/[2-6]/;

			#last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
			$white_pawn = $lastpawn . $white_pawn;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $white_pawn = substr($white_pawn, 2);
			    last;
			}
		    }
		}
		$running_white_pawn_types >>= 1;
	    }

	    foreach my $black_pawn (@black_pawns) {

		if ($running_black_pawn_types & 1) {

		    $black_pawn .= "+";

		    if (&checkallpositions($white_base, (isort @white_pawns),
					   $black_base, (sort @black_pawns))) {
			while ($black_pawn =~ m/^(.[2-6])/) {
			    $black_pawn =~ tr/[2-6]/[3-7]/;
			    if (not &checkallpositions($white_base, (isort @white_pawns),
						       $black_base, (sort @black_pawns))) {
				$black_pawn =~ tr/[3-7]/[2-6]/;
				last;
			    }
			}
		    }

		} else {

		    # consider advancing black pawn

		    while ($black_pawn =~ m/(.[3-7])$/) {
			my $lastpawn = $1;
			$lastpawn =~ tr/[3-7]/[2-6]/;

			#last if ("@white_pawns@black_pawns" =~ m/$lastpawn/);
			last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
			$black_pawn .= $lastpawn;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $black_pawn = substr($black_pawn, 0, -2);
			    last;
			}
		    }

		    # consider retreating black pawn

		    while ($black_pawn =~ m/^(.[2-6])/) {
			my $lastpawn = $1;
			$lastpawn =~ tr/[2-6]/[3-7]/;

			#last if ("@white_pawns@black_pawns" =~ m/$lastpawn/);
			last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
			$black_pawn = $lastpawn . $black_pawn;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $black_pawn = substr($black_pawn, 2);
			    last;
			}
		    }
		}
		$running_black_pawn_types >>= 1;
	    }

	    # Save current configuration if it's the best.  The difference between ">=" and ">"
	    # is to prefer plus-pawns (because they are tested last) over an explicit location
	    # list.

	    if (&checkallpositions($white_base, (isort @white_pawns),
				   $black_base, (sort @black_pawns))
		>= $best_count) {
		$best_count = &checkallpositions($white_base, (isort @white_pawns),
						 $black_base, (sort @black_pawns));
		@best_white_pawns = isort @white_pawns;
		@best_black_pawns = sort @black_pawns;
	    }
	}
    }

    # multiply $best_count by 64 ^ (number of fully mobile pieces) to get a count
    # of the number of positions

    $best_count <<= 6*(length($white_base) + length($black_base));

    $LIST_SEPARATOR = " ";
    print "$white_base @best_white_pawns $black_base @best_black_pawns $best_count\n";
    $LIST_SEPARATOR = undef;

    &assignallpositions("$white_base@best_white_pawns$black_base@best_black_pawns",
			$white_base, @best_white_pawns, $black_base, @best_black_pawns);
}

sub genallsets {
    while (($position, $filename) = each %positions) {
	#if (not defined $filename) {
	if (not defined $positions{$position}) {
	    #print "Processing $position\n";
	    &genset($position);
	}
    }
}


#&consider_position("Kh3Kh5");
&consider_position("Kg2h3Kg6h5");
#&consider_position("Kb2g2h3Kg6h5");
#&consider_position("Kd4Kd5d6");
#&consider_position("Kb7d4g2h3Kd5d6g6h5");

foreach my $file (@ARGV) { &assign_file($file); }

#&genset("Kb7d4g2h3Kd5d6g6h5");
&genallsets;
