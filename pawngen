#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# PAWNGEN - generates a directory full of Hoffman XML control files to
# analyze a particular pawn configuration
#

use IO::Zlib;

use Data::Dumper;

my $for_real = 1;

use English;
$LIST_SEPARATOR = undef;

use strict;

#open(DEBUG,">&STDOUT");

my $analysis = "analysis4";

my $concede_stalemates = 0;

my $url_prefix = "ftp://vger.freesoft.org/Hoffman/$analysis/";
my $completion_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=complete&amp;tb=";
my $error_url = "http://vger.freesoft.org/cgi-bin/hoffman.cgi?status=error&amp;tb=";

my %piece_names;

$piece_names{'K'} = "king";
$piece_names{'Q'} = "queen";
$piece_names{'R'} = "rook";
$piece_names{'B'} = "bishop";
$piece_names{'N'} = "knight";

if ($for_real) {
    open (MAKEFILE, ">makefile") || die "open";
} else {
    open (MAKEFILE, ">/dev/null") || die "open";
}

# position format - K[pieces][pawn locations]K[pieces][pawn locations]

my $white_queens_allowed = 1;
my $black_queens_allowed = 0;

my %positions;

my %white_base;
my %white_pawns;
my %black_base;
my %black_pawns;

# inverse sort

sub isort {
    return sort {$b cmp $a} @_;
}

# This Perl equivalent to "sort | uniq" might not be portable to other versions of Perl (I'm using
# 5.8.8), as it modifies the array being sorted.

sub uniqsort {
#    return grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @_;
    my @sorted = sort @_;
    for (my $i = 0; $i < $#sorted; $i++) {
	splice @sorted,$i,1 while (($i < $#sorted) and ($sorted[$i] eq $sorted[$i+1]));
    }
    return @sorted;
}

sub debuguniqsort {
#    return grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @_;
    my @sorted = sort @_;
    for (my $i = 0; $i < $#sorted; $i++) {
	print " @sorted\n";
	splice @sorted,$i,1 while (($i < $#sorted) and ($sorted[$i] eq $sorted[$i+1]));
    }
    return @sorted;
}

sub normalize_position {
    my ($position) = @_;

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    return "$white_base@white_pawns$black_base@black_pawns";
}

sub pattern_to_name {
    my @pattern = @_;

    return join '', map { substr($_, 0, 1) eq "K" ? $_ : substr($_, 0, 2) } @pattern;
}

# Critical to the operation of this algorithm is the sorting of the pawn positions.
# First of all, we keep pawn positions sorted so that there's no way to confuse "a5 b6"
# with "b6 a5".  Next, we sort white pawn in inverse sort order, so that "a5" comes
# before "a2".  This makes plus-pawns work easy and well - we just run through
# the pawns in (inverse) sort order, and advance each plus-pawn until it hits something.

sub compute_futurebases {
    my ($position) = @_;

    my (@white_captures, @black_captures);
    my (@white_promotions, @black_promotions);
    my (@white_capture_promotions, @black_capture_promotions);
    my (@white_normals, @black_normals);
    my (@white_prunes, @black_prunes);

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    #return if (exists $positions{$position});
    #$positions{$position} = undef;
    #print "Considering $position\n";

    #return if (exists $positions{"$white_base@white_pawns$black_base@black_pawns"});
    #$positions{"$white_base@white_pawns$black_base@black_pawns"} = undef;
    print DEBUG "Considering $position as $white_base@white_pawns$black_base@black_pawns\n";

    # if we were considering pawn-pieces captured, that would be here

    my $pawns = $white_pawns . $black_pawns;

    foreach my $white_pawn (unpack "(a2)*", $white_pawns) {

	# first, try to queen the pawn
	if ($white_pawn =~ /.7/) {
	    if ($white_queens_allowed and ($position !~ /^K[QRBN]/)) {
		my $position2 = $position;
		$position2 =~ s/$white_pawn//;
		$position2 =~ s/^K/KQ/;
		#print "  $position2\n";
		#&consider_position($position2);
		push @white_promotions, &normalize_position($position2);
	    } else {
		push @white_prunes, "P=Q";
	    }
	    # if other black pieces allowed, consider capture promotions here
	}

	# now try to move the pawn forward
	if ($white_pawn !~ /.7/) {
	    my $forward_move = $white_pawn;
	    $forward_move =~ tr/[2-7]/[3-8]/;
	    if ($pawns !~ /$forward_move/) {
		my $position2 = $position;
		# have to consider queening
		$position2 =~ s/$white_pawn/$forward_move/;
		push @white_normals, &normalize_position($position2);

		if ($forward_move =~ /.3/) {
		    my $forward_move2 = $forward_move;
		    $forward_move2 =~ tr/3/4/;
		    if ($pawns !~ /$forward_move2/) {
			my $position3 = $position;
			$position3 =~ s/$white_pawn/$forward_move2/;
			push @white_normals, &normalize_position($position3);
		    }
		}
	    }
	}

	# can the pawn capture another pawn?
	if ($white_pawn !~ /.7/) {
	    if ($white_pawn !~ /a./) {
		my $capture_move = $white_pawn;
		$capture_move =~ tr/[2-7]/[3-8]/;
		$capture_move =~ tr/[b-h]/[a-g]/;
		if ($black_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$white_pawn/$capture_move/;
		    push @white_captures, &normalize_position($position4);
		}
		# en passant capture?
		if ($capture_move =~ /.6/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/6/5/;
		    if ($black_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$white_pawn/$capture_move/;
			push @white_captures, &normalize_position($position5);
		    }
		}
	    }
	    if ($white_pawn !~ /h./) {
		my $capture_move = $white_pawn;
		$capture_move =~ tr/[2-7]/[3-8]/;
		$capture_move =~ tr/[a-g]/[b-h]/;
		if ($black_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$white_pawn/$capture_move/;
		    push @white_captures, &normalize_position($position4);
		}
		# en passant capture?
		if ($capture_move =~ /.6/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/6/5/;
		    if ($black_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$white_pawn/$capture_move/;
			push @white_captures, &normalize_position($position5);
		    }
		}
	    }
	}

	# can the pawn be captured by the black king?
	my ($protector1, $protector2);
	if ($white_pawn !~ /a./) {
	    $protector1 = $white_pawn;
	    $protector1 =~ tr/[b-h]/[a-g]/;
	    $protector1 =~ tr/[2-7]/[1-6]/;
	} else {
	    $protector1 = "XX";
	}
	if ($white_pawn !~ /h./) {
	    $protector2 = $white_pawn;
	    $protector2 =~ tr/[a-g]/[b-h]/;
	    $protector2 =~ tr/[2-7]/[1-6]/;
	} else {
	    $protector2 = "XX";
	}
	if ($white_pawns !~ /$protector1/ and $white_pawns !~ /$protector2/) {
	    my $position6 = $position;
	    $position6 =~ s/$white_pawn//;
	    push @black_captures, &normalize_position($position6);
	}
    }

    foreach my $black_pawn (unpack "(a2)*", $black_pawns) {

	# first, try to queen the pawn
	if ($black_pawn =~ /.2/) {
	    if ($black_queens_allowed and $position !~ /\BK[QRBN]/) {
		my $position2 = $position;
		$position2 =~ s/$black_pawn//;
		$position2 =~ s/\BK/KQ/;
		push @black_promotions, &normalize_position($position2);
	    } else {
		push @black_prunes, "P=Q";
	    }

	    # consider capture promotions
	    if ($position =~ /^K([QRBN])/) {
		if ($black_queens_allowed and $position !~ /\BK[QRBN]/) {
		    my $position2 = $position;
		    $position2 =~ s/$black_pawn//;
		    $position2 =~ s/\BK/KQ/;
		    $position2 =~ s/^K[QRBN]/K/;
		    push @black_capture_promotions, &normalize_position($position2);
		} else {
		    push @black_prunes, "Px$1=Q";
		}
	    }
	}

	# now try to move the pawn forward
	if ($black_pawn !~ /.2/) {
	    my $forward_move = $black_pawn;
	    $forward_move =~ tr/[2-7]/[1-6]/;
	    if ($pawns !~ /$forward_move/) {
		my $position2 = $position;
		# have to consider queening
		$position2 =~ s/$black_pawn/$forward_move/;
		push @black_normals, &normalize_position($position2);

		if ($forward_move =~ /.6/) {
		    my $forward_move2 = $forward_move;
		    $forward_move2 =~ tr/6/5/;
		    if ($pawns !~ /$forward_move2/) {
			my $position3 = $position;
			$position3 =~ s/$black_pawn/$forward_move2/;
			push @black_normals, &normalize_position($position3);
		    }
		}
	    }
	}

	# can the pawn capture another pawn?
	if ($black_pawn !~ /.2/) {
	    if ($black_pawn !~ /a./) {
		my $capture_move = $black_pawn;
		$capture_move =~ tr/[2-7]/[1-6]/;
		$capture_move =~ tr/[b-h]/[a-g]/;
		if ($white_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$black_pawn/$capture_move/;
		    push @black_captures, &normalize_position($position4);
		}
		# en passant capture?
		if ($capture_move =~ /.3/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/3/4/;
		    if ($white_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$black_pawn/$capture_move/;
			push @black_captures, &normalize_position($position5);
		    }
		}
	    }
	    if ($black_pawn !~ /h./) {
		my $capture_move = $black_pawn;
		$capture_move =~ tr/[2-7]/[1-6]/;
		$capture_move =~ tr/[a-g]/[b-h]/;
		if ($white_pawns =~ /$capture_move/) {
		    my $position4 = $position;
		    $position4 =~ s/$capture_move//;
		    $position4 =~ s/$black_pawn/$capture_move/;
		    push @black_captures, &normalize_position($position4);
		}
		# en passant capture?
		if ($capture_move =~ /.3/ and $pawns !~ /$capture_move/) {
		    my $oldpawn = $capture_move;
		    $oldpawn =~ s/3/4/;
		    if ($white_pawns =~ /$oldpawn/) {
			my $position5 = $position;
			$position5 =~ s/$oldpawn//;
			$position5 =~ s/$black_pawn/$capture_move/;
			push @black_captures, &normalize_position($position5);
		    }
		}
	    }
	}

	# can the pawn be captured by the white king?
	my ($protector1, $protector2);
	if ($black_pawn !~ /a./) {
	    $protector1 = $black_pawn;
	    $protector1 =~ tr/[b-h]/[a-g]/;
	    $protector1 =~ tr/[2-7]/[3-8]/;
	} else {
	    $protector1 = "XX";
	}
	if ($black_pawn !~ /h./) {
	    $protector2 = $black_pawn;
	    $protector2 =~ tr/[a-g]/[b-h]/;
	    $protector2 =~ tr/[2-7]/[3-8]/;
	} else {
	    $protector2 = "XX";
	}
	if ($black_pawns !~ /$protector1/ and $black_pawns !~ /$protector2/) {
	    my $position6 = $position;
	    $position6 =~ s/$black_pawn//;
	    push @white_captures, &normalize_position($position6);
	}
    }

    # if both sides have non-king, non-pawns, have to consider captures here
    if ($position =~ /^K[QRBN]/) {
	my $position7 = $position;
	$position7 =~ s/^K[QRBN]/K/;
	push @black_captures, &normalize_position($position7);
    }

    die "futurebase" if (grep { not defined $_ } @white_captures, @black_captures);

    return (\@white_captures, \@black_captures,
	    \@white_promotions, \@black_promotions,
	    \@white_capture_promotions, \@black_capture_promotions,
	    \@white_normals, \@black_normals,
	    \@white_prunes, \@black_prunes);
}

sub consider_position {
    my ($position) = @_;

    $position = &normalize_position($position);

    return if (exists $positions{$position});
    $positions{$position} = undef;

    my ($white_captures, $black_captures,
	$white_promotions, $black_promotions,
	$white_capture_promotions, $black_capture_promotions,
	$white_normals, $black_normals,
	$white_prunes, $black_prunes) = &compute_futurebases($position);

    foreach my $new_position (@$white_captures, @$black_captures,
			      @$white_promotions, @$black_promotions,
			      @$white_capture_promotions, @$black_capture_promotions,
			      @$white_normals, @$black_normals) {
	&consider_position($new_position);
    }
}

# Returns a list of the positions assigned or checked

sub expand_pattern_list {
    my ($prefix, @sequence) = @_;
    my $first = shift @sequence;
    my @retval = ();

    if (not defined $first) {

	my $white_pawns = $prefix;
	$white_pawns =~ s/^(K[QRBN]*)//;
	my $white_base = $1;
	$white_pawns =~ s/K.*//;
	my @white_pawns = isort unpack "(a2)*", $white_pawns;

	my $black_pawns = $prefix;
	$black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
	my $black_base = $1;
	my @black_pawns = sort unpack "(a2)*", $black_pawns;

	return "$white_base@white_pawns$black_base@black_pawns";

    } elsif ($first =~ m:^K:) {

	return &expand_pattern_list($prefix . $first, @sequence);

    } elsif ($first =~ m:^(..)\+$:) {

	# plus pawns - advance them as far as they can go without hitting another pawn

	my $pawn = $1;
	if ($prefix =~ m:^K[^K]*$:) {
	    # white plus-pawn
	    #print "white pawn = $pawn\n";
	    while ($pawn !~ /8/ and "$prefix@sequence" !~ /$pawn/) {
		push @retval, &expand_pattern_list($prefix . $pawn, @sequence);
		$pawn =~ tr/[2-7]/[3-8]/;
	    }
	} else {
	    # black plus-pawn
	    while ($pawn !~ /1/ and "$prefix@sequence" !~ /$pawn/) {
		push @retval, &expand_pattern_list($prefix . $pawn, @sequence);
		$pawn =~ tr/[2-7]/[1-6]/;
	    }
	}

    } elsif ($first ne "") {

	# conventional restriction

	foreach my $square (unpack "(a2)*", $first) {
	    if ($prefix !~ /$square/) {
		push @retval, &expand_pattern_list($prefix . $square, @sequence);
	    }
	}

    } else {

	# unrestricted pawn

	foreach my $row ('2' .. '7') {
	    foreach my $col ('a' .. 'h') {
		push @retval, &expand_pattern_list($prefix . $col . $row, @sequence);
	    }
	}

    }

    return @retval;
}

sub assignallpositions {
    my ($target, @pattern) = @_;

    foreach my $position (&expand_pattern_list(@pattern)) {
	#$positions{$position} = $target if (exists $positions{$position} and not defined $positions{$position});
	$positions{$position} = $target;
    }
}

# Checks all positions resulting from a given pattern and returns either 0 (if at least one
# of them either doesn't exist in our table or has already been assigned) or a count
# of the number of unique positions matched by the pattern.

sub checkallpositions {

    my @positions = &expand_pattern_list(@_);

    print DEBUG "Checking @_ : $#positions @positions\n";

    my @unique_positions = &uniqsort(@positions);

    print DEBUG "Unique: $#unique_positions @unique_positions\n";

    foreach my $position (@unique_positions) {
	if ((not exists $positions{$position}) or (defined $positions{$position})) {
	    print DEBUG "Rejecting because of $position\n";
	    return 0;
	}
    }

    #return 1 + $#positions;
    return 1 + $#unique_positions;
}

sub assign_file {
    my ($filename) = @_;
    my ($white_pieces, $black_pieces);
    my @white_pawns;
    my @black_pawns;

    # To get the tablebase name we'll use, strip off any directory component and file extension.
    # We'll prepend $url_prefix and append '.htb', just like any other tablebase name.

    $filename =~ m|/([^/]*)\.[^/.]*$|;
    my $tbname = $1;

    #open(FILE, "<$filename");
    tie *FILE, 'IO::Zlib', $filename, "rb" or die "Can't open $filename";

    while (<FILE>) {
	$_ = lc $_;
	last if m|</tablebase>|;
	if (m|<piece|) {
	    my ($color) = m|color="([^"]*)"|;
	    my ($type) = m|type="([^"]*)"|;
	    my ($location) = m|location="([^"]*)"|;  #"
	    $location = "" if not defined $location;

	    die "Can't have non-pawn restrictions ($filename)\n" if ($type ne "pawn" and $location ne "");

	    #print "$color $type $location\n";

	    if ($color eq "white") {
		if ($type eq "knight") {
		    $white_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $white_pieces .= uc substr($type, 0, 1);
		} else {
		    push @white_pawns, $location;
		}
	    } else {
		if ($type eq "knight") {
		    $black_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $black_pieces .= uc substr($type, 0, 1);
		} else {
		    push @black_pawns, $location;
		}
	    }
	}
    }
    close(FILE);

    &assignallpositions($tbname, $white_pieces, (isort @white_pawns), $black_pieces, (sort @black_pawns));
}


sub generate_control_file {
    my ($position) = @_;

    my $cntl_filename = "$position.xml";

    if ($for_real) {
	open (OUT, ">$cntl_filename") || die "open";
    } else {
	open (OUT, ">&STDOUT") || die "open";
    }

    my $white_base = $white_base{$position};
    my $black_base = $black_base{$position};

    my @white_pieces = unpack "(a1)*", $white_base;
    my @black_pieces = unpack "(a1)*", $black_base;

    my @white_pawns = @{$white_pawns{$position}};
    my @black_pawns = @{$black_pawns{$position}};

    print OUT "<tablebase>\n";
    print OUT "   <move-restriction color=\"white\" type=\"discard\"/>\n";
    print OUT "   <move-restriction color=\"black\" type=\"concede\"/>\n";
    print OUT "   <index type=\"compact\"/>\n";
    print OUT "   <format><dtm bits=\"8\"/></format>\n";

    # isort here to make sure a white queen comes first (if present)

    foreach my $white_piece (isort @white_pieces) {
	print OUT "   <piece color=\"white\" type=\"$piece_names{$white_piece}\"/>\n";
    }
    foreach my $black_piece (@black_pieces) {
	print OUT "   <piece color=\"black\" type=\"$piece_names{$black_piece}\"/>\n";
    }

    # Sort the pawns here to make sure that doubled pawns appear in "board order"

    foreach my $white_pawn (isort @white_pawns) {
	if (defined $white_pawn) {
	    print OUT "   <piece color=\"white\" type=\"pawn\" location=\"$white_pawn\"/>\n";
	} else {
	    print OUT "   <piece color=\"white\" type=\"pawn\"/>\n";
	}
    }

    foreach my $black_pawn (sort @black_pawns) {
	if (defined $black_pawn) {
	    print OUT "   <piece color=\"black\" type=\"pawn\" location=\"$black_pawn\"/>\n";
	} else {
	    print OUT "   <piece color=\"black\" type=\"pawn\"/>\n";
	}
    }

    my (@positions, @unique_positions);
    my (@white_captures, @black_captures);
    my (@white_promotions, @black_promotions);
    my (@white_capture_promotions, @black_capture_promotions);
    my (@white_normals, @black_normals);
    my (@white_prunes, @black_prunes);

    @positions = &expand_pattern_list($white_base, (isort @white_pawns), $black_base, (sort @black_pawns));
    @unique_positions = grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @positions;

    foreach my $subposition (@unique_positions) {
	my ($white_captures, $black_captures,
	    $white_promotions, $black_promotions,
	    $white_capture_promotions, $black_capture_promotions,
	    $white_normals, $black_normals,
	    $white_prunes, $black_prunes) = &compute_futurebases($subposition);

	push @white_captures, map { $positions{$_} } @$white_captures;
	push @white_promotions, map { $positions{$_} } @$white_promotions;
	push @white_capture_promotions, map { $positions{$_} } @$white_capture_promotions;
	push @white_normals, map { $positions{$_} } @$white_normals;
	push @white_prunes, @$white_prunes;

	push @black_captures, map { $positions{$_} } @$black_captures;
	push @black_promotions, map { $positions{$_} } @$black_promotions;
	push @black_capture_promotions, map { $positions{$_} } @$black_capture_promotions;
	push @black_normals, map { $positions{$_} } @$black_normals;
	push @black_prunes, @$black_prunes;

	if (grep { not defined $_ } @white_captures, @black_captures) {
	    print "$subposition\n";
	    foreach my $capture (@$white_captures, @$black_captures) {
		print "$capture $positions{$capture}\n";
	    }
	    die "captures";
	}
    }

    my @unique_captures = &uniqsort(@white_captures, @black_captures);
    my @unique_promotions = &uniqsort(@white_promotions, @black_promotions);
    my @unique_capture_promotions = &uniqsort(@white_capture_promotions, @black_capture_promotions);
    my @unique_normals = &uniqsort(@white_normals, @black_normals);

    my @unique_white_prunes = &uniqsort(@white_prunes);
    my @unique_black_prunes = &uniqsort(@black_prunes);

    foreach my $futurebase (@unique_captures) {
	print OUT "   <futurebase url=\"$url_prefix$futurebase.htb\" type=\"capture\"/>\n";
    }

    foreach my $futurebase (@unique_promotions) {
	print OUT "   <futurebase url=\"$url_prefix$futurebase.htb\" type=\"promotion\"/>\n";
    }

    foreach my $futurebase (@unique_capture_promotions) {
	print OUT "   <futurebase url=\"$url_prefix$futurebase.htb\" type=\"capture-promotion\"/>\n";
    }

    foreach my $futurebase (@unique_normals) {
	if ($futurebase ne $position) {
	    print OUT "   <futurebase url=\"$url_prefix$futurebase.htb\" type=\"normal\"/>\n";
	}
    }

    foreach my $white_prune (@unique_white_prunes) {
	print OUT "   <prune color=\"white\" move=\"$white_prune\" type=\"discard\"/>\n";
    }
    foreach my $black_prune (@unique_black_prunes) {
	print OUT "   <prune color=\"black\" move=\"$black_prune\" type=\"concede\"/>\n";
    }


    print OUT "   <prune color=\"black\" move=\"stalemate\" type=\"concede\"/>\n" if $concede_stalemates;
    print OUT "   <generation-controls>\n";
    print OUT "      <output url=\"$url_prefix$position.htb\"/>\n";
    print OUT "      <completion-report url=\"$completion_url$position\"/>\n";
    print OUT "      <error-report url=\"$error_url$position\"/>\n";
    print OUT "   </generation-controls>\n";
    print OUT "</tablebase>\n";

    close OUT;

    print MAKEFILE "$position:";
    foreach my $futurebase (@unique_captures,
			    @unique_promotions,
			    @unique_capture_promotions,
			    @unique_normals) {
	print MAKEFILE " $futurebase";
    }
    print MAKEFILE "\n";

}


sub genset {
    my ($position) = @_;

    print DEBUG "Genset $position\n";

    # We search for plus-pawn positions by trying to back up each pawn as far as it can go,
    # going through the pawns in order, so we want them sorted so that the trailing pawn
    # comes first.  For white pawns, this means standard sort order (a4 then a5), for
    # black pawns this means reverse sort order (a5 then a4)
    #
    # Once we are testing for positions, we'll be moving the plus-pawns forward, so we want
    # them with lead pawn first.  That means inverse sort order for white (a5 then a4),
    # and standard sort order for black (a4 then a5).
    #
    # XXX - A possible problem with these regex's - the "B" for bishop could get confused
    # with a "b" for a b-pawn, but that isn't a problem if we always use caps B for
    # bishop and lowercase b for pawns.

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;

    #print "genset: $white_base @white_pawns $black_base @black_pawns\n";

    # There's two different ways we can expand the location of each pawn - by turning it into a
    # plus-pawn, or by explicitly adding to its list of squares.  It's really not clear just what
    # combination of these ways is best, so we try both possibilties for each file, keeping count of
    # which of them could assign the most positions, and use that at the end.

    my $files_in_play;

    foreach my $file ('a' .. 'h') {
	$files_in_play .= $file if grep /$file/, $white_pawns.$black_pawns;
    }

    my $num_files_in_play = length($files_in_play);
    my $file_limit = (1 << $num_files_in_play);

    my $best_count = 0;
    my @best_white_pawns;
    my @best_black_pawns;

    for (my $file_types = 0; $file_types < $file_limit; $file_types ++) {

	# OK, I just had to get crazy with Perl here.  We want a list of files that we're going to
	# put plus-pawns on, corresponding to the binary number $file_types.  So we convert
	# $file_types into a bitstring, transform it into a template (with 'x' to skip a byte and
	# 'a' to convert it), then use that template on $files_in_play to compute $plus_files.

	my $template = unpack "b$num_files_in_play", $file_types;
	$template =~ tr/01/xa/;
	my $plus_files = join '', unpack $template, $files_in_play;

	#print STDERR "$white_pawns$black_pawns $file_types $num_files_in_play $template $files_in_play $plus_files\n";

	my @white_pawns = sort unpack "(a2)*", $white_pawns;
	my @black_pawns = isort unpack "(a2)*", $black_pawns;

	foreach my $white_pawn (@white_pawns) {

	    my $white_pawn_file = substr($white_pawn,0,1);
	    if (grep /$white_pawn_file/, $plus_files) {

		$white_pawn .= "+";

		if (&checkallpositions($white_base, (isort @white_pawns),
				       $black_base, (sort @black_pawns))) {
		    while ($white_pawn =~ m/^(.[3-7])/) {
			$white_pawn =~ tr/[3-7]/[2-6]/;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $white_pawn =~ tr/[2-6]/[3-7]/;
			    last;
			}
		    }
		}

	    } else {

		# consider advancing white pawn

		while ($white_pawn =~ m/(.[2-6])$/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[2-6]/[3-7]/;

		    #last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
		    $white_pawn .= $lastpawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$white_pawn = substr($white_pawn, 0, -2);
			last;
		    }
		}

		# consider retreating white pawn

		while ($white_pawn =~ m/^(.[3-7])/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[3-7]/[2-6]/;

		    #last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
		    $white_pawn = $lastpawn . $white_pawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$white_pawn = substr($white_pawn, 2);
			last;
		    }
		}
	    }
	}

	foreach my $black_pawn (@black_pawns) {

	    my $black_pawn_file = substr($black_pawn,0,1);
	    if (grep /$black_pawn_file/, $plus_files) {

		$black_pawn .= "+";

		if (&checkallpositions($white_base, (isort @white_pawns),
				       $black_base, (sort @black_pawns))) {
		    while ($black_pawn =~ m/^(.[2-6])/) {
			$black_pawn =~ tr/[2-6]/[3-7]/;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $black_pawn =~ tr/[3-7]/[2-6]/;
			    last;
			}
		    }
		}

	    } else {

		# consider advancing black pawn

		while ($black_pawn =~ m/(.[3-7])$/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[3-7]/[2-6]/;

		    #last if ("@white_pawns@black_pawns" =~ m/$lastpawn/);
		    last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
		    $black_pawn .= $lastpawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$black_pawn = substr($black_pawn, 0, -2);
			last;
		    }
		}

		# consider retreating black pawn

		while ($black_pawn =~ m/^(.[2-6])/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[2-6]/[3-7]/;

		    #last if ("@white_pawns@black_pawns" =~ m/$lastpawn/);
		    last if grep m/^$lastpawn$/, @white_pawns, @black_pawns;
		    $black_pawn = $lastpawn . $black_pawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$black_pawn = substr($black_pawn, 2);
			last;
		    }
		}
	    }
	}

	# Save current configuration if it's the best.  The difference between ">=" and ">"
	# is to prefer plus-pawns (because they are tested last) over an explicit location
	# list.

	# Sort the black pawns in reverse order here so that doubled pawns appear in board
	# order, as is (currently) required by Hoffman.

	if (&checkallpositions($white_base, (isort @white_pawns),
			       $black_base, (sort @black_pawns))
	    >= $best_count) {
	    $best_count = &checkallpositions($white_base, (isort @white_pawns),
					     $black_base, (sort @black_pawns));
	    @best_white_pawns = sort @white_pawns;
	    @best_black_pawns = isort @black_pawns;
	}
    }

    # multiply $best_count by 64 ^ (number of fully mobile pieces) to get a count
    # of the number of positions

    $best_count <<= 6*(length($white_base) + length($black_base));

    my $cntl_filename = &pattern_to_name($white_base, @best_white_pawns, $black_base, @best_black_pawns);

    $white_base{$cntl_filename} = $white_base;
    $white_pawns{$cntl_filename} = \@best_white_pawns;
    $black_base{$cntl_filename} = $black_base;
    $black_pawns{$cntl_filename} = \@best_black_pawns;

    $LIST_SEPARATOR = " ";
    print "$white_base @best_white_pawns $black_base @best_black_pawns $best_count as $cntl_filename from $position\n";
    $LIST_SEPARATOR = undef;

    &assignallpositions($cntl_filename, $white_base, (isort @best_white_pawns), $black_base, (sort @best_black_pawns));

    die "$position wasn't defined" if not defined $positions{$position};

    return $cntl_filename;
}

sub genallsets {
    my @cntl_files_needed;

    while (my ($position, $filename) = each %positions) {
	#if (not defined $filename) {
	if (not defined $positions{$position}) {
	    #print "Processing $position\n";
	    push @cntl_files_needed, &genset($position);
	}
    }

    if ($for_real) {
	foreach my $cntl_file (@cntl_files_needed) {
	    &generate_control_file($cntl_file);
	}
    }
}


#&consider_position("Kh3Kh5");
#&consider_position("Kg2h3Kg6h5");
#&consider_position("Kb2g2h3Kg6h5");
#&consider_position("Kd4Kd5d6");
&consider_position("Kb7d4g2h3Kd5d6g6h5");

foreach my $file (@ARGV) { &assign_file($file); }

#&genset("Kb7d4g2h3Kd5d6g6h5");
&genallsets;
