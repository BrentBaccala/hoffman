#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# PAWNGEN - expands <pawngen> elements in a Hoffman XML control file.
#
# The main program can only handle <pawngen> elements with a fixed number of white and black pawns.
# This script takes a control file with a variable number of pawns and creates a set of control
# files, each with a fixed number and color of pawns.
#
# The generated control files are named identically to the original file, with the addition of a
# suffix of the form '-#WHITE-#BLACK', i.e, 'fine67.xml' generates files like 'fine67-3-2.xml',
# which would evaluate all positions with three white pawns and two black ones.

use strict;

use IO::Zlib;
use XML::LibXML;

use English;
$LIST_SEPARATOR = undef;

#open(VERBOSE,">&STDOUT");
#open(DEBUG,">&STDOUT");
#open(DEBUG2,">&STDOUT");

my $url_prefix;

my %piece_names;

$piece_names{'K'} = "king";
$piece_names{'Q'} = "queen";
$piece_names{'R'} = "rook";
$piece_names{'B'} = "bishop";
$piece_names{'N'} = "knight";

# An inverse mapping for the piece names

my %piece_character;

foreach my $piece_char (keys %piece_names) { $piece_character{$piece_names{$piece_char}} = $piece_char };

# Our original XML control file

my $XMLparser = XML::LibXML->new();
#$XMLparser->validation(1);
$XMLparser->load_ext_dtd(0);

my @white_prune_enables;
my @black_prune_enables;

my @white_XML_prunes;
my @black_XML_prunes;

my %futurebases;


# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package XML_prefix_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;
	return 0 if (defined $self->{'truncate'});

	my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	if ($search_result != -1) {
	    substr($$bufref, $search_result - length($self->{'trailing data'}) + length("</tablebase>")) = "";
	    $result = length($$bufref);
	    $self->{'truncate'} = 1;
	} else {
	    $self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	}
	return $result;
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

# Determine which of the positions we've identified are already handled by one of the futurebases
# that was specified in the original control file.  Pass in an XML futurebase node.
#
# XXX doesn't handle genuine URLs; just filenames

sub assign_futurebase {
    my ($futurebase) = @_;
    my ($white_pieces, $black_pieces);
    my @white_pawns;
    my @black_pawns;

    my $invert_colors = ($futurebase->findvalue('@colors') eq 'invert');
    my $filename;

    if ($futurebase->findvalue('@url') ne "") {
	$filename = $futurebase->findvalue('@url');
    } elsif ($futurebase->findvalue('@filename') ne "") {
	$filename = $futurebase->findvalue('@filename');
    } else {
	die "Can't find url or filename in futurebase element\n";
    }

    tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open futurebase $filename\n";
    tie *FILE, 'XML_prefix_only', *ZFILE;

    my $XMLfuturebase = $XMLparser->parse_fh(*FILE)->getDocumentElement();

    close(FILE);

    for my $white_prune_enable (map {lc $_->to_literal} $XMLfuturebase->findnodes('*[self::prune-enable or self::move-restriction][@color="white"]/@type')) {
	die "Futurebase pruning incompatible ($filename)\n"
	    if (grep({ $_ eq $white_prune_enable } @white_prune_enables) == 0);
    }

    for my $black_prune_enable (map {lc $_->to_literal} $XMLfuturebase->findnodes('*[self::prune-enable or self::move-restriction][@color="black"]/@type')) {
	die "Futurebase pruning incompatible ($filename)\n"
	    if (grep({ $_ eq $black_prune_enable } @black_prune_enables) == 0);
    }


    foreach my $XMLpiece ($XMLfuturebase->findnodes('piece[@color = "white" and @type != "pawn"]')) {
	die "Futurebases can't have non-pawn restrictions ($filename)\n" if ($XMLpiece->findvalue('@location') ne "");
	$white_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
    }

    foreach my $XMLpiece ($XMLfuturebase->findnodes('piece[@color = "black" and @type != "pawn"]')) {
	die "Futurebases can't have non-pawn restrictions ($filename)\n" if ($XMLpiece->findvalue('@location') ne "");
	$black_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
    }

    my $white_pawn_count = $XMLfuturebase->findnodes('piece[@color = "white" and @type = "pawn"]')->size();
    my $black_pawn_count = $XMLfuturebase->findnodes('piece[@color = "black" and @type = "pawn"]')->size();

    if (not $invert_colors) {
	$futurebases{$white_pawn_count . $black_pawn_count} = $futurebase->cloneNode(1);
    } else {
	$futurebases{$black_pawn_count . $white_pawn_count} = $futurebase->cloneNode(1);
    }
}


sub validate_xml_control_file {
    my ($XMLcontrolFile) = @_;

    if ($XMLcontrolFile->findnodes('piece[@color = "white" and @type = "king"]')->size() != 1
	or $XMLcontrolFile->findnodes('piece[@color = "black" and @type = "king"]')->size() != 1) {
	die "Must have one white king and one black one!\n";
    }

    # Pawngen is currently very restrictive in its piece restrictions (checked in &pawngen).  When
    # these restrictions are relaxed, though, we should...
    #
    # Check piece locations to make sure they make sense
    # Check for "more than two identical pieces with overlapping move restrictions"
    # Check for "more than one pieces frozen on XX"

    if ($XMLcontrolFile->findnodes('index[@symmetry != "8"]')->size() > 0) {
	die "pawngen doesn't support symmetry\n";
    }

    if ($XMLcontrolFile->findnodes('output')->size() > 0) {
	die "pawngen doesn't support output elements in generation-controls\n";
    }

    @white_prune_enables = map {lc $_->to_literal} $XMLcontrolFile->findnodes('*[self::prune-enable or self::move-restriction][@color="white"]/@type');
    @black_prune_enables = map {lc $_->to_literal} $XMLcontrolFile->findnodes('*[self::prune-enable or self::move-restriction][@color="black"]/@type');

    for my $white_prune (map {lc $_->to_literal} $XMLcontrolFile->findnodes('prune[@color="white"]/@type')) {
	die "At least one prune statement incompatible with prune-enable\n"
	    if (grep({ $_ eq $white_prune } @white_prune_enables) == 0);
    }

    for my $black_prune (map {lc $_->to_literal} $XMLcontrolFile->findnodes('prune[@color="black"]/@type')) {
	die "At least one prune statement incompatible with prune-enable\n"
	    if (grep({ $_ eq $black_prune } @black_prune_enables) == 0);
    }
}

#### MAIN ROUTINE ####

sub basename {
    my ($basename, $white_pawns, $black_pawns) = @_;

    $basename =~ s/.xml$//;

    return $basename . "-$white_pawns-$black_pawns";
}

sub create_control_file {
    my ($control_file, $XMLtree, $XMLcontrolFile, $white_pawns, $black_pawns) = @_;

    # Generate control/htb filenames.

    my $cntl_filename = $control_file;
    $cntl_filename =~ s/\.xml$/-$white_pawns-$black_pawns.xml/;
    die "Invalid control filename\n" if ($cntl_filename eq $control_file);

    my $htb_filename = $cntl_filename;
    $htb_filename =~ s/.xml$/.htb/;

    # Generate a futurebase element to be used by other control files to reference this one and add
    # it to the %futurebases hash.

    my $new_futurebase = XML::LibXML::Element->new('futurebase');
    $new_futurebase->setAttribute('filename', $htb_filename);
    $futurebases{$white_pawns . $black_pawns} = $new_futurebase;

    # Make a copy of the original XML control file.

    my $XMLroot = $XMLcontrolFile->cloneNode(1);

    # Set the pawngen element correctly

    my $pawngen = ($XMLroot->findnodes('pawngen'))[0];

    $pawngen->setAttribute("white-pawns-required", $white_pawns);
    $pawngen->setAttribute("black-pawns-required", $black_pawns);

    # Remove all futurebase elements

    my $first_futurebase_location = ($XMLroot->findnodes('futurebase'))[0]->previousSibling();

    $_->unbindNode() foreach $XMLroot->findnodes('futurebase');

    # Add new futurebase elements

    if ($white_pawns > 0) {
	if (not exists $futurebases{($white_pawns-1) . $black_pawns}) {
	    &create_control_file($control_file, $XMLtree, $XMLcontrolFile, $white_pawns - 1, $black_pawns);
	}
	$XMLroot->insertAfter($futurebases{($white_pawns-1) . $black_pawns}, $first_futurebase_location);
    }

    if ($black_pawns > 0) {
	if (not exists $futurebases{$white_pawns . ($black_pawns-1)}) {
	    &create_control_file($control_file, $XMLtree, $XMLcontrolFile, $white_pawns, $black_pawns - 1);
	}
	$XMLroot->insertAfter($futurebases{$white_pawns . ($black_pawns-1)}, $first_futurebase_location);
    }

    # Add an output element

    my $output = XML::LibXML::Element->new('output');
    $output->setAttribute('filename', $htb_filename);
    $XMLroot->insertAfter($output, $first_futurebase_location);

    # Save the generated control file.  Using the original $XMLtree preserves the DTD header, and
    # using format '1' inserts whitespace text nodes.

    $XMLtree->setDocumentElement($XMLroot);
    $XMLtree->toFile($cntl_filename, 2);
}

sub pawngen {
    my ($control_file) = @_;

    # Obtain an XML copy of our control file

    my $XMLtree = $XMLparser->parse_file($control_file);
    my $XMLcontrolFile = $XMLtree->getDocumentElement();
    &validate_xml_control_file($XMLcontrolFile);

    # Extract URL prefix from the control file, if it exists.  If not, then $url_prefix will be an
    # empty string.

    $url_prefix = $XMLcontrolFile->findvalue('generation-controls/url-prefix');

    # Extract any futurebases from the input control file and assign them to any positions that they
    # match.

    foreach my $futurebase ($XMLcontrolFile->findnodes("futurebase")) {
	&assign_futurebase($futurebase);
    }

    # Extract the XML pruning statements from the control file.  I do this globally because I've
    # found that each time I call findnodes I get a list of different XML::LibXML::Element's back -
    # identical in content, but different.  Since I use their addresses to generate a hash
    # indicating which prunes have been used in which positions, I need to make sure that those
    # addresses are also the same.  So do this once, here, and use it in &compute_futurebases.

#    @white_XML_prunes = $XMLcontrolFile->findnodes('prune[@color = "white"]');
#    @black_XML_prunes = $XMLcontrolFile->findnodes('prune[@color = "black"]');

    # Extract pawngen element and determine how many white and black pawns it contains.

    die "Exactly one pawngen element is required\n" if ($XMLcontrolFile->findnodes('pawngen')->size() != 1);

    my $pawngen = ($XMLcontrolFile->findnodes('pawngen'))[0];

    my $white_pawn_locations = $pawngen->findvalue('@white-pawn-locations');
    my $black_pawn_locations = $pawngen->findvalue('@black-pawn-locations');

    die "Illegal white pawn syntax in pawngen element\n" unless $white_pawn_locations =~ /^[a-h][1-8]( [a-h][1-8])*$/;
    die "Illegal black pawn syntax in pawngen element\n" unless $black_pawn_locations =~ /^[a-h][1-8]( [a-h][1-8])*$/;

    my $white_pawn_count = (length($white_pawn_locations)+1)/3;
    my $black_pawn_count = (length($black_pawn_locations)+1)/3;

    # We'll use modified copies of the original control file to create new control files, so just
    # add a single comment right now to note their origin.

    $XMLtree->addChild(XML::LibXML::Comment->new(" Created by pawngen from $control_file "));

    &create_control_file($control_file, $XMLtree, $XMLcontrolFile, $white_pawn_count, $black_pawn_count);
}


if ($#ARGV >= 0) {
    #foreach my $file (@ARGV) { &assign_file($file); }
    foreach my $control_file (@ARGV) { &pawngen($control_file); }
}
