#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# PAWNGEN - generates a directory full of Hoffman XML control files to analyze a particular pawn
# configuration, with more complicated pruning operations than are possible with a single run.
# Starting from a particular pawn configuration, this program will systematically consider all
# possible pawn movements and promotions that can result from the position.  The 'condition'
# attribute on pruning statements allows them to be applied selectively at various captures and
# promotions in the analysis.

use strict;

use IO::Zlib;
use XML::LibXML;
use Data::Dumper;

my $for_real = 1;

use English;
$LIST_SEPARATOR = undef;

open(VERBOSE,">&STDOUT");
#open(DEBUG,">&STDOUT");
#open(DEBUG2,">&STDOUT");

my $analysis = "analysis4";

# Consider pawn positions that arise after we queen, then capture with a pawn (moving the pawn to a
# different file), then queen, then capture again to a different file, etc., or just those pawn
# positions that arise directly from the current position?

my $consider_all_captures = 0;

my $url_prefix = "ftp://vger.freesoft.org/Hoffman/$analysis/";

my %piece_names;

$piece_names{'K'} = "king";
$piece_names{'Q'} = "queen";
$piece_names{'R'} = "rook";
$piece_names{'B'} = "bishop";
$piece_names{'N'} = "knight";

# An inverse mapping for the piece names

my %piece_character;

foreach my $piece_char (keys %piece_names) { $piece_character{$piece_names{$piece_char}} = $piece_char };

if ($for_real) {
    open (MAKEFILE, ">makefile") || die "open";
} else {
    open (MAKEFILE, ">/dev/null") || die "open";
}

# Our original XML control file

my $XMLtree;
my $XMLcontrolFile;

# position format - K[pieces][pawn locations]K[pieces][pawn locations]

my $white_queens_allowed = 1;
my $black_queens_allowed = 0;

my %positions;

my %white_base;
my %white_pawns;
my %black_base;
my %black_pawns;

# inverse sort

sub isort {
    return sort {$b cmp $a} @_;
}

# This Perl equivalent to "sort | uniq" might not be portable to other versions of Perl (I'm using
# 5.8.8), as it modifies the array being sorted.

sub uniqsort {
#    return grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @_;
    my @sorted = sort @_;
    for (my $i = 0; $i < $#sorted; $i++) {
	splice @sorted,$i,1 while (($i < $#sorted) and ($sorted[$i] eq $sorted[$i+1]));
    }
    return @sorted;
}

sub debuguniqsort {
#    return grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @_;
    my @sorted = sort @_;
    for (my $i = 0; $i < $#sorted; $i++) {
	print " @sorted\n";
	splice @sorted,$i,1 while (($i < $#sorted) and ($sorted[$i] eq $sorted[$i+1]));
    }
    return @sorted;
}

sub normalize_position {
    my ($position) = @_;

    print DEBUG "Normalizing $position\n";

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    return "$white_base@white_pawns$black_base@black_pawns";
}

sub pattern_to_name {
    my @pattern = @_;

    return join '', map { substr($_, 0, 1) eq "K" ? $_ : substr($_, 0, 2) } @pattern;
}

# Prune statement matching.  Given a movement and a list of prune statements (which can be regular
# expressions), figure out if any of them match and return TRUE if so.

sub match_prune {
    my ($movement, @prune_list) = @_;

    foreach my $prune_statement (@prune_list) {
	return 1 if ($movement =~ /$prune_statement/);
    }

    return 0;
}

# Given a particular position, in standard position format (see above), we now compute all possible
# future positions that can arise from it.  These aren't exactly futurebases, yet, because we
# haven't yet tried to collapse multiple positions together (using plus pawns) in a single control
# file, but the positions that come out of this routine form the core data of this program.
#
# Critical to the operation of this algorithm is the sorting of the pawn positions.
# First of all, we keep pawn positions sorted so that there's no way to confuse "a5 b6"
# with "b6 a5".  Next, we sort white pawn in inverse sort order, so that "a5" comes
# before "a2".  This makes plus-pawns work easy and well - we just run through
# the pawns in (inverse) sort order, and advance each plus-pawn until it hits something.

sub forward_pawn_move {
    my ($color, $pawn) = @_;

    if ($color eq 'white') {
	$pawn =~ tr/[2-7]/[3-8]/;
    } else {
	$pawn =~ tr/[2-7]/[1-6]/;
    }

    return $pawn;
}

sub reverse_pawn_move {
    my ($color, $pawn) = @_;

    return &forward_pawn_move($color eq 'white' ? 'black' : 'white', $pawn);
}

sub add_piece_to_position {
    my ($color, $position, $piece) = @_;

    if ($color eq 'white') {
	$position =~ s/^K/K$piece/;
    } else {
	$position =~ s/(.K)/\1$piece/;
    }

    return $position;
}

sub remove_enemy_piece_from_position {
    my ($color, $position, $piece) = @_;

    if ($color eq 'white') {
	$position =~ s/(K[^K]*K[^$piece]*)$piece/\1/;
    } else {
	$position =~ s/^([^$piece]*)$piece/\1/;
    }

    return $position;
}

sub compute_futurebases_from_one_pawn {
    my ($color, $position, $pawn, $prunes) = @_;

    my @futurebases;

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    my @white_pieces = unpack "(a1)*", $white_base;
    my @black_pieces = unpack "(a1)*", $black_base;

    my $pawns = $white_pawns . $black_pawns;

    my (@enemy_pieces, $enemy_pawns, $friendly_pawns);

    if ($color eq 'white') {
	@enemy_pieces = @black_pieces;
	$enemy_pawns = $black_pawns;
	$friendly_pawns = $white_pawns;
    } else {
	@enemy_pieces = @white_pieces;
	$enemy_pawns = $white_pawns;
	$friendly_pawns = $black_pawns;
    }

    my $forward_move = &forward_pawn_move($color, $pawn);

    if ($forward_move =~ /.[18]/) {

	# this is a promotion situation

	foreach my $promotion ('Q', 'R', 'B', 'N') {
	    if (not &match_prune("P=$promotion", @$prunes) and not &match_prune("P$pawn=$promotion", @$prunes)) {
		my $position2 = &add_piece_to_position($color, $position, $promotion);
		$position2 =~ s/$pawn//;
		push @futurebases, &normalize_position($position2);
	    }

	    # consider capture promotions

	    foreach my $enemy_piece (@enemy_pieces) {
		if ($enemy_piece != 'K' and not &match_prune("Px$enemy_piece=$promotion", @$prunes)) {
		    my $position2 = &remove_enemy_piece_from_position($color, $position, $enemy_piece);
		    $position2 = &add_piece_to_position($color, $position, $promotion);
		    $position2 =~ s/$pawn//;
		    push @futurebases, &normalize_position($position2);
		}
	    }
	}

    } else {

	# not a promotion situation, try to move the pawn forward

	if ($pawns !~ /$forward_move/) {
	    if (not &match_prune("P$forward_move", @$prunes)) {
		my $position2 = $position;
		$position2 =~ s/$pawn/$forward_move/;
		push @futurebases, &normalize_position($position2);
	    }

	    if (($color eq 'white' and $forward_move =~ /.3/) or ($color eq 'black' and $forward_move =~ /.6/)) {
		my $forward_move2 = &forward_pawn_move($color, $forward_move);
		if ($pawns !~ /$forward_move2/ and not &match_prune("P$forward_move2", @$prunes)) {
		    my $position3 = $position;
		    $position3 =~ s/$pawn/$forward_move2/;
		    push @futurebases, &normalize_position($position3);
		}
	    }
	}

	# ordinary (non-promotion) captures by the pawn

	foreach my $direction ("a-to-h", "h-to-a") {
	    next if ($direction eq "a-to-h" and $pawn =~ /h./);
	    next if ($direction eq "h-to-a" and $pawn =~ /a./);

	    my $capture_move = $forward_move;

	    if ($direction eq "a-to-h") {
		$capture_move =~ tr/[a-g]/[b-h]/;
	    } else {
		$capture_move =~ tr/[b-h]/[a-g]/;
	    }

	    # can the pawn capture a piece?

	    # This is where we used to special case $consider_all_captures

	    foreach my $enemy_piece (@enemy_pieces) {
		if ($enemy_piece != 'K' and not &match_prune("Px$enemy_piece", @$prunes) and $pawns !~ /$capture_move/) {
		    my $position2 = &remove_enemy_piece_from_position($color, $position, $enemy_piece);
		    $position2 =~ s/$pawn/$capture_move/;
		    push @futurebases, &normalize_position($position2);
		}
	    }

	    # can the pawn capture another pawn?

	    if (not &match_prune("PxP", @$prunes) and $enemy_pawns =~ /$capture_move/) {
		my $position4 = $position;
		$position4 =~ s/$capture_move//;
		$position4 =~ s/$pawn/$capture_move/;
		push @futurebases, &normalize_position($position4);
	    }

	    # en passant capture?

	    if (not &match_prune("PxP", @$prunes) and ($pawns !~ /$capture_move/)
		and (($color eq 'white' and $capture_move =~ /.6/) or ($color eq 'black' and $capture_move =~ /.3/))) {

		my $oldpawn = &reverse_pawn_move($color, $capture_move);
		if ($enemy_pawns =~ /$oldpawn/) {
		    my $position5 = $position;
		    $position5 =~ s/$oldpawn//;
		    $position5 =~ s/$pawn/$capture_move/;
		    push @futurebases, &normalize_position($position5);
		}
	    }
	}
    }

    # captures of the pawn by a piece (captures by another pawn will be considered in another pass
    # through this routine).  Special case for captures by the king (an optimization) - look to see
    # if a friendly pawn is protecting this one, if so it can't be captured by the king.

    foreach my $enemy_piece (@enemy_pieces) {
	if (not &match_prune("${enemy_piece}xP")) {
	    if ($enemy_piece eq 'K') {
		my $protector1 = &reverse_pawn_move($color, $pawn);
		my $protector2 = &reverse_pawn_move($color, $pawn);
		$protector1 =~ tr/[a-h]/[b-i]/;
		$protector2 =~ tr/abcdefgh/xabcdefg/;
		next if ($friendly_pawns =~ /$protector1/ or $friendly_pawns =~ /$protector2/);
	    }
	    my $position6 = $position;
	    $position6 =~ s/$pawn//;
	    push @futurebases, &normalize_position($position6);
	}
    }

    return @futurebases;
}

sub compute_futurebases {
    my ($position) = @_;

    my @futurebases;
    my (@white_prunes, @black_prunes);

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;
    my @white_pawns = isort unpack "(a2)*", $white_pawns;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;
    my @black_pawns = sort unpack "(a2)*", $black_pawns;

    my @white_pieces = unpack "(a1)*", $white_base;
    my @black_pieces = unpack "(a1)*", $black_base;

    print VERBOSE "Considering $position (sorted as $white_base@white_pawns$black_base@black_pawns)\n";

    # Look into the global XML control file and extract the prune statements.  Not all of them may
    # apply to a given position; we allow arbitrary Perl code in the prune statement to selectively
    # apply them.  XXX need to track concede/discard, too

    foreach my $white_prune ($XMLcontrolFile->findnodes("prune[attribute::color = 'white']")) {
	my $condition_present = $white_prune->findnodes('@condition')->size();
	my $condition = $white_prune->findvalue('@condition');
	if (not $condition_present or eval $condition) {
	    push @white_prunes, $white_prune->findvalue('@move');
	}
    }

    foreach my $black_prune ($XMLcontrolFile->findnodes("prune[attribute::color = 'black']")) {
	my $condition_present = $black_prune->findnodes('@condition')->size();
	my $condition = $black_prune->findvalue('@condition');
	if (not $condition_present or eval $condition) {
	    push @black_prunes, $black_prune->findvalue('@move');
	}
    }

    # consider all pawn possibilities

    foreach my $white_pawn (unpack "(a2)*", $white_pawns) {
	push @futurebases, &compute_futurebases_from_one_pawn('white', $position, $white_pawn, \@white_prunes);
    }

    foreach my $black_pawn (unpack "(a2)*", $black_pawns) {
	push @futurebases, &compute_futurebases_from_one_pawn('black', $position, $black_pawn, \@black_prunes);
    }

    # consider piece-on-piece captures

    # XXX add something to prune here

    for (my $i=0; $i < length($position); $i ++) {
	if (substr($position,$i,1) =~ /QRBN/) {
	    my $position7 = $position;
	    substr($position7,$i,1) = "";
	    push @futurebases, &normalize_position($position7);
	}
    }

    return (\@futurebases, \@white_prunes, \@black_prunes);
}

sub consider_position {
    my ($position) = @_;

    $position = &normalize_position($position);

    return if (exists $positions{$position});
    $positions{$position} = undef;

    my ($futurebases, $white_prunes, $black_prunes) = &compute_futurebases($position);

    foreach my $new_position (@$futurebases) {
	&consider_position($new_position);
    }
}

# Returns a list of the positions assigned or checked

sub expand_pattern_list {
    my ($prefix, @sequence) = @_;
    my $first = shift @sequence;
    my @retval = ();

    if (not defined $first) {

	my $white_pawns = $prefix;
	$white_pawns =~ s/^(K[QRBN]*)//;
	my $white_base = $1;
	$white_pawns =~ s/K.*//;
	my @white_pawns = isort unpack "(a2)*", $white_pawns;

	my $black_pawns = $prefix;
	$black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
	my $black_base = $1;
	my @black_pawns = sort unpack "(a2)*", $black_pawns;

	return "$white_base@white_pawns$black_base@black_pawns";

    } elsif ($first =~ /^K/) {

	return &expand_pattern_list($prefix . $first, @sequence);

    } elsif ($first =~ /^(..)\+$/) {

	# plus pawns - advance them as far as they can go without hitting another pawn

	my $pawn = $1;
	if ($prefix =~ /^K[^K]*$/) {
	    # white plus-pawn
	    #print "white pawn = $pawn\n";
	    while ($pawn !~ /8/ and "$prefix@sequence" !~ /$pawn/) {
		push @retval, &expand_pattern_list($prefix . $pawn, @sequence);
		$pawn =~ tr/[2-7]/[3-8]/;
	    }
	} else {
	    # black plus-pawn
	    while ($pawn !~ /1/ and "$prefix@sequence" !~ /$pawn/) {
		push @retval, &expand_pattern_list($prefix . $pawn, @sequence);
		$pawn =~ tr/[2-7]/[1-6]/;
	    }
	}

    } elsif ($first ne "") {

	# conventional restriction

	foreach my $square (unpack "(a2)*", $first) {
	    if ($prefix !~ /$square/) {
		push @retval, &expand_pattern_list($prefix . $square, @sequence);
	    }
	}

    } else {

	# unrestricted pawn

	foreach my $row ('2' .. '7') {
	    foreach my $col ('a' .. 'h') {
		push @retval, &expand_pattern_list($prefix . $col . $row, @sequence);
	    }
	}

    }

    return @retval;
}

sub assignallpositions {
    my ($target, @pattern) = @_;

    foreach my $position (&expand_pattern_list(@pattern)) {
	#$positions{$position} = $target if (exists $positions{$position} and not defined $positions{$position});
	$positions{$position} = $target;
    }
}

# Checks all positions resulting from a given pattern and returns either 0 (if at least one
# of them either doesn't exist in our table or has already been assigned) or a count
# of the number of unique positions matched by the pattern.

sub checkallpositions {

    my @positions = &expand_pattern_list(@_);

    print DEBUG2 "Checking @_ : $#positions @positions\n";

    my @unique_positions = &uniqsort(@positions);

    print DEBUG2 "Unique: $#unique_positions @unique_positions\n";

    foreach my $position (@unique_positions) {
	if ((not exists $positions{$position}) or (defined $positions{$position})) {
	    print DEBUG2 "Rejecting because of $position\n";
	    return 0;
	}
    }

    #return 1 + $#positions;
    return 1 + $#unique_positions;
}

# Determine which of the positions we've identified are already handled by one of the tablebases
# that we passed in on the command line.

sub assign_file {
    my ($filename) = @_;
    my ($white_pieces, $black_pieces);
    my @white_pawns;
    my @black_pawns;

    # To get the tablebase name we'll use, strip off any directory component and file extension.
    # We'll prepend $url_prefix and append '.htb', just like any other tablebase name.

    $filename =~ m|/([^/]*)\.[^/.]*$|;
    my $tbname = $1;

    #open(FILE, "<$filename");
    tie *FILE, 'IO::Zlib', $filename, "rb" or die "Can't open $filename";

    while (<FILE>) {
	$_ = lc $_;
	last if m|</tablebase>|;
	if (m|<piece|) {
	    my ($color) = m|color="([^"]*)"|;
	    my ($type) = m|type="([^"]*)"|;
	    my ($location) = m|location="([^"]*)"|;
	    $location = "" if not defined $location;

	    # Hoffman XML location format allows spaces - this script does not
	    $location =~ s/ //g;

	    die "Can't have non-pawn restrictions ($filename)\n" if ($type ne "pawn" and $location ne "");

	    #print "$color $type $location\n";

	    if ($color eq "white") {
		if ($type eq "knight") {
		    $white_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $white_pieces .= uc substr($type, 0, 1);
		} else {
		    push @white_pawns, $location;
		}
	    } else {
		if ($type eq "knight") {
		    $black_pieces .= "N";
		} elsif ($type ne "pawn") {
		    $black_pieces .= uc substr($type, 0, 1);
		} else {
		    push @black_pawns, $location;
		}
	    }
	}
    }
    close(FILE);

    &assignallpositions($tbname, $white_pieces, (isort @white_pawns), $black_pieces, (sort @black_pawns));
}


my $piece_text;
my $next_piece_location;

my $XMLroot;

# Convenience subroutine to add a piece to the XML.  Not only do we add the element, but we put
# some text in (determined below) to keep the formatting nice.

sub add_piece {
    my ($color, $type, $location) = @_;
    # my $new_piece = $XMLtree->createElement('piece');
    my $new_piece = XML::LibXML::Element->new('piece');
    $new_piece->addChild($XMLtree->createAttribute('color', $color));
    $new_piece->addChild($XMLtree->createAttribute('type', $type));
    $new_piece->addChild($XMLtree->createAttribute('location', $location)) if defined $location;
    $XMLroot->insertAfter($new_piece, $next_piece_location);
    #$XMLroot->appendChild($new_piece);
    $next_piece_location = $XMLtree->createTextNode($piece_text);
    $XMLroot->insertAfter($next_piece_location, $new_piece);
}

sub add_futurebase {
    my ($url) = @_;
    my $new_futurebase = $XMLtree->createElement('futurebase');
    $new_futurebase->addChild($XMLtree->createAttribute('url', $url));
    $XMLroot->insertAfter($new_futurebase, $next_piece_location);
    $next_piece_location = $XMLtree->createTextNode($piece_text);
    $XMLroot->insertAfter($next_piece_location, $new_futurebase);
}

sub add_prune {
    my ($color, $move, $type) = @_;
    my $new_prune = $XMLtree->createElement('prune');
    $new_prune->addChild($XMLtree->createAttribute('color', $color));
    $new_prune->addChild($XMLtree->createAttribute('move', $move));
    $new_prune->addChild($XMLtree->createAttribute('type', $type));
    $XMLroot->insertAfter($new_prune, $next_piece_location);
    $next_piece_location = $XMLtree->createTextNode($piece_text);
    $XMLroot->insertAfter($next_piece_location, $new_prune);
}

sub generate_control_file {
    my ($position) = @_;

    my $cntl_filename = "$position.xml";

    my $white_base = $white_base{$position};
    my $black_base = $black_base{$position};

    my @white_pieces = unpack "(a1)*", $white_base;
    my @black_pieces = unpack "(a1)*", $black_base;

    my @white_pawns = @{$white_pawns{$position}};
    my @black_pawns = @{$black_pawns{$position}};

    # Make a copy of the original XML control file, then remove all existing pieces from it.  We'll
    # reinsert the ones we want below.  This destroys location restrictions, which means that we
    # don't support location restrictions yet in pawngen.  It also removes any text node that
    # follows the pieces, and notes what that text was for later use.

    $XMLroot = $XMLtree->getDocumentElement->cloneNode(1);

    #print $XMLroot->toString() . "\n";

    undef $next_piece_location;

    foreach my $old_piece ($XMLroot->findnodes('piece')) {
	my $text_node = $old_piece->nextSibling();

	if (not defined $next_piece_location) {
	    $next_piece_location = $old_piece->previousSibling();
	}

	if ($text_node->nodeValue ne "") {
	    $piece_text = $text_node->nodeValue unless defined $piece_text;
	    $text_node->unbindNode();
	}

	$old_piece->unbindNode();
    }

    #print $XMLroot->toString() . "\n";

    # isort here to make sure a white queen comes first (if present)

    foreach my $white_piece (isort @white_pieces) {
	&add_piece('white', $piece_names{$white_piece});
    }

    foreach my $black_piece (@black_pieces) {
	&add_piece('black', $piece_names{$black_piece});
    }

    # Sort the pawns here to make sure that doubled pawns appear in "board order".  Also note that a
    # value in the pawns array may be undefined to indicate an unrestricted pawn.  &add_piece
    # handles this correctly.

    foreach my $white_pawn (sort @white_pawns) {
	&add_piece('white', 'pawn', $white_pawn);
    }

    foreach my $black_pawn (sort @black_pawns) {
	&add_piece('black', 'pawn', $black_pawn);
    }

    #print $XMLroot->toString() . "\n";

    # Now we need to figure out which futurebases we'll need to build this tablebase and add a list
    # of them to the control file.  Keep on adding them right after the pieces.

    my (@positions, @unique_positions);
    my @futurebases;
    my (@white_prunes, @black_prunes);

    @positions = &expand_pattern_list($white_base, (isort @white_pawns), $black_base, (sort @black_pawns));
    @unique_positions = grep {defined $_ } sort { ($a cmp $b) or (($a = undef),0) } @positions;

    foreach my $subposition (@unique_positions) {
	my ($futurebases, $white_prunes, $black_prunes) = &compute_futurebases($subposition);

	push @futurebases, map { $positions{$_} } @$futurebases;
	push @white_prunes, @$white_prunes;
	push @black_prunes, @$black_prunes;

#	if (grep { not defined $_ } @white_captures, @black_captures) {
#	    print "$subposition\n";
#	    foreach my $capture (@$white_captures, @$black_captures) {
#		print "$capture $positions{$capture}\n";
#	    }
#	    die "captures";
#	}
    }

    my @unique_futurebases = &uniqsort(@futurebases);
    my @unique_white_prunes = &uniqsort(@white_prunes);
    my @unique_black_prunes = &uniqsort(@black_prunes);

    foreach my $futurebase (@unique_futurebases) {
	if ($futurebase ne $position) {
	    &add_futurebase("$url_prefix$futurebase.htb");
	}
    }

    foreach my $white_prune (@unique_white_prunes) {
	&add_prune('white', $white_prune, 'discard');
    }
    foreach my $black_prune (@unique_black_prunes) {
	&add_prune('black', $black_prune, 'concede');
    }


    if ($for_real) {
	open (OUT, ">$cntl_filename") || die "open";
    } else {
	open (OUT, ">&STDOUT") || die "open";
    }

    print OUT $XMLroot->toString();
    close OUT;

    print MAKEFILE "$position:";
    foreach my $futurebase (@futurebases) {
	print MAKEFILE " $futurebase" if ($futurebase ne $position);
    }
    print MAKEFILE "\n";

}


sub genset {
    my ($position) = @_;

    print DEBUG "Genset $position\n";

    # We search for plus-pawn positions by trying to back up each pawn as far as it can go,
    # going through the pawns in order, so we want them sorted so that the trailing pawn
    # comes first.  For white pawns, this means standard sort order (a4 then a5), for
    # black pawns this means reverse sort order (a5 then a4)
    #
    # Once we are testing for positions, we'll be moving the plus-pawns forward, so we want
    # them with lead pawn first.  That means inverse sort order for white (a5 then a4),
    # and standard sort order for black (a4 then a5).
    #
    # XXX - A possible problem with these regex's - the "B" for bishop could get confused
    # with a "b" for a b-pawn, but that isn't a problem if we always use caps B for
    # bishop and lowercase b for pawns.

    my $white_pawns = $position;
    $white_pawns =~ s/^(K[QRBN]*)//;
    my $white_base = $1;
    $white_pawns =~ s/K.*//;

    my $black_pawns = $position;
    $black_pawns =~ s/^K[^K]*(K[QRBN]*)//;
    my $black_base = $1;

    #print "genset: $white_base @white_pawns $black_base @black_pawns\n";

    # There's two different ways we can expand the location of each pawn - by turning it into a
    # plus-pawn, or by explicitly adding to its list of squares.  It's really not clear just what
    # combination of these ways is best, so we try both possibilties for each file, keeping count of
    # which of them could assign the most positions, and use that at the end.

    my $files_in_play;

    foreach my $file ('a' .. 'h') {
	$files_in_play .= $file if grep /$file/, $white_pawns.$black_pawns;
    }

    my $num_files_in_play = length($files_in_play);
    my $file_limit = (1 << $num_files_in_play);

    my $best_count = 0;
    my @best_white_pawns;
    my @best_black_pawns;

    for (my $file_types = 0; $file_types < $file_limit; $file_types ++) {

	# OK, I just had to get crazy with Perl here.  We want a list of files that we're going to
	# put plus-pawns on, corresponding to the binary number $file_types.  So we convert
	# $file_types into a bitstring, transform it into a template (with 'x' to skip a byte and
	# 'a' to convert it), then use that template on $files_in_play to compute $plus_files.

	my $template = unpack "b$num_files_in_play", $file_types;
	$template =~ tr/01/xa/;
	my $plus_files = join '', unpack $template, $files_in_play;

	#print STDERR "$white_pawns$black_pawns $file_types $num_files_in_play $template $files_in_play $plus_files\n";

	my @white_pawns = sort unpack "(a2)*", $white_pawns;
	my @black_pawns = isort unpack "(a2)*", $black_pawns;

	foreach my $white_pawn (@white_pawns) {

	    my $white_pawn_file = substr($white_pawn,0,1);
	    if (grep /$white_pawn_file/, $plus_files) {

		$white_pawn .= "+";

		if (&checkallpositions($white_base, (isort @white_pawns),
				       $black_base, (sort @black_pawns))) {
		    while ($white_pawn =~ /^(.[3-7])/) {
			$white_pawn =~ tr/[3-7]/[2-6]/;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $white_pawn =~ tr/[2-6]/[3-7]/;
			    last;
			}
		    }
		}

	    } else {

		# consider advancing white pawn

		while ($white_pawn =~ /(.[2-6])$/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[2-6]/[3-7]/;

		    #last if grep /^$lastpawn$/, @white_pawns, @black_pawns;
		    $white_pawn .= $lastpawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$white_pawn = substr($white_pawn, 0, -2);
			last;
		    }
		}

		# consider retreating white pawn

		while ($white_pawn =~ /^(.[3-7])/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[3-7]/[2-6]/;

		    #last if grep /^$lastpawn$/, @white_pawns, @black_pawns;
		    $white_pawn = $lastpawn . $white_pawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$white_pawn = substr($white_pawn, 2);
			last;
		    }
		}
	    }
	}

	foreach my $black_pawn (@black_pawns) {

	    my $black_pawn_file = substr($black_pawn,0,1);
	    if (grep /$black_pawn_file/, $plus_files) {

		$black_pawn .= "+";

		if (&checkallpositions($white_base, (isort @white_pawns),
				       $black_base, (sort @black_pawns))) {
		    while ($black_pawn =~ /^(.[2-6])/) {
			$black_pawn =~ tr/[2-6]/[3-7]/;
			if (not &checkallpositions($white_base, (isort @white_pawns),
						   $black_base, (sort @black_pawns))) {
			    $black_pawn =~ tr/[3-7]/[2-6]/;
			    last;
			}
		    }
		}

	    } else {

		# consider advancing black pawn

		while ($black_pawn =~ /(.[3-7])$/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[3-7]/[2-6]/;

		    #last if ("@white_pawns@black_pawns" =~ /$lastpawn/);
		    last if grep /^$lastpawn$/, @white_pawns, @black_pawns;
		    $black_pawn .= $lastpawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$black_pawn = substr($black_pawn, 0, -2);
			last;
		    }
		}

		# consider retreating black pawn

		while ($black_pawn =~ /^(.[2-6])/) {
		    my $lastpawn = $1;
		    $lastpawn =~ tr/[2-6]/[3-7]/;

		    #last if ("@white_pawns@black_pawns" =~ /$lastpawn/);
		    last if grep /^$lastpawn$/, @white_pawns, @black_pawns;
		    $black_pawn = $lastpawn . $black_pawn;
		    if (not &checkallpositions($white_base, (isort @white_pawns),
					       $black_base, (sort @black_pawns))) {
			$black_pawn = substr($black_pawn, 2);
			last;
		    }
		}
	    }
	}

	# Save current configuration if it's the best.  The difference between ">=" and ">"
	# is to prefer plus-pawns (because they are tested last) over an explicit location
	# list.

	# Sort the black pawns in reverse order here so that doubled pawns appear in board
	# order, as is (currently) required by Hoffman.

	if (&checkallpositions($white_base, (isort @white_pawns),
			       $black_base, (sort @black_pawns))
	    >= $best_count) {
	    $best_count = &checkallpositions($white_base, (isort @white_pawns),
					     $black_base, (sort @black_pawns));
	    @best_white_pawns = sort @white_pawns;
	    @best_black_pawns = isort @black_pawns;
	}
    }

    # multiply $best_count by 64 ^ (number of fully mobile pieces) to get a count
    # of the number of positions

    $best_count <<= 6*(length($white_base) + length($black_base));

    my $cntl_filename = &pattern_to_name($white_base, @best_white_pawns, $black_base, @best_black_pawns);

    $white_base{$cntl_filename} = $white_base;
    $white_pawns{$cntl_filename} = \@best_white_pawns;
    $black_base{$cntl_filename} = $black_base;
    $black_pawns{$cntl_filename} = \@best_black_pawns;

    $LIST_SEPARATOR = " ";
    print "$white_base @best_white_pawns $black_base @best_black_pawns $best_count as $cntl_filename from $position\n";
    $LIST_SEPARATOR = undef;

    &assignallpositions($cntl_filename, $white_base, (isort @best_white_pawns), $black_base, (sort @best_black_pawns));

    die "$position wasn't defined" if not defined $positions{$position};

    return $cntl_filename;
}

sub genallsets {
    my @cntl_files_needed;

    while (my ($position, $filename) = each %positions) {
	#if (not defined $filename) {
	if (not defined $positions{$position}) {
	    #print "Processing $position\n";
	    push @cntl_files_needed, &genset($position);
	}
    }

    if ($for_real) {
	foreach my $cntl_file (@cntl_files_needed) {
	    &generate_control_file($cntl_file);
	}
    }
}


#### MAIN ROUTINE ####

sub pawngen {
    my ($control_file) = @_;

    # Obtain an XML copy of our control file ($XMLtree is global so other routines can copy it)

    my $XMLparser = XML::LibXML->new();
    $XMLparser->recover_silently(0);

    $XMLtree = $XMLparser->parse_file($control_file);
    $XMLcontrolFile = $XMLtree->getDocumentElement();

    # Figure out our starting position

    my $starting_position = "";

    foreach my $white_piece ($XMLcontrolFile->findnodes("piece[attribute::color = 'white' and attribute::type != 'pawn']")) {
	die "pawngen doesn't support movement restrictions on non-pawns yet" if $white_piece->findvalue('@location');
	$starting_position .= $piece_character{$white_piece->findvalue('@type')};
    }

    foreach my $white_pawn ($XMLcontrolFile->findnodes("piece[attribute::color = 'white' and attribute::type = 'pawn']")) {
	die "pawngen doesn't unrestricted pawns yet" if not $white_pawn->findvalue('@location');
	my $pawn_location = $white_pawn->findvalue('@location');
	die "pawngen doesn't support any pawn restrictions other than plus pawns yet" unless
	    $pawn_location =~ s/^([a-h][1-8])\+$/\1/;
	$starting_position .= $pawn_location;
    }

    foreach my $black_piece ($XMLcontrolFile->findnodes("piece[attribute::color = 'black' and attribute::type != 'pawn']")) {
	die "pawngen doesn't support movement restrictions on non-pawns yet" if $black_piece->findvalue('@location');
	$starting_position .= $piece_character{$black_piece->findvalue('@type')};
    }

    foreach my $black_pawn ($XMLcontrolFile->findnodes("piece[attribute::color = 'black' and attribute::type = 'pawn']")) {
	die "pawngen doesn't unrestricted pawns yet" if not $black_pawn->findvalue('@location');
	my $pawn_location = $black_pawn->findvalue('@location');
	die "pawngen doesn't support any pawn restrictions other than plus pawns yet" unless
	    $pawn_location =~ s/^([a-h][1-8])\+$/\1/;
	$starting_position .= $pawn_location;
    }

    print "Starting position $starting_position\n";

    &consider_position($starting_position);

    &genallsets;
}


if ($#ARGV >= 0) {
    #foreach my $file (@ARGV) { &assign_file($file); }
    foreach my $control_file (@ARGV) { &pawngen($control_file); }
}
