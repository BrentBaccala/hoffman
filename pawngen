#! /usr/bin/perl
# -*- fill-column: 100; -*-
#
# PAWNGEN - expands <pawngen> elements in a Hoffman XML control file.
#
# The main program can only handle <pawngen> elements with a fixed number of white and black pawns.
# This script takes a control file with a variable number of pawns and creates a set of control
# files, each with a fixed number and color of pawns.
#
# The generated control files are named identically to the original file, with the addition of a
# suffix of the form '-#WHITE-#BLACK', i.e, 'fine67.xml' generates files like 'fine67-3-2.xml',
# which would evaluate all positions with three white pawns and two black ones.

use strict;

use IO::Zlib;
use XML::LibXML;

use English;
$LIST_SEPARATOR = undef;

#open(VERBOSE,">&STDOUT");
#open(DEBUG,">&STDOUT");
#open(DEBUG2,">&STDOUT");

my $url_prefix;

my %piece_names;

$piece_names{'K'} = "king";
$piece_names{'Q'} = "queen";
$piece_names{'R'} = "rook";
$piece_names{'B'} = "bishop";
$piece_names{'N'} = "knight";

# An inverse mapping for the piece names

my %piece_character;

foreach my $piece_char (keys %piece_names) { $piece_character{$piece_names{$piece_char}} = $piece_char };

# Our original XML control file

my $XMLparser = XML::LibXML->new();
#$XMLparser->validation(1);
$XMLparser->load_ext_dtd(0);

my @white_prune_enables;
my @black_prune_enables;

my @white_XML_prunes;
my @black_XML_prunes;

my %futurebases;


# The purpose of this little package is to eliminate a parser error that would be be generated by
# 'extra content at the end of the document' when we're parsing a futurebase.  We use Perl's tie
# mechanism to wrap ourselves around a filehandle, and then truncate its reads after we've seen the
# closing '</tablebase>' tag.  This is made a bit tricky by the possibility of the '</tablebase>'
# tag spanning two reads; to handle this case we save 16 bytes of trailing data from each read and
# use that to prefix the match on the next read.  Without this special case, it'd really be no more
# complex than 's|</tablebase>.*|</tablebase>|s'.

{
    package XML_prefix_only;

    sub TIEHANDLE {
	my ($classname, $fh) = @_;
	my $self = {'fh' => $fh, 'trailing data' => ""};
	return bless $self, $classname;
    }

    sub READ {
	my $bufref = \$_[1];
	my ($self, undef, $len, $offset) = @_;
	return 0 if (defined $self->{'truncate'});

	my $result = read(*{$self->{'fh'}}, $$bufref, $len, $offset);
	my $search_result = index($self->{'trailing data'} . $$bufref, "</tablebase>");

	if ($search_result != -1) {
	    substr($$bufref, $search_result - length($self->{'trailing data'}) + length("</tablebase>")) = "";
	    $result = length($$bufref);
	    $self->{'truncate'} = 1;
	} else {
	    $self->{'trailing data'} = substr($self->{'trailing data'} . $$bufref, -16);
	}
	return $result;
    }

    sub CLOSE {
	my ($self) = @_;
	return close(*{$self->{'fh'}});
    }
}

# Determine which of the positions we've identified are already handled by one of the futurebases
# that was specified in the original control file.  Pass in an XML futurebase node.
#
# XXX doesn't handle genuine URLs; just filenames

sub assign_futurebase {
    my ($futurebase) = @_;

    my $invert_colors = ($futurebase->findvalue('@colors') eq 'invert');

    my $filename_string;

    if ($futurebase->findvalue('@url') ne "") {
	$filename_string = $futurebase->findvalue('@url');
    } elsif ($futurebase->findvalue('@filename') ne "") {
	$filename_string = $futurebase->findvalue('@filename');
    } else {
	die "Can't find url or filename in futurebase element\n";
    }

    foreach my $filename (glob $filename_string) {

	my ($white_pieces, $black_pieces);
	my @white_pawns;
	my @black_pawns;

	$futurebase->setAttribute('filename', $filename);

	if ($filename =~ m/.rtbw$/) {
	    # Syzygy win-draw-loss bitbase
	    $filename =~ s/.rtbw$//;
	    $filename =~ s|.*/||;
	    my ($whitename, $blackname) = split(/v/, $filename);
	    my $whitepawns = ($whitename =~ tr/P//d);
	    my $blackpawns = ($blackname =~ tr/P//d);

	    my $key;
	    if (not $invert_colors) {
		$key = uc($whitename) . $whitepawns . uc($blackname) . $blackpawns;
	    } else {
		$key = uc($blackname) . $blackpawns . uc($whitename) . $whitepawns;
	    }

	    $futurebases{$key} = $futurebase->cloneNode(1);
	    print "$key -> $filename\n";
	    next;
	}

	if ($filename =~ m/.nbw$/ || $filename =~ m/.nbb$/ || $filename =~ m/.emd$/) {
	    # Nalimov tablebase
	    $filename =~ s/.emd$//;
	    $filename =~ s/.nbw$//;
	    $filename =~ s/.nbb$//;
	    $filename =~ s|.*/||;
	    my ($empty, $whitename, $blackname) = split(/k/, $filename);
	    my $whitepawns = ($whitename =~ tr/p//d);
	    my $blackpawns = ($blackname =~ tr/p//d);

	    my $key;
	    if (not $invert_colors) {
		$key = 'K' . uc($whitename) . $whitepawns . 'K' . uc($blackname) . $blackpawns;
	    } else {
		$key = 'K' . uc($blackname) . $blackpawns . 'K' . uc($whitename) . $whitepawns;
	    }

	    $futurebases{$key} = $futurebase->cloneNode(1);
	    print "$key -> $filename\n";
	    next;
	}

	tie *ZFILE, 'IO::Zlib', $filename, "rb" or die "Can't open futurebase $filename\n";
	tie *FILE, 'XML_prefix_only', *ZFILE;

	my $XMLfuturebase = $XMLparser->parse_fh(*FILE)->getDocumentElement();

	close(FILE);

	# Check to make sure that any pruning elements in the futurebase have matching pruning
	# elements in the main control file.  The main file can have additional pruning elements,
	# but the futurebases can't have pruning elements that aren't in the main file.

	for my $white_prune_enable (map {lc $_->to_literal} $XMLfuturebase->findnodes('*[self::prune-enable or self::move-restriction][@color="white"]/@type')) {
	    die "Futurebase pruning incompatible ($filename)\n"
		if (grep({ $_ eq $white_prune_enable } @white_prune_enables) == 0);
	}

	for my $black_prune_enable (map {lc $_->to_literal} $XMLfuturebase->findnodes('*[self::prune-enable or self::move-restriction][@color="black"]/@type')) {
	    die "Futurebase pruning incompatible ($filename)\n"
		if (grep({ $_ eq $black_prune_enable } @black_prune_enables) == 0);
	}

	foreach my $XMLpiece ($XMLfuturebase->findnodes('piece[@color = "white" and @type != "pawn"]')) {
	    die "Futurebases can't have non-pawn restrictions ($filename)\n" if ($XMLpiece->findvalue('@location') ne "");
	    $white_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
	}

	foreach my $XMLpiece ($XMLfuturebase->findnodes('piece[@color = "black" and @type != "pawn"]')) {
	    die "Futurebases can't have non-pawn restrictions ($filename)\n" if ($XMLpiece->findvalue('@location') ne "");
	    $black_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
	}

	my $white_pawn_count = $XMLfuturebase->findnodes('piece[@color = "white" and @type = "pawn"]')->size();
	my $black_pawn_count = $XMLfuturebase->findnodes('piece[@color = "black" and @type = "pawn"]')->size();

	for my $pawngen ($XMLfuturebase->findnodes('pawngen')) {

	    $white_pawn_count = $pawngen->findvalue('@white-pawns-required');
	    $black_pawn_count = $pawngen->findvalue('@black-pawns-required');

	}

	if (not $invert_colors) {
	    $futurebases{$white_pieces . $white_pawn_count . $black_pieces . $black_pawn_count} = $futurebase->cloneNode(1);
	    print "$white_pieces$white_pawn_count$black_pieces$black_pawn_count -> $filename\n";
	} else {
	    $futurebases{$black_pieces . $black_pawn_count . $white_pieces . $white_pawn_count} = $futurebase->cloneNode(1);
	}
    }
}


sub validate_xml_control_file {
    my ($XMLcontrolFile) = @_;

    if ($XMLcontrolFile->findnodes('piece[@color = "white" and @type = "king"]')->size() != 1
	or $XMLcontrolFile->findnodes('piece[@color = "black" and @type = "king"]')->size() != 1) {
	die "Must have one white king and one black one!\n";
    }

    # Pawngen is currently very restrictive in its piece restrictions (checked in &pawngen).  When
    # these restrictions are relaxed, though, we should...
    #
    # Check piece locations to make sure they make sense
    # Check for "more than two identical pieces with overlapping move restrictions"
    # Check for "more than one pieces frozen on XX"

    if ($XMLcontrolFile->findnodes('index[@symmetry != "8"]')->size() > 0) {
	die "pawngen doesn't support symmetry\n";
    }

    if ($XMLcontrolFile->findnodes('output')->size() > 0) {
	die "pawngen doesn't support output elements in generation-controls\n";
    }

    @white_prune_enables = map {lc $_->to_literal} $XMLcontrolFile->findnodes('*[self::prune-enable or self::move-restriction][@color="white"]/@type');
    @black_prune_enables = map {lc $_->to_literal} $XMLcontrolFile->findnodes('*[self::prune-enable or self::move-restriction][@color="black"]/@type');

    for my $white_prune (map {lc $_->to_literal} $XMLcontrolFile->findnodes('prune[@color="white"]/@type')) {
	die "At least one prune statement incompatible with prune-enable\n"
	    if (grep({ $_ eq $white_prune } @white_prune_enables) == 0);
    }

    for my $black_prune (map {lc $_->to_literal} $XMLcontrolFile->findnodes('prune[@color="black"]/@type')) {
	die "At least one prune statement incompatible with prune-enable\n"
	    if (grep({ $_ eq $black_prune } @black_prune_enables) == 0);
    }
}

#### MAIN ROUTINE ####

sub basename {
    my ($basename, $white_pawns, $black_pawns) = @_;

    $basename =~ s/.xml$//;

    return $basename . "-$white_pawns-$black_pawns";
}

sub create_control_file {
    my ($control_file, $XMLdocument, $XMLcontrolFile, $white_pieces, $white_pawns, $black_pieces, $black_pawns) = @_;

    # Generate control/htb filenames.

    my $cntl_filename = $control_file;
    $cntl_filename =~ s/\.xml$/-$white_pawns-$black_pawns.xml/;
    die "Invalid control filename\n" if ($cntl_filename eq $control_file);

    my $htb_filename = $cntl_filename;
    $htb_filename =~ s/.xml$/.htb/;

    # Generate a futurebase element to be used by other control files to reference this one and add
    # it to the %futurebases hash.

    my $new_futurebase = XML::LibXML::Element->new('futurebase');
    $new_futurebase->setAttribute('filename', $htb_filename);
    $futurebases{$white_pieces . $white_pawns . $black_pieces . $black_pawns} = $new_futurebase;

    # Make a copy of the original XML control file.

    my $XMLroot = $XMLcontrolFile->cloneNode(1);

    # Set the pawngen element correctly

    my $pawngen = ($XMLroot->findnodes('pawngen'))[0];

    $pawngen->setAttribute("white-pawns-required", $white_pawns);
    $pawngen->setAttribute("black-pawns-required", $black_pawns);

    # Remove all futurebase elements

    my $first_futurebase_location = ($XMLroot->findnodes('futurebase'))[0]->previousSibling();

    $_->unbindNode() foreach $XMLroot->findnodes('futurebase');

    # Add new futurebase elements

    if ($white_pawns > 0) {
	if (not exists $futurebases{$white_pieces . ($white_pawns-1) . $black_pieces . $black_pawns}) {
	    &create_control_file($control_file, $XMLdocument, $XMLcontrolFile, $white_pieces, $white_pawns - 1, $black_pieces, $black_pawns);
	}
	$XMLroot->insertAfter($futurebases{$white_pieces . ($white_pawns-1) . $black_pieces . $black_pawns}, $first_futurebase_location);

	# What about queening?  If any futurebases were specified that would match a queening
	# possibility, include it now.
	#
	# XXX need to consider capture promotions

	foreach my $piece_char (keys %piece_names) {
	    my $key = $white_pieces . $piece_char . ($white_pawns-1) . $black_pieces . $black_pawns;
	    if (exists $futurebases{$key}) {
		$XMLroot->insertAfter($futurebases{$key}, $first_futurebase_location);
	    }
	}
    }

    if ($black_pawns > 0) {
	if (not exists $futurebases{$white_pieces . $white_pawns . $black_pieces . ($black_pawns-1)}) {
	    &create_control_file($control_file, $XMLdocument, $XMLcontrolFile, $white_pieces, $white_pawns, $black_pieces, $black_pawns - 1);
	}
	$XMLroot->insertAfter($futurebases{$white_pieces . $white_pawns . $black_pieces . ($black_pawns-1)}, $first_futurebase_location);

	# What about queening?  If any futurebases were specified that would match a queening
	# possibility, include it now.
	#
	# XXX need to consider capture promotions

	foreach my $piece_char (keys %piece_names) {
	    my $key = $white_pieces . $white_pawns . $black_pieces . $piece_char . ($black_pawns-1);
	    if (exists $futurebases{$key}) {
		$XMLroot->insertAfter($futurebases{$key}, $first_futurebase_location);
	    }
	}
    }

    # Consider possible piece captures.  For each piece type, consider removing one of it from the
    # white (or black) piece list.  If there is a corresponding futurebase, include it.

    foreach my $piece_char (keys %piece_names) {
	if ($white_pieces =~ /$piece_char/) {
	    my $key = ($white_pieces =~ s/$piece_char//r) . $white_pawns . $black_pieces . $black_pawns;
	    if (exists $futurebases{$key}) {
		$XMLroot->insertAfter($futurebases{$key}, $first_futurebase_location);
	    }
	}
	if ($black_pieces =~ /$piece_char/) {
	    my $key = $white_pieces . $white_pawns . ($black_pieces =~ s/$piece_char//r) . $black_pawns;
	    if (exists $futurebases{$key}) {
		$XMLroot->insertAfter($futurebases{$key}, $first_futurebase_location);
	    }
	}
    }

    # Add an output element

    my $output = XML::LibXML::Element->new('output');
    $output->setAttribute('filename', $htb_filename);
    $XMLroot->insertAfter($output, $first_futurebase_location);

    # Save the generated control file.  Using the original $XMLdocument preserves the DTD header, and
    # using format '1' inserts whitespace text nodes.

    $XMLdocument->setDocumentElement($XMLroot);
    $XMLdocument->toFile($cntl_filename, 2);
}

sub pawngen {
    my ($control_file) = @_;
    my ($white_pieces, $black_pieces);

    # Obtain an XML copy of our control file

    my $XMLdocument = $XMLparser->parse_file($control_file);
    my $XMLcontrolFile = $XMLdocument->getDocumentElement();
    &validate_xml_control_file($XMLcontrolFile);

    # Extract URL prefix from the control file, if it exists.  If not, then $url_prefix will be an
    # empty string.

    $url_prefix = $XMLcontrolFile->findvalue('generation-controls/url-prefix');

    # Extract any futurebases from the input control file and assign them to any positions that they
    # match.

    foreach my $futurebase ($XMLcontrolFile->findnodes("futurebase")) {
	&assign_futurebase($futurebase);
    }

    # Extract the XML pruning statements from the control file.  I do this globally because I've
    # found that each time I call findnodes I get a list of different XML::LibXML::Element's back -
    # identical in content, but different.  Since I use their addresses to generate a hash
    # indicating which prunes have been used in which positions, I need to make sure that those
    # addresses are also the same.  So do this once, here, and use it in &compute_futurebases.

#    @white_XML_prunes = $XMLcontrolFile->findnodes('prune[@color = "white"]');
#    @black_XML_prunes = $XMLcontrolFile->findnodes('prune[@color = "black"]');

    # Figure out what non-pawn pieces are present

    foreach my $XMLpiece ($XMLcontrolFile->findnodes('piece[@color = "white" and @type != "pawn"]')) {
	die "Can't have non-pawn restrictions\n" if ($XMLpiece->findvalue('@location') ne "");
	$white_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
    }

    foreach my $XMLpiece ($XMLcontrolFile->findnodes('piece[@color = "black" and @type != "pawn"]')) {
	die "Can't have non-pawn restrictions\n" if ($XMLpiece->findvalue('@location') ne "");
	$black_pieces .= $piece_character{lc $XMLpiece->findvalue('@type')};
    }

    # Extract pawngen element and determine how many white and black pawns it contains.

    die "Exactly one pawngen element is required\n" if ($XMLcontrolFile->findnodes('pawngen')->size() != 1);

    my $pawngen = ($XMLcontrolFile->findnodes('pawngen'))[0];

    my $white_pawn_locations = $pawngen->findvalue('@white-pawn-locations');
    my $black_pawn_locations = $pawngen->findvalue('@black-pawn-locations');

    die "Illegal white pawn syntax in pawngen element\n" unless $white_pawn_locations =~ /^[a-h][1-8]( [a-h][1-8])*$/;
    die "Illegal black pawn syntax in pawngen element\n" unless $black_pawn_locations =~ /^[a-h][1-8]( [a-h][1-8])*$/;

    my $white_pawn_count = (length($white_pawn_locations)+1)/3;
    my $black_pawn_count = (length($black_pawn_locations)+1)/3;

    # Handle required queens by subtracting them from the pawn count

    my $white_queens_required = $pawngen->findvalue('@white-queens-required');
    my $black_queens_required = $pawngen->findvalue('@black-queens-required');

    $white_pawn_count -= $white_queens_required;
    $black_pawn_count -= $black_queens_required;

    # We'll use modified copies of the original control file to create new control files, so just
    # add a single comment right now to note their origin.

    $XMLdocument->addChild(XML::LibXML::Comment->new(" Created by pawngen from $control_file "));

    &create_control_file($control_file, $XMLdocument, $XMLcontrolFile, $white_pieces, $white_pawn_count, $black_pieces, $black_pawn_count);
}


if ($#ARGV >= 0) {
    #foreach my $file (@ARGV) { &assign_file($file); }
    foreach my $control_file (@ARGV) { &pawngen($control_file); }
}
